From |kry|ov @end|ng |rom d|@root@org  Sat Feb  1 10:39:04 2025
From: |kry|ov @end|ng |rom d|@root@org (Ivan Krylov)
Date: Sat, 1 Feb 2025 12:39:04 +0300
Subject: [Rd] 
 [SPAM Warning!] Suggestion to emphasize Rboolean is unrelated
 to LGLSXP in R-exts
In-Reply-To: <CAPRVBcwA_j9=nPsjo272knqzK8Bdaoi6bgsGO+5YrKLhttHvDw@mail.gmail.com>
References: <CAPRVBcwA_j9=nPsjo272knqzK8Bdaoi6bgsGO+5YrKLhttHvDw@mail.gmail.com>
Message-ID: <20250201123904.6fc253be@Tarkus>

On Thu, 30 Jan 2025 13:07:31 -0800
Michael Chirico <michaelchirico4 at gmail.com> wrote:

> There are at least dozens of other cases on CRAN [2],[3].

Some of these involve casting an int to Rboolean. Best case, the int is
compared against NA_LOGICAL beforehand, avoiding any mistake (there's
at least one like that). Worst case, NA_LOGICAL is not considered before
the cast, so NA will now be interpreted as TRUE. This is hard to check
without actually reading the code.

Some packages compare an Rboolean expression against NA_LOGICAL [1].
This implies having stored an int in an Rboolean value as in the
previous paragraph. I think that it wasn't disallowed according to the
C standard to store NA_LOGICAL in an enumeration type wide enough to
fit it (and it evidently worked in practice). With typedef bool
Rboolean, storing NA_LOGICAL in an Rboolean converts it to 'true', so
the comparison will definitely fail:

DPQ src/pnchisq-it.c:530,532
Rmpfr src/convert.c:535
checkmate src/helper.c:102
chron src/unpaste.c:21
collapse src/data.table_rbindlist.c:208,258,383,384,408,431
data.table (many; fixed in Git)
ff src/ordermerge.c:5074 (one declaration, many comparisons)
networkDynamic src/Rinit.c:209 src/is.active.c:75,76,96-98
slam src/util.c:258
this.path src/get_file_from_closure.h:13,43 src/thispath.c:14,17,19,39
 src/ext.c:25 src/setsyspath.c:8 src/get_file_from_closure.h:13,43

Four packages cast int* pointers returned by LOGICAL() to Rboolean* or
use sizeof(Rboolean) to calculate buffer sizes in calls to memcpy()
with LOGICAL() buffers [2]. With typedef bool Rboolean, this is a
serious mistake, because the memory layout of the types is no longer
compatible:

bit64 src/integer64.c:576,603,914,929,942,955,968,981,994
collapse src/data.table_rbindlist.c:19,67,105
data.table (many; fixed in Git)
kit src/utils.c:390

I don't know Coccinelle that well and there may be additional cases I
failed to consider. At which point is it appropriate to start notifying
maintainers of the bugs not caught by their test suites?

-- 
Best regards,
Ivan

[1] Coccinelle script:
@@
typedef Rboolean;
Rboolean E;
@@
* E == NA_LOGICAL

[2] Coccinelle scripts:

@@
typedef Rboolean;
int* E;
@@
* (Rboolean*)E

This one will offer a diff to fix the bug:

@@
int *E1;
int *E2;
typedef Rboolean;
@@
(
 memcpy
|
 memmove
)
 (E1, E2,
 <+...
-sizeof(Rboolean)
+sizeof(int)
 ...+>
 )


From |kry|ov @end|ng |rom d|@root@org  Sun Feb  2 16:50:58 2025
From: |kry|ov @end|ng |rom d|@root@org (Ivan Krylov)
Date: Sun, 2 Feb 2025 18:50:58 +0300
Subject: [Rd] Suggestion to emphasize Rboolean is unrelated to LGLSXP in
 R-exts
In-Reply-To: <20250201123904.6fc253be@Tarkus>
References: <CAPRVBcwA_j9=nPsjo272knqzK8Bdaoi6bgsGO+5YrKLhttHvDw@mail.gmail.com>
 <20250201123904.6fc253be@Tarkus>
Message-ID: <20250202185058.531317c2@Tarkus>

The good news is that without a C23-enabled compiler, the problem will
only happen to source files that #include <stdbool.h>. The bad news is
that such a source file will technically disagree with the rest of R
about the type of Rboolean, including the prototypes of the API
functions that accept Rboolean:

#include <stdbool.h>
#include <Rinternals.h>
typedef void (*pordervector1)(int *, int, SEXP, Rboolean, Rboolean);
// ...
pordervector1 f = R_orderVector1;
f(pindx, length(indx), arg, nalast, decreasing);

foo.c:27:17: runtime error: call to function R_orderVector1 through
pointer to incorrect function type 'void (*)(int *, int, struct SEXPREC
*, bool, bool)'
/tmp/R-devel/src/main/sort.c:1135: note: R_orderVector1 defined here
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior foo.c:27:17

With sanitizers disabled, this doesn't seem to cause any real problems
thanks to the calling convention, where both 'enum's and 'bool's are
passed and returned in a register.

-- 
Best regards,
Ivan


From r|p|eybd @end|ng |rom |c|oud@com  Mon Feb  3 11:07:13 2025
From: r|p|eybd @end|ng |rom |c|oud@com (Prof Brian Ripley)
Date: Mon, 3 Feb 2025 10:07:13 +0000
Subject: [Rd] Suggestion to emphasize Rboolean is unrelated to LGLSXP in
 R-exts
In-Reply-To: <20250202185058.531317c2@Tarkus>
References: <CAPRVBcwA_j9=nPsjo272knqzK8Bdaoi6bgsGO+5YrKLhttHvDw@mail.gmail.com>
 <20250201123904.6fc253be@Tarkus> <20250202185058.531317c2@Tarkus>
Message-ID: <551e7875-03a3-4a94-99e5-751ac9c496f4@icloud.com>

On 02/02/2025 15:50, Ivan Krylov via R-devel wrote:
> The good news is that without a C23-enabled compiler, the problem will
> only happen to source files that #include <stdbool.h>. The bad news is
> that such a source file will technically disagree with the rest of R
> about the type of Rboolean, including the prototypes of the API
> functions that accept Rboolean:
> 
> #include <stdbool.h>
> #include <Rinternals.h>
> typedef void (*pordervector1)(int *, int, SEXP, Rboolean, Rboolean);
> // ...
> pordervector1 f = R_orderVector1;
> f(pindx, length(indx), arg, nalast, decreasing);
> 
> foo.c:27:17: runtime error: call to function R_orderVector1 through
> pointer to incorrect function type 'void (*)(int *, int, struct SEXPREC
> *, bool, bool)'
> /tmp/R-devel/src/main/sort.c:1135: note: R_orderVector1 defined here
> SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior foo.c:27:17
> 
> With sanitizers disabled, this doesn't seem to cause any real problems
> thanks to the calling convention, where both 'enum's and 'bool's are
> passed and returned in a register.

This is work in progress, and it was not intended to apply to R-devel 
unless configured with --with-C23 or using a compiler (such as GCC 
pre-15) that defaults to C23.  We will back that out pending further 
testing.

-- 
Brian D. Ripley,                  ripley at stats.ox.ac.uk
Emeritus Professor of Applied Statistics, University of Oxford


From r|p|eybd @end|ng |rom |c|oud@com  Mon Feb  3 18:36:28 2025
From: r|p|eybd @end|ng |rom |c|oud@com (Prof Brian Ripley)
Date: Mon, 3 Feb 2025 17:36:28 +0000
Subject: [Rd] boolean and logical types -draft
Message-ID: <93d0bc7e-9ad2-4193-b43e-34c1544bb1a7@icloud.com>

Tomas,

I am thinking of writing something for R-devel, and hope to have your 
input first.

I get moderated on R-devel as I am now subscribed as 
brian.ripley at R-project.org which of course I cannot send from. So I am 
even more discouraged from posting there.  (R-core is bad enough with 
Luke discouraging all innovation except by him and Simon completely 
misunderstanding the C23 status.)

Thanks,

Brian

----------------

There are several of these, and few guarantees for inter-working.

a) R's logical vectors, which include a value NA for its elements.
b) R's Rboolean type in C/C++

c) C++'s bool type
d) C23's bool type
e) C99's _Bool type to which bool is aliased if <stdbool.h> is included.
f) Fortran's LOGICAL type

a) is currently implemented as a C int (so 32-bit) type with NA as the C 
value NA_LOGICAL which is the same a NA_INTEGER.

b) is currently implemented as a C enum with two values.  I don't know 
of any guarantees on how that is stored except in char or an integer 
type -- however it seems common practice to use a 32-bit type (int or 
unsigned int would not be distinguishable).  (C23 ?6.7.3.3)  Enums can 
have a specified data type, but we do not.

C23 states that bool has 1 value bit and some padding bits (?6.2.6.2) so 
it can be stored in char-sized storage (i.e. bytes) or multiples 
thereof.  And that _Bool is a alternative name for bool.

f) is complier-dependent: for interoperability with C or R, code should 
use c_bool from iso_c_binding (Fortran 2003).  Fortran compilers store 
LOGICAL in compiler-dependent ways, and for a long time we got away with 
assuming that was equivalent to int (so LOGICAL values could be passed 
to and from with int* on the C/R side).  But sometime around GCC 8 they 
changed to int_least32_t, which on common platforms is the same as int 
but does not need to be.

It seems that in all cases coercion to an integer type coerces false 
values to 0 and true values to 1 (and this is guaranteed by C23 at 
least).  And C23 guarantees that when coercing from an integer type to 
bool zero values are coerced to false and non-zero ones to true (bool is 
'an unsigned integer type').  However, that does not seem to be true for 
C++ as UB sanitizers warn on coercing values other than 0/1.

I believe it to be the intention that c), d) and e) have the same 
representation and interwork using the same compiler, but I could not 
find that documented and see signs that e) might differ in C17 and C23 
modes.

----------------

I need to look again at the C and C++ standards which with my vision I 
need to do in very small chunks.  Oh for the vision I once had!

-- 
Brian D. Ripley,                  ripley at stats.ox.ac.uk
Emeritus Professor of Applied Statistics, University of Oxford


From r|p|eybd @end|ng |rom |c|oud@com  Mon Feb  3 18:39:07 2025
From: r|p|eybd @end|ng |rom |c|oud@com (Prof Brian Ripley)
Date: Mon, 3 Feb 2025 17:39:07 +0000
Subject: [Rd] boolean and logical types -draft
In-Reply-To: <93d0bc7e-9ad2-4193-b43e-34c1544bb1a7@icloud.com>
References: <93d0bc7e-9ad2-4193-b43e-34c1544bb1a7@icloud.com>
Message-ID: <fd059a61-57ab-4592-80e5-7a68b3b1d6d0@icloud.com>

Sent in error (and not moderated).

On 03/02/2025 17:36, Prof Brian Ripley via R-devel wrote:
> Tomas,
> 
> I am thinking of writing something for R-devel, and hope to have your 
> input first.
> 
> I get moderated on R-devel as I am now subscribed as brian.ripley at R- 
> project.org which of course I cannot send from. So I am even more 
> discouraged from posting there.? (R-core is bad enough with Luke 
> discouraging all innovation except by him and Simon completely 
> misunderstanding the C23 status.)
> 
> Thanks,
> 
> Brian
> 
> ----------------
> 
> There are several of these, and few guarantees for inter-working.
> 
> a) R's logical vectors, which include a value NA for its elements.
> b) R's Rboolean type in C/C++
> 
> c) C++'s bool type
> d) C23's bool type
> e) C99's _Bool type to which bool is aliased if <stdbool.h> is included.
> f) Fortran's LOGICAL type
> 
> a) is currently implemented as a C int (so 32-bit) type with NA as the C 
> value NA_LOGICAL which is the same a NA_INTEGER.
> 
> b) is currently implemented as a C enum with two values.? I don't know 
> of any guarantees on how that is stored except in char or an integer 
> type -- however it seems common practice to use a 32-bit type (int or 
> unsigned int would not be distinguishable).? (C23 ?6.7.3.3)? Enums can 
> have a specified data type, but we do not.
> 
> C23 states that bool has 1 value bit and some padding bits (?6.2.6.2) so 
> it can be stored in char-sized storage (i.e. bytes) or multiples 
> thereof.? And that _Bool is a alternative name for bool.
> 
> f) is complier-dependent: for interoperability with C or R, code should 
> use c_bool from iso_c_binding (Fortran 2003).? Fortran compilers store 
> LOGICAL in compiler-dependent ways, and for a long time we got away with 
> assuming that was equivalent to int (so LOGICAL values could be passed 
> to and from with int* on the C/R side).? But sometime around GCC 8 they 
> changed to int_least32_t, which on common platforms is the same as int 
> but does not need to be.
> 
> It seems that in all cases coercion to an integer type coerces false 
> values to 0 and true values to 1 (and this is guaranteed by C23 at 
> least).? And C23 guarantees that when coercing from an integer type to 
> bool zero values are coerced to false and non-zero ones to true (bool is 
> 'an unsigned integer type').? However, that does not seem to be true for 
> C++ as UB sanitizers warn on coercing values other than 0/1.
> 
> I believe it to be the intention that c), d) and e) have the same 
> representation and interwork using the same compiler, but I could not 
> find that documented and see signs that e) might differ in C17 and C23 
> modes.
> 
> ----------------
> 
> I need to look again at the C and C++ standards which with my vision I 
> need to do in very small chunks.? Oh for the vision I once had!
> 


-- 
Brian D. Ripley,                  ripley at stats.ox.ac.uk
Emeritus Professor of Applied Statistics, University of Oxford


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Tue Feb  4 13:45:49 2025
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Tue, 4 Feb 2025 13:45:49 +0100
Subject: [Rd] Suggestion to emphasize Rboolean is unrelated to LGLSXP in
 R-exts
In-Reply-To: <20250201123904.6fc253be@Tarkus>
References: <CAPRVBcwA_j9=nPsjo272knqzK8Bdaoi6bgsGO+5YrKLhttHvDw@mail.gmail.com>
 <20250201123904.6fc253be@Tarkus>
Message-ID: <b9e0a7c2-ea92-43d8-ac7d-db816bd31123@gmail.com>


On 2/1/25 10:39, Ivan Krylov via R-devel wrote:
> On Thu, 30 Jan 2025 13:07:31 -0800
> Michael Chirico <michaelchirico4 at gmail.com> wrote:
>
>> There are at least dozens of other cases on CRAN [2],[3].
> Some of these involve casting an int to Rboolean. Best case, the int is
> compared against NA_LOGICAL beforehand, avoiding any mistake (there's
> at least one like that). Worst case, NA_LOGICAL is not considered before
> the cast, so NA will now be interpreted as TRUE. This is hard to check
> without actually reading the code.
>
> Some packages compare an Rboolean expression against NA_LOGICAL [1].
> This implies having stored an int in an Rboolean value as in the
> previous paragraph. I think that it wasn't disallowed according to the
> C standard to store NA_LOGICAL in an enumeration type wide enough to
> fit it (and it evidently worked in practice). With typedef bool
> Rboolean, storing NA_LOGICAL in an Rboolean converts it to 'true', so
> the comparison will definitely fail:
>
> DPQ src/pnchisq-it.c:530,532
> Rmpfr src/convert.c:535
> checkmate src/helper.c:102
> chron src/unpaste.c:21
> collapse src/data.table_rbindlist.c:208,258,383,384,408,431
> data.table (many; fixed in Git)
> ff src/ordermerge.c:5074 (one declaration, many comparisons)
> networkDynamic src/Rinit.c:209 src/is.active.c:75,76,96-98
> slam src/util.c:258
> this.path src/get_file_from_closure.h:13,43 src/thispath.c:14,17,19,39
>   src/ext.c:25 src/setsyspath.c:8 src/get_file_from_closure.h:13,43
>
> Four packages cast int* pointers returned by LOGICAL() to Rboolean* or
> use sizeof(Rboolean) to calculate buffer sizes in calls to memcpy()
> with LOGICAL() buffers [2]. With typedef bool Rboolean, this is a
> serious mistake, because the memory layout of the types is no longer
> compatible:
>
> bit64 src/integer64.c:576,603,914,929,942,955,968,981,994
> collapse src/data.table_rbindlist.c:19,67,105
> data.table (many; fixed in Git)
> kit src/utils.c:390
>
> I don't know Coccinelle that well and there may be additional cases I
> failed to consider. At which point is it appropriate to start notifying
> maintainers of the bugs not caught by their test suites?

Yes, thanks, if you have the energy, I think it would be great if you 
could contact the maintainers directly if you find obvious problems in 
their packages, as much as in any open-source project. Casting int* from 
LOGICAL() to Rboolean* falls into that category.

Any bug finding tool would only find a subset of the bugs, that's ok - 
helping to fix only some packages (and not all) is still a big help.

Tomas


