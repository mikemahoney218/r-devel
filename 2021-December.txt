From henr|k@bengt@@on @end|ng |rom gm@||@com  Wed Dec  1 07:10:34 2021
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Tue, 30 Nov 2021 22:10:34 -0800
Subject: [Rd] mapply(): Special case of USE.NAMES=TRUE with recent R-devel
 updates
Message-ID: <CAFDcVCRaGk8b3jeHQq5AL1LQkY1H7GjLRGTcrCPQ9UHye1FTgw@mail.gmail.com>

Hi,

in R-devel (4.2.0), we now get:

> mapply(paste, "A", character(), USE.NAMES = TRUE)
named list()

Now, in ?mapply we have:

USE.NAMES: logical; use the names of the first ... argument, or if
that is an unnamed character vector, use that vector as the names.

This basically says we should get:

> answer <- list()
> first <- "A"
> names(answer) <- first

which obviously is an error. The help is not explicit what should
happen when the length "of the first ... argument" is zero, but the
above behavior effectively does something like:

> answer <- list()
> first <- "A"
> names(answer) <- first[seq_along(answer)]
> answer
named list()

Is there a need for the docs to be updated, or should the result be an
unnamed empty list?

/Henrik


From hp@ge@@on@g|thub @end|ng |rom gm@||@com  Wed Dec  1 07:45:15 2021
From: hp@ge@@on@g|thub @end|ng |rom gm@||@com (=?UTF-8?B?SGVydsOpIFBhZ8Oocw==?=)
Date: Tue, 30 Nov 2021 22:45:15 -0800
Subject: [Rd] 
 mapply(): Special case of USE.NAMES=TRUE with recent R-devel updates
In-Reply-To: <CAFDcVCRaGk8b3jeHQq5AL1LQkY1H7GjLRGTcrCPQ9UHye1FTgw@mail.gmail.com>
References: <CAFDcVCRaGk8b3jeHQq5AL1LQkY1H7GjLRGTcrCPQ9UHye1FTgw@mail.gmail.com>
Message-ID: <842f72bb-53fa-1755-5480-1e351d9f56cb@gmail.com>

And also:

   > mapply(paste, c(a="A"), character(), USE.NAMES = TRUE)

   Error in names(answer) <- names1 :

     'names' attribute [1] must be the same length as the vector [0]


When the shortest arguments get recycled to the length of the longest, 
shouldn't their names also get recycled?

   > mapply(paste, c(a="A", b="B"), letters[1:6], USE.NAMES=TRUE)

       a     b  <NA>  <NA>  <NA>  <NA>

   "A a" "B b" "A c" "B d" "A e" "B f"

That's assuming that rep() accurately materializes recycling (I hope it 
does):

   > rep(c(a="A", b="B"), length.out=6)

     a   b   a   b   a   b

   "A" "B" "A" "B" "A" "B"


   > rep(c(a="A", b="B"), length.out=0)

   named character(0)


I always wished that the process of recycling which happens everywhere 
all the time in R was implemented in its own dedicated function 
recycle(). But that's another story.

Anyways, back to mapply(): Once what happens to the names during 
recycling is clarified, there should be no need to be explicit about 
what should happen when the length "of the first ... argument" is zero 
because it will no longer be a special case.

Cheers,
H.


On 30/11/2021 22:10, Henrik Bengtsson wrote:
> Hi,
> 
> in R-devel (4.2.0), we now get:
> 
>> mapply(paste, "A", character(), USE.NAMES = TRUE)
> named list()
> 
> Now, in ?mapply we have:
> 
> USE.NAMES: logical; use the names of the first ... argument, or if
> that is an unnamed character vector, use that vector as the names.
> 
> This basically says we should get:
> 
>> answer <- list()
>> first <- "A"
>> names(answer) <- first
> 
> which obviously is an error. The help is not explicit what should
> happen when the length "of the first ... argument" is zero, but the
> above behavior effectively does something like:
> 
>> answer <- list()
>> first <- "A"
>> names(answer) <- first[seq_along(answer)]
>> answer
> named list()
> 
> Is there a need for the docs to be updated, or should the result be an
> unnamed empty list?
> 
> /Henrik
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 

-- 
Herv? Pag?s

Bioconductor Core Team
hpages.on.github at gmail.com


From henr|k@bengt@@on @end|ng |rom gm@||@com  Wed Dec  1 18:59:13 2021
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Wed, 1 Dec 2021 09:59:13 -0800
Subject: [Rd] R-devel: as.vector(x,
 mode = "list") drops attributes despite documented not to
Message-ID: <CAFDcVCQJ2+X_jOEtyJaYb+YHuN4ohGber5pAJDWzCZXNS435Zw@mail.gmail.com>

Hi,

in R 4.1.2 we have:

> x <- structure(as.list(1:2), dim = c(1,2))
> x
     [,1] [,2]
[1,] 1    2
> as.vector(x, mode = "list")
     [,1] [,2]
[1,] 1    2

whereas in recent versions of R-devel (4.2.0) we have:

> x <- structure(as.list(1:2), dim = c(1,2))
> x
     [,1] [,2]
[1,] 1    2
> as.vector(x, mode = "list")
[[1]]
[1] 1

[[2]]
[1] 2

However, as I read ?as.vector, dropping of attributes should _not_
happen for non-atomic results such as lists.  Is the new behavior a
mistake?

Specifically, ?as.vector says:

'as.vector', a generic, attempts to coerce its argument into a vector
of mode 'mode' (the default is to coerce to whichever vector mode is
most convenient): if the result is atomic all attributes are removed.

[...]

Details:

The atomic modes are "logical", "integer", "numeric" (synonym
"double"), "complex", "character" and "raw".

[...] On the other hand, as.vector removes all attributes including
names for results of atomic mode (but not those of mode "list" nor
"expression").

Value:

[...]

For as.vector, a vector (atomic or of type list or expression). All
attributes are removed from the result if it is of an atomic mode, but
not in general for a list result. The default method handles 24 input
types and 12 values of type: the details of most coercions are
undocumented and subject to change.

/Henrik


From Thom@@@SOEIRO @end|ng |rom @p-hm@|r  Wed Dec  1 23:41:04 2021
From: Thom@@@SOEIRO @end|ng |rom @p-hm@|r (SOEIRO Thomas)
Date: Wed, 1 Dec 2021 22:41:04 +0000
Subject: [Rd] Add ... to Reduce?
Message-ID: <1638398464828.91211@ap-hm.fr>

Dear list,

Currently, it is needed to use anonymous functions to pass additional parameters to f in Reduce.

The following patch adds ... to pass additional arguments directly and seems to work in simple cases (see example below).

However, since this was not available (even though it is common for similar functions), I suspect that I am missing something...

Best,

Thomas


dfs <- list(x = warpbreaks)
dfs$x$id <- seq_along(dfs$x$breaks)
dfs$y <- dfs$x[1:15, ]
dfs$z <- dfs$x[20:35, ]

identical(
  Reduce(function(...) merge(..., by = "id", all = TRUE), dfs),
  Reduce(merge, dfs, by = "id", all = TRUE)
)


diff -u orig/funprog.R mod/funprog.R
--- orig/funprog.R	2021-12-01 23:02:09.710231318 +0100
+++ mod/funprog.R	2021-12-01 23:23:58.591120101 +0100
@@ -1,7 +1,7 @@
 #  File src/library/base/R/funprog.R
 #  Part of the R package, https://www.R-project.org
 #
-#  Copyright (C) 1995-2014 The R Core Team
+#  Copyright (C) 1995-2021 The R Core Team
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License as published by
@@ -17,7 +17,7 @@
 #  https://www.R-project.org/Licenses/
 
 Reduce <-
-function(f, x, init, right = FALSE, accumulate = FALSE)
+function(f, x, init, right = FALSE, accumulate = FALSE, ...)
 {
     mis <- missing(init)
     len <- length(x)
@@ -49,11 +49,11 @@
     if(!accumulate) {
         if(right) {
             for(i in rev(ind))
-                init <- forceAndCall(2, f, x[[i]], init)
+                init <- forceAndCall(2, f, x[[i]], init, ...)
         }
         else {
             for(i in ind)
-                init <- forceAndCall(2, f, init, x[[i]])
+                init <- forceAndCall(2, f, init, x[[i]], ...)
         }
         init
     }
@@ -66,13 +66,13 @@
             if(right) {
                 out[[len]] <- init
                 for(i in rev(ind)) {
-                    init <- forceAndCall(2, f, x[[i]], init)
+                    init <- forceAndCall(2, f, x[[i]], init, ...)
                     out[[i]] <- init
                 }
             } else {
                 out[[1L]] <- init
                 for(i in ind) {
-                    init <- forceAndCall(2, f, init, x[[i]])
+                    init <- forceAndCall(2, f, init, x[[i]], ...)
                     out[[i]] <- init
                 }
             }
@@ -80,14 +80,14 @@
             if(right) {
                 out[[len]] <- init
                 for(i in rev(ind)) {
-                    init <- forceAndCall(2, f, x[[i]], init)
+                    init <- forceAndCall(2, f, x[[i]], init, ...)
                     out[[i]] <- init
                 }
             }
             else {
                 for(i in ind) {
                     out[[i]] <- init
-                    init <- forceAndCall(2, f, init, x[[i]])
+                    init <- forceAndCall(2, f, init, x[[i]], ...)
                 }
                 out[[len]] <- init
             }
diff -u orig/funprog.Rd mod/funprog.Rd
--- orig/funprog.Rd	2021-12-01 23:02:38.400738386 +0100
+++ mod/funprog.Rd	2021-12-01 23:29:28.993976101 +0100
@@ -21,7 +21,7 @@
   given function.
 }
 \usage{
-Reduce(f, x, init, right = FALSE, accumulate = FALSE)
+Reduce(f, x, init, right = FALSE, accumulate = FALSE, ...)
 Filter(f, x)
 Find(f, x, right = FALSE, nomatch = NULL)
 Map(f, ...)
@@ -44,7 +44,7 @@
     combination is used.}
   \item{nomatch}{the value to be returned in the case when
     \dQuote{no match} (no element satisfying the predicate) is found.}
-  \item{\dots}{vectors.}
+  \item{\dots}{arguments to be passed to FUN.}
 }
 \details{
   If \code{init} is given, \code{Reduce} logically adds it to the start




From j|ox @end|ng |rom mcm@@ter@c@  Thu Dec  2 22:02:25 2021
From: j|ox @end|ng |rom mcm@@ter@c@ (Fox, John)
Date: Thu, 2 Dec 2021 21:02:25 +0000
Subject: [Rd] capturing multiple warnings in tryCatch()
Message-ID: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>

Dear R-devel list members,

Is it possible to capture more than one warning message using tryCatch()? The answer may be in ?conditions, but, if it is, I can't locate it.

For example, in the following only the first warning message is captured and reported:

> foo <- function(){
+   warning("warning 1")
+   warning("warning 2")
+ }

> foo()
Warning messages:
1: In foo() : warning 1
2: In foo() : warning 2

> bar <- function(){
+   tryCatch(foo(), warning=function(w) print(w))
+ }

> bar()
<simpleWarning in foo(): warning 1>

Is there a way to capture "warning 2" as well?

Any help would be appreciated.

John

-- 
John Fox, Professor Emeritus
McMaster University
Hamilton, Ontario, Canada
Web: http://socserv.mcmaster.ca/jfox/
 
 


From @|mon@urb@nek @end|ng |rom R-project@org  Thu Dec  2 22:14:28 2021
From: @|mon@urb@nek @end|ng |rom R-project@org (Simon Urbanek)
Date: Fri, 3 Dec 2021 10:14:28 +1300
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
Message-ID: <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>


Adapted from demo(error.catching):

> W=list()
> withCallingHandlers(foo(), warning=function(w) { W <<- c(W, list(w)); invokeRestart("muffleWarning") })
> str(W)
List of 2
 $ :List of 2
  ..$ message: chr "warning 1"
  ..$ call   : language foo()
  ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
 $ :List of 2
  ..$ message: chr "warning 2"
  ..$ call   : language foo()
  ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"

Cheers,
Simon


> On Dec 3, 2021, at 10:02 AM, Fox, John <jfox at mcmaster.ca> wrote:
> 
> Dear R-devel list members,
> 
> Is it possible to capture more than one warning message using tryCatch()? The answer may be in ?conditions, but, if it is, I can't locate it.
> 
> For example, in the following only the first warning message is captured and reported:
> 
>> foo <- function(){
> +   warning("warning 1")
> +   warning("warning 2")
> + }
> 
>> foo()
> Warning messages:
> 1: In foo() : warning 1
> 2: In foo() : warning 2
> 
>> bar <- function(){
> +   tryCatch(foo(), warning=function(w) print(w))
> + }
> 
>> bar()
> <simpleWarning in foo(): warning 1>
> 
> Is there a way to capture "warning 2" as well?
> 
> Any help would be appreciated.
> 
> John
> 
> -- 
> John Fox, Professor Emeritus
> McMaster University
> Hamilton, Ontario, Canada
> Web: http://socserv.mcmaster.ca/jfox/
> 
> 
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


From du@@@@dr|@n @end|ng |rom un|buc@ro  Thu Dec  2 22:52:36 2021
From: du@@@@dr|@n @end|ng |rom un|buc@ro (=?UTF-8?B?QWRyaWFuIER1yJlh?=)
Date: Thu, 2 Dec 2021 23:52:36 +0200
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
Message-ID: <CAJ=0CtCF3YAKkcUETBZHgCO6EaUxNkxDCWxYq7nq1Ua+f_5ubw@mail.gmail.com>

Dear John,

I have a function in package admisc called tryCatchWEM (catches warnings,
errors and messages):

> tryCatchWEM(foo())
$warning
[1] "warning1" "warning2"

Hope this helps,
Adrian

On Thu, 2 Dec 2021 at 23:04, Fox, John <jfox at mcmaster.ca> wrote:

> Dear R-devel list members,
>
> Is it possible to capture more than one warning message using tryCatch()?
> The answer may be in ?conditions, but, if it is, I can't locate it.
>
> For example, in the following only the first warning message is captured
> and reported:
>
> > foo <- function(){
> +   warning("warning 1")
> +   warning("warning 2")
> + }
>
> > foo()
> Warning messages:
> 1: In foo() : warning 1
> 2: In foo() : warning 2
>
> > bar <- function(){
> +   tryCatch(foo(), warning=function(w) print(w))
> + }
>
> > bar()
> <simpleWarning in foo(): warning 1>
>
> Is there a way to capture "warning 2" as well?
>
> Any help would be appreciated.
>
> John
>
> --
> John Fox, Professor Emeritus
> McMaster University
> Hamilton, Ontario, Canada
> Web: http://socserv.mcmaster.ca/jfox/
>
>
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


-- 
Adrian Dusa
University of Bucharest
Romanian Social Data Archive
Soseaua Panduri nr. 90-92
050663 Bucharest sector 5
Romania
https://adriandusa.eu

	[[alternative HTML version deleted]]


From henr|k@bengt@@on @end|ng |rom gm@||@com  Thu Dec  2 23:18:57 2021
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Thu, 2 Dec 2021 14:18:57 -0800
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
Message-ID: <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>

Simon's suggestion with withCallingHandlers() is the correct way.
Also, note that if you use tryCatch() to catch warnings, you're
*interrupting* the evaluation of the expression of interest, e.g.

> res <- tryCatch({ message("hey"); warning("boom"); message("there"); 42 }, warning = function(w) { message("Warning caught: ", conditionMessage(w)); 3.14 })
hey
Warning caught: boom
> res
[1] 3.14

Note how it never completes your expression.

/Henrik

On Thu, Dec 2, 2021 at 1:14 PM Simon Urbanek
<simon.urbanek at r-project.org> wrote:
>
>
> Adapted from demo(error.catching):
>
> > W=list()
> > withCallingHandlers(foo(), warning=function(w) { W <<- c(W, list(w)); invokeRestart("muffleWarning") })
> > str(W)
> List of 2
>  $ :List of 2
>   ..$ message: chr "warning 1"
>   ..$ call   : language foo()
>   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
>  $ :List of 2
>   ..$ message: chr "warning 2"
>   ..$ call   : language foo()
>   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
>
> Cheers,
> Simon
>
>
> > On Dec 3, 2021, at 10:02 AM, Fox, John <jfox at mcmaster.ca> wrote:
> >
> > Dear R-devel list members,
> >
> > Is it possible to capture more than one warning message using tryCatch()? The answer may be in ?conditions, but, if it is, I can't locate it.
> >
> > For example, in the following only the first warning message is captured and reported:
> >
> >> foo <- function(){
> > +   warning("warning 1")
> > +   warning("warning 2")
> > + }
> >
> >> foo()
> > Warning messages:
> > 1: In foo() : warning 1
> > 2: In foo() : warning 2
> >
> >> bar <- function(){
> > +   tryCatch(foo(), warning=function(w) print(w))
> > + }
> >
> >> bar()
> > <simpleWarning in foo(): warning 1>
> >
> > Is there a way to capture "warning 2" as well?
> >
> > Any help would be appreciated.
> >
> > John
> >
> > --
> > John Fox, Professor Emeritus
> > McMaster University
> > Hamilton, Ontario, Canada
> > Web: http://socserv.mcmaster.ca/jfox/
> >
> >
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From j|ox @end|ng |rom mcm@@ter@c@  Thu Dec  2 23:37:52 2021
From: j|ox @end|ng |rom mcm@@ter@c@ (Fox, John)
Date: Thu, 2 Dec 2021 22:37:52 +0000
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
Message-ID: <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>

Dear Henrik, Simon, and Adrian,

As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I want, which is both to capture all messages and the result of the expression (rather than the visible representation of the result). I was easily able to modify tryCatchWEM() to return the result.

Henrik: I was aware that tryCatch() doesn't return the final result of the expression, and I was previously re-executing the expression to capture the reult, but only getting the first warning message, along with the result. 

Thanks for responding to my question and providing viable solutions,
 John

?On 2021-12-02, 5:19 PM, "Henrik Bengtsson" <henrik.bengtsson at gmail.com> wrote:

    Simon's suggestion with withCallingHandlers() is the correct way.
    Also, note that if you use tryCatch() to catch warnings, you're
    *interrupting* the evaluation of the expression of interest, e.g.

    > res <- tryCatch({ message("hey"); warning("boom"); message("there"); 42 }, warning = function(w) { message("Warning caught: ", conditionMessage(w)); 3.14 })
    hey
    Warning caught: boom
    > res
    [1] 3.14

    Note how it never completes your expression.

    /Henrik

    On Thu, Dec 2, 2021 at 1:14 PM Simon Urbanek
    <simon.urbanek at r-project.org> wrote:
    >
    >
    > Adapted from demo(error.catching):
    >
    > > W=list()
    > > withCallingHandlers(foo(), warning=function(w) { W <<- c(W, list(w)); invokeRestart("muffleWarning") })
    > > str(W)
    > List of 2
    >  $ :List of 2
    >   ..$ message: chr "warning 1"
    >   ..$ call   : language foo()
    >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
    >  $ :List of 2
    >   ..$ message: chr "warning 2"
    >   ..$ call   : language foo()
    >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
    >
    > Cheers,
    > Simon
    >
    >
    > > On Dec 3, 2021, at 10:02 AM, Fox, John <jfox at mcmaster.ca> wrote:
    > >
    > > Dear R-devel list members,
    > >
    > > Is it possible to capture more than one warning message using tryCatch()? The answer may be in ?conditions, but, if it is, I can't locate it.
    > >
    > > For example, in the following only the first warning message is captured and reported:
    > >
    > >> foo <- function(){
    > > +   warning("warning 1")
    > > +   warning("warning 2")
    > > + }
    > >
    > >> foo()
    > > Warning messages:
    > > 1: In foo() : warning 1
    > > 2: In foo() : warning 2
    > >
    > >> bar <- function(){
    > > +   tryCatch(foo(), warning=function(w) print(w))
    > > + }
    > >
    > >> bar()
    > > <simpleWarning in foo(): warning 1>
    > >
    > > Is there a way to capture "warning 2" as well?
    > >
    > > Any help would be appreciated.
    > >
    > > John
    > >
    > > --
    > > John Fox, Professor Emeritus
    > > McMaster University
    > > Hamilton, Ontario, Canada
    > > Web: http://socserv.mcmaster.ca/jfox/
    > >
    > >
    > >
    > > ______________________________________________
    > > R-devel at r-project.org mailing list
    > > https://stat.ethz.ch/mailman/listinfo/r-devel
    > >
    >
    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From dmedr| @end|ng |rom gm@||@com  Fri Dec  3 10:19:43 2021
From: dmedr| @end|ng |rom gm@||@com (Daniele Medri)
Date: Fri, 3 Dec 2021 10:19:43 +0100
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
 <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
Message-ID: <CAOSBRp9UW-2jynwZtnNg5rjnD0XKoaXEkqtxVpB3tCCtVUi=cA@mail.gmail.com>

Interesting exchange of ideas.

A feature that should be included soon in the codebase to help in some
use-cases  -- eg. handling thousand database connections on {L,W}AN.



Il Gio 2 Dic 2021, 23:38 Fox, John <jfox at mcmaster.ca> ha scritto:

> Dear Henrik, Simon, and Adrian,
>
> As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I want,
> which is both to capture all messages and the result of the expression
> (rather than the visible representation of the result). I was easily able
> to modify tryCatchWEM() to return the result.
>
> Henrik: I was aware that tryCatch() doesn't return the final result of the
> expression, and I was previously re-executing the expression to capture the
> reult, but only getting the first warning message, along with the result.
>
> Thanks for responding to my question and providing viable solutions,
>  John
>
> ?On 2021-12-02, 5:19 PM, "Henrik Bengtsson" <henrik.bengtsson at gmail.com>
> wrote:
>
>     Simon's suggestion with withCallingHandlers() is the correct way.
>     Also, note that if you use tryCatch() to catch warnings, you're
>     *interrupting* the evaluation of the expression of interest, e.g.
>
>     > res <- tryCatch({ message("hey"); warning("boom"); message("there");
> 42 }, warning = function(w) { message("Warning caught: ",
> conditionMessage(w)); 3.14 })
>     hey
>     Warning caught: boom
>     > res
>     [1] 3.14
>
>     Note how it never completes your expression.
>
>     /Henrik
>
>     On Thu, Dec 2, 2021 at 1:14 PM Simon Urbanek
>     <simon.urbanek at r-project.org> wrote:
>     >
>     >
>     > Adapted from demo(error.catching):
>     >
>     > > W=list()
>     > > withCallingHandlers(foo(), warning=function(w) { W <<- c(W,
> list(w)); invokeRestart("muffleWarning") })
>     > > str(W)
>     > List of 2
>     >  $ :List of 2
>     >   ..$ message: chr "warning 1"
>     >   ..$ call   : language foo()
>     >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning"
> "condition"
>     >  $ :List of 2
>     >   ..$ message: chr "warning 2"
>     >   ..$ call   : language foo()
>     >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning"
> "condition"
>     >
>     > Cheers,
>     > Simon
>     >
>     >
>     > > On Dec 3, 2021, at 10:02 AM, Fox, John <jfox at mcmaster.ca> wrote:
>     > >
>     > > Dear R-devel list members,
>     > >
>     > > Is it possible to capture more than one warning message using
> tryCatch()? The answer may be in ?conditions, but, if it is, I can't locate
> it.
>     > >
>     > > For example, in the following only the first warning message is
> captured and reported:
>     > >
>     > >> foo <- function(){
>     > > +   warning("warning 1")
>     > > +   warning("warning 2")
>     > > + }
>     > >
>     > >> foo()
>     > > Warning messages:
>     > > 1: In foo() : warning 1
>     > > 2: In foo() : warning 2
>     > >
>     > >> bar <- function(){
>     > > +   tryCatch(foo(), warning=function(w) print(w))
>     > > + }
>     > >
>     > >> bar()
>     > > <simpleWarning in foo(): warning 1>
>     > >
>     > > Is there a way to capture "warning 2" as well?
>     > >
>     > > Any help would be appreciated.
>     > >
>     > > John
>     > >
>     > > --
>     > > John Fox, Professor Emeritus
>     > > McMaster University
>     > > Hamilton, Ontario, Canada
>     > > Web: http://socserv.mcmaster.ca/jfox/
>     > >
>     > >
>     > >
>     > > ______________________________________________
>     > > R-devel at r-project.org mailing list
>     > > https://stat.ethz.ch/mailman/listinfo/r-devel
>     > >
>     >
>     > ______________________________________________
>     > R-devel at r-project.org mailing list
>     > https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Fri Dec  3 17:35:29 2021
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Fri, 3 Dec 2021 16:35:29 +0000
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
 <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
Message-ID: <c31cc520-d4dc-a8c4-ac94-40323e63c8cb@sapo.pt>

Hello,

I remembered having seen a function tryCatch.W.E and after an online 
search, found where.
It was in a R-Help post and in demo(error.catching). The question by 
Marius Hofert [1] was answered, among others, by Martin Maechler [2] 
which included the function tryCatch.W.E.

These posts refer to an old thread dated 2004 [3], with an answer by 
Luke Tierney [4]. The function withWarnings posted by Luke returns all 
warning messages in a list, as seen below.
I repost the function to have this self contained.



withWarnings <- function (expr) {
   warnings <- character()
   retval <- withCallingHandlers(expr, warning = function(ex) {
     warnings <<- c(warnings, conditionMessage(ex))
     invokeRestart("muffleWarning")
   })
   list(Value = retval, Warnings = warnings)
}
withWarnings(foo())
#$Value
#[1] "warning 2"
#
#$Warnings
#[1] "warning 1" "warning 2"



Function tryCatch.W.E is now part of contributed package simsalapar [5], 
with credits to Marius and Martin given in its documentation.


[1] https://stat.ethz.ch/pipermail/r-help/2010-December/262185.html
[2] https://stat.ethz.ch/pipermail/r-help/2010-December/262626.html
[3] https://stat.ethz.ch/pipermail/r-help/2004-June/052092.html
[4] https://stat.ethz.ch/pipermail/r-help/2004-June/052132.html
[5] https://CRAN.R-project.org/package=simsalapar


Hope this helps,

Rui Barradas



?s 22:37 de 02/12/21, Fox, John escreveu:
> Dear Henrik, Simon, and Adrian,
> 
> As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I want, which is both to capture all messages and the result of the expression (rather than the visible representation of the result). I was easily able to modify tryCatchWEM() to return the result.
> 
> Henrik: I was aware that tryCatch() doesn't return the final result of the expression, and I was previously re-executing the expression to capture the reult, but only getting the first warning message, along with the result.
> 
> Thanks for responding to my question and providing viable solutions,
>   John
> 
> ?On 2021-12-02, 5:19 PM, "Henrik Bengtsson" <henrik.bengtsson at gmail.com> wrote:
> 
>      Simon's suggestion with withCallingHandlers() is the correct way.
>      Also, note that if you use tryCatch() to catch warnings, you're
>      *interrupting* the evaluation of the expression of interest, e.g.
> 
>      > res <- tryCatch({ message("hey"); warning("boom"); message("there"); 42 }, warning = function(w) { message("Warning caught: ", conditionMessage(w)); 3.14 })
>      hey
>      Warning caught: boom
>      > res
>      [1] 3.14
> 
>      Note how it never completes your expression.
> 
>      /Henrik
> 
>      On Thu, Dec 2, 2021 at 1:14 PM Simon Urbanek
>      <simon.urbanek at r-project.org> wrote:
>      >
>      >
>      > Adapted from demo(error.catching):
>      >
>      > > W=list()
>      > > withCallingHandlers(foo(), warning=function(w) { W <<- c(W, list(w)); invokeRestart("muffleWarning") })
>      > > str(W)
>      > List of 2
>      >  $ :List of 2
>      >   ..$ message: chr "warning 1"
>      >   ..$ call   : language foo()
>      >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
>      >  $ :List of 2
>      >   ..$ message: chr "warning 2"
>      >   ..$ call   : language foo()
>      >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
>      >
>      > Cheers,
>      > Simon
>      >
>      >
>      > > On Dec 3, 2021, at 10:02 AM, Fox, John <jfox at mcmaster.ca> wrote:
>      > >
>      > > Dear R-devel list members,
>      > >
>      > > Is it possible to capture more than one warning message using tryCatch()? The answer may be in ?conditions, but, if it is, I can't locate it.
>      > >
>      > > For example, in the following only the first warning message is captured and reported:
>      > >
>      > >> foo <- function(){
>      > > +   warning("warning 1")
>      > > +   warning("warning 2")
>      > > + }
>      > >
>      > >> foo()
>      > > Warning messages:
>      > > 1: In foo() : warning 1
>      > > 2: In foo() : warning 2
>      > >
>      > >> bar <- function(){
>      > > +   tryCatch(foo(), warning=function(w) print(w))
>      > > + }
>      > >
>      > >> bar()
>      > > <simpleWarning in foo(): warning 1>
>      > >
>      > > Is there a way to capture "warning 2" as well?
>      > >
>      > > Any help would be appreciated.
>      > >
>      > > John
>      > >
>      > > --
>      > > John Fox, Professor Emeritus
>      > > McMaster University
>      > > Hamilton, Ontario, Canada
>      > > Web: http://socserv.mcmaster.ca/jfox/
>      > >
>      > >
>      > >
>      > > ______________________________________________
>      > > R-devel at r-project.org mailing list
>      > > https://stat.ethz.ch/mailman/listinfo/r-devel
>      > >
>      >
>      > ______________________________________________
>      > R-devel at r-project.org mailing list
>      > https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From du@@@@dr|@n @end|ng |rom gm@||@com  Fri Dec  3 19:55:53 2021
From: du@@@@dr|@n @end|ng |rom gm@||@com (=?UTF-8?B?QWRyaWFuIER1yJlh?=)
Date: Fri, 3 Dec 2021 20:55:53 +0200
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
 <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
Message-ID: <CAJ=0CtAVpv6QKAZwWxEB3fsjUD8PA6+-nBYnok=Kffa_SfNF3Q@mail.gmail.com>

On Fri, 3 Dec 2021 at 00:37, Fox, John <jfox at mcmaster.ca> wrote:

> Dear Henrik, Simon, and Adrian,
>
> As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I want,
> which is both to capture all messages and the result of the expression
> (rather than the visible representation of the result). I was easily able
> to modify tryCatchWEM() to return the result.
>

Glad it helps.
I would be happy to improve the function, should you send a reprex with the
desired final result.

Best wishes,
Adrian

	[[alternative HTML version deleted]]


From j|ox @end|ng |rom mcm@@ter@c@  Fri Dec  3 20:27:48 2021
From: j|ox @end|ng |rom mcm@@ter@c@ (Fox, John)
Date: Fri, 3 Dec 2021 19:27:48 +0000
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <c31cc520-d4dc-a8c4-ac94-40323e63c8cb@sapo.pt>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
 <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
 <c31cc520-d4dc-a8c4-ac94-40323e63c8cb@sapo.pt>
Message-ID: <97C656F9-F4BF-4EC1-8874-74E2B69B5E90@mcmaster.ca>

Dear Rui,

Thanks for this. Simon referred to demo(error.catching), and Adrian's version returns the printed representation of the result along with messages.

Best,
 John

?On 2021-12-03, 11:35 AM, "Rui Barradas" <ruipbarradas at sapo.pt> wrote:

    Hello,

    I remembered having seen a function tryCatch.W.E and after an online 
    search, found where.
    It was in a R-Help post and in demo(error.catching). The question by 
    Marius Hofert [1] was answered, among others, by Martin Maechler [2] 
    which included the function tryCatch.W.E.

    These posts refer to an old thread dated 2004 [3], with an answer by 
    Luke Tierney [4]. The function withWarnings posted by Luke returns all 
    warning messages in a list, as seen below.
    I repost the function to have this self contained.



    withWarnings <- function (expr) {
       warnings <- character()
       retval <- withCallingHandlers(expr, warning = function(ex) {
         warnings <<- c(warnings, conditionMessage(ex))
         invokeRestart("muffleWarning")
       })
       list(Value = retval, Warnings = warnings)
    }
    withWarnings(foo())
    #$Value
    #[1] "warning 2"
    #
    #$Warnings
    #[1] "warning 1" "warning 2"



    Function tryCatch.W.E is now part of contributed package simsalapar [5], 
    with credits to Marius and Martin given in its documentation.


    [1] https://stat.ethz.ch/pipermail/r-help/2010-December/262185.html
    [2] https://stat.ethz.ch/pipermail/r-help/2010-December/262626.html
    [3] https://stat.ethz.ch/pipermail/r-help/2004-June/052092.html
    [4] https://stat.ethz.ch/pipermail/r-help/2004-June/052132.html
    [5] https://CRAN.R-project.org/package=simsalapar


    Hope this helps,

    Rui Barradas



    ?s 22:37 de 02/12/21, Fox, John escreveu:
    > Dear Henrik, Simon, and Adrian,
    > 
    > As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I want, which is both to capture all messages and the result of the expression (rather than the visible representation of the result). I was easily able to modify tryCatchWEM() to return the result.
    > 
    > Henrik: I was aware that tryCatch() doesn't return the final result of the expression, and I was previously re-executing the expression to capture the reult, but only getting the first warning message, along with the result.
    > 
    > Thanks for responding to my question and providing viable solutions,
    >   John
    > 
    > On 2021-12-02, 5:19 PM, "Henrik Bengtsson" <henrik.bengtsson at gmail.com> wrote:
    > 
    >      Simon's suggestion with withCallingHandlers() is the correct way.
    >      Also, note that if you use tryCatch() to catch warnings, you're
    >      *interrupting* the evaluation of the expression of interest, e.g.
    > 
    >      > res <- tryCatch({ message("hey"); warning("boom"); message("there"); 42 }, warning = function(w) { message("Warning caught: ", conditionMessage(w)); 3.14 })
    >      hey
    >      Warning caught: boom
    >      > res
    >      [1] 3.14
    > 
    >      Note how it never completes your expression.
    > 
    >      /Henrik
    > 
    >      On Thu, Dec 2, 2021 at 1:14 PM Simon Urbanek
    >      <simon.urbanek at r-project.org> wrote:
    >      >
    >      >
    >      > Adapted from demo(error.catching):
    >      >
    >      > > W=list()
    >      > > withCallingHandlers(foo(), warning=function(w) { W <<- c(W, list(w)); invokeRestart("muffleWarning") })
    >      > > str(W)
    >      > List of 2
    >      >  $ :List of 2
    >      >   ..$ message: chr "warning 1"
    >      >   ..$ call   : language foo()
    >      >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
    >      >  $ :List of 2
    >      >   ..$ message: chr "warning 2"
    >      >   ..$ call   : language foo()
    >      >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
    >      >
    >      > Cheers,
    >      > Simon
    >      >
    >      >
    >      > > On Dec 3, 2021, at 10:02 AM, Fox, John <jfox at mcmaster.ca> wrote:
    >      > >
    >      > > Dear R-devel list members,
    >      > >
    >      > > Is it possible to capture more than one warning message using tryCatch()? The answer may be in ?conditions, but, if it is, I can't locate it.
    >      > >
    >      > > For example, in the following only the first warning message is captured and reported:
    >      > >
    >      > >> foo <- function(){
    >      > > +   warning("warning 1")
    >      > > +   warning("warning 2")
    >      > > + }
    >      > >
    >      > >> foo()
    >      > > Warning messages:
    >      > > 1: In foo() : warning 1
    >      > > 2: In foo() : warning 2
    >      > >
    >      > >> bar <- function(){
    >      > > +   tryCatch(foo(), warning=function(w) print(w))
    >      > > + }
    >      > >
    >      > >> bar()
    >      > > <simpleWarning in foo(): warning 1>
    >      > >
    >      > > Is there a way to capture "warning 2" as well?
    >      > >
    >      > > Any help would be appreciated.
    >      > >
    >      > > John
    >      > >
    >      > > --
    >      > > John Fox, Professor Emeritus
    >      > > McMaster University
    >      > > Hamilton, Ontario, Canada
    >      > > Web: http://socserv.mcmaster.ca/jfox/
    >      > >
    >      > >
    >      > >
    >      > > ______________________________________________
    >      > > R-devel at r-project.org mailing list
    >      > > https://stat.ethz.ch/mailman/listinfo/r-devel
    >      > >
    >      >
    >      > ______________________________________________
    >      > R-devel at r-project.org mailing list
    >      > https://stat.ethz.ch/mailman/listinfo/r-devel
    > 
    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel
    > 


From j|ox @end|ng |rom mcm@@ter@c@  Fri Dec  3 20:42:34 2021
From: j|ox @end|ng |rom mcm@@ter@c@ (Fox, John)
Date: Fri, 3 Dec 2021 19:42:34 +0000
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <20482_1638557779_1B3IuJTH009857_CAJ=0CtAVpv6QKAZwWxEB3fsjUD8PA6+-nBYnok=Kffa_SfNF3Q@mail.gmail.com>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
 <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
 <20482_1638557779_1B3IuJTH009857_CAJ=0CtAVpv6QKAZwWxEB3fsjUD8PA6+-nBYnok=Kffa_SfNF3Q@mail.gmail.com>
Message-ID: <D3316D5B-283C-4FE0-ADF5-07C7F821872A@mcmaster.ca>

Dear Adrian,

Here's my slightly modified version of your function, which serves my purpose:

------- snip -------

tryCatchWEM <- function (expr, capture = TRUE) {
    toreturn <- list()
    output <- withVisible(withCallingHandlers(
        tryCatch(expr, 
                 error = function(e) {
                     toreturn$error <<- e$message
                     NULL
                 }), warning = function(w) {
                     toreturn$warning <<- c(toreturn$warning, w$message)
                     invokeRestart("muffleWarning")
                 }, message = function(m) {
                     toreturn$message <<- paste(toreturn$message, m$message, 
                                                sep = "")
                     invokeRestart("muffleMessage")
                 }))
    if (capture & output$visible) {
        if (!is.null(output$value)) {
            toreturn$result <- output$value
        }
    }
    if (length(toreturn) > 0) {
        return(toreturn)
    }
}

------- snip -------

The two small modifications are to change the default of capture to TRUE and to return output$value rather than capture.output(output$value). So a suggestion would be to modify the capture argument to, say, capture=c("no", "output", "value") and then something like

	. . .
	capture <- match.arg(capture)
	. . .
	if (capture == "output"){
      	toreturn$output <- capture.output(output$value)
	} else if (capture == "value"){
		toreturn$value <- output$value
	}
	. . .

Best,
 John

?On 2021-12-03, 1:56 PM, "R-devel on behalf of Adrian Du?a" <r-devel-bounces at r-project.org on behalf of dusa.adrian at gmail.com> wrote:

    On Fri, 3 Dec 2021 at 00:37, Fox, John <jfox at mcmaster.ca> wrote:

    > Dear Henrik, Simon, and Adrian,
    >
    > As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I want,
    > which is both to capture all messages and the result of the expression
    > (rather than the visible representation of the result). I was easily able
    > to modify tryCatchWEM() to return the result.
    >

    Glad it helps.
    I would be happy to improve the function, should you send a reprex with the
    desired final result.

    Best wishes,
    Adrian

    	[[alternative HTML version deleted]]

    ______________________________________________
    R-devel at r-project.org mailing list
    https://stat.ethz.ch/mailman/listinfo/r-devel


From du@@@@dr|@n @end|ng |rom gm@||@com  Sat Dec  4 00:26:44 2021
From: du@@@@dr|@n @end|ng |rom gm@||@com (=?UTF-8?B?QWRyaWFuIER1yJlh?=)
Date: Sat, 4 Dec 2021 01:26:44 +0200
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <D3316D5B-283C-4FE0-ADF5-07C7F821872A@mcmaster.ca>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
 <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
 <20482_1638557779_1B3IuJTH009857_CAJ=0CtAVpv6QKAZwWxEB3fsjUD8PA6+-nBYnok=Kffa_SfNF3Q@mail.gmail.com>
 <D3316D5B-283C-4FE0-ADF5-07C7F821872A@mcmaster.ca>
Message-ID: <CAJ=0CtC6ZOpbxTBKhgWmovQ9L1f4LKir-z92ru-XtrxgFV5X2Q@mail.gmail.com>

Dear John,

The logical argument capture is already in production use by other
packages, but I think this is easily solved by:

if (!is.null(output$value) & output$visible) {
    if (capture) {
        toreturn$output <- capture.output(output$value)
    }
    toreturn$value <- output$value
}

so that value is always part of the return list, if visible.

This is a very good suggestion, and I've already incorporated it into this
function.

All the best,
Adrian

On Fri, 3 Dec 2021 at 21:42, Fox, John <jfox at mcmaster.ca> wrote:

> Dear Adrian,
>
> Here's my slightly modified version of your function, which serves my
> purpose:
>
> ------- snip -------
>
> tryCatchWEM <- function (expr, capture = TRUE) {
>     toreturn <- list()
>     output <- withVisible(withCallingHandlers(
>         tryCatch(expr,
>                  error = function(e) {
>                      toreturn$error <<- e$message
>                      NULL
>                  }), warning = function(w) {
>                      toreturn$warning <<- c(toreturn$warning, w$message)
>                      invokeRestart("muffleWarning")
>                  }, message = function(m) {
>                      toreturn$message <<- paste(toreturn$message,
> m$message,
>                                                 sep = "")
>                      invokeRestart("muffleMessage")
>                  }))
>     if (capture & output$visible) {
>         if (!is.null(output$value)) {
>             toreturn$result <- output$value
>         }
>     }
>     if (length(toreturn) > 0) {
>         return(toreturn)
>     }
> }
>
> ------- snip -------
>
> The two small modifications are to change the default of capture to TRUE
> and to return output$value rather than capture.output(output$value). So a
> suggestion would be to modify the capture argument to, say, capture=c("no",
> "output", "value") and then something like
>
>         . . .
>         capture <- match.arg(capture)
>         . . .
>         if (capture == "output"){
>         toreturn$output <- capture.output(output$value)
>         } else if (capture == "value"){
>                 toreturn$value <- output$value
>         }
>         . . .
>
> Best,
>  John
>
> ?On 2021-12-03, 1:56 PM, "R-devel on behalf of Adrian Du?a" <
> r-devel-bounces at r-project.org on behalf of dusa.adrian at gmail.com> wrote:
>
>     On Fri, 3 Dec 2021 at 00:37, Fox, John <jfox at mcmaster.ca> wrote:
>
>     > Dear Henrik, Simon, and Adrian,
>     >
>     > As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I
> want,
>     > which is both to capture all messages and the result of the
> expression
>     > (rather than the visible representation of the result). I was easily
> able
>     > to modify tryCatchWEM() to return the result.
>     >
>
>     Glad it helps.
>     I would be happy to improve the function, should you send a reprex
> with the
>     desired final result.
>
>     Best wishes,
>     Adrian
>
>         [[alternative HTML version deleted]]
>
>     ______________________________________________
>     R-devel at r-project.org mailing list
>     https://stat.ethz.ch/mailman/listinfo/r-devel
>
>

	[[alternative HTML version deleted]]


From j|ox @end|ng |rom mcm@@ter@c@  Sat Dec  4 02:40:39 2021
From: j|ox @end|ng |rom mcm@@ter@c@ (Fox, John)
Date: Sat, 4 Dec 2021 01:40:39 +0000
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <8582_1638574041_1B3NRK7r032693_CAJ=0CtC6ZOpbxTBKhgWmovQ9L1f4LKir-z92ru-XtrxgFV5X2Q@mail.gmail.com>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
 <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
 <20482_1638557779_1B3IuJTH009857_CAJ=0CtAVpv6QKAZwWxEB3fsjUD8PA6+-nBYnok=Kffa_SfNF3Q@mail.gmail.com>
 <D3316D5B-283C-4FE0-ADF5-07C7F821872A@mcmaster.ca>
 <8582_1638574041_1B3NRK7r032693_CAJ=0CtC6ZOpbxTBKhgWmovQ9L1f4LKir-z92ru-XtrxgFV5X2Q@mail.gmail.com>
Message-ID: <4E0E55D8-250E-4781-BA8C-FBCEEFAD59BA@mcmaster.ca>

Dear Adrian,

For consistency, you might want to put toreturn$value <- output$value inside of if (capture) {}. In any event, it makes sense for me to wait for the modified admisc::tryCatchWEM to find its way to CRAN rather than to maintain my own version of the function.

Thanks for this,
 John

?On 2021-12-03, 6:27 PM, "R-devel on behalf of Adrian Du?a" <r-devel-bounces at r-project.org on behalf of dusa.adrian at gmail.com> wrote:

    Dear John,

    The logical argument capture is already in production use by other
    packages, but I think this is easily solved by:

    if (!is.null(output$value) & output$visible) {
        if (capture) {
            toreturn$output <- capture.output(output$value)
        }
        toreturn$value <- output$value
    }

    so that value is always part of the return list, if visible.

    This is a very good suggestion, and I've already incorporated it into this
    function.

    All the best,
    Adrian

    On Fri, 3 Dec 2021 at 21:42, Fox, John <jfox at mcmaster.ca> wrote:

    > Dear Adrian,
    >
    > Here's my slightly modified version of your function, which serves my
    > purpose:
    >
    > ------- snip -------
    >
    > tryCatchWEM <- function (expr, capture = TRUE) {
    >     toreturn <- list()
    >     output <- withVisible(withCallingHandlers(
    >         tryCatch(expr,
    >                  error = function(e) {
    >                      toreturn$error <<- e$message
    >                      NULL
    >                  }), warning = function(w) {
    >                      toreturn$warning <<- c(toreturn$warning, w$message)
    >                      invokeRestart("muffleWarning")
    >                  }, message = function(m) {
    >                      toreturn$message <<- paste(toreturn$message,
    > m$message,
    >                                                 sep = "")
    >                      invokeRestart("muffleMessage")
    >                  }))
    >     if (capture & output$visible) {
    >         if (!is.null(output$value)) {
    >             toreturn$result <- output$value
    >         }
    >     }
    >     if (length(toreturn) > 0) {
    >         return(toreturn)
    >     }
    > }
    >
    > ------- snip -------
    >
    > The two small modifications are to change the default of capture to TRUE
    > and to return output$value rather than capture.output(output$value). So a
    > suggestion would be to modify the capture argument to, say, capture=c("no",
    > "output", "value") and then something like
    >
    >         . . .
    >         capture <- match.arg(capture)
    >         . . .
    >         if (capture == "output"){
    >         toreturn$output <- capture.output(output$value)
    >         } else if (capture == "value"){
    >                 toreturn$value <- output$value
    >         }
    >         . . .
    >
    > Best,
    >  John
    >
    > On 2021-12-03, 1:56 PM, "R-devel on behalf of Adrian Du?a" <
    > r-devel-bounces at r-project.org on behalf of dusa.adrian at gmail.com> wrote:
    >
    >     On Fri, 3 Dec 2021 at 00:37, Fox, John <jfox at mcmaster.ca> wrote:
    >
    >     > Dear Henrik, Simon, and Adrian,
    >     >
    >     > As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I
    > want,
    >     > which is both to capture all messages and the result of the
    > expression
    >     > (rather than the visible representation of the result). I was easily
    > able
    >     > to modify tryCatchWEM() to return the result.
    >     >
    >
    >     Glad it helps.
    >     I would be happy to improve the function, should you send a reprex
    > with the
    >     desired final result.
    >
    >     Best wishes,
    >     Adrian
    >
    >         [[alternative HTML version deleted]]
    >
    >     ______________________________________________
    >     R-devel at r-project.org mailing list
    >     https://stat.ethz.ch/mailman/listinfo/r-devel
    >
    >

    	[[alternative HTML version deleted]]

    ______________________________________________
    R-devel at r-project.org mailing list
    https://stat.ethz.ch/mailman/listinfo/r-devel


From gr@ntmcd @end|ng |rom uoregon@edu  Sat Dec  4 23:36:44 2021
From: gr@ntmcd @end|ng |rom uoregon@edu (Grant McDermott)
Date: Sat, 4 Dec 2021 22:36:44 +0000
Subject: [Rd] string concatenation operator (revisited)
Message-ID: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>

Hi all,

I wonder if the R Core team might reconsider an old feature request, as detailed in this 2005 thread: https://stat.ethz.ch/pipermail/r-help/2005-February/thread.html#66698

The TL;DR version is base R support for a `+.character` method. This would essentially provide a shortcut to `paste?0`, in much the same way that `\(x)` now provides a shortcut to `function(x)`.

> a = "hello "; b = "world"
> a + b
> [1] "hello world"

I appreciate some of the original concerns raised against a native "string1 + string2" implementation. The above thread also provides several use-at-your-own-risk workarounds. But sixteen years is a long time in software development and R now stands as something of an exception on this score. Python, Julia, Stata, and SQL (among various others) all support native string concatenation/interpolation using binary/arithmetic operators. It's been a surprising source of frustration for students in some of the classes I teach, particularly those coming from another language.

Many thanks for considering.

PS. I hope I didn't miss any additional discussion of this issue beyond the original 2005 thread. My search efforts didn't turn anything else up, except this popular Stackoverflow question: https://stackoverflow.com/questions/4730551/making-a-string-concatenation-operator-in-r

Grant McDermott
Assistant Professor
Department of Economics
University of Oregon
www.grantmcdermott.com


	[[alternative HTML version deleted]]


From @v|gro@@ @end|ng |rom ver|zon@net  Sun Dec  5 03:26:05 2021
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Sat, 4 Dec 2021 21:26:05 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
References: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
Message-ID: <00df01d7e97f$74cc8d80$5e65a880$@verizon.net>

Grant,

One nit to consider is that the default behavior of pasteo() to include a space as a separator would not be a perfect choice for the usual meaning of plus. 

I would prefer a+b to be "helloworld" in your example and to get what you say would be 

a + " " + b

Which I assume would put in a space where you want it and not where you don't.

As I am sure you have been told, you already can make an operator like this:

`%+%` <- function(x, y) paste0(x, y)

And then use:

a %+% b

And to do it this way, you might have two such functions where %+% does NOT add a space but the odd version with a space in it, % +% or %++% does add a space!

`%+%` <- function(x, y) paste0(x, y, sep="")
`%++%` <- function(x, y) paste0(x, " ",  y)
`% +%` <- function(x, y) paste0(x, " ",  y)

Now testing it with:

a = "hello"; b = "world" # NOTE I removed the trailing space you had in "a".

> a %+% b
[1] "helloworld"
> a %++% b
[1] "hello world"
> a % +% b
[1] "hello world"

It also seems to work with multiple units mixed in a row as shown below:

> a %+% b % +% a %++% b
[1] "helloworld hello world"

And it sort of works with vectors of strings or numbers using string concatenation:

> a <- letters[1:3]
> b <- seq(from=101, to = 301, by = 100)
> a %+% b %+% a
[1] "a101a" "b201b" "c301c"

But are you asking for a naked "+" sign to be vectorized like that?

And what if someone accidentally types something like:

a = "text"
a = a + 1

The addition now looks like adding an integer to a text string. In many languages, like PERL, this results in implicated conversion to make "text1" the result. My work-around does that:

> a = a %+% 1
> a
[1] "text1"

BUT what you are asking for is for R to do normal addition if a and b are both numeric and presumably do (as languages like Python do) text concatenation when they are both text. What do you suggest happen if one is numeric and the other is text or perhaps some arbitrary data type? 

I checked to see what Python version 3.9 does:

>>> 5 + 4
9
>>> "5" + "4"
'54'
>>> "5" + 4
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    "5" + 4
TypeError: can only concatenate str (not "int") to str

It is clear it does not normally support such mixed methods, albeit I can probably easily create an object sub-class where I create a dunder method that perhaps checks if one of the two things being added can be coerced into a string or into a number as needed to convert so the two types match.

But this is about R.

As others have said, the underlying early philosophy of R being created as a language did not head the same way as some other languages and R is mainly not the same kind of object-oriented as some others and thus some things are not trivially done but can be done using other ways like the %+% technique above.

But R also allows weird things like this: 
# VERY CAREFULLY as overwriting "+" means you cannot use it in your other ...
# So not a suggested idea but if done you must preserve the original meaning of plus elsewhere like I do.

flexible_plus <- function(first, second) {
  if (all(is.numeric(first), is.numeric(second))) return(first + second)
  if (all(is.character(first), is.character(second))) return(paste0(first, second))
  # If you reach here, there is an error
  print("ERROR: both arguments must be numeric or both character")
  return(NULL)
}

Now define things carefully to use something like the function flexible_plus I created becoming the MEANING of a naked plus sign.  But note it will now be used in other ways and places in any code that does addition so it is not an ideal solution. It does sort of work, FWIW.

`%+++%` <- `+`
`+` <- flexible_plus

Finally some testing:

> 5 %+++% 3
[1] 8
> flexible_plus(5, 3)
[1] 8
> 5 + 3
[1] 8
> "hello" + "world"
[1] "helloworld"
> "hello" + 5
[1] "ERROR: both arguments must be numeric or both character"
NULL

It does seem to do approximately what I said it would do but also does some vectorized things as well as long as all are the same type:

> c(1,2,3) + 4
[1] 5 6 7
> c(1,2,3) + c(4,5,6)
[1] 5 7 9
> c("word1", "word2", "word3") + "more"
[1] "word1more" "word2more" "word3more"
> c("word1", "word2", "word3") + c("more", "snore")
[1] "word1more"  "word2snore" "word3more"

Again, the above code is for illustration purposes only. I would be beyond shocked if the above did not break something somewhere and it certainly is not as efficient as the built-in adder. As an exercise, it looks reasonable. LOL!


-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Grant McDermott
Sent: Saturday, December 4, 2021 5:37 PM
To: r-devel at r-project.org
Subject: [Rd] string concatenation operator (revisited)

Hi all,

I wonder if the R Core team might reconsider an old feature request, as detailed in this 2005 thread: https://stat.ethz.ch/pipermail/r-help/2005-February/thread.html#66698

The TL;DR version is base R support for a `+.character` method. This would essentially provide a shortcut to `paste?0`, in much the same way that `\(x)` now provides a shortcut to `function(x)`.

> a = "hello "; b = "world"
> a + b
> [1] "hello world"

I appreciate some of the original concerns raised against a native "string1 + string2" implementation. The above thread also provides several use-at-your-own-risk workarounds. But sixteen years is a long time in software development and R now stands as something of an exception on this score. Python, Julia, Stata, and SQL (among various others) all support native string concatenation/interpolation using binary/arithmetic operators. It's been a surprising source of frustration for students in some of the classes I teach, particularly those coming from another language.

Many thanks for considering.

PS. I hope I didn't miss any additional discussion of this issue beyond the original 2005 thread. My search efforts didn't turn anything else up, except this popular Stackoverflow question: https://stackoverflow.com/questions/4730551/making-a-string-concatenation-operator-in-r

Grant McDermott
Assistant Professor
Department of Economics
University of Oregon
www.grantmcdermott.com


	[[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Sun Dec  5 08:41:05 2021
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Sun, 5 Dec 2021 07:41:05 +0000
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
References: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
Message-ID: <5aa24f01-b224-c19c-c3a4-3b96c27f0413@sapo.pt>

Hello,

Bert Gunter started a very recent R-Help thread [1] about the following 
method not working.

`+.character` <- function(x, y) paste0(x, y)


The discussion is worth reading and at least partly answers to the 
reason why the feature request has never made it to base R.

It goes without saying that I do not speak for the R Core team.


[1] https://stat.ethz.ch/pipermail/r-help/2021-December/473163.html


Hope this helps,

Rui Barradas

?s 22:36 de 04/12/21, Grant McDermott escreveu:
> Hi all,
> 
> I wonder if the R Core team might reconsider an old feature request, as detailed in this 2005 thread: https://stat.ethz.ch/pipermail/r-help/2005-February/thread.html#66698
> 
> The TL;DR version is base R support for a `+.character` method. This would essentially provide a shortcut to `paste?0`, in much the same way that `\(x)` now provides a shortcut to `function(x)`.
> 
>> a = "hello "; b = "world"
>> a + b
>> [1] "hello world"
> 
> I appreciate some of the original concerns raised against a native "string1 + string2" implementation. The above thread also provides several use-at-your-own-risk workarounds. But sixteen years is a long time in software development and R now stands as something of an exception on this score. Python, Julia, Stata, and SQL (among various others) all support native string concatenation/interpolation using binary/arithmetic operators. It's been a surprising source of frustration for students in some of the classes I teach, particularly those coming from another language.
> 
> Many thanks for considering.
> 
> PS. I hope I didn't miss any additional discussion of this issue beyond the original 2005 thread. My search efforts didn't turn anything else up, except this popular Stackoverflow question: https://stackoverflow.com/questions/4730551/making-a-string-concatenation-operator-in-r
> 
> Grant McDermott
> Assistant Professor
> Department of Economics
> University of Oregon
> www.grantmcdermott.com
> 
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From kry|ov@r00t @end|ng |rom gm@||@com  Sun Dec  5 13:22:12 2021
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Sun, 5 Dec 2021 15:22:12 +0300
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <00df01d7e97f$74cc8d80$5e65a880$@verizon.net>
References: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
 <00df01d7e97f$74cc8d80$5e65a880$@verizon.net>
Message-ID: <20211205152212.3b7a6806@Tarkus>

On Sat, 4 Dec 2021 21:26:05 -0500
Avi Gross via R-devel <r-devel at r-project.org> wrote:

> In many languages, like PERL, this results in implicated conversion
> to make "text1" the result.

FWIW, Perl5 has a separate string concatenation operator (".") in order
to avoid potential confusion with addition. So do Lua (".."), SQL
("||", only some of the dialects) and Raku ("~", former Perl6). Some of
the potential concerns with string concatenation as an operator in R
could be alleviated by introducing a separate operator, just like matrix
multiplication ("%*%") is separate from elementwise multiplication
("*"), nowadays even in Python ("@" and "*", respectively).

-- 
Best regards,
Ivan


From Andre@G||||bert @end|ng |rom chu-rouen@|r  Sun Dec  5 14:56:27 2021
From: Andre@G||||bert @end|ng |rom chu-rouen@|r (GILLIBERT, Andre)
Date: Sun, 5 Dec 2021 13:56:27 +0000
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <20211205152212.3b7a6806@Tarkus>
References: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
 <00df01d7e97f$74cc8d80$5e65a880$@verizon.net>, <20211205152212.3b7a6806@Tarkus>
Message-ID: <a6c3a2ab3af8492b8ef6a2670f833e9f@chu-rouen.fr>

Ivan Krylov <krylov.r00t at gmail.com> wrote:
> FWIW, Perl5 has a separate string concatenation operator (".") in order
> to avoid potential confusion with addition. So do Lua (".."), SQL
> ("||", only some of the dialects) and Raku ("~", former Perl6).


Indeed, using the same operator '+' for addition and string concatenation is not a great idea in my opinion.
Accidental character arguments to a '+' that meant to be a numerical addition would go undetected. Bug tracking would be harder in that case.

R is already too permissive: it finds some interpretation of most probably buggy code, such as ifelse() on vectors of unequal length or '[' operator with only one argument to index a matrix. I would not want to add new permissive behaviors.

A new operator, dedicated to string concatenation, such as %+% or %.%, would be better, in my opinion.

--
Sincerely
Andr? GILLIBERT

	[[alternative HTML version deleted]]


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Dec  5 17:50:23 2021
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sun, 5 Dec 2021 11:50:23 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <20211205152212.3b7a6806@Tarkus>
References: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
 <00df01d7e97f$74cc8d80$5e65a880$@verizon.net>
 <20211205152212.3b7a6806@Tarkus>
Message-ID: <a499c740-940d-7ef0-b80c-70b968983a65@gmail.com>

On 05/12/2021 7:22 a.m., Ivan Krylov wrote:
> On Sat, 4 Dec 2021 21:26:05 -0500
> Avi Gross via R-devel <r-devel at r-project.org> wrote:
> 
>> In many languages, like PERL, this results in implicated conversion
>> to make "text1" the result.
> 
> FWIW, Perl5 has a separate string concatenation operator (".") in order
> to avoid potential confusion with addition. So do Lua (".."), SQL
> ("||", only some of the dialects) and Raku ("~", former Perl6). Some of
> the potential concerns with string concatenation as an operator in R
> could be alleviated by introducing a separate operator, just like matrix
> multiplication ("%*%") is separate from elementwise multiplication
> ("*"), nowadays even in Python ("@" and "*", respectively).
> 

People seem to handle the automatic conversion of comparison operators. 
  Occasionally someone is surprised that

   123 < "5"

is TRUE, but mostly people muddle along.

One possible issue is that for some things (e.g. S3 Arith group 
generic), "+" is grouped with the other arithmetic operators, "-", "*", 
"^", "%%", "%/%", "/".  I don't think it would make sense for any of 
them to work on strings.  But there are exceptions listed for number of 
arguments among the Math group, so an exception in the Arith group 
wouldn't be the end of the world.

Duncan Murdoch


From r@d|ord @end|ng |rom c@@toronto@edu  Mon Dec  6 07:14:02 2021
From: r@d|ord @end|ng |rom c@@toronto@edu (Radford Neal)
Date: Mon, 6 Dec 2021 01:14:02 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
Message-ID: <20211206061402.GA3810@mail.cs.toronto.edu>

> The TL;DR version is base R support for a `+.character` method. This
> would essentially provide a shortcut to `paste0`...

In pqR (see pqR-project.org), I have implemented ! and !! as binary
string concatenation operators, equivalent to paste0 and paste,
respectively.  

For instance,

    > "hello" ! "world"
    [1] "helloworld"
    > "hello" !! "world"
    [1] "hello world"
    > "hello" !! 1:4
    [1] "hello 1" "hello 2" "hello 3" "hello 4"
    
This seems preferable to overloading the + operator, which would lead
to people reading code wondering whether a+b is doing an addition or a
string concatenation.  There are very few circumstances in which one
would want to write code where a+b might be either of these.  So it's
better to make clear what is going on by having a different operator
for string concatenation.  

Plus ! and !! semm natural for representing paste0 and paste, whereas
using ++ for paste (with + for paste0) would look rather strange.

   Radford Neal


From murdoch@dunc@n @end|ng |rom gm@||@com  Mon Dec  6 11:06:42 2021
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Mon, 6 Dec 2021 05:06:42 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <20211206061402.GA3810@mail.cs.toronto.edu>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
Message-ID: <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>

On 06/12/2021 1:14 a.m., Radford Neal wrote:
>> The TL;DR version is base R support for a `+.character` method. This
>> would essentially provide a shortcut to `paste0`...
> 
> In pqR (see pqR-project.org), I have implemented ! and !! as binary
> string concatenation operators, equivalent to paste0 and paste,
> respectively.
> 
> For instance,
> 
>      > "hello" ! "world"
>      [1] "helloworld"
>      > "hello" !! "world"
>      [1] "hello world"
>      > "hello" !! 1:4
>      [1] "hello 1" "hello 2" "hello 3" "hello 4"

I'm curious about the details:

Would `1 ! 2` convert both to strings?

Where does the binary ! fit in the operator priority?  E.g. how is

   a ! b > c

parsed?

Duncan Murdoch


>      
> This seems preferable to overloading the + operator, which would lead
> to people reading code wondering whether a+b is doing an addition or a
> string concatenation.  There are very few circumstances in which one
> would want to write code where a+b might be either of these.  So it's
> better to make clear what is going on by having a different operator
> for string concatenation.
> 
> Plus ! and !! semm natural for representing paste0 and paste, whereas
> using ++ for paste (with + for paste0) would look rather strange.
> 
>     Radford Neal
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From th|erry@onke||nx @end|ng |rom |nbo@be  Mon Dec  6 13:02:45 2021
From: th|erry@onke||nx @end|ng |rom |nbo@be (Thierry Onkelinx)
Date: Mon, 6 Dec 2021 13:02:45 +0100
Subject: [Rd] install.packages() and Additional_repositories
Message-ID: <CAJuCY5zvTbKbMX3T8Rwu3tkDcOGv1z=hHo5rYN78SQkUeuEppA@mail.gmail.com>

Dear R core team,

Writing R extensions mentions an optional 'Additional_repositories' field
in the DESCRIPTION. (
https://cran.r-project.org/doc/manuals/R-exts.html#Package-Dependencies).
Currently, install.packages() does not use that information when installing
a package. Would you accept a patch to amend this?

If so, should install.packages() use the `Additional_repositories` when
listed? Or should that be based on an extra argument? E.g. additional_repos
= FALSE (default).

Best regards,

Thierry

ir. Thierry Onkelinx
Statisticus / Statistician

Vlaamse Overheid / Government of Flanders
INSTITUUT VOOR NATUUR- EN BOSONDERZOEK / RESEARCH INSTITUTE FOR NATURE AND
FOREST
Team Biometrie & Kwaliteitszorg / Team Biometrics & Quality Assurance
thierry.onkelinx at inbo.be
Havenlaan 88 bus 73, 1000 Brussel
www.inbo.be

///////////////////////////////////////////////////////////////////////////////////////////
To call in the statistician after the experiment is done may be no more
than asking him to perform a post-mortem examination: he may be able to say
what the experiment died of. ~ Sir Ronald Aylmer Fisher
The plural of anecdote is not data. ~ Roger Brinner
The combination of some data and an aching desire for an answer does not
ensure that a reasonable answer can be extracted from a given body of data.
~ John Tukey
///////////////////////////////////////////////////////////////////////////////////////////

<https://www.inbo.be>

	[[alternative HTML version deleted]]


From @zwj|08 @end|ng |rom gm@||@com  Mon Dec  6 18:23:26 2021
From: @zwj|08 @end|ng |rom gm@||@com (Jiefei Wang)
Date: Mon, 6 Dec 2021 12:23:26 -0500
Subject: [Rd] Great overhead for setTimeLimit?
Message-ID: <CAGiFhPNCBG_iieiNmo6+4a0cMnO-0Arfkj2zuUDO=+2MdZONow@mail.gmail.com>

Hi all,

>From the document of 'setTimeLimit', it states "Setting any limit has
a small overhead ? well under 1% on the systems measured.", but
something is wrong with my benchmark code, enabling the time limit
makes my benchmark 1x slower than the benchmark without the limit.
Below is an example

```
benchFunc <- function(x, data) {
    value <- 0
    for(i in 1:5000){
        for(j in seq_along(data))
            value <- value + data[j]
    }
    value
}
data <- sample(1:10, 10)

setTimeLimit(Inf, Inf, FALSE)
system.time(lapply(1:5000, benchFunc, data = data))

setTimeLimit(999, 999, FALSE)
system.time(lapply(1:5000, benchFunc, data = data))
```

Here are the test results

> setTimeLimit(Inf, Inf, FALSE)
> system.time(lapply(1:5000, benchFunc, data = data))
   user  system elapsed
 10.809   0.006  10.812
> setTimeLimit(999, 999, FALSE)
> system.time(lapply(1:5000, benchFunc, data = data))
   user  system elapsed
 13.634   6.478  20.106


As a side note, it looks like the GC consumes the most CPU time. The
GC costs 10 secs without the time limit, but 19 secs with the limit.
Any thoughts?

Best,
Jiefei


From r@d|ord @end|ng |rom c@@toronto@edu  Mon Dec  6 19:03:02 2021
From: r@d|ord @end|ng |rom c@@toronto@edu (Radford Neal)
Date: Mon, 6 Dec 2021 13:03:02 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
Message-ID: <20211206180302.GA6850@mail.cs.toronto.edu>

> > In pqR (see pqR-project.org), I have implemented ! and !! as binary
> > string concatenation operators, equivalent to paste0 and paste,
> > respectively.
> > 
> > For instance,
> > 
> >      > "hello" ! "world"
> >      [1] "helloworld"
> >      > "hello" !! "world"
> >      [1] "hello world"
> >      > "hello" !! 1:4
> >      [1] "hello 1" "hello 2" "hello 3" "hello 4"
> 
> I'm curious about the details:
> 
> Would `1 ! 2` convert both to strings?

They're equivalent to paste0 and paste, so 1 ! 2 produces "12", just
like paste0(1,2) does.  Of course, they wouldn't have to be exactly
equivalent to paste0 and paste - one could impose stricter
requirements if that seemed better for error detection.  Off hand,
though, I think automatically converting is more in keeping with the
rest of R.  Explicitly converting with as.character could be tedious.

I suppose disallowing logical arguments might make sense to guard
against typos where ! was meant to be the unary-not operator, but
ended up being a binary operator, after some sort of typo.  I doubt
that this would be a common error, though.

(Note that there's no ambiguity when there are no typos, except that
when negation is involved a space may be needed - so, for example, 
"x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  Existing uses of
double negation are still fine - eg, a <- !!TRUE still sets a to TRUE.
Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not "xTRUE".)

> Where does the binary ! fit in the operator priority?  E.g. how is
> 
>   a ! b > c
> 
> parsed?

As (a ! b) > c.

Their precedence is between that of + and - and that of < and >.
So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.  

(Actually, pqR also has a .. operator that fixes the problems with
generating sequences with the : operator, and it has precedence lower
than + and - and higher than ! and !!, but that's not relevant if you
don't have the .. operator.)

   Radford Neal


From g@bembecker @end|ng |rom gm@||@com  Mon Dec  6 21:34:40 2021
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Mon, 6 Dec 2021 12:34:40 -0800
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <20211206180302.GA6850@mail.cs.toronto.edu>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
Message-ID: <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>

Hi All,

Seeing this and the other thread (and admittedly not having clicked through
to the linked r-help thread), I wonder about NAs.

Should NA <concat> "hi there"  not result in NA_character_? This is not
what any of the paste functions do, but in my opinoin, NA + <non_na_value>
seems like it should be NA  (not "NA"), particularly if we are talking
about `+` overloading, but potentially even in the case of a distinct
concatenation operator?

I guess what I'm saying is that in my head missingness propagation rules
should take priority in such an operator (ie NA + <anything> should
*always * be NA).

Is that something others disagree with, or has it just not come up yet in
(the parts I have read) of this discussion?

Best,
~G

On Mon, Dec 6, 2021 at 10:03 AM Radford Neal <radford at cs.toronto.edu> wrote:

> > > In pqR (see pqR-project.org), I have implemented ! and !! as binary
> > > string concatenation operators, equivalent to paste0 and paste,
> > > respectively.
> > >
> > > For instance,
> > >
> > >      > "hello" ! "world"
> > >      [1] "helloworld"
> > >      > "hello" !! "world"
> > >      [1] "hello world"
> > >      > "hello" !! 1:4
> > >      [1] "hello 1" "hello 2" "hello 3" "hello 4"
> >
> > I'm curious about the details:
> >
> > Would `1 ! 2` convert both to strings?
>
> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", just
> like paste0(1,2) does.  Of course, they wouldn't have to be exactly
> equivalent to paste0 and paste - one could impose stricter
> requirements if that seemed better for error detection.  Off hand,
> though, I think automatically converting is more in keeping with the
> rest of R.  Explicitly converting with as.character could be tedious.
>
> I suppose disallowing logical arguments might make sense to guard
> against typos where ! was meant to be the unary-not operator, but
> ended up being a binary operator, after some sort of typo.  I doubt
> that this would be a common error, though.
>
> (Note that there's no ambiguity when there are no typos, except that
> when negation is involved a space may be needed - so, for example,
> "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  Existing uses of
> double negation are still fine - eg, a <- !!TRUE still sets a to TRUE.
> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not "xTRUE".)
>
> > Where does the binary ! fit in the operator priority?  E.g. how is
> >
> >   a ! b > c
> >
> > parsed?
>
> As (a ! b) > c.
>
> Their precedence is between that of + and - and that of < and >.
> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>
> (Actually, pqR also has a .. operator that fixes the problems with
> generating sequences with the : operator, and it has precedence lower
> than + and - and higher than ! and !!, but that's not relevant if you
> don't have the .. operator.)
>
>    Radford Neal
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From @vr@h@m@@d|er @end|ng |rom gm@||@com  Mon Dec  6 22:21:37 2021
From: @vr@h@m@@d|er @end|ng |rom gm@||@com (Avraham Adler)
Date: Mon, 6 Dec 2021 16:21:37 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
Message-ID: <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>

Gabe, I agree that missingness is important to factor in. To somewhat abuse
the terminology, NA is often used to represent missingness. Perhaps
concatenating character something with character something missing should
result in the original character?

Avi

On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker <gabembecker at gmail.com> wrote:

> Hi All,
>
> Seeing this and the other thread (and admittedly not having clicked through
> to the linked r-help thread), I wonder about NAs.
>
> Should NA <concat> "hi there"  not result in NA_character_? This is not
> what any of the paste functions do, but in my opinoin, NA + <non_na_value>
> seems like it should be NA  (not "NA"), particularly if we are talking
> about `+` overloading, but potentially even in the case of a distinct
> concatenation operator?
>
> I guess what I'm saying is that in my head missingness propagation rules
> should take priority in such an operator (ie NA + <anything> should
> *always * be NA).
>
> Is that something others disagree with, or has it just not come up yet in
> (the parts I have read) of this discussion?
>
> Best,
> ~G
>
> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal <radford at cs.toronto.edu>
> wrote:
>
> > > > In pqR (see pqR-project.org), I have implemented ! and !! as binary
> > > > string concatenation operators, equivalent to paste0 and paste,
> > > > respectively.
> > > >
> > > > For instance,
> > > >
> > > >      > "hello" ! "world"
> > > >      [1] "helloworld"
> > > >      > "hello" !! "world"
> > > >      [1] "hello world"
> > > >      > "hello" !! 1:4
> > > >      [1] "hello 1" "hello 2" "hello 3" "hello 4"
> > >
> > > I'm curious about the details:
> > >
> > > Would `1 ! 2` convert both to strings?
> >
> > They're equivalent to paste0 and paste, so 1 ! 2 produces "12", just
> > like paste0(1,2) does.  Of course, they wouldn't have to be exactly
> > equivalent to paste0 and paste - one could impose stricter
> > requirements if that seemed better for error detection.  Off hand,
> > though, I think automatically converting is more in keeping with the
> > rest of R.  Explicitly converting with as.character could be tedious.
> >
> > I suppose disallowing logical arguments might make sense to guard
> > against typos where ! was meant to be the unary-not operator, but
> > ended up being a binary operator, after some sort of typo.  I doubt
> > that this would be a common error, though.
> >
> > (Note that there's no ambiguity when there are no typos, except that
> > when negation is involved a space may be needed - so, for example,
> > "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  Existing uses of
> > double negation are still fine - eg, a <- !!TRUE still sets a to TRUE.
> > Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not "xTRUE".)
> >
> > > Where does the binary ! fit in the operator priority?  E.g. how is
> > >
> > >   a ! b > c
> > >
> > > parsed?
> >
> > As (a ! b) > c.
> >
> > Their precedence is between that of + and - and that of < and >.
> > So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
> >
> > (Actually, pqR also has a .. operator that fixes the problems with
> > generating sequences with the : operator, and it has precedence lower
> > than + and - and higher than ! and !!, but that's not relevant if you
> > don't have the .. operator.)
> >
> >    Radford Neal
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
-- 
Sent from Gmail Mobile

	[[alternative HTML version deleted]]


From murdoch@dunc@n @end|ng |rom gm@||@com  Mon Dec  6 22:28:01 2021
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Mon, 6 Dec 2021 16:28:01 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
Message-ID: <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>

On 06/12/2021 4:21 p.m., Avraham Adler wrote:
> Gabe, I agree that missingness is important to factor in. To somewhat abuse
> the terminology, NA is often used to represent missingness. Perhaps
> concatenating character something with character something missing should
> result in the original character?

I think that's a bad idea.  If you wanted to represent an empty string, 
you should use "" or NULL, not NA.

I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it should 
give NA.

Duncan Murdoch

> 
> Avi
> 
> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker <gabembecker at gmail.com> wrote:
> 
>> Hi All,
>>
>> Seeing this and the other thread (and admittedly not having clicked through
>> to the linked r-help thread), I wonder about NAs.
>>
>> Should NA <concat> "hi there"  not result in NA_character_? This is not
>> what any of the paste functions do, but in my opinoin, NA + <non_na_value>
>> seems like it should be NA  (not "NA"), particularly if we are talking
>> about `+` overloading, but potentially even in the case of a distinct
>> concatenation operator?
>>
>> I guess what I'm saying is that in my head missingness propagation rules
>> should take priority in such an operator (ie NA + <anything> should
>> *always * be NA).
>>
>> Is that something others disagree with, or has it just not come up yet in
>> (the parts I have read) of this discussion?
>>
>> Best,
>> ~G
>>
>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal <radford at cs.toronto.edu>
>> wrote:
>>
>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as binary
>>>>> string concatenation operators, equivalent to paste0 and paste,
>>>>> respectively.
>>>>>
>>>>> For instance,
>>>>>
>>>>>       > "hello" ! "world"
>>>>>       [1] "helloworld"
>>>>>       > "hello" !! "world"
>>>>>       [1] "hello world"
>>>>>       > "hello" !! 1:4
>>>>>       [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>
>>>> I'm curious about the details:
>>>>
>>>> Would `1 ! 2` convert both to strings?
>>>
>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", just
>>> like paste0(1,2) does.  Of course, they wouldn't have to be exactly
>>> equivalent to paste0 and paste - one could impose stricter
>>> requirements if that seemed better for error detection.  Off hand,
>>> though, I think automatically converting is more in keeping with the
>>> rest of R.  Explicitly converting with as.character could be tedious.
>>>
>>> I suppose disallowing logical arguments might make sense to guard
>>> against typos where ! was meant to be the unary-not operator, but
>>> ended up being a binary operator, after some sort of typo.  I doubt
>>> that this would be a common error, though.
>>>
>>> (Note that there's no ambiguity when there are no typos, except that
>>> when negation is involved a space may be needed - so, for example,
>>> "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  Existing uses of
>>> double negation are still fine - eg, a <- !!TRUE still sets a to TRUE.
>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not "xTRUE".)
>>>
>>>> Where does the binary ! fit in the operator priority?  E.g. how is
>>>>
>>>>    a ! b > c
>>>>
>>>> parsed?
>>>
>>> As (a ! b) > c.
>>>
>>> Their precedence is between that of + and - and that of < and >.
>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>
>>> (Actually, pqR also has a .. operator that fixes the problems with
>>> generating sequences with the : operator, and it has precedence lower
>>> than + and - and higher than ! and !!, but that's not relevant if you
>>> don't have the .. operator.)
>>>
>>>     Radford Neal
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>
>>          [[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>


From w||||@mwdun|@p @end|ng |rom gm@||@com  Tue Dec  7 01:11:29 2021
From: w||||@mwdun|@p @end|ng |rom gm@||@com (Bill Dunlap)
Date: Mon, 6 Dec 2021 16:11:29 -0800
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
Message-ID: <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>

Should paste0(character(0), c("a","b")) give character(0)?
There is a fair bit of code that assumes that paste("X",NULL) gives "X" but
c(1,2)+NULL gives numeric(0).

-Bill

On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:

> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
> > Gabe, I agree that missingness is important to factor in. To somewhat
> abuse
> > the terminology, NA is often used to represent missingness. Perhaps
> > concatenating character something with character something missing should
> > result in the original character?
>
> I think that's a bad idea.  If you wanted to represent an empty string,
> you should use "" or NULL, not NA.
>
> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it should
> give NA.
>
> Duncan Murdoch
>
> >
> > Avi
> >
> > On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker <gabembecker at gmail.com>
> wrote:
> >
> >> Hi All,
> >>
> >> Seeing this and the other thread (and admittedly not having clicked
> through
> >> to the linked r-help thread), I wonder about NAs.
> >>
> >> Should NA <concat> "hi there"  not result in NA_character_? This is not
> >> what any of the paste functions do, but in my opinoin, NA +
> <non_na_value>
> >> seems like it should be NA  (not "NA"), particularly if we are talking
> >> about `+` overloading, but potentially even in the case of a distinct
> >> concatenation operator?
> >>
> >> I guess what I'm saying is that in my head missingness propagation rules
> >> should take priority in such an operator (ie NA + <anything> should
> >> *always * be NA).
> >>
> >> Is that something others disagree with, or has it just not come up yet
> in
> >> (the parts I have read) of this discussion?
> >>
> >> Best,
> >> ~G
> >>
> >> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal <radford at cs.toronto.edu>
> >> wrote:
> >>
> >>>>> In pqR (see pqR-project.org), I have implemented ! and !! as binary
> >>>>> string concatenation operators, equivalent to paste0 and paste,
> >>>>> respectively.
> >>>>>
> >>>>> For instance,
> >>>>>
> >>>>>       > "hello" ! "world"
> >>>>>       [1] "helloworld"
> >>>>>       > "hello" !! "world"
> >>>>>       [1] "hello world"
> >>>>>       > "hello" !! 1:4
> >>>>>       [1] "hello 1" "hello 2" "hello 3" "hello 4"
> >>>>
> >>>> I'm curious about the details:
> >>>>
> >>>> Would `1 ! 2` convert both to strings?
> >>>
> >>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", just
> >>> like paste0(1,2) does.  Of course, they wouldn't have to be exactly
> >>> equivalent to paste0 and paste - one could impose stricter
> >>> requirements if that seemed better for error detection.  Off hand,
> >>> though, I think automatically converting is more in keeping with the
> >>> rest of R.  Explicitly converting with as.character could be tedious.
> >>>
> >>> I suppose disallowing logical arguments might make sense to guard
> >>> against typos where ! was meant to be the unary-not operator, but
> >>> ended up being a binary operator, after some sort of typo.  I doubt
> >>> that this would be a common error, though.
> >>>
> >>> (Note that there's no ambiguity when there are no typos, except that
> >>> when negation is involved a space may be needed - so, for example,
> >>> "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  Existing uses of
> >>> double negation are still fine - eg, a <- !!TRUE still sets a to TRUE.
> >>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
> "xTRUE".)
> >>>
> >>>> Where does the binary ! fit in the operator priority?  E.g. how is
> >>>>
> >>>>    a ! b > c
> >>>>
> >>>> parsed?
> >>>
> >>> As (a ! b) > c.
> >>>
> >>> Their precedence is between that of + and - and that of < and >.
> >>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
> >>>
> >>> (Actually, pqR also has a .. operator that fixes the problems with
> >>> generating sequences with the : operator, and it has precedence lower
> >>> than + and - and higher than ! and !!, but that's not relevant if you
> >>> don't have the .. operator.)
> >>>
> >>>     Radford Neal
> >>>
> >>> ______________________________________________
> >>> R-devel at r-project.org mailing list
> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>
> >>
> >>          [[alternative HTML version deleted]]
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From g@bembecker @end|ng |rom gm@||@com  Tue Dec  7 01:20:51 2021
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Mon, 6 Dec 2021 16:20:51 -0800
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
Message-ID: <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>

As I recall, there was a large discussion related to that which resulted in
the recycle0 argument being added (but defaulting to FALSE) for
paste/paste0.

I think a lot of these things ultimately mean that if there were to be a
string concatenation operator, it probably shouldn't have behavior
identical to paste0. Was that what you were getting at as well, Bill?

~G

On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:

> Should paste0(character(0), c("a","b")) give character(0)?
> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
> but c(1,2)+NULL gives numeric(0).
>
> -Bill
>
> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
>
>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>> > Gabe, I agree that missingness is important to factor in. To somewhat
>> abuse
>> > the terminology, NA is often used to represent missingness. Perhaps
>> > concatenating character something with character something missing
>> should
>> > result in the original character?
>>
>> I think that's a bad idea.  If you wanted to represent an empty string,
>> you should use "" or NULL, not NA.
>>
>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it should
>> give NA.
>>
>> Duncan Murdoch
>>
>> >
>> > Avi
>> >
>> > On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker <gabembecker at gmail.com>
>> wrote:
>> >
>> >> Hi All,
>> >>
>> >> Seeing this and the other thread (and admittedly not having clicked
>> through
>> >> to the linked r-help thread), I wonder about NAs.
>> >>
>> >> Should NA <concat> "hi there"  not result in NA_character_? This is not
>> >> what any of the paste functions do, but in my opinoin, NA +
>> <non_na_value>
>> >> seems like it should be NA  (not "NA"), particularly if we are talking
>> >> about `+` overloading, but potentially even in the case of a distinct
>> >> concatenation operator?
>> >>
>> >> I guess what I'm saying is that in my head missingness propagation
>> rules
>> >> should take priority in such an operator (ie NA + <anything> should
>> >> *always * be NA).
>> >>
>> >> Is that something others disagree with, or has it just not come up yet
>> in
>> >> (the parts I have read) of this discussion?
>> >>
>> >> Best,
>> >> ~G
>> >>
>> >> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal <radford at cs.toronto.edu>
>> >> wrote:
>> >>
>> >>>>> In pqR (see pqR-project.org), I have implemented ! and !! as binary
>> >>>>> string concatenation operators, equivalent to paste0 and paste,
>> >>>>> respectively.
>> >>>>>
>> >>>>> For instance,
>> >>>>>
>> >>>>>       > "hello" ! "world"
>> >>>>>       [1] "helloworld"
>> >>>>>       > "hello" !! "world"
>> >>>>>       [1] "hello world"
>> >>>>>       > "hello" !! 1:4
>> >>>>>       [1] "hello 1" "hello 2" "hello 3" "hello 4"
>> >>>>
>> >>>> I'm curious about the details:
>> >>>>
>> >>>> Would `1 ! 2` convert both to strings?
>> >>>
>> >>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", just
>> >>> like paste0(1,2) does.  Of course, they wouldn't have to be exactly
>> >>> equivalent to paste0 and paste - one could impose stricter
>> >>> requirements if that seemed better for error detection.  Off hand,
>> >>> though, I think automatically converting is more in keeping with the
>> >>> rest of R.  Explicitly converting with as.character could be tedious.
>> >>>
>> >>> I suppose disallowing logical arguments might make sense to guard
>> >>> against typos where ! was meant to be the unary-not operator, but
>> >>> ended up being a binary operator, after some sort of typo.  I doubt
>> >>> that this would be a common error, though.
>> >>>
>> >>> (Note that there's no ambiguity when there are no typos, except that
>> >>> when negation is involved a space may be needed - so, for example,
>> >>> "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  Existing uses of
>> >>> double negation are still fine - eg, a <- !!TRUE still sets a to TRUE.
>> >>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>> "xTRUE".)
>> >>>
>> >>>> Where does the binary ! fit in the operator priority?  E.g. how is
>> >>>>
>> >>>>    a ! b > c
>> >>>>
>> >>>> parsed?
>> >>>
>> >>> As (a ! b) > c.
>> >>>
>> >>> Their precedence is between that of + and - and that of < and >.
>> >>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>> >>>
>> >>> (Actually, pqR also has a .. operator that fixes the problems with
>> >>> generating sequences with the : operator, and it has precedence lower
>> >>> than + and - and higher than ! and !!, but that's not relevant if you
>> >>> don't have the .. operator.)
>> >>>
>> >>>     Radford Neal
>> >>>
>> >>> ______________________________________________
>> >>> R-devel at r-project.org mailing list
>> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
>> >>>
>> >>
>> >>          [[alternative HTML version deleted]]
>> >>
>> >> ______________________________________________
>> >> R-devel at r-project.org mailing list
>> >> https://stat.ethz.ch/mailman/listinfo/r-devel
>> >>
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>

	[[alternative HTML version deleted]]


From d@@cott @end|ng |rom @uck|@nd@@c@nz  Tue Dec  7 01:35:15 2021
From: d@@cott @end|ng |rom @uck|@nd@@c@nz (David Scott)
Date: Tue, 7 Dec 2021 13:35:15 +1300
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
Message-ID: <30e5215a-1dd8-fbd4-75e5-6190640a36f2@auckland.ac.nz>

I am surprised nobody so far has mentioned glue which is an 
implementation in R of a python idiom.

It is a reverse import in a great number of R packages on CRAN. It 
specifies how some of the special cases so far considered are treated 
which seems an advantage:

 > library(glue)
 > glue(NA, 2)
NA2
 > glue(NA, 2, .sep = " ")
NA 2
 > glue(NA, 2, .na = NULL)
NA

David Scott

On 7/12/2021 1:20 pm, Gabriel Becker wrote:
> As I recall, there was a large discussion related to that which 
> resulted in
> the recycle0 argument being added (but defaulting to FALSE) for
> paste/paste0.
>
> I think a lot of these things ultimately mean that if there were to be a
> string concatenation operator, it probably shouldn't have behavior
> identical to paste0. Was that what you were getting at as well, Bill?
>
> ~G
>
> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> 
> wrote:
>
> > Should paste0(character(0), c("a","b")) give character(0)?
> > There is a fair bit of code that assumes that paste("X",NULL) gives "X"
> > but c(1,2)+NULL gives numeric(0).
> >
> > -Bill
> >
> > On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch <murdoch.duncan at gmail.com>
> > wrote:
> >
> >> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
> >> > Gabe, I agree that missingness is important to factor in. To somewhat
> >> abuse
> >> > the terminology, NA is often used to represent missingness. Perhaps
> >> > concatenating character something with character something missing
> >> should
> >> > result in the original character?
> >>
> >> I think that's a bad idea. If you wanted to represent an empty string,
> >> you should use "" or NULL, not NA.
> >>
> >> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it 
> should
> >> give NA.
> >>
> >> Duncan Murdoch
> >>
> >> >
> >> > Avi
> >> >
> >> > On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker <gabembecker at gmail.com>
> >> wrote:
> >> >
> >> >> Hi All,
> >> >>
> >> >> Seeing this and the other thread (and admittedly not having clicked
> >> through
> >> >> to the linked r-help thread), I wonder about NAs.
> >> >>
> >> >> Should NA <concat> "hi there" not result in NA_character_? This 
> is not
> >> >> what any of the paste functions do, but in my opinoin, NA +
> >> <non_na_value>
> >> >> seems like it should be NA (not "NA"), particularly if we are 
> talking
> >> >> about `+` overloading, but potentially even in the case of a 
> distinct
> >> >> concatenation operator?
> >> >>
> >> >> I guess what I'm saying is that in my head missingness propagation
> >> rules
> >> >> should take priority in such an operator (ie NA + <anything> should
> >> >> *always * be NA).
> >> >>
> >> >> Is that something others disagree with, or has it just not come 
> up yet
> >> in
> >> >> (the parts I have read) of this discussion?
> >> >>
> >> >> Best,
> >> >> ~G
> >> >>
> >> >> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal 
> <radford at cs.toronto.edu>
> >> >> wrote:
> >> >>
> >> >>>>> In pqR (see pqR-project.org), I have implemented ! and !! as 
> binary
> >> >>>>> string concatenation operators, equivalent to paste0 and paste,
> >> >>>>> respectively.
> >> >>>>>
> >> >>>>> For instance,
> >> >>>>>
> >> >>>>> > "hello" ! "world"
> >> >>>>> [1] "helloworld"
> >> >>>>> > "hello" !! "world"
> >> >>>>> [1] "hello world"
> >> >>>>> > "hello" !! 1:4
> >> >>>>> [1] "hello 1" "hello 2" "hello 3" "hello 4"
> >> >>>>
> >> >>>> I'm curious about the details:
> >> >>>>
> >> >>>> Would `1 ! 2` convert both to strings?
> >> >>>
> >> >>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", 
> just
> >> >>> like paste0(1,2) does. Of course, they wouldn't have to be exactly
> >> >>> equivalent to paste0 and paste - one could impose stricter
> >> >>> requirements if that seemed better for error detection. Off hand,
> >> >>> though, I think automatically converting is more in keeping 
> with the
> >> >>> rest of R. Explicitly converting with as.character could be 
> tedious.
> >> >>>
> >> >>> I suppose disallowing logical arguments might make sense to guard
> >> >>> against typos where ! was meant to be the unary-not operator, but
> >> >>> ended up being a binary operator, after some sort of typo. I doubt
> >> >>> that this would be a common error, though.
> >> >>>
> >> >>> (Note that there's no ambiguity when there are no typos, except 
> that
> >> >>> when negation is involved a space may be needed - so, for example,
> >> >>> "x" ! !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE". Existing 
> uses of
> >> >>> double negation are still fine - eg, a <- !!TRUE still sets a 
> to TRUE.
> >> >>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
> >> "xTRUE".)
> >> >>>
> >> >>>> Where does the binary ! fit in the operator priority? E.g. how is
> >> >>>>
> >> >>>> a ! b > c
> >> >>>>
> >> >>>> parsed?
> >> >>>
> >> >>> As (a ! b) > c.
> >> >>>
> >> >>> Their precedence is between that of + and - and that of < and >.
> >> >>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
> >> >>>
> >> >>> (Actually, pqR also has a .. operator that fixes the problems with
> >> >>> generating sequences with the : operator, and it has precedence 
> lower
> >> >>> than + and - and higher than ! and !!, but that's not relevant 
> if you
> >> >>> don't have the .. operator.)
> >> >>>
> >> >>> Radford Neal
> >> >>>
> >> >>> ______________________________________________
> >> >>> R-devel at r-project.org mailing list
> >> >>> https://stat.ethz.ch/mailman/listinfo/r-devel 
> <https://stat.ethz.ch/mailman/listinfo/r-devel>
> >> >>>
> >> >>
> >> >> [[alternative HTML version deleted]]
> >> >>
> >> >> ______________________________________________
> >> >> R-devel at r-project.org mailing list
> >> >> https://stat.ethz.ch/mailman/listinfo/r-devel 
> <https://stat.ethz.ch/mailman/listinfo/r-devel>
> >> >>
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel 
> <https://stat.ethz.ch/mailman/listinfo/r-devel>
> >>
> >
>
> [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel 
> <https://stat.ethz.ch/mailman/listinfo/r-devel>

-- 
_________________________________________________________________
David Scott
Department of Statistics
The University of Auckland, PB 92019
Auckland 1142,    NEW ZEALAND
Email:d.scott at auckland.ac.nz


	[[alternative HTML version deleted]]


From w||||@mwdun|@p @end|ng |rom gm@||@com  Tue Dec  7 02:18:08 2021
From: w||||@mwdun|@p @end|ng |rom gm@||@com (Bill Dunlap)
Date: Mon, 6 Dec 2021 17:18:08 -0800
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
Message-ID: <CAHqSRuRDKLbyVGDQezGkkOLYRJwOqD6ARFbRPvNVxBpDutYHGg@mail.gmail.com>

>I think a lot of these things ultimately mean that if there were to be a
string >concatenation operator, it probably shouldn't have behavior
identical to >paste0. Was that what you were getting at as well, Bill?

Yes.

On Mon, Dec 6, 2021 at 4:21 PM Gabriel Becker <gabembecker at gmail.com> wrote:

> As I recall, there was a large discussion related to that which resulted
> in the recycle0 argument being added (but defaulting to FALSE) for
> paste/paste0.
>
> I think a lot of these things ultimately mean that if there were to be a
> string concatenation operator, it probably shouldn't have behavior
> identical to paste0. Was that what you were getting at as well, Bill?
>
> ~G
>
> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com>
> wrote:
>
>> Should paste0(character(0), c("a","b")) give character(0)?
>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>> but c(1,2)+NULL gives numeric(0).
>>
>> -Bill
>>
>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch <murdoch.duncan at gmail.com>
>> wrote:
>>
>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>> > Gabe, I agree that missingness is important to factor in. To somewhat
>>> abuse
>>> > the terminology, NA is often used to represent missingness. Perhaps
>>> > concatenating character something with character something missing
>>> should
>>> > result in the original character?
>>>
>>> I think that's a bad idea.  If you wanted to represent an empty string,
>>> you should use "" or NULL, not NA.
>>>
>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it should
>>> give NA.
>>>
>>> Duncan Murdoch
>>>
>>> >
>>> > Avi
>>> >
>>> > On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker <gabembecker at gmail.com>
>>> wrote:
>>> >
>>> >> Hi All,
>>> >>
>>> >> Seeing this and the other thread (and admittedly not having clicked
>>> through
>>> >> to the linked r-help thread), I wonder about NAs.
>>> >>
>>> >> Should NA <concat> "hi there"  not result in NA_character_? This is
>>> not
>>> >> what any of the paste functions do, but in my opinoin, NA +
>>> <non_na_value>
>>> >> seems like it should be NA  (not "NA"), particularly if we are talking
>>> >> about `+` overloading, but potentially even in the case of a distinct
>>> >> concatenation operator?
>>> >>
>>> >> I guess what I'm saying is that in my head missingness propagation
>>> rules
>>> >> should take priority in such an operator (ie NA + <anything> should
>>> >> *always * be NA).
>>> >>
>>> >> Is that something others disagree with, or has it just not come up
>>> yet in
>>> >> (the parts I have read) of this discussion?
>>> >>
>>> >> Best,
>>> >> ~G
>>> >>
>>> >> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal <radford at cs.toronto.edu>
>>> >> wrote:
>>> >>
>>> >>>>> In pqR (see pqR-project.org), I have implemented ! and !! as binary
>>> >>>>> string concatenation operators, equivalent to paste0 and paste,
>>> >>>>> respectively.
>>> >>>>>
>>> >>>>> For instance,
>>> >>>>>
>>> >>>>>       > "hello" ! "world"
>>> >>>>>       [1] "helloworld"
>>> >>>>>       > "hello" !! "world"
>>> >>>>>       [1] "hello world"
>>> >>>>>       > "hello" !! 1:4
>>> >>>>>       [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>> >>>>
>>> >>>> I'm curious about the details:
>>> >>>>
>>> >>>> Would `1 ! 2` convert both to strings?
>>> >>>
>>> >>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", just
>>> >>> like paste0(1,2) does.  Of course, they wouldn't have to be exactly
>>> >>> equivalent to paste0 and paste - one could impose stricter
>>> >>> requirements if that seemed better for error detection.  Off hand,
>>> >>> though, I think automatically converting is more in keeping with the
>>> >>> rest of R.  Explicitly converting with as.character could be tedious.
>>> >>>
>>> >>> I suppose disallowing logical arguments might make sense to guard
>>> >>> against typos where ! was meant to be the unary-not operator, but
>>> >>> ended up being a binary operator, after some sort of typo.  I doubt
>>> >>> that this would be a common error, though.
>>> >>>
>>> >>> (Note that there's no ambiguity when there are no typos, except that
>>> >>> when negation is involved a space may be needed - so, for example,
>>> >>> "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  Existing uses
>>> of
>>> >>> double negation are still fine - eg, a <- !!TRUE still sets a to
>>> TRUE.
>>> >>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>> "xTRUE".)
>>> >>>
>>> >>>> Where does the binary ! fit in the operator priority?  E.g. how is
>>> >>>>
>>> >>>>    a ! b > c
>>> >>>>
>>> >>>> parsed?
>>> >>>
>>> >>> As (a ! b) > c.
>>> >>>
>>> >>> Their precedence is between that of + and - and that of < and >.
>>> >>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>> >>>
>>> >>> (Actually, pqR also has a .. operator that fixes the problems with
>>> >>> generating sequences with the : operator, and it has precedence lower
>>> >>> than + and - and higher than ! and !!, but that's not relevant if you
>>> >>> don't have the .. operator.)
>>> >>>
>>> >>>     Radford Neal
>>> >>>
>>> >>> ______________________________________________
>>> >>> R-devel at r-project.org mailing list
>>> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> >>>
>>> >>
>>> >>          [[alternative HTML version deleted]]
>>> >>
>>> >> ______________________________________________
>>> >> R-devel at r-project.org mailing list
>>> >> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> >>
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>

	[[alternative HTML version deleted]]


From @v|gro@@ @end|ng |rom ver|zon@net  Tue Dec  7 02:27:06 2021
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Mon, 6 Dec 2021 20:27:06 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
Message-ID: <010101d7eb09$8c0156d0$a4040470$@verizon.net>

After seeing what others are saying, it is clear that you need to carefully
think things out before designing any implementation of a more native
concatenation operator whether it is called "+' or anything else. There may
not be any ONE right solution but unlike a function version like paste()
there is nowhere to place any options that specify what you mean.

You can obviously expand paste() to accept arguments like replace.NA="" or
replace.NA="<NA>" and similar arguments on what to do if you see a NaN, and
Inf or -Inf, a NULL or even an NA.character_ and so on. Heck, you might tell
to make other substitutions as in substitute=list(100=99, D=F) or any other
nonsense you can come up with.

But you have nowhere to put options when saying:

c <- a + b

Sure, you could set various global options before the addition and maybe
rest them after, but that is not a way I like to go for something this
basic.

And enough such tinkering makes me wonder if it is easier to ask a user to
use a slightly different function like this:

paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
list(...)))

The above one-line function removes any NA from the argument list to make a
potentially shorter list before calling the real paste() using it.

Variations can, of course, be made that allow functionality as above. 

If R was a true object-oriented language in the same sense as others like
Python, operator overloading of "+" might be doable in more complex ways but
we can only work with what we have. I tend to agree with others that in some
places R is so lenient that all kinds of errors can happen because it makes
a guess on how to correct it. Generally, if you really want to mix numeric
and character, many languages require you to transform any arguments to make
all of compatible types. The paste() function is clearly stated to coerce
all arguments to be of type character for you. Whereas a+b makes no such
promises and also is not properly defined even if a and b are both of type
character. Sure, we can expand the language but it may still do things some
find not to be quite what they wanted as in "2"+"3" becoming "23" rather
than 5. Right now, I can use as.numeric("2")+as.numeric("3") and get the
intended result after making very clear to anyone reading the code that I
wanted strings converted to floating point before the addition.

As has been pointed out, the plus operator if used to concatenate does not
have a cognate for other operations like -*/ and R has used most other
special symbols for other purposes. So, sure, we can use something like ....
(4 periods) if it is not already being used for something but using + here
is a tad confusing. Having said that, the makers of Python did make that
choice.

-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel Becker
Sent: Monday, December 6, 2021 7:21 PM
To: Bill Dunlap <williamwdunlap at gmail.com>
Cc: Radford Neal <radford at cs.toronto.edu>; r-devel <r-devel at r-project.org>
Subject: Re: [Rd] string concatenation operator (revisited)

As I recall, there was a large discussion related to that which resulted in
the recycle0 argument being added (but defaulting to FALSE) for
paste/paste0.

I think a lot of these things ultimately mean that if there were to be a
string concatenation operator, it probably shouldn't have behavior identical
to paste0. Was that what you were getting at as well, Bill?

~G

On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:

> Should paste0(character(0), c("a","b")) give character(0)?
> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
> but c(1,2)+NULL gives numeric(0).
>
> -Bill
>
> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch 
> <murdoch.duncan at gmail.com>
> wrote:
>
>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>> > Gabe, I agree that missingness is important to factor in. To 
>> > somewhat
>> abuse
>> > the terminology, NA is often used to represent missingness. Perhaps 
>> > concatenating character something with character something missing
>> should
>> > result in the original character?
>>
>> I think that's a bad idea.  If you wanted to represent an empty 
>> string, you should use "" or NULL, not NA.
>>
>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it 
>> should give NA.
>>
>> Duncan Murdoch
>>
>> >
>> > Avi
>> >
>> > On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker 
>> > <gabembecker at gmail.com>
>> wrote:
>> >
>> >> Hi All,
>> >>
>> >> Seeing this and the other thread (and admittedly not having 
>> >> clicked
>> through
>> >> to the linked r-help thread), I wonder about NAs.
>> >>
>> >> Should NA <concat> "hi there"  not result in NA_character_? This 
>> >> is not what any of the paste functions do, but in my opinoin, NA +
>> <non_na_value>
>> >> seems like it should be NA  (not "NA"), particularly if we are 
>> >> talking about `+` overloading, but potentially even in the case of 
>> >> a distinct concatenation operator?
>> >>
>> >> I guess what I'm saying is that in my head missingness propagation
>> rules
>> >> should take priority in such an operator (ie NA + <anything> 
>> >> should *always * be NA).
>> >>
>> >> Is that something others disagree with, or has it just not come up 
>> >> yet
>> in
>> >> (the parts I have read) of this discussion?
>> >>
>> >> Best,
>> >> ~G
>> >>
>> >> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal 
>> >> <radford at cs.toronto.edu>
>> >> wrote:
>> >>
>> >>>>> In pqR (see pqR-project.org), I have implemented ! and !! as 
>> >>>>> binary string concatenation operators, equivalent to paste0 and 
>> >>>>> paste, respectively.
>> >>>>>
>> >>>>> For instance,
>> >>>>>
>> >>>>>       > "hello" ! "world"
>> >>>>>       [1] "helloworld"
>> >>>>>       > "hello" !! "world"
>> >>>>>       [1] "hello world"
>> >>>>>       > "hello" !! 1:4
>> >>>>>       [1] "hello 1" "hello 2" "hello 3" "hello 4"
>> >>>>
>> >>>> I'm curious about the details:
>> >>>>
>> >>>> Would `1 ! 2` convert both to strings?
>> >>>
>> >>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", 
>> >>> just like paste0(1,2) does.  Of course, they wouldn't have to be 
>> >>> exactly equivalent to paste0 and paste - one could impose 
>> >>> stricter requirements if that seemed better for error detection.  
>> >>> Off hand, though, I think automatically converting is more in 
>> >>> keeping with the rest of R.  Explicitly converting with as.character
could be tedious.
>> >>>
>> >>> I suppose disallowing logical arguments might make sense to guard 
>> >>> against typos where ! was meant to be the unary-not operator, but 
>> >>> ended up being a binary operator, after some sort of typo.  I 
>> >>> doubt that this would be a common error, though.
>> >>>
>> >>> (Note that there's no ambiguity when there are no typos, except 
>> >>> that when negation is involved a space may be needed - so, for 
>> >>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  
>> >>> Existing uses of double negation are still fine - eg, a <- !!TRUE
still sets a to TRUE.
>> >>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>> "xTRUE".)
>> >>>
>> >>>> Where does the binary ! fit in the operator priority?  E.g. how 
>> >>>> is
>> >>>>
>> >>>>    a ! b > c
>> >>>>
>> >>>> parsed?
>> >>>
>> >>> As (a ! b) > c.
>> >>>
>> >>> Their precedence is between that of + and - and that of < and >.
>> >>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>> >>>
>> >>> (Actually, pqR also has a .. operator that fixes the problems 
>> >>> with generating sequences with the : operator, and it has 
>> >>> precedence lower than + and - and higher than ! and !!, but 
>> >>> that's not relevant if you don't have the .. operator.)
>> >>>
>> >>>     Radford Neal
>> >>>
>> >>> ______________________________________________
>> >>> R-devel at r-project.org mailing list 
>> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
>> >>>
>> >>
>> >>          [[alternative HTML version deleted]]
>> >>
>> >> ______________________________________________
>> >> R-devel at r-project.org mailing list 
>> >> https://stat.ethz.ch/mailman/listinfo/r-devel
>> >>
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>

	[[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From t@r@@@z@kh@rko @end|ng |rom uzh@ch  Tue Dec  7 10:09:08 2021
From: t@r@@@z@kh@rko @end|ng |rom uzh@ch (Taras Zakharko)
Date: Tue, 7 Dec 2021 10:09:08 +0100
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <010101d7eb09$8c0156d0$a4040470$@verizon.net>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
Message-ID: <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>

Great summary, Avi. 

String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have 
a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs. 

As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).

? Taras


> On 7 Dec 2021, at 02:27, Avi Gross via R-devel <r-devel at r-project.org> wrote:
> 
> After seeing what others are saying, it is clear that you need to carefully
> think things out before designing any implementation of a more native
> concatenation operator whether it is called "+' or anything else. There may
> not be any ONE right solution but unlike a function version like paste()
> there is nowhere to place any options that specify what you mean.
> 
> You can obviously expand paste() to accept arguments like replace.NA="" or
> replace.NA="<NA>" and similar arguments on what to do if you see a NaN, and
> Inf or -Inf, a NULL or even an NA.character_ and so on. Heck, you might tell
> to make other substitutions as in substitute=list(100=99, D=F) or any other
> nonsense you can come up with.
> 
> But you have nowhere to put options when saying:
> 
> c <- a + b
> 
> Sure, you could set various global options before the addition and maybe
> rest them after, but that is not a way I like to go for something this
> basic.
> 
> And enough such tinkering makes me wonder if it is easier to ask a user to
> use a slightly different function like this:
> 
> paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
> list(...)))
> 
> The above one-line function removes any NA from the argument list to make a
> potentially shorter list before calling the real paste() using it.
> 
> Variations can, of course, be made that allow functionality as above. 
> 
> If R was a true object-oriented language in the same sense as others like
> Python, operator overloading of "+" might be doable in more complex ways but
> we can only work with what we have. I tend to agree with others that in some
> places R is so lenient that all kinds of errors can happen because it makes
> a guess on how to correct it. Generally, if you really want to mix numeric
> and character, many languages require you to transform any arguments to make
> all of compatible types. The paste() function is clearly stated to coerce
> all arguments to be of type character for you. Whereas a+b makes no such
> promises and also is not properly defined even if a and b are both of type
> character. Sure, we can expand the language but it may still do things some
> find not to be quite what they wanted as in "2"+"3" becoming "23" rather
> than 5. Right now, I can use as.numeric("2")+as.numeric("3") and get the
> intended result after making very clear to anyone reading the code that I
> wanted strings converted to floating point before the addition.
> 
> As has been pointed out, the plus operator if used to concatenate does not
> have a cognate for other operations like -*/ and R has used most other
> special symbols for other purposes. So, sure, we can use something like ....
> (4 periods) if it is not already being used for something but using + here
> is a tad confusing. Having said that, the makers of Python did make that
> choice.
> 
> -----Original Message-----
> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel Becker
> Sent: Monday, December 6, 2021 7:21 PM
> To: Bill Dunlap <williamwdunlap at gmail.com>
> Cc: Radford Neal <radford at cs.toronto.edu>; r-devel <r-devel at r-project.org>
> Subject: Re: [Rd] string concatenation operator (revisited)
> 
> As I recall, there was a large discussion related to that which resulted in
> the recycle0 argument being added (but defaulting to FALSE) for
> paste/paste0.
> 
> I think a lot of these things ultimately mean that if there were to be a
> string concatenation operator, it probably shouldn't have behavior identical
> to paste0. Was that what you were getting at as well, Bill?
> 
> ~G
> 
> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
> 
>> Should paste0(character(0), c("a","b")) give character(0)?
>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>> but c(1,2)+NULL gives numeric(0).
>> 
>> -Bill
>> 
>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch 
>> <murdoch.duncan at gmail.com>
>> wrote:
>> 
>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>>> Gabe, I agree that missingness is important to factor in. To 
>>>> somewhat
>>> abuse
>>>> the terminology, NA is often used to represent missingness. Perhaps 
>>>> concatenating character something with character something missing
>>> should
>>>> result in the original character?
>>> 
>>> I think that's a bad idea.  If you wanted to represent an empty 
>>> string, you should use "" or NULL, not NA.
>>> 
>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it 
>>> should give NA.
>>> 
>>> Duncan Murdoch
>>> 
>>>> 
>>>> Avi
>>>> 
>>>> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker 
>>>> <gabembecker at gmail.com>
>>> wrote:
>>>> 
>>>>> Hi All,
>>>>> 
>>>>> Seeing this and the other thread (and admittedly not having 
>>>>> clicked
>>> through
>>>>> to the linked r-help thread), I wonder about NAs.
>>>>> 
>>>>> Should NA <concat> "hi there"  not result in NA_character_? This 
>>>>> is not what any of the paste functions do, but in my opinoin, NA +
>>> <non_na_value>
>>>>> seems like it should be NA  (not "NA"), particularly if we are 
>>>>> talking about `+` overloading, but potentially even in the case of 
>>>>> a distinct concatenation operator?
>>>>> 
>>>>> I guess what I'm saying is that in my head missingness propagation
>>> rules
>>>>> should take priority in such an operator (ie NA + <anything> 
>>>>> should *always * be NA).
>>>>> 
>>>>> Is that something others disagree with, or has it just not come up 
>>>>> yet
>>> in
>>>>> (the parts I have read) of this discussion?
>>>>> 
>>>>> Best,
>>>>> ~G
>>>>> 
>>>>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal 
>>>>> <radford at cs.toronto.edu>
>>>>> wrote:
>>>>> 
>>>>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as 
>>>>>>>> binary string concatenation operators, equivalent to paste0 and 
>>>>>>>> paste, respectively.
>>>>>>>> 
>>>>>>>> For instance,
>>>>>>>> 
>>>>>>>>> "hello" ! "world"
>>>>>>>>      [1] "helloworld"
>>>>>>>>> "hello" !! "world"
>>>>>>>>      [1] "hello world"
>>>>>>>>> "hello" !! 1:4
>>>>>>>>      [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>>>> 
>>>>>>> I'm curious about the details:
>>>>>>> 
>>>>>>> Would `1 ! 2` convert both to strings?
>>>>>> 
>>>>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", 
>>>>>> just like paste0(1,2) does.  Of course, they wouldn't have to be 
>>>>>> exactly equivalent to paste0 and paste - one could impose 
>>>>>> stricter requirements if that seemed better for error detection.  
>>>>>> Off hand, though, I think automatically converting is more in 
>>>>>> keeping with the rest of R.  Explicitly converting with as.character
> could be tedious.
>>>>>> 
>>>>>> I suppose disallowing logical arguments might make sense to guard 
>>>>>> against typos where ! was meant to be the unary-not operator, but 
>>>>>> ended up being a binary operator, after some sort of typo.  I 
>>>>>> doubt that this would be a common error, though.
>>>>>> 
>>>>>> (Note that there's no ambiguity when there are no typos, except 
>>>>>> that when negation is involved a space may be needed - so, for 
>>>>>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  
>>>>>> Existing uses of double negation are still fine - eg, a <- !!TRUE
> still sets a to TRUE.
>>>>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>> "xTRUE".)
>>>>>> 
>>>>>>> Where does the binary ! fit in the operator priority?  E.g. how 
>>>>>>> is
>>>>>>> 
>>>>>>>   a ! b > c
>>>>>>> 
>>>>>>> parsed?
>>>>>> 
>>>>>> As (a ! b) > c.
>>>>>> 
>>>>>> Their precedence is between that of + and - and that of < and >.
>>>>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>>>> 
>>>>>> (Actually, pqR also has a .. operator that fixes the problems 
>>>>>> with generating sequences with the : operator, and it has 
>>>>>> precedence lower than + and - and higher than ! and !!, but 
>>>>>> that's not relevant if you don't have the .. operator.)
>>>>>> 
>>>>>>    Radford Neal
>>>>>> 
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list 
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>> 
>>>>> 
>>>>>         [[alternative HTML version deleted]]
>>>>> 
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list 
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>> 
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> 
>> 
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Tue Dec  7 11:05:45 2021
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Tue, 7 Dec 2021 05:05:45 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
Message-ID: <4a29fe16-1828-c545-2744-1a4ad5993033@gmail.com>

On 07/12/2021 4:09 a.m., Taras Zakharko wrote:
> Great summary, Avi.
> 
> String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have
> a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs.
> 
> As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. 

> This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).

R already has that in the glue package and elsewhere in other packages 
(e.g. I wrote a simple version for rgl). What would be the benefit of 
having it built in?

Duncan Murdoch

> 
> ? Taras
> 
> 
>> On 7 Dec 2021, at 02:27, Avi Gross via R-devel <r-devel at r-project.org> wrote:
>>
>> After seeing what others are saying, it is clear that you need to carefully
>> think things out before designing any implementation of a more native
>> concatenation operator whether it is called "+' or anything else. There may
>> not be any ONE right solution but unlike a function version like paste()
>> there is nowhere to place any options that specify what you mean.
>>
>> You can obviously expand paste() to accept arguments like replace.NA="" or
>> replace.NA="<NA>" and similar arguments on what to do if you see a NaN, and
>> Inf or -Inf, a NULL or even an NA.character_ and so on. Heck, you might tell
>> to make other substitutions as in substitute=list(100=99, D=F) or any other
>> nonsense you can come up with.
>>
>> But you have nowhere to put options when saying:
>>
>> c <- a + b
>>
>> Sure, you could set various global options before the addition and maybe
>> rest them after, but that is not a way I like to go for something this
>> basic.
>>
>> And enough such tinkering makes me wonder if it is easier to ask a user to
>> use a slightly different function like this:
>>
>> paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
>> list(...)))
>>
>> The above one-line function removes any NA from the argument list to make a
>> potentially shorter list before calling the real paste() using it.
>>
>> Variations can, of course, be made that allow functionality as above.
>>
>> If R was a true object-oriented language in the same sense as others like
>> Python, operator overloading of "+" might be doable in more complex ways but
>> we can only work with what we have. I tend to agree with others that in some
>> places R is so lenient that all kinds of errors can happen because it makes
>> a guess on how to correct it. Generally, if you really want to mix numeric
>> and character, many languages require you to transform any arguments to make
>> all of compatible types. The paste() function is clearly stated to coerce
>> all arguments to be of type character for you. Whereas a+b makes no such
>> promises and also is not properly defined even if a and b are both of type
>> character. Sure, we can expand the language but it may still do things some
>> find not to be quite what they wanted as in "2"+"3" becoming "23" rather
>> than 5. Right now, I can use as.numeric("2")+as.numeric("3") and get the
>> intended result after making very clear to anyone reading the code that I
>> wanted strings converted to floating point before the addition.
>>
>> As has been pointed out, the plus operator if used to concatenate does not
>> have a cognate for other operations like -*/ and R has used most other
>> special symbols for other purposes. So, sure, we can use something like ....
>> (4 periods) if it is not already being used for something but using + here
>> is a tad confusing. Having said that, the makers of Python did make that
>> choice.
>>
>> -----Original Message-----
>> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel Becker
>> Sent: Monday, December 6, 2021 7:21 PM
>> To: Bill Dunlap <williamwdunlap at gmail.com>
>> Cc: Radford Neal <radford at cs.toronto.edu>; r-devel <r-devel at r-project.org>
>> Subject: Re: [Rd] string concatenation operator (revisited)
>>
>> As I recall, there was a large discussion related to that which resulted in
>> the recycle0 argument being added (but defaulting to FALSE) for
>> paste/paste0.
>>
>> I think a lot of these things ultimately mean that if there were to be a
>> string concatenation operator, it probably shouldn't have behavior identical
>> to paste0. Was that what you were getting at as well, Bill?
>>
>> ~G
>>
>> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
>>
>>> Should paste0(character(0), c("a","b")) give character(0)?
>>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>>> but c(1,2)+NULL gives numeric(0).
>>>
>>> -Bill
>>>
>>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch
>>> <murdoch.duncan at gmail.com>
>>> wrote:
>>>
>>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>>>> Gabe, I agree that missingness is important to factor in. To
>>>>> somewhat
>>>> abuse
>>>>> the terminology, NA is often used to represent missingness. Perhaps
>>>>> concatenating character something with character something missing
>>>> should
>>>>> result in the original character?
>>>>
>>>> I think that's a bad idea.  If you wanted to represent an empty
>>>> string, you should use "" or NULL, not NA.
>>>>
>>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it
>>>> should give NA.
>>>>
>>>> Duncan Murdoch
>>>>
>>>>>
>>>>> Avi
>>>>>
>>>>> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker
>>>>> <gabembecker at gmail.com>
>>>> wrote:
>>>>>
>>>>>> Hi All,
>>>>>>
>>>>>> Seeing this and the other thread (and admittedly not having
>>>>>> clicked
>>>> through
>>>>>> to the linked r-help thread), I wonder about NAs.
>>>>>>
>>>>>> Should NA <concat> "hi there"  not result in NA_character_? This
>>>>>> is not what any of the paste functions do, but in my opinoin, NA +
>>>> <non_na_value>
>>>>>> seems like it should be NA  (not "NA"), particularly if we are
>>>>>> talking about `+` overloading, but potentially even in the case of
>>>>>> a distinct concatenation operator?
>>>>>>
>>>>>> I guess what I'm saying is that in my head missingness propagation
>>>> rules
>>>>>> should take priority in such an operator (ie NA + <anything>
>>>>>> should *always * be NA).
>>>>>>
>>>>>> Is that something others disagree with, or has it just not come up
>>>>>> yet
>>>> in
>>>>>> (the parts I have read) of this discussion?
>>>>>>
>>>>>> Best,
>>>>>> ~G
>>>>>>
>>>>>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal
>>>>>> <radford at cs.toronto.edu>
>>>>>> wrote:
>>>>>>
>>>>>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as
>>>>>>>>> binary string concatenation operators, equivalent to paste0 and
>>>>>>>>> paste, respectively.
>>>>>>>>>
>>>>>>>>> For instance,
>>>>>>>>>
>>>>>>>>>> "hello" ! "world"
>>>>>>>>>       [1] "helloworld"
>>>>>>>>>> "hello" !! "world"
>>>>>>>>>       [1] "hello world"
>>>>>>>>>> "hello" !! 1:4
>>>>>>>>>       [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>>>>>
>>>>>>>> I'm curious about the details:
>>>>>>>>
>>>>>>>> Would `1 ! 2` convert both to strings?
>>>>>>>
>>>>>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12",
>>>>>>> just like paste0(1,2) does.  Of course, they wouldn't have to be
>>>>>>> exactly equivalent to paste0 and paste - one could impose
>>>>>>> stricter requirements if that seemed better for error detection.
>>>>>>> Off hand, though, I think automatically converting is more in
>>>>>>> keeping with the rest of R.  Explicitly converting with as.character
>> could be tedious.
>>>>>>>
>>>>>>> I suppose disallowing logical arguments might make sense to guard
>>>>>>> against typos where ! was meant to be the unary-not operator, but
>>>>>>> ended up being a binary operator, after some sort of typo.  I
>>>>>>> doubt that this would be a common error, though.
>>>>>>>
>>>>>>> (Note that there's no ambiguity when there are no typos, except
>>>>>>> that when negation is involved a space may be needed - so, for
>>>>>>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".
>>>>>>> Existing uses of double negation are still fine - eg, a <- !!TRUE
>> still sets a to TRUE.
>>>>>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>>> "xTRUE".)
>>>>>>>
>>>>>>>> Where does the binary ! fit in the operator priority?  E.g. how
>>>>>>>> is
>>>>>>>>
>>>>>>>>    a ! b > c
>>>>>>>>
>>>>>>>> parsed?
>>>>>>>
>>>>>>> As (a ! b) > c.
>>>>>>>
>>>>>>> Their precedence is between that of + and - and that of < and >.
>>>>>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>>>>>
>>>>>>> (Actually, pqR also has a .. operator that fixes the problems
>>>>>>> with generating sequences with the : operator, and it has
>>>>>>> precedence lower than + and - and higher than ! and !!, but
>>>>>>> that's not relevant if you don't have the .. operator.)
>>>>>>>
>>>>>>>     Radford Neal
>>>>>>>
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>
>>>>>>
>>>>>>          [[alternative HTML version deleted]]
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>
>>
>> 	[[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From @|mon@urb@nek @end|ng |rom R-project@org  Tue Dec  7 12:06:13 2021
From: @|mon@urb@nek @end|ng |rom R-project@org (Simon Urbanek)
Date: Wed, 8 Dec 2021 00:06:13 +1300
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
Message-ID: <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>



> On Dec 7, 2021, at 22:09, Taras Zakharko <taras.zakharko at uzh.ch> wrote:
> 
> Great summary, Avi. 
> 
> String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have 
> a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs. 
> 
> As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).
> 

This is getting OT, but there is a very good reason why string interpolation is not in core R. As I recall it has been considered some time ago, but it is very dangerous as it implies evaluation on constants which opens a huge security hole and has questionable semantics (where you evaluate etc). Hence it's much easier to ban a package than to hack it out of R ;).

Cheers,
Simon


> ? Taras
> 
> 
>> On 7 Dec 2021, at 02:27, Avi Gross via R-devel <r-devel at r-project.org> wrote:
>> 
>> After seeing what others are saying, it is clear that you need to carefully
>> think things out before designing any implementation of a more native
>> concatenation operator whether it is called "+' or anything else. There may
>> not be any ONE right solution but unlike a function version like paste()
>> there is nowhere to place any options that specify what you mean.
>> 
>> You can obviously expand paste() to accept arguments like replace.NA="" or
>> replace.NA="<NA>" and similar arguments on what to do if you see a NaN, and
>> Inf or -Inf, a NULL or even an NA.character_ and so on. Heck, you might tell
>> to make other substitutions as in substitute=list(100=99, D=F) or any other
>> nonsense you can come up with.
>> 
>> But you have nowhere to put options when saying:
>> 
>> c <- a + b
>> 
>> Sure, you could set various global options before the addition and maybe
>> rest them after, but that is not a way I like to go for something this
>> basic.
>> 
>> And enough such tinkering makes me wonder if it is easier to ask a user to
>> use a slightly different function like this:
>> 
>> paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
>> list(...)))
>> 
>> The above one-line function removes any NA from the argument list to make a
>> potentially shorter list before calling the real paste() using it.
>> 
>> Variations can, of course, be made that allow functionality as above. 
>> 
>> If R was a true object-oriented language in the same sense as others like
>> Python, operator overloading of "+" might be doable in more complex ways but
>> we can only work with what we have. I tend to agree with others that in some
>> places R is so lenient that all kinds of errors can happen because it makes
>> a guess on how to correct it. Generally, if you really want to mix numeric
>> and character, many languages require you to transform any arguments to make
>> all of compatible types. The paste() function is clearly stated to coerce
>> all arguments to be of type character for you. Whereas a+b makes no such
>> promises and also is not properly defined even if a and b are both of type
>> character. Sure, we can expand the language but it may still do things some
>> find not to be quite what they wanted as in "2"+"3" becoming "23" rather
>> than 5. Right now, I can use as.numeric("2")+as.numeric("3") and get the
>> intended result after making very clear to anyone reading the code that I
>> wanted strings converted to floating point before the addition.
>> 
>> As has been pointed out, the plus operator if used to concatenate does not
>> have a cognate for other operations like -*/ and R has used most other
>> special symbols for other purposes. So, sure, we can use something like ....
>> (4 periods) if it is not already being used for something but using + here
>> is a tad confusing. Having said that, the makers of Python did make that
>> choice.
>> 
>> -----Original Message-----
>> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel Becker
>> Sent: Monday, December 6, 2021 7:21 PM
>> To: Bill Dunlap <williamwdunlap at gmail.com>
>> Cc: Radford Neal <radford at cs.toronto.edu>; r-devel <r-devel at r-project.org>
>> Subject: Re: [Rd] string concatenation operator (revisited)
>> 
>> As I recall, there was a large discussion related to that which resulted in
>> the recycle0 argument being added (but defaulting to FALSE) for
>> paste/paste0.
>> 
>> I think a lot of these things ultimately mean that if there were to be a
>> string concatenation operator, it probably shouldn't have behavior identical
>> to paste0. Was that what you were getting at as well, Bill?
>> 
>> ~G
>> 
>> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
>> 
>>> Should paste0(character(0), c("a","b")) give character(0)?
>>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>>> but c(1,2)+NULL gives numeric(0).
>>> 
>>> -Bill
>>> 
>>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch 
>>> <murdoch.duncan at gmail.com>
>>> wrote:
>>> 
>>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>>>> Gabe, I agree that missingness is important to factor in. To 
>>>>> somewhat
>>>> abuse
>>>>> the terminology, NA is often used to represent missingness. Perhaps 
>>>>> concatenating character something with character something missing
>>>> should
>>>>> result in the original character?
>>>> 
>>>> I think that's a bad idea.  If you wanted to represent an empty 
>>>> string, you should use "" or NULL, not NA.
>>>> 
>>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it 
>>>> should give NA.
>>>> 
>>>> Duncan Murdoch
>>>> 
>>>>> 
>>>>> Avi
>>>>> 
>>>>> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker 
>>>>> <gabembecker at gmail.com>
>>>> wrote:
>>>>> 
>>>>>> Hi All,
>>>>>> 
>>>>>> Seeing this and the other thread (and admittedly not having 
>>>>>> clicked
>>>> through
>>>>>> to the linked r-help thread), I wonder about NAs.
>>>>>> 
>>>>>> Should NA <concat> "hi there"  not result in NA_character_? This 
>>>>>> is not what any of the paste functions do, but in my opinoin, NA +
>>>> <non_na_value>
>>>>>> seems like it should be NA  (not "NA"), particularly if we are 
>>>>>> talking about `+` overloading, but potentially even in the case of 
>>>>>> a distinct concatenation operator?
>>>>>> 
>>>>>> I guess what I'm saying is that in my head missingness propagation
>>>> rules
>>>>>> should take priority in such an operator (ie NA + <anything> 
>>>>>> should *always * be NA).
>>>>>> 
>>>>>> Is that something others disagree with, or has it just not come up 
>>>>>> yet
>>>> in
>>>>>> (the parts I have read) of this discussion?
>>>>>> 
>>>>>> Best,
>>>>>> ~G
>>>>>> 
>>>>>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal 
>>>>>> <radford at cs.toronto.edu>
>>>>>> wrote:
>>>>>> 
>>>>>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as 
>>>>>>>>> binary string concatenation operators, equivalent to paste0 and 
>>>>>>>>> paste, respectively.
>>>>>>>>> 
>>>>>>>>> For instance,
>>>>>>>>> 
>>>>>>>>>> "hello" ! "world"
>>>>>>>>>     [1] "helloworld"
>>>>>>>>>> "hello" !! "world"
>>>>>>>>>     [1] "hello world"
>>>>>>>>>> "hello" !! 1:4
>>>>>>>>>     [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>>>>> 
>>>>>>>> I'm curious about the details:
>>>>>>>> 
>>>>>>>> Would `1 ! 2` convert both to strings?
>>>>>>> 
>>>>>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", 
>>>>>>> just like paste0(1,2) does.  Of course, they wouldn't have to be 
>>>>>>> exactly equivalent to paste0 and paste - one could impose 
>>>>>>> stricter requirements if that seemed better for error detection.  
>>>>>>> Off hand, though, I think automatically converting is more in 
>>>>>>> keeping with the rest of R.  Explicitly converting with as.character
>> could be tedious.
>>>>>>> 
>>>>>>> I suppose disallowing logical arguments might make sense to guard 
>>>>>>> against typos where ! was meant to be the unary-not operator, but 
>>>>>>> ended up being a binary operator, after some sort of typo.  I 
>>>>>>> doubt that this would be a common error, though.
>>>>>>> 
>>>>>>> (Note that there's no ambiguity when there are no typos, except 
>>>>>>> that when negation is involved a space may be needed - so, for 
>>>>>>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  
>>>>>>> Existing uses of double negation are still fine - eg, a <- !!TRUE
>> still sets a to TRUE.
>>>>>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>>> "xTRUE".)
>>>>>>> 
>>>>>>>> Where does the binary ! fit in the operator priority?  E.g. how 
>>>>>>>> is
>>>>>>>> 
>>>>>>>>  a ! b > c
>>>>>>>> 
>>>>>>>> parsed?
>>>>>>> 
>>>>>>> As (a ! b) > c.
>>>>>>> 
>>>>>>> Their precedence is between that of + and - and that of < and >.
>>>>>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>>>>> 
>>>>>>> (Actually, pqR also has a .. operator that fixes the problems 
>>>>>>> with generating sequences with the : operator, and it has 
>>>>>>> precedence lower than + and - and higher than ! and !!, but 
>>>>>>> that's not relevant if you don't have the .. operator.)
>>>>>>> 
>>>>>>>   Radford Neal
>>>>>>> 
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list 
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>> 
>>>>>> 
>>>>>>        [[alternative HTML version deleted]]
>>>>>> 
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list 
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>> 
>>>> 
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>> 
>>> 
>> 
>> 	[[alternative HTML version deleted]]
>> 
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>> 
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


From t@r@@@z@kh@rko @end|ng |rom uzh@ch  Tue Dec  7 12:56:30 2021
From: t@r@@@z@kh@rko @end|ng |rom uzh@ch (Taras Zakharko)
Date: Tue, 7 Dec 2021 12:56:30 +0100
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
Message-ID: <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>

I fully agree! General string interpolation opens a gaping security hole and is accompanied by all kinds of problems and decisions. What I envision instead is something like this:

   f?hello {name}? 

Which gets parsed by R to this:

   (STRINTERPSXP (CHARSXP (PROMISE nil)))

Basically, a new type of R language construct that still can be processed by packages (for customized interpolation like in cli etc.), with a default eval which is basically paste0(). The benefit here would be that this is eagerly parsed and syntactically checked, and that the promise code could carry a srcref. And of course, that you could pass an interpolated string expression lazily between frames without losing the environment etc? For more advanced applications, a low level string interpolation expression constructor could be provided (that could either parse a general string ? at the user?s risk, or build it directly from expressions). 

? Taras


> On 7 Dec 2021, at 12:06, Simon Urbanek <simon.urbanek at R-project.org> wrote:
> 
> 
> 
>> On Dec 7, 2021, at 22:09, Taras Zakharko <taras.zakharko at uzh.ch <mailto:taras.zakharko at uzh.ch>> wrote:
>> 
>> Great summary, Avi. 
>> 
>> String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have 
>> a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs. 
>> 
>> As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).
>> 
> 
> This is getting OT, but there is a very good reason why string interpolation is not in core R. As I recall it has been considered some time ago, but it is very dangerous as it implies evaluation on constants which opens a huge security hole and has questionable semantics (where you evaluate etc). Hence it's much easier to ban a package than to hack it out of R ;).
> 
> Cheers,
> Simon
> 
> 
>> ? Taras
>> 
>> 
>>> On 7 Dec 2021, at 02:27, Avi Gross via R-devel <r-devel at r-project.org> wrote:
>>> 
>>> After seeing what others are saying, it is clear that you need to carefully
>>> think things out before designing any implementation of a more native
>>> concatenation operator whether it is called "+' or anything else. There may
>>> not be any ONE right solution but unlike a function version like paste()
>>> there is nowhere to place any options that specify what you mean.
>>> 
>>> You can obviously expand paste() to accept arguments like replace.NA="" or
>>> replace.NA="<NA>" and similar arguments on what to do if you see a NaN, and
>>> Inf or -Inf, a NULL or even an NA.character_ and so on. Heck, you might tell
>>> to make other substitutions as in substitute=list(100=99, D=F) or any other
>>> nonsense you can come up with.
>>> 
>>> But you have nowhere to put options when saying:
>>> 
>>> c <- a + b
>>> 
>>> Sure, you could set various global options before the addition and maybe
>>> rest them after, but that is not a way I like to go for something this
>>> basic.
>>> 
>>> And enough such tinkering makes me wonder if it is easier to ask a user to
>>> use a slightly different function like this:
>>> 
>>> paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
>>> list(...)))
>>> 
>>> The above one-line function removes any NA from the argument list to make a
>>> potentially shorter list before calling the real paste() using it.
>>> 
>>> Variations can, of course, be made that allow functionality as above. 
>>> 
>>> If R was a true object-oriented language in the same sense as others like
>>> Python, operator overloading of "+" might be doable in more complex ways but
>>> we can only work with what we have. I tend to agree with others that in some
>>> places R is so lenient that all kinds of errors can happen because it makes
>>> a guess on how to correct it. Generally, if you really want to mix numeric
>>> and character, many languages require you to transform any arguments to make
>>> all of compatible types. The paste() function is clearly stated to coerce
>>> all arguments to be of type character for you. Whereas a+b makes no such
>>> promises and also is not properly defined even if a and b are both of type
>>> character. Sure, we can expand the language but it may still do things some
>>> find not to be quite what they wanted as in "2"+"3" becoming "23" rather
>>> than 5. Right now, I can use as.numeric("2")+as.numeric("3") and get the
>>> intended result after making very clear to anyone reading the code that I
>>> wanted strings converted to floating point before the addition.
>>> 
>>> As has been pointed out, the plus operator if used to concatenate does not
>>> have a cognate for other operations like -*/ and R has used most other
>>> special symbols for other purposes. So, sure, we can use something like ....
>>> (4 periods) if it is not already being used for something but using + here
>>> is a tad confusing. Having said that, the makers of Python did make that
>>> choice.
>>> 
>>> -----Original Message-----
>>> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel Becker
>>> Sent: Monday, December 6, 2021 7:21 PM
>>> To: Bill Dunlap <williamwdunlap at gmail.com>
>>> Cc: Radford Neal <radford at cs.toronto.edu>; r-devel <r-devel at r-project.org>
>>> Subject: Re: [Rd] string concatenation operator (revisited)
>>> 
>>> As I recall, there was a large discussion related to that which resulted in
>>> the recycle0 argument being added (but defaulting to FALSE) for
>>> paste/paste0.
>>> 
>>> I think a lot of these things ultimately mean that if there were to be a
>>> string concatenation operator, it probably shouldn't have behavior identical
>>> to paste0. Was that what you were getting at as well, Bill?
>>> 
>>> ~G
>>> 
>>> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
>>> 
>>>> Should paste0(character(0), c("a","b")) give character(0)?
>>>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>>>> but c(1,2)+NULL gives numeric(0).
>>>> 
>>>> -Bill
>>>> 
>>>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch 
>>>> <murdoch.duncan at gmail.com>
>>>> wrote:
>>>> 
>>>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>>>>> Gabe, I agree that missingness is important to factor in. To 
>>>>>> somewhat
>>>>> abuse
>>>>>> the terminology, NA is often used to represent missingness. Perhaps 
>>>>>> concatenating character something with character something missing
>>>>> should
>>>>>> result in the original character?
>>>>> 
>>>>> I think that's a bad idea.  If you wanted to represent an empty 
>>>>> string, you should use "" or NULL, not NA.
>>>>> 
>>>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it 
>>>>> should give NA.
>>>>> 
>>>>> Duncan Murdoch
>>>>> 
>>>>>> 
>>>>>> Avi
>>>>>> 
>>>>>> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker 
>>>>>> <gabembecker at gmail.com>
>>>>> wrote:
>>>>>> 
>>>>>>> Hi All,
>>>>>>> 
>>>>>>> Seeing this and the other thread (and admittedly not having 
>>>>>>> clicked
>>>>> through
>>>>>>> to the linked r-help thread), I wonder about NAs.
>>>>>>> 
>>>>>>> Should NA <concat> "hi there"  not result in NA_character_? This 
>>>>>>> is not what any of the paste functions do, but in my opinoin, NA +
>>>>> <non_na_value>
>>>>>>> seems like it should be NA  (not "NA"), particularly if we are 
>>>>>>> talking about `+` overloading, but potentially even in the case of 
>>>>>>> a distinct concatenation operator?
>>>>>>> 
>>>>>>> I guess what I'm saying is that in my head missingness propagation
>>>>> rules
>>>>>>> should take priority in such an operator (ie NA + <anything> 
>>>>>>> should *always * be NA).
>>>>>>> 
>>>>>>> Is that something others disagree with, or has it just not come up 
>>>>>>> yet
>>>>> in
>>>>>>> (the parts I have read) of this discussion?
>>>>>>> 
>>>>>>> Best,
>>>>>>> ~G
>>>>>>> 
>>>>>>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal 
>>>>>>> <radford at cs.toronto.edu>
>>>>>>> wrote:
>>>>>>> 
>>>>>>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as 
>>>>>>>>>> binary string concatenation operators, equivalent to paste0 and 
>>>>>>>>>> paste, respectively.
>>>>>>>>>> 
>>>>>>>>>> For instance,
>>>>>>>>>> 
>>>>>>>>>>> "hello" ! "world"
>>>>>>>>>>    [1] "helloworld"
>>>>>>>>>>> "hello" !! "world"
>>>>>>>>>>    [1] "hello world"
>>>>>>>>>>> "hello" !! 1:4
>>>>>>>>>>    [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>>>>>> 
>>>>>>>>> I'm curious about the details:
>>>>>>>>> 
>>>>>>>>> Would `1 ! 2` convert both to strings?
>>>>>>>> 
>>>>>>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", 
>>>>>>>> just like paste0(1,2) does.  Of course, they wouldn't have to be 
>>>>>>>> exactly equivalent to paste0 and paste - one could impose 
>>>>>>>> stricter requirements if that seemed better for error detection.  
>>>>>>>> Off hand, though, I think automatically converting is more in 
>>>>>>>> keeping with the rest of R.  Explicitly converting with as.character
>>> could be tedious.
>>>>>>>> 
>>>>>>>> I suppose disallowing logical arguments might make sense to guard 
>>>>>>>> against typos where ! was meant to be the unary-not operator, but 
>>>>>>>> ended up being a binary operator, after some sort of typo.  I 
>>>>>>>> doubt that this would be a common error, though.
>>>>>>>> 
>>>>>>>> (Note that there's no ambiguity when there are no typos, except 
>>>>>>>> that when negation is involved a space may be needed - so, for 
>>>>>>>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  
>>>>>>>> Existing uses of double negation are still fine - eg, a <- !!TRUE
>>> still sets a to TRUE.
>>>>>>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>>>> "xTRUE".)
>>>>>>>> 
>>>>>>>>> Where does the binary ! fit in the operator priority?  E.g. how 
>>>>>>>>> is
>>>>>>>>> 
>>>>>>>>> a ! b > c
>>>>>>>>> 
>>>>>>>>> parsed?
>>>>>>>> 
>>>>>>>> As (a ! b) > c.
>>>>>>>> 
>>>>>>>> Their precedence is between that of + and - and that of < and >.
>>>>>>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>>>>>> 
>>>>>>>> (Actually, pqR also has a .. operator that fixes the problems 
>>>>>>>> with generating sequences with the : operator, and it has 
>>>>>>>> precedence lower than + and - and higher than ! and !!, but 
>>>>>>>> that's not relevant if you don't have the .. operator.)
>>>>>>>> 
>>>>>>>>  Radford Neal
>>>>>>>> 
>>>>>>>> ______________________________________________
>>>>>>>> R-devel at r-project.org mailing list 
>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>> 
>>>>>>> 
>>>>>>>       [[alternative HTML version deleted]]
>>>>>>> 
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list 
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>> 
>>>>> 
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>> 
>>>> 
>>> 
>>> 	[[alternative HTML version deleted]]
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>> 
>> ______________________________________________
>> R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel <https://stat.ethz.ch/mailman/listinfo/r-devel>

	[[alternative HTML version deleted]]


From Thom@@@SOEIRO @end|ng |rom @p-hm@|r  Tue Dec  7 14:21:04 2021
From: Thom@@@SOEIRO @end|ng |rom @p-hm@|r (SOEIRO Thomas)
Date: Tue, 7 Dec 2021 13:21:04 +0000
Subject: [Rd] Documentation of addmargins
Message-ID: <5fc9ba4689ea495786a23d5b51781002@SCWPR-EXDAG1-6A.aphm.ap-hm.fr>

Dear list,

There is a minor typo in addmargins (section Details):

- If the functions used to form margins are not commutative the result depends on the order in which margins are computed. Annotation of margins is done via naming the FUN list.
+ If the functions used to form margins are not commutative**add ':' or ', i.e.' here** the result depends on the order in which margins are computed. Annotation of margins is done via naming the FUN list.


I'm not sure if such minor things really need to be reported when they are noticed... Please let me know if not. Of course this is minor, but imho one of the strengths of R is also its documentation!

Best,

Thomas


From Andre@G||||bert @end|ng |rom chu-rouen@|r  Tue Dec  7 16:59:08 2021
From: Andre@G||||bert @end|ng |rom chu-rouen@|r (GILLIBERT, Andre)
Date: Tue, 7 Dec 2021 15:59:08 +0000
Subject: [Rd] Documentation of addmargins
In-Reply-To: <5fc9ba4689ea495786a23d5b51781002@SCWPR-EXDAG1-6A.aphm.ap-hm.fr>
References: <5fc9ba4689ea495786a23d5b51781002@SCWPR-EXDAG1-6A.aphm.ap-hm.fr>
Message-ID: <588ee29d2a0047b8807a9f0451aeae0b@chu-rouen.fr>


Thomas SOEIRO wrote:
> Dear list,

> There is a minor typo in addmargins (section Details):

> - If the functions used to form margins are not commutative the result depends on the order in which margins are computed. Annotation of margins is done via naming the FUN list.
> + If the functions used to form margins are not commutative**add ':' or ', i.e.' here** the result depends on the order in which margins are computed. Annotation of margins is done via naming the FUN list.
>
>
> I'm not sure if such minor things really need to be reported when they are noticed... Please let me know if not. Of course this is minor, but imho one of the strengths of R is also its documentation!
>

The documentation looks correct to me.
If the function FUN is not commutative (i.e. the result depends on the order of the vector passed to it), then the result of addmargins() will depend on the order of the 'margin' argument to the addmargins() function.

For instance:
mat <- rbind(c(1,10),c(100,1000))
fun <- function(x) {x[1]-x[2]-x[1]*x[2]} # non-commutative function
a <- addmargins(mat ,margin=c(1,2), FUN=fun)
b <- addmargins(mat ,margin=c(2,1), FUN=fun)

a and b are different, because the fun function is not commutative.

-- 
Sincerely
Andr? GILLIBERT

From Thom@@@SOEIRO @end|ng |rom @p-hm@|r  Tue Dec  7 17:01:18 2021
From: Thom@@@SOEIRO @end|ng |rom @p-hm@|r (SOEIRO Thomas)
Date: Tue, 7 Dec 2021 16:01:18 +0000
Subject: [Rd] Documentation of addmargins
In-Reply-To: <588ee29d2a0047b8807a9f0451aeae0b@chu-rouen.fr>
References: <5fc9ba4689ea495786a23d5b51781002@SCWPR-EXDAG1-6A.aphm.ap-hm.fr>
 <588ee29d2a0047b8807a9f0451aeae0b@chu-rouen.fr>
Message-ID: <768a3b50cc2442939fbd381cf2779ec6@SCWPR-EXDAG1-6A.aphm.ap-hm.fr>

Yes, it is!

There is only a small typo (missing punctuation for easier reading)

Sorry for the misunderstanding, it may not be clear enough in my previous mail.

-----Message d'origine-----
De?: GILLIBERT, Andre [mailto:Andre.Gillibert at chu-rouen.fr] 
Envoy??: mardi 7 d?cembre 2021 16:59
??: SOEIRO Thomas; R Development List
Objet?: RE: Documentation of addmargins

EMAIL EXTERNE - TRAITER AVEC PR?CAUTION LIENS ET FICHIERS

Thomas SOEIRO wrote:
> Dear list,

> There is a minor typo in addmargins (section Details):

> - If the functions used to form margins are not commutative the result depends on the order in which margins are computed. Annotation of margins is done via naming the FUN list.
> + If the functions used to form margins are not commutative**add ':' or ', i.e.' here** the result depends on the order in which margins are computed. Annotation of margins is done via naming the FUN list.
>
>
> I'm not sure if such minor things really need to be reported when they are noticed... Please let me know if not. Of course this is minor, but imho one of the strengths of R is also its documentation!
>

The documentation looks correct to me.
If the function FUN is not commutative (i.e. the result depends on the order of the vector passed to it), then the result of addmargins() will depend on the order of the 'margin' argument to the addmargins() function.

For instance:
mat <- rbind(c(1,10),c(100,1000))
fun <- function(x) {x[1]-x[2]-x[1]*x[2]} # non-commutative function a <- addmargins(mat ,margin=c(1,2), FUN=fun) b <- addmargins(mat ,margin=c(2,1), FUN=fun)

a and b are different, because the fun function is not commutative.

--
Sincerely
Andr? GILLIBERT

From edd @end|ng |rom deb|@n@org  Tue Dec  7 17:48:59 2021
From: edd @end|ng |rom deb|@n@org (Dirk Eddelbuettel)
Date: Tue, 7 Dec 2021 10:48:59 -0600
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
Message-ID: <25007.36987.625028.288350@rob.eddelbuettel.com>


On 8 December 2021 at 00:06, Simon Urbanek wrote:
| Hence it's much easier to ban a package than to hack it out of R ;).

Paging Achim for suggested `fortunes` inclusion.

Dirk

-- 
https://dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Tue Dec  7 18:35:00 2021
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Tue, 7 Dec 2021 18:35:00 +0100
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
 <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>
Message-ID: <25007.39748.476241.17592@stat.math.ethz.ch>

>>>>> Taras Zakharko 
>>>>>     on Tue, 7 Dec 2021 12:56:30 +0100 writes:

    > I fully agree! General string interpolation opens a gaping security hole and is accompanied by all kinds of problems and decisions. What I envision instead is something like this:
    > f?hello {name}? 

    > Which gets parsed by R to this:

    > (STRINTERPSXP (CHARSXP (PROMISE nil)))

    > Basically, a new type of R language construct that still can be processed by packages (for customized interpolation like in cli etc.), with a default eval which is basically paste0(). The benefit here would be that this is eagerly parsed and syntactically checked, and that the promise code could carry a srcref. And of course, that you could pass an interpolated string expression lazily between frames without losing the environment etc? For more advanced applications, a low level string interpolation expression constructor could be provided (that could either parse a general string ? at the user?s risk, or build it directly from expressions). 

    > ? Taras

Well, many months ago, R's  NEWS (for R-devel, then became R 4.0.0)
contained

    * There is a new syntax for specifying _raw_ character constants
      similar to the one used in C++: r"(...)" with ... any character
      sequence not containing the sequence )".  This makes it easier to
      write strings that contain backslashes or both single and double
      quotes.  For more details see ?Quotes.

This should be pretty close to what you propose above
(well, you need to replace your UTF-8 forward double quotes by
ASCII ones),
no ?

    >> On 7 Dec 2021, at 12:06, Simon Urbanek <simon.urbanek at R-project.org> wrote:
    >> 
    >> 
    >> 
    >>> On Dec 7, 2021, at 22:09, Taras Zakharko <taras.zakharko at uzh.ch <mailto:taras.zakharko at uzh.ch>> wrote:
    >>> 
    >>> Great summary, Avi. 
    >>> 
    >>> String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have 
    >>> a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs. 
    >>> 
    >>> As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).
    >>> 
    >> 
    >> This is getting OT, but there is a very good reason why string interpolation is not in core R. As I recall it has been considered some time ago, but it is very dangerous as it implies evaluation on constants which opens a huge security hole and has questionable semantics (where you evaluate etc). Hence it's much easier to ban a package than to hack it out of R ;).
    >> 
    >> Cheers,
    >> Simon
    >> 
    >>> ? Taras

 [............]


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Tue Dec  7 18:37:40 2021
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Tue, 7 Dec 2021 18:37:40 +0100
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <25007.39748.476241.17592@stat.math.ethz.ch>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
 <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>
 <25007.39748.476241.17592@stat.math.ethz.ch>
Message-ID: <25007.39908.493984.292262@stat.math.ethz.ch>

>>>>> Martin Maechler 
>>>>>     on Tue, 7 Dec 2021 18:35:00 +0100 writes:

>>>>> Taras Zakharko 
>>>>>     on Tue, 7 Dec 2021 12:56:30 +0100 writes:

    >> I fully agree! General string interpolation opens a gaping security hole and is accompanied by all kinds of problems and decisions. What I envision instead is something like this:
    >> f?hello {name}? 

    >> Which gets parsed by R to this:

    >> (STRINTERPSXP (CHARSXP (PROMISE nil)))

    >> Basically, a new type of R language construct that still can be processed by packages (for customized interpolation like in cli etc.), with a default eval which is basically paste0(). The benefit here would be that this is eagerly parsed and syntactically checked, and that the promise code could carry a srcref. And of course, that you could pass an interpolated string expression lazily between frames without losing the environment etc? For more advanced applications, a low level string interpolation expression constructor could be provided (that could either parse a general string ? at the user?s risk, or build it directly from expressions). 

    >> ? Taras

    > Well, many months ago, R's  NEWS (for R-devel, then became R 4.0.0)
    > contained

    > * There is a new syntax for specifying _raw_ character constants
    > similar to the one used in C++: r"(...)" with ... any character
    > sequence not containing the sequence )".  This makes it easier to
    > write strings that contain backslashes or both single and double
    > quotes.  For more details see ?Quotes.

    > This should be pretty close to what you propose above
    > (well, you need to replace your UTF-8 forward double quotes by
    > ASCII ones),
    > no ?

No it is not; sorry I'm not at full strength..
Martin


    >>> On 7 Dec 2021, at 12:06, Simon Urbanek <simon.urbanek at R-project.org> wrote:
    >>> 
    >>> 
    >>> 
    >>>> On Dec 7, 2021, at 22:09, Taras Zakharko <taras.zakharko at uzh.ch <mailto:taras.zakharko at uzh.ch>> wrote:
    >>>> 
    >>>> Great summary, Avi. 
    >>>> 
    >>>> String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have 
    >>>> a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs. 
    >>>> 
    >>>> As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).
    >>>> 
    >>> 
    >>> This is getting OT, but there is a very good reason why string interpolation is not in core R. As I recall it has been considered some time ago, but it is very dangerous as it implies evaluation on constants which opens a huge security hole and has questionable semantics (where you evaluate etc). Hence it's much easier to ban a package than to hack it out of R ;).
    >>> 
    >>> Cheers,
    >>> Simon
    >>> 
    >>>> ? Taras

    > [............]

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From @|mon@urb@nek @end|ng |rom R-project@org  Tue Dec  7 23:05:52 2021
From: @|mon@urb@nek @end|ng |rom R-project@org (Simon Urbanek)
Date: Wed, 8 Dec 2021 11:05:52 +1300
Subject: [Rd] String interpolation [Was: string concatenation operator
 (revisited)]
In-Reply-To: <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
 <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>
Message-ID: <98866BE8-AA8B-45DC-85CB-D51AEE625533@R-project.org>

I don't think a custom type alone would work, because users would expect to use such string anywhere a regular string can be used, and that's where the problems start - the evaluation would have to happen at a point where it is not expected since we can assume today that CHAR() doesn't evaluate. If it's just construct that needs some function call to turn it into a real string, then that's (from user's perspective) no different than glue() so I don't think the users would see the benefit (admittedly, you could do a lot more with such internal type, but not sure if the complexity is worth it).

Cheers,
Simon



> On Dec 8, 2021, at 12:56 AM, Taras Zakharko <taras.zakharko at uzh.ch> wrote:
> 
> I fully agree! General string interpolation opens a gaping security hole and is accompanied by all kinds of problems and decisions. What I envision instead is something like this:
> 
>   f?hello {name}? 
> 
> Which gets parsed by R to this:
> 
>   (STRINTERPSXP (CHARSXP (PROMISE nil)))
> 
> Basically, a new type of R language construct that still can be processed by packages (for customized interpolation like in cli etc.), with a default eval which is basically paste0(). The benefit here would be that this is eagerly parsed and syntactically checked, and that the promise code could carry a srcref. And of course, that you could pass an interpolated string expression lazily between frames without losing the environment etc? For more advanced applications, a low level string interpolation expression constructor could be provided (that could either parse a general string ? at the user?s risk, or build it directly from expressions). 
> 
> ? Taras
> 
> 
>> On 7 Dec 2021, at 12:06, Simon Urbanek <simon.urbanek at R-project.org> wrote:
>> 
>> 
>> 
>>> On Dec 7, 2021, at 22:09, Taras Zakharko <taras.zakharko at uzh.ch <mailto:taras.zakharko at uzh.ch>> wrote:
>>> 
>>> Great summary, Avi. 
>>> 
>>> String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have 
>>> a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs. 
>>> 
>>> As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).
>>> 
>> 
>> This is getting OT, but there is a very good reason why string interpolation is not in core R. As I recall it has been considered some time ago, but it is very dangerous as it implies evaluation on constants which opens a huge security hole and has questionable semantics (where you evaluate etc). Hence it's much easier to ban a package than to hack it out of R ;).
>> 
>> Cheers,
>> Simon
>> 
>> 
>>> ? Taras
>>> 
>>> 
>>>> On 7 Dec 2021, at 02:27, Avi Gross via R-devel <r-devel at r-project.org> wrote:
>>>> 
>>>> After seeing what others are saying, it is clear that you need to carefully
>>>> think things out before designing any implementation of a more native
>>>> concatenation operator whether it is called "+' or anything else. There may
>>>> not be any ONE right solution but unlike a function version like paste()
>>>> there is nowhere to place any options that specify what you mean.
>>>> 
>>>> You can obviously expand paste() to accept arguments like replace.NA="" or
>>>> replace.NA="<NA>" and similar arguments on what to do if you see a NaN, and
>>>> Inf or -Inf, a NULL or even an NA.character_ and so on. Heck, you might tell
>>>> to make other substitutions as in substitute=list(100=99, D=F) or any other
>>>> nonsense you can come up with.
>>>> 
>>>> But you have nowhere to put options when saying:
>>>> 
>>>> c <- a + b
>>>> 
>>>> Sure, you could set various global options before the addition and maybe
>>>> rest them after, but that is not a way I like to go for something this
>>>> basic.
>>>> 
>>>> And enough such tinkering makes me wonder if it is easier to ask a user to
>>>> use a slightly different function like this:
>>>> 
>>>> paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
>>>> list(...)))
>>>> 
>>>> The above one-line function removes any NA from the argument list to make a
>>>> potentially shorter list before calling the real paste() using it.
>>>> 
>>>> Variations can, of course, be made that allow functionality as above. 
>>>> 
>>>> If R was a true object-oriented language in the same sense as others like
>>>> Python, operator overloading of "+" might be doable in more complex ways but
>>>> we can only work with what we have. I tend to agree with others that in some
>>>> places R is so lenient that all kinds of errors can happen because it makes
>>>> a guess on how to correct it. Generally, if you really want to mix numeric
>>>> and character, many languages require you to transform any arguments to make
>>>> all of compatible types. The paste() function is clearly stated to coerce
>>>> all arguments to be of type character for you. Whereas a+b makes no such
>>>> promises and also is not properly defined even if a and b are both of type
>>>> character. Sure, we can expand the language but it may still do things some
>>>> find not to be quite what they wanted as in "2"+"3" becoming "23" rather
>>>> than 5. Right now, I can use as.numeric("2")+as.numeric("3") and get the
>>>> intended result after making very clear to anyone reading the code that I
>>>> wanted strings converted to floating point before the addition.
>>>> 
>>>> As has been pointed out, the plus operator if used to concatenate does not
>>>> have a cognate for other operations like -*/ and R has used most other
>>>> special symbols for other purposes. So, sure, we can use something like ....
>>>> (4 periods) if it is not already being used for something but using + here
>>>> is a tad confusing. Having said that, the makers of Python did make that
>>>> choice.
>>>> 
>>>> -----Original Message-----
>>>> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel Becker
>>>> Sent: Monday, December 6, 2021 7:21 PM
>>>> To: Bill Dunlap <williamwdunlap at gmail.com>
>>>> Cc: Radford Neal <radford at cs.toronto.edu>; r-devel <r-devel at r-project.org>
>>>> Subject: Re: [Rd] string concatenation operator (revisited)
>>>> 
>>>> As I recall, there was a large discussion related to that which resulted in
>>>> the recycle0 argument being added (but defaulting to FALSE) for
>>>> paste/paste0.
>>>> 
>>>> I think a lot of these things ultimately mean that if there were to be a
>>>> string concatenation operator, it probably shouldn't have behavior identical
>>>> to paste0. Was that what you were getting at as well, Bill?
>>>> 
>>>> ~G
>>>> 
>>>> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
>>>> 
>>>>> Should paste0(character(0), c("a","b")) give character(0)?
>>>>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>>>>> but c(1,2)+NULL gives numeric(0).
>>>>> 
>>>>> -Bill
>>>>> 
>>>>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch 
>>>>> <murdoch.duncan at gmail.com>
>>>>> wrote:
>>>>> 
>>>>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>>>>>> Gabe, I agree that missingness is important to factor in. To 
>>>>>>> somewhat
>>>>>> abuse
>>>>>>> the terminology, NA is often used to represent missingness. Perhaps 
>>>>>>> concatenating character something with character something missing
>>>>>> should
>>>>>>> result in the original character?
>>>>>> 
>>>>>> I think that's a bad idea.  If you wanted to represent an empty 
>>>>>> string, you should use "" or NULL, not NA.
>>>>>> 
>>>>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it 
>>>>>> should give NA.
>>>>>> 
>>>>>> Duncan Murdoch
>>>>>> 
>>>>>>> 
>>>>>>> Avi
>>>>>>> 
>>>>>>> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker 
>>>>>>> <gabembecker at gmail.com>
>>>>>> wrote:
>>>>>>> 
>>>>>>>> Hi All,
>>>>>>>> 
>>>>>>>> Seeing this and the other thread (and admittedly not having 
>>>>>>>> clicked
>>>>>> through
>>>>>>>> to the linked r-help thread), I wonder about NAs.
>>>>>>>> 
>>>>>>>> Should NA <concat> "hi there"  not result in NA_character_? This 
>>>>>>>> is not what any of the paste functions do, but in my opinoin, NA +
>>>>>> <non_na_value>
>>>>>>>> seems like it should be NA  (not "NA"), particularly if we are 
>>>>>>>> talking about `+` overloading, but potentially even in the case of 
>>>>>>>> a distinct concatenation operator?
>>>>>>>> 
>>>>>>>> I guess what I'm saying is that in my head missingness propagation
>>>>>> rules
>>>>>>>> should take priority in such an operator (ie NA + <anything> 
>>>>>>>> should *always * be NA).
>>>>>>>> 
>>>>>>>> Is that something others disagree with, or has it just not come up 
>>>>>>>> yet
>>>>>> in
>>>>>>>> (the parts I have read) of this discussion?
>>>>>>>> 
>>>>>>>> Best,
>>>>>>>> ~G
>>>>>>>> 
>>>>>>>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal 
>>>>>>>> <radford at cs.toronto.edu>
>>>>>>>> wrote:
>>>>>>>> 
>>>>>>>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as 
>>>>>>>>>>> binary string concatenation operators, equivalent to paste0 and 
>>>>>>>>>>> paste, respectively.
>>>>>>>>>>> 
>>>>>>>>>>> For instance,
>>>>>>>>>>> 
>>>>>>>>>>>> "hello" ! "world"
>>>>>>>>>>>   [1] "helloworld"
>>>>>>>>>>>> "hello" !! "world"
>>>>>>>>>>>   [1] "hello world"
>>>>>>>>>>>> "hello" !! 1:4
>>>>>>>>>>>   [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>>>>>>> 
>>>>>>>>>> I'm curious about the details:
>>>>>>>>>> 
>>>>>>>>>> Would `1 ! 2` convert both to strings?
>>>>>>>>> 
>>>>>>>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", 
>>>>>>>>> just like paste0(1,2) does.  Of course, they wouldn't have to be 
>>>>>>>>> exactly equivalent to paste0 and paste - one could impose 
>>>>>>>>> stricter requirements if that seemed better for error detection.  
>>>>>>>>> Off hand, though, I think automatically converting is more in 
>>>>>>>>> keeping with the rest of R.  Explicitly converting with as.character
>>>> could be tedious.
>>>>>>>>> 
>>>>>>>>> I suppose disallowing logical arguments might make sense to guard 
>>>>>>>>> against typos where ! was meant to be the unary-not operator, but 
>>>>>>>>> ended up being a binary operator, after some sort of typo.  I 
>>>>>>>>> doubt that this would be a common error, though.
>>>>>>>>> 
>>>>>>>>> (Note that there's no ambiguity when there are no typos, except 
>>>>>>>>> that when negation is involved a space may be needed - so, for 
>>>>>>>>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  
>>>>>>>>> Existing uses of double negation are still fine - eg, a <- !!TRUE
>>>> still sets a to TRUE.
>>>>>>>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>>>>> "xTRUE".)
>>>>>>>>> 
>>>>>>>>>> Where does the binary ! fit in the operator priority?  E.g. how 
>>>>>>>>>> is
>>>>>>>>>> 
>>>>>>>>>> a ! b > c
>>>>>>>>>> 
>>>>>>>>>> parsed?
>>>>>>>>> 
>>>>>>>>> As (a ! b) > c.
>>>>>>>>> 
>>>>>>>>> Their precedence is between that of + and - and that of < and >.
>>>>>>>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>>>>>>> 
>>>>>>>>> (Actually, pqR also has a .. operator that fixes the problems 
>>>>>>>>> with generating sequences with the : operator, and it has 
>>>>>>>>> precedence lower than + and - and higher than ! and !!, but 
>>>>>>>>> that's not relevant if you don't have the .. operator.)
>>>>>>>>> 
>>>>>>>>> Radford Neal
>>>>>>>>> 
>>>>>>>>> ______________________________________________
>>>>>>>>> R-devel at r-project.org mailing list 
>>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>> 
>>>>>>>> 
>>>>>>>>      [[alternative HTML version deleted]]
>>>>>>>> 
>>>>>>>> ______________________________________________
>>>>>>>> R-devel at r-project.org mailing list 
>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>> 
>>>>>> 
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>> 
>>>>> 
>>>> 
>>>> 	[[alternative HTML version deleted]]
>>>> 
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>> 
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel <https://stat.ethz.ch/mailman/listinfo/r-devel>
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


From kev|nu@hey @end|ng |rom gm@||@com  Wed Dec  8 00:13:56 2021
From: kev|nu@hey @end|ng |rom gm@||@com (Kevin Ushey)
Date: Tue, 7 Dec 2021 15:13:56 -0800
Subject: [Rd] String interpolation [Was: string concatenation operator
 (revisited)]
In-Reply-To: <98866BE8-AA8B-45DC-85CB-D51AEE625533@R-project.org>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
 <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>
 <98866BE8-AA8B-45DC-85CB-D51AEE625533@R-project.org>
Message-ID: <CAJXgQP1ir2gurPusQDJXfmvJZYBtnKztKkUU5shvTBMq1Nj2ow@mail.gmail.com>

For what it's worth, you can also get 90% of the way there with:

    f <- glue::glue
    f("if you squint, this is a Python f-string")

Having this in an add-on package also makes it much easier to change
in response to user feedback; R packages have more freedom to make
backwards-incompatible changes.

That said, if something like this were to happen in R, my vote would
be an implementation in the parser that transformed f"string" into
something like 'interpolate("string")', so that f"string" would just
become syntactic sugar for already-existing code (and so such code
could remain debuggable, easy to reason about, etc without any changes
to R internals)

Thanks,
Kevin

On Tue, Dec 7, 2021 at 2:06 PM Simon Urbanek
<simon.urbanek at r-project.org> wrote:
>
> I don't think a custom type alone would work, because users would expect to use such string anywhere a regular string can be used, and that's where the problems start - the evaluation would have to happen at a point where it is not expected since we can assume today that CHAR() doesn't evaluate. If it's just construct that needs some function call to turn it into a real string, then that's (from user's perspective) no different than glue() so I don't think the users would see the benefit (admittedly, you could do a lot more with such internal type, but not sure if the complexity is worth it).
>
> Cheers,
> Simon
>
>
>
> > On Dec 8, 2021, at 12:56 AM, Taras Zakharko <taras.zakharko at uzh.ch> wrote:
> >
> > I fully agree! General string interpolation opens a gaping security hole and is accompanied by all kinds of problems and decisions. What I envision instead is something like this:
> >
> >   f?hello {name}?
> >
> > Which gets parsed by R to this:
> >
> >   (STRINTERPSXP (CHARSXP (PROMISE nil)))
> >
> > Basically, a new type of R language construct that still can be processed by packages (for customized interpolation like in cli etc.), with a default eval which is basically paste0(). The benefit here would be that this is eagerly parsed and syntactically checked, and that the promise code could carry a srcref. And of course, that you could pass an interpolated string expression lazily between frames without losing the environment etc? For more advanced applications, a low level string interpolation expression constructor could be provided (that could either parse a general string ? at the user?s risk, or build it directly from expressions).
> >
> > ? Taras
> >
> >


From @v|gro@@ @end|ng |rom ver|zon@net  Wed Dec  8 03:10:12 2021
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Tue, 7 Dec 2021 21:10:12 -0500
Subject: [Rd] string concatenation operator (revisited)
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch> 
Message-ID: <008e01d7ebd8$bbf26fd0$33d74f70$@verizon.net>

Taras and Duncan and others do make a point about things not needing to be built in to the base R distribution if something similar can already be found elsewhere.

To an extent, that is quite true. But what exactly should be in the core of a language that has this kind of extensibility? 

I note how annoying it can be to load a package that then loads all kinds of other packages it depends on and often ones you personally will not know anything about and mostly never use directly. If core R was minimal, this can get worse and there can be serious overhead.

Obviously some code belongs there that directly interacts with the operating system or that implements major parts of the language. But clearly there was more put into S/R than the minimum even from early days based on how the language was expected to be used. And it has grown further over the years. The recent addition of a modified form of a pipe operator, along with a new way to declare a function so it can be added into a pipeline, are examples. Ideally, any feature that becomes used heavily that is already in a package, let alone a package with many such useful features, can be a candidate for inclusion directly or by emulation.

Back to string concatenation, I think it is fair to suggest S began as a statistical language of sorts with a heavy emphasis on numeric data and on vectorized data that led to vectors and data.frames being "built-in" so doing lots more with text was a secondary consideration that functions like paste() not only could easily handle, but could also handle vectorized input. It works pretty well and arguably overloading '+' is not needed. And note, underneath it all, R programs can largely be written using functions rather than operators. You can type:

`+`(5, `*`(2, 3))

and it evaluates to 11 and means 5+(2*3) and 

And paste() is not the only function you can use to do string concatenation. Consider one trivial use of sprintf() which also does much more:

> first <- "Avi"
> last <- "Gross"
> combined <- sprintf("%s%s", first, last)
> print(combined)
[1] "AviGross"

Obviously this also supports including a space between the %s copies and so on.


I note other languages also keep trying to expand to be everything for everybody and can use examples from many but Python is easy to see in many ways and is a bit of a competitor to R for some purposes. Python too has  packages called modules that extend the interpreted language and have had tons of modules added over the years including some to deal with items not included when the language was created. One reason R has done so well is that Python had things like lists but had no vectorized methods and other components like R did so lots of programs must first import modules like numpy and pandas to be able to create Series and Dataframes and manipulate them efficiently. But many modules have now been built on top of these extensions for various kinds of scientific programming and at some point you wonder why it is not built-in to the language to fill a gap they left. Lists are slow and dictionaries have limited use for many things. Tasks like machine learning can use huge amounts of data and do complex calculations repeatedly so Python has had to be extended. Yet, there too, most things have to be imported at runtime.

I am not a fanatic in R about the tidyverse set of packages  and often do some things using the built-in ways or use the tidyverse or mix and match. Both have value for me and some things remain easier than others depending on circumstances. Of course, using the same function name as other packages makes it hard to incorporate. But I don't think it would be hard to create a base R that includes a subset of the tidyverse as part of the base and leave other parts to be brought in only as needed.

The talk about string concatenation, also mentions the use of the glue package that I also sometimes use. The concatenation of strings and other types into a bigger string is often done in many languages and I note I have used five different methods in Python that are built-in as people keep wanting to bring in the way it is already done in some other language they like. I am talking about not so much concatenation but variants on the printf() family to format a string from many components and some look a bit like glue.  Potentially, a package like glue could also qualify as worth including in base R but let me clarify. There is a difference between being in the minimal core of a language and being in a list of packages that are by default included when R is built. Even if you include a package by default, it should not be an error to say library(name) if it is already loaded on your machine. So even after you make something part of the base distribution, people may continue to invoke it as if it was not there, lest the code be run on an older version.

The reality is that there can be significant costs in a tradeoff between ease of use with many choices and in the expense of running a bloated application that takes longer to load and more memory and spends more time searching namespaces and so on. 

Does adding a properly designed "+" cause much bloat? Maybe not. But the guardians of the language get so many requests, that realistically they can only approve a small number for each release and often then have to spend more time fixing bugs after getting complaints about code that does not work the same anymore!


-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Taras Zakharko
Sent: Tuesday, December 7, 2021 4:09 AM
To: r-devel <r-devel at r-project.org>
Subject: Re: [Rd] string concatenation operator (revisited)

Great summary, Avi. 

String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs. 

As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).

? Taras


> On 7 Dec 2021, at 02:27, Avi Gross via R-devel <r-devel at r-project.org> wrote:
> 
> After seeing what others are saying, it is clear that you need to 
> carefully think things out before designing any implementation of a 
> more native concatenation operator whether it is called "+' or 
> anything else. There may not be any ONE right solution but unlike a 
> function version like paste() there is nowhere to place any options that specify what you mean.
> 
> You can obviously expand paste() to accept arguments like 
> replace.NA="" or replace.NA="<NA>" and similar arguments on what to do 
> if you see a NaN, and Inf or -Inf, a NULL or even an NA.character_ and 
> so on. Heck, you might tell to make other substitutions as in 
> substitute=list(100=99, D=F) or any other nonsense you can come up with.
> 
> But you have nowhere to put options when saying:
> 
> c <- a + b
> 
> Sure, you could set various global options before the addition and 
> maybe rest them after, but that is not a way I like to go for 
> something this basic.
> 
> And enough such tinkering makes me wonder if it is easier to ask a 
> user to use a slightly different function like this:
> 
> paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
> list(...)))
> 
> The above one-line function removes any NA from the argument list to 
> make a potentially shorter list before calling the real paste() using it.
> 
> Variations can, of course, be made that allow functionality as above. 
> 
> If R was a true object-oriented language in the same sense as others 
> like Python, operator overloading of "+" might be doable in more 
> complex ways but we can only work with what we have. I tend to agree 
> with others that in some places R is so lenient that all kinds of 
> errors can happen because it makes a guess on how to correct it.
> Generally, if you really want to mix numeric and character, many 
> languages require you to transform any arguments to make all of 
> compatible types. The paste() function is clearly stated to coerce all 
> arguments to be of type character for you. Whereas a+b makes no such 
> promises and also is not properly defined even if a and b are both of 
> type character. Sure, we can expand the language but it may still do 
> things some find not to be quite what they wanted as in "2"+"3"
> becoming "23" rather than 5. Right now, I can use
> as.numeric("2")+as.numeric("3") and get the intended result after making very clear to anyone reading the code that I wanted strings converted to floating point before the addition.
> 
> As has been pointed out, the plus operator if used to concatenate does 
> not have a cognate for other operations like -*/ and R has used most 
> other special symbols for other purposes. So, sure, we can use something like ....
> (4 periods) if it is not already being used for something but using + 
> here is a tad confusing. Having said that, the makers of Python did 
> make that choice.
> 
> -----Original Message-----
> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel 
> Becker
> Sent: Monday, December 6, 2021 7:21 PM
> To: Bill Dunlap <williamwdunlap at gmail.com>
> Cc: Radford Neal <radford at cs.toronto.edu>; r-devel 
> <r-devel at r-project.org>
> Subject: Re: [Rd] string concatenation operator (revisited)
> 
> As I recall, there was a large discussion related to that which 
> resulted in the recycle0 argument being added (but defaulting to
> FALSE) for paste/paste0.
> 
> I think a lot of these things ultimately mean that if there were to be 
> a string concatenation operator, it probably shouldn't have behavior 
> identical to paste0. Was that what you were getting at as well, Bill?
> 
> ~G
> 
> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
> 
>> Should paste0(character(0), c("a","b")) give character(0)?
>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>> but c(1,2)+NULL gives numeric(0).
>> 
>> -Bill
>> 
>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch 
>> <murdoch.duncan at gmail.com>
>> wrote:
>> 
>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>>> Gabe, I agree that missingness is important to factor in. To 
>>>> somewhat
>>> abuse
>>>> the terminology, NA is often used to represent missingness. Perhaps 
>>>> concatenating character something with character something missing
>>> should
>>>> result in the original character?
>>> 
>>> I think that's a bad idea.  If you wanted to represent an empty 
>>> string, you should use "" or NULL, not NA.
>>> 
>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it 
>>> should give NA.
>>> 
>>> Duncan Murdoch
>>> 
>>>> 
>>>> Avi
>>>> 
>>>> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker 
>>>> <gabembecker at gmail.com>
>>> wrote:
>>>> 
>>>>> Hi All,
>>>>> 
>>>>> Seeing this and the other thread (and admittedly not having 
>>>>> clicked
>>> through
>>>>> to the linked r-help thread), I wonder about NAs.
>>>>> 
>>>>> Should NA <concat> "hi there"  not result in NA_character_? This 
>>>>> is not what any of the paste functions do, but in my opinoin, NA +
>>> <non_na_value>
>>>>> seems like it should be NA  (not "NA"), particularly if we are 
>>>>> talking about `+` overloading, but potentially even in the case of 
>>>>> a distinct concatenation operator?
>>>>> 
>>>>> I guess what I'm saying is that in my head missingness propagation
>>> rules
>>>>> should take priority in such an operator (ie NA + <anything> 
>>>>> should *always * be NA).
>>>>> 
>>>>> Is that something others disagree with, or has it just not come up 
>>>>> yet
>>> in
>>>>> (the parts I have read) of this discussion?
>>>>> 
>>>>> Best,
>>>>> ~G
>>>>> 
>>>>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal 
>>>>> <radford at cs.toronto.edu>
>>>>> wrote:
>>>>> 
>>>>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as 
>>>>>>>> binary string concatenation operators, equivalent to paste0 and 
>>>>>>>> paste, respectively.
>>>>>>>> 
>>>>>>>> For instance,
>>>>>>>> 
>>>>>>>>> "hello" ! "world"
>>>>>>>>      [1] "helloworld"
>>>>>>>>> "hello" !! "world"
>>>>>>>>      [1] "hello world"
>>>>>>>>> "hello" !! 1:4
>>>>>>>>      [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>>>> 
>>>>>>> I'm curious about the details:
>>>>>>> 
>>>>>>> Would `1 ! 2` convert both to strings?
>>>>>> 
>>>>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", 
>>>>>> just like paste0(1,2) does.  Of course, they wouldn't have to be 
>>>>>> exactly equivalent to paste0 and paste - one could impose 
>>>>>> stricter requirements if that seemed better for error detection.
>>>>>> Off hand, though, I think automatically converting is more in 
>>>>>> keeping with the rest of R.  Explicitly converting with 
>>>>>> as.character
> could be tedious.
>>>>>> 
>>>>>> I suppose disallowing logical arguments might make sense to guard 
>>>>>> against typos where ! was meant to be the unary-not operator, but 
>>>>>> ended up being a binary operator, after some sort of typo.  I 
>>>>>> doubt that this would be a common error, though.
>>>>>> 
>>>>>> (Note that there's no ambiguity when there are no typos, except 
>>>>>> that when negation is involved a space may be needed - so, for 
>>>>>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".
>>>>>> Existing uses of double negation are still fine - eg, a <- !!TRUE
> still sets a to TRUE.
>>>>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>> "xTRUE".)
>>>>>> 
>>>>>>> Where does the binary ! fit in the operator priority?  E.g. how 
>>>>>>> is
>>>>>>> 
>>>>>>>   a ! b > c
>>>>>>> 
>>>>>>> parsed?
>>>>>> 
>>>>>> As (a ! b) > c.
>>>>>> 
>>>>>> Their precedence is between that of + and - and that of < and >.
>>>>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>>>> 
>>>>>> (Actually, pqR also has a .. operator that fixes the problems 
>>>>>> with generating sequences with the : operator, and it has 
>>>>>> precedence lower than + and - and higher than ! and !!, but 
>>>>>> that's not relevant if you don't have the .. operator.)
>>>>>> 
>>>>>>    Radford Neal
>>>>>> 
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list 
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>> 
>>>>> 
>>>>>         [[alternative HTML version deleted]]
>>>>> 
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list 
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>> 
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> 
>> 
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From t@r@@@z@kh@rko @end|ng |rom uzh@ch  Wed Dec  8 08:55:13 2021
From: t@r@@@z@kh@rko @end|ng |rom uzh@ch (Taras Zakharko)
Date: Wed, 8 Dec 2021 08:55:13 +0100
Subject: [Rd] String interpolation [Was: string concatenation operator
 (revisited)]
In-Reply-To: <CAJXgQP1ir2gurPusQDJXfmvJZYBtnKztKkUU5shvTBMq1Nj2ow@mail.gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
 <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>
 <98866BE8-AA8B-45DC-85CB-D51AEE625533@R-project.org>
 <CAJXgQP1ir2gurPusQDJXfmvJZYBtnKztKkUU5shvTBMq1Nj2ow@mail.gmail.com>
Message-ID: <C451D8F9-52A2-4482-A2CF-BAFC5B588452@uzh.ch>

> I don't think a custom type alone would work, because users would expect to use such string anywhere a regular string can be used, and that's where the problems start - the evaluation would have to happen at a point where it is not expected since we can assume today that CHAR() doesn't evaluate. If it's just construct that needs some function call to turn it into a real string, then that's (from user's perspective) no different than glue() 
> 

Oh, it will be still evaluated as expected. It would just be a new type of language expression, just like byte code or call or a promise. You just need a new case in the switch statement of eval(). The rest is just lazy evaluation as usual, no change of rules is needed. Of course, some rules need to be established on when exactly the evaluation kicks in  (and this can be a bit tricky), but I am sure one can figure out a sane approach ? my intuition would be to evaluate a format string any time one evaluates a promise. In fact, it could probably be treated as a special type of promise itself, with value caching and all. Under which approach the end user will never see the special type, every time you assign a formatted string somewhere, it will get evaluated to a plain old character vector. But if passed as an argument you get the benefits of lazy evaluation. 

What functions could do is suspend the evaluation to check if an argument is a (processed) format string and apply custom formatting to it. Again, not any different from today?s R, where  you can capture the lazy expression and apply transformations to it. The R parser just does some basic preprocessing for you. 

> admittedly, you could do a lot more with such internal type, but not sure if the complexity is worth it

That?s the question :) I am not sure either. It was just a spontaneous idea I thew out there, not a result of careful deliberation. Still, I believe it can be useful to think about things like that, it just might give the right person just the right idea. 


> For what it's worth, you can also get 90% of the way there with:
> 
>    f <- glue::glue
>    f("if you squint, this is a Python f-string?)
> 
> ...
> 
> That said, if something like this were to happen in R, my vote would
> be an implementation in the parser that transformed f"string" into
> something like 'interpolate("string")', so that f"string" would just
> become syntactic sugar for already-existing code

Not really. With this approach expression parsing would still be done at evaluation time, so you don?t get any  of the potential benefits that come from my suggestion (expression parsing at parse time, higher runtime performance, correctly captured expression promises). 

One quick note about parser transformations: lazy evaluation with expression capturing (substitution) is one of unique strength of R, as it allows one to trivially implement powerful DLSs on top of the language (as demonstrated by ?tidy evaluation? implementation in tidyverse).  Parser transformations might make the implementation simpler, but they remove the  information from the parse tree and reduce opportunities. 

? Taras


> On 8 Dec 2021, at 00:13, Kevin Ushey <kevinushey at gmail.com> wrote:
> 
> For what it's worth, you can also get 90% of the way there with:
> 
>    f <- glue::glue
>    f("if you squint, this is a Python f-string")
> 
> Having this in an add-on package also makes it much easier to change
> in response to user feedback; R packages have more freedom to make
> backwards-incompatible changes.
> 
> That said, if something like this were to happen in R, my vote would
> be an implementation in the parser that transformed f"string" into
> something like 'interpolate("string")', so that f"string" would just
> become syntactic sugar for already-existing code (and so such code
> could remain debuggable, easy to reason about, etc without any changes
> to R internals)
> 
> Thanks,
> Kevin
> 
> On Tue, Dec 7, 2021 at 2:06 PM Simon Urbanek
> <simon.urbanek at r-project.org> wrote:
>> 
>> I don't think a custom type alone would work, because users would expect to use such string anywhere a regular string can be used, and that's where the problems start - the evaluation would have to happen at a point where it is not expected since we can assume today that CHAR() doesn't evaluate. If it's just construct that needs some function call to turn it into a real string, then that's (from user's perspective) no different than glue() so I don't think the users would see the benefit (admittedly, you could do a lot more with such internal type, but not sure if the complexity is worth it).
>> 
>> Cheers,
>> Simon
>> 
>> 
>> 
>>> On Dec 8, 2021, at 12:56 AM, Taras Zakharko <taras.zakharko at uzh.ch> wrote:
>>> 
>>> I fully agree! General string interpolation opens a gaping security hole and is accompanied by all kinds of problems and decisions. What I envision instead is something like this:
>>> 
>>>  f?hello {name}?
>>> 
>>> Which gets parsed by R to this:
>>> 
>>>  (STRINTERPSXP (CHARSXP (PROMISE nil)))
>>> 
>>> Basically, a new type of R language construct that still can be processed by packages (for customized interpolation like in cli etc.), with a default eval which is basically paste0(). The benefit here would be that this is eagerly parsed and syntactically checked, and that the promise code could carry a srcref. And of course, that you could pass an interpolated string expression lazily between frames without losing the environment etc? For more advanced applications, a low level string interpolation expression constructor could be provided (that could either parse a general string ? at the user?s risk, or build it directly from expressions).
>>> 
>>> ? Taras
>>> 
>>> 


	[[alternative HTML version deleted]]


From |reder|k @end|ng |rom o|b@net  Wed Dec  8 09:24:47 2021
From: |reder|k @end|ng |rom o|b@net (Frederick Eaton)
Date: Wed, 8 Dec 2021 00:24:47 -0800
Subject: [Rd] 
 meaning of browser(skipCalls=) [and multiple mouse buttons]
In-Reply-To: <20211122171358.7rej26rdwpq5ywrm@localhost>
References: <20211122171358.7rej26rdwpq5ywrm@localhost>
Message-ID: <20211208082447.vd3hpq4gxd37llqy@localhost>

Dear R Core Team,

I'm attaching a proposed patch to hopefully address my confusions regarding the documentation of browser(). I'm not sure if all the material I added is correct, but I made experiments to confirm that the behavior is at least roughly as described.

     patch ./src/library/base/man/browser.Rd < browser.patch

Also, here is a patch to support multiple mouse buttons in getGraphicsEvent(). This must be edited before it can be applied, I decided to keep the old code in an 'if(0)' to help make it clearer that my code is essentially doing the same thing.

     https://github.com/navarum/tweaks/blob/master/r/patches/0001-Add-support-for-multiple-mouse-buttons.patch
     wget -O - https://raw.githubusercontent.com/navarum/tweaks/master/r/patches/0001-Add-support-for-multiple-mouse-buttons.patch | patch -p1

It would be useful to have support in R for more than three mouse buttons because this enables the use of the mouse wheel (buttons 4 and 5), which can provide a more convenient interface when adjusting numbers and graphics and so on. I also have shift+wheel bound to buttons 6 and 7 via xbindkeys and xte, which I use for horizontal scrolling, via a trick from the web somewhere:

     $ cat .xbindkeysrc.scm | grep xte
     (xbindkey '(shift "b:4") "xte 'mouseclick 6'")
     (xbindkey '(shift "b:5") "xte 'mouseclick 7'")

I hope that these contributions can be found acceptable.

Thank you in advance,

Frederick



On Mon, Nov 22, 2021 at 09:13:58AM -0800, Frederick Eaton wrote:
>Dear R Devel,
>
>I have been advised to use "options(error=recover)" to enable
>debugging on errors. But sometimes it would seem more convenient to
>override "stopifnot", for example:
>
>    stopifnot = function(b) { if(!b) { browser(skipCalls=1); } }
>
>However, this doesn't do what I expected. On looking closer I find
>that the "skipCalls" argument seems to be ignored except when printing
>the "Called from: " message; it does not affect the evaluation context
>or the output of 'where':
>
>    > var=2; f=function(){var=1; browser(skipCalls=0)}; f()
>    Called from: f()
>    Browse[1]> var
>    [1] 1
>    Browse[1]> where
>    where 1: f()
>
>    Browse[1]> Q
>    > var=2; f=function(){var=1; browser(skipCalls=1)}; f()
>    Called from: top level     Browse[1]> var
>    [1] 1
>    Browse[1]> where
>    where 1: f()
>
>    Browse[1]> Q
>    > var=2; f=function(){var=1; browser(skipCalls=2)}; f()
>    Called from: top level     Browse[1]> var
>    [1] 1
>    Browse[1]> where
>    where 1: f()
>
>    Browse[1]> Q
>
>So it appears that the "browser()" API does not actually make it
>possible to call this built-in function from within another R function
>and thereby emulate the same behavior as calling browser() directly.
>
>If this is the case, it might be good to have it fixed or documented.
>I am aware of "browser(expr=)", but this requires editing the
>particular call that failed. The documentation for "browser()" led me
>to hope that my use case would be supported, if only because it admits
>that users might want to build other debugging functions with
>browser(): "The 'skipCalls' argument should be used when the
>'browser()' call is nested within another debugging function". An
>example where this 'skipCalls' parameter is used to build a useful
>debugging function would help to clarify its English description in
>the manual.
>
>Also, from the browser() command line I could not find a way to step
>*out* of the current function. This would have been a way to recover
>from skipCalls not working as expected. Am I missing something? For
>example is there some command other than "n", where the below
>interaction could pause before "hi" and "bye"?
>
>    > f=function(){browser(); message("in f"); message("out f")}; f(); message("hi"); message("bye")
>    Called from: f()
>    Browse[1]> n
>    debug at #1: message("in f")
>    Browse[2]> n
>    in f
>    debug at #1: message("out f")
>    Browse[2]> n
>    out f
>    hi
>    bye
>
>If it is not possible for the R debugger to step out of a function, it
>would be good to document that too, maybe after the list of browser
>prompt commands in "?browser". Being confined within a single function
>is not an obvious disability for a debugger to have.
>
>I feel that R is an excellent tool, but sometimes I think that if the
>shortcomings of the system were better documented, then this would
>save users a lot of time in certain cases.
>
>Thank you,
>
>Frederick
>

-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: browser.patch
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20211208/056037de/attachment.ksh>

From murdoch@dunc@n @end|ng |rom gm@||@com  Wed Dec  8 12:24:04 2021
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Wed, 8 Dec 2021 06:24:04 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <008e01d7ebd8$bbf26fd0$33d74f70$@verizon.net>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <008e01d7ebd8$bbf26fd0$33d74f70$@verizon.net>
Message-ID: <5e74a3e3-6a5f-79f8-dbbf-b908d82e5d64@gmail.com>

On 07/12/2021 9:10 p.m., Avi Gross via R-devel wrote:
> Taras and Duncan and others do make a point about things not needing to be built in to the base R distribution if something similar can already be found elsewhere.
> 
> To an extent, that is quite true. But what exactly should be in the core of a language that has this kind of extensibility?
> 
> I note how annoying it can be to load a package that then loads all kinds of other packages it depends on and often ones you personally will not know anything about and mostly never use directly. If core R was minimal, this can get worse and there can be serious overhead.

In that case you shouldn't use that package, you should find or write 
another one that doesn't have all those dependencies.

> Obviously some code belongs there that directly interacts with the operating system or that implements major parts of the language. But clearly there was more put into S/R than the minimum even from early days based on how the language was expected to be used. And it has grown further over the years. The recent addition of a modified form of a pipe operator, along with a new way to declare a function so it can be added into a pipeline, are examples. Ideally, any feature that becomes used heavily that is already in a package, let alone a package with many such useful features, can be a candidate for inclusion directly or by emulation.

The difference between core R and contributed R is mainly who is 
responsible for supporting it.  When you ask for something to move to 
core R, you are asking R Core members to take on added work.  When they 
add something, they are volunteering to take on that responsibility. 
That's a big difference.

Duncan Murdoch

> Back to string concatenation, I think it is fair to suggest S began as a statistical language of sorts with a heavy emphasis on numeric data and on vectorized data that led to vectors and data.frames being "built-in" so doing lots more with text was a secondary consideration that functions like paste() not only could easily handle, but could also handle vectorized input. It works pretty well and arguably overloading '+' is not needed. And note, underneath it all, R programs can largely be written using functions rather than operators. You can type:
> 
> `+`(5, `*`(2, 3))
> 
> and it evaluates to 11 and means 5+(2*3) and
> 
> And paste() is not the only function you can use to do string concatenation. Consider one trivial use of sprintf() which also does much more:
> 
>> first <- "Avi"
>> last <- "Gross"
>> combined <- sprintf("%s%s", first, last)
>> print(combined)
> [1] "AviGross"
> 
> Obviously this also supports including a space between the %s copies and so on.
> 
> 
> I note other languages also keep trying to expand to be everything for everybody and can use examples from many but Python is easy to see in many ways and is a bit of a competitor to R for some purposes. Python too has  packages called modules that extend the interpreted language and have had tons of modules added over the years including some to deal with items not included when the language was created. One reason R has done so well is that Python had things like lists but had no vectorized methods and other components like R did so lots of programs must first import modules like numpy and pandas to be able to create Series and Dataframes and manipulate them efficiently. But many modules have now been built on top of these extensions for various kinds of scientific programming and at some point you wonder why it is not built-in to the language to fill a gap they left. Lists are slow and dictionaries have limited use for many things. Tasks like machine learning can use huge amounts of data and do complex calculations repeatedly so Python has had to be extended. Yet, there too, most things have to be imported at runtime.
> 
> I am not a fanatic in R about the tidyverse set of packages  and often do some things using the built-in ways or use the tidyverse or mix and match. Both have value for me and some things remain easier than others depending on circumstances. Of course, using the same function name as other packages makes it hard to incorporate. But I don't think it would be hard to create a base R that includes a subset of the tidyverse as part of the base and leave other parts to be brought in only as needed.
> 
> The talk about string concatenation, also mentions the use of the glue package that I also sometimes use. The concatenation of strings and other types into a bigger string is often done in many languages and I note I have used five different methods in Python that are built-in as people keep wanting to bring in the way it is already done in some other language they like. I am talking about not so much concatenation but variants on the printf() family to format a string from many components and some look a bit like glue.  Potentially, a package like glue could also qualify as worth including in base R but let me clarify. There is a difference between being in the minimal core of a language and being in a list of packages that are by default included when R is built. Even if you include a package by default, it should not be an error to say library(name) if it is already loaded on your machine. So even after you make something part of the base distribution, people may continue to invoke it as if it was not there, lest the code be run on an older version.
> 
> The reality is that there can be significant costs in a tradeoff between ease of use with many choices and in the expense of running a bloated application that takes longer to load and more memory and spends more time searching namespaces and so on.
> 
> Does adding a properly designed "+" cause much bloat? Maybe not. But the guardians of the language get so many requests, that realistically they can only approve a small number for each release and often then have to spend more time fixing bugs after getting complaints about code that does not work the same anymore!
> 
> 
> -----Original Message-----
> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Taras Zakharko
> Sent: Tuesday, December 7, 2021 4:09 AM
> To: r-devel <r-devel at r-project.org>
> Subject: Re: [Rd] string concatenation operator (revisited)
> 
> Great summary, Avi.
> 
> String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs.
> 
> As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).
> 
> ? Taras
> 
> 
>> On 7 Dec 2021, at 02:27, Avi Gross via R-devel <r-devel at r-project.org> wrote:
>>
>> After seeing what others are saying, it is clear that you need to
>> carefully think things out before designing any implementation of a
>> more native concatenation operator whether it is called "+' or
>> anything else. There may not be any ONE right solution but unlike a
>> function version like paste() there is nowhere to place any options that specify what you mean.
>>
>> You can obviously expand paste() to accept arguments like
>> replace.NA="" or replace.NA="<NA>" and similar arguments on what to do
>> if you see a NaN, and Inf or -Inf, a NULL or even an NA.character_ and
>> so on. Heck, you might tell to make other substitutions as in
>> substitute=list(100=99, D=F) or any other nonsense you can come up with.
>>
>> But you have nowhere to put options when saying:
>>
>> c <- a + b
>>
>> Sure, you could set various global options before the addition and
>> maybe rest them after, but that is not a way I like to go for
>> something this basic.
>>
>> And enough such tinkering makes me wonder if it is easier to ask a
>> user to use a slightly different function like this:
>>
>> paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
>> list(...)))
>>
>> The above one-line function removes any NA from the argument list to
>> make a potentially shorter list before calling the real paste() using it.
>>
>> Variations can, of course, be made that allow functionality as above.
>>
>> If R was a true object-oriented language in the same sense as others
>> like Python, operator overloading of "+" might be doable in more
>> complex ways but we can only work with what we have. I tend to agree
>> with others that in some places R is so lenient that all kinds of
>> errors can happen because it makes a guess on how to correct it.
>> Generally, if you really want to mix numeric and character, many
>> languages require you to transform any arguments to make all of
>> compatible types. The paste() function is clearly stated to coerce all
>> arguments to be of type character for you. Whereas a+b makes no such
>> promises and also is not properly defined even if a and b are both of
>> type character. Sure, we can expand the language but it may still do
>> things some find not to be quite what they wanted as in "2"+"3"
>> becoming "23" rather than 5. Right now, I can use
>> as.numeric("2")+as.numeric("3") and get the intended result after making very clear to anyone reading the code that I wanted strings converted to floating point before the addition.
>>
>> As has been pointed out, the plus operator if used to concatenate does
>> not have a cognate for other operations like -*/ and R has used most
>> other special symbols for other purposes. So, sure, we can use something like ....
>> (4 periods) if it is not already being used for something but using +
>> here is a tad confusing. Having said that, the makers of Python did
>> make that choice.
>>
>> -----Original Message-----
>> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel
>> Becker
>> Sent: Monday, December 6, 2021 7:21 PM
>> To: Bill Dunlap <williamwdunlap at gmail.com>
>> Cc: Radford Neal <radford at cs.toronto.edu>; r-devel
>> <r-devel at r-project.org>
>> Subject: Re: [Rd] string concatenation operator (revisited)
>>
>> As I recall, there was a large discussion related to that which
>> resulted in the recycle0 argument being added (but defaulting to
>> FALSE) for paste/paste0.
>>
>> I think a lot of these things ultimately mean that if there were to be
>> a string concatenation operator, it probably shouldn't have behavior
>> identical to paste0. Was that what you were getting at as well, Bill?
>>
>> ~G
>>
>> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
>>
>>> Should paste0(character(0), c("a","b")) give character(0)?
>>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>>> but c(1,2)+NULL gives numeric(0).
>>>
>>> -Bill
>>>
>>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch
>>> <murdoch.duncan at gmail.com>
>>> wrote:
>>>
>>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>>>> Gabe, I agree that missingness is important to factor in. To
>>>>> somewhat
>>>> abuse
>>>>> the terminology, NA is often used to represent missingness. Perhaps
>>>>> concatenating character something with character something missing
>>>> should
>>>>> result in the original character?
>>>>
>>>> I think that's a bad idea.  If you wanted to represent an empty
>>>> string, you should use "" or NULL, not NA.
>>>>
>>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it
>>>> should give NA.
>>>>
>>>> Duncan Murdoch
>>>>
>>>>>
>>>>> Avi
>>>>>
>>>>> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker
>>>>> <gabembecker at gmail.com>
>>>> wrote:
>>>>>
>>>>>> Hi All,
>>>>>>
>>>>>> Seeing this and the other thread (and admittedly not having
>>>>>> clicked
>>>> through
>>>>>> to the linked r-help thread), I wonder about NAs.
>>>>>>
>>>>>> Should NA <concat> "hi there"  not result in NA_character_? This
>>>>>> is not what any of the paste functions do, but in my opinoin, NA +
>>>> <non_na_value>
>>>>>> seems like it should be NA  (not "NA"), particularly if we are
>>>>>> talking about `+` overloading, but potentially even in the case of
>>>>>> a distinct concatenation operator?
>>>>>>
>>>>>> I guess what I'm saying is that in my head missingness propagation
>>>> rules
>>>>>> should take priority in such an operator (ie NA + <anything>
>>>>>> should *always * be NA).
>>>>>>
>>>>>> Is that something others disagree with, or has it just not come up
>>>>>> yet
>>>> in
>>>>>> (the parts I have read) of this discussion?
>>>>>>
>>>>>> Best,
>>>>>> ~G
>>>>>>
>>>>>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal
>>>>>> <radford at cs.toronto.edu>
>>>>>> wrote:
>>>>>>
>>>>>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as
>>>>>>>>> binary string concatenation operators, equivalent to paste0 and
>>>>>>>>> paste, respectively.
>>>>>>>>>
>>>>>>>>> For instance,
>>>>>>>>>
>>>>>>>>>> "hello" ! "world"
>>>>>>>>>       [1] "helloworld"
>>>>>>>>>> "hello" !! "world"
>>>>>>>>>       [1] "hello world"
>>>>>>>>>> "hello" !! 1:4
>>>>>>>>>       [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>>>>>
>>>>>>>> I'm curious about the details:
>>>>>>>>
>>>>>>>> Would `1 ! 2` convert both to strings?
>>>>>>>
>>>>>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12",
>>>>>>> just like paste0(1,2) does.  Of course, they wouldn't have to be
>>>>>>> exactly equivalent to paste0 and paste - one could impose
>>>>>>> stricter requirements if that seemed better for error detection.
>>>>>>> Off hand, though, I think automatically converting is more in
>>>>>>> keeping with the rest of R.  Explicitly converting with
>>>>>>> as.character
>> could be tedious.
>>>>>>>
>>>>>>> I suppose disallowing logical arguments might make sense to guard
>>>>>>> against typos where ! was meant to be the unary-not operator, but
>>>>>>> ended up being a binary operator, after some sort of typo.  I
>>>>>>> doubt that this would be a common error, though.
>>>>>>>
>>>>>>> (Note that there's no ambiguity when there are no typos, except
>>>>>>> that when negation is involved a space may be needed - so, for
>>>>>>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".
>>>>>>> Existing uses of double negation are still fine - eg, a <- !!TRUE
>> still sets a to TRUE.
>>>>>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>>> "xTRUE".)
>>>>>>>
>>>>>>>> Where does the binary ! fit in the operator priority?  E.g. how
>>>>>>>> is
>>>>>>>>
>>>>>>>>    a ! b > c
>>>>>>>>
>>>>>>>> parsed?
>>>>>>>
>>>>>>> As (a ! b) > c.
>>>>>>>
>>>>>>> Their precedence is between that of + and - and that of < and >.
>>>>>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>>>>>
>>>>>>> (Actually, pqR also has a .. operator that fixes the problems
>>>>>>> with generating sequences with the : operator, and it has
>>>>>>> precedence lower than + and - and higher than ! and !!, but
>>>>>>> that's not relevant if you don't have the .. operator.)
>>>>>>>
>>>>>>>     Radford Neal
>>>>>>>
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>
>>>>>>
>>>>>>          [[alternative HTML version deleted]]
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>
>>
>> 	[[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Wed Dec  8 14:56:36 2021
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Wed, 8 Dec 2021 14:56:36 +0100
Subject: [Rd] R/CRAN switch to UCRT on Windows
Message-ID: <332260b1-0dad-2808-97dd-150aa7687dd3@gmail.com>

Please note an update concerning the support of UTF-8 as native encoding 
on Windows, which may at this point be of interest particularly to 
developers of packages with native code and to R users using R-devel 
(the development version of R) on Windows:

https://developer.r-project.org/Blog/public/2021/12/07/upcoming-changes-in-r-4.2-on-windows/

The key part is that CRAN will switch the incoming checks of R packages 
on Windows to a new toolchain targeting UCRT on Monday, December 13.

It may take up to several days for all systems to synchronize and during 
this time, it may be difficult to build R-devel on Windows from source 
or to install packages.? After the switch, the snapshot R-devel builds 
and binary package builds provided by CRAN will be built using the new 
toolchain for UCRT. These new builds will use UTF-8 as the native 
encoding on recent Windows.

These builds will be incompatible with the previous builds for MSVCRT 
and installed/binary packages will be incompatible as well. The 
recommended/simplest course of action for R-devel users is to uninstall 
the old build of R-devel, RTools, delete the old package libraries, and 
then install the new versions.

Checks of CRAN packages with the new toolchain have been running since 
March with results available on CRAN pages. By now, most packages are 
working, but some packages using native (C, C++, Fortran) code still 
have to be updated. The Winbuilder service and R-hub support the new 
toolchain, there is also support/example for using github actions. The 
builds of R-devel and CRAN (and recommended binary packages) with the 
new toolchain are available regularly since March.

I've created patches for CRAN (and required Bioconductor packages) which 
are installed automatically at package installation time by R. This 
feature will be also in R-devel after the switch and will be used 
temporarily to give package authors more time to fix their packages. Uwe 
Ligges, other CRAN team members and I have also been in touch with some 
package authors, providing advice how to fix their packages, when the 
issues required more explanation. I am prepared to help the remaining 
authors as well if needed.

Please see the blog post and materials linked from there for more 
details and feel free to ask questions.

Thanks
Tomas


From ||gge@ @end|ng |rom @t@t|@t|k@tu-dortmund@de  Wed Dec  8 15:24:21 2021
From: ||gge@ @end|ng |rom @t@t|@t|k@tu-dortmund@de (Uwe Ligges)
Date: Wed, 8 Dec 2021 15:24:21 +0100
Subject: [Rd] R/CRAN switch to UCRT on Windows
In-Reply-To: <332260b1-0dad-2808-97dd-150aa7687dd3@gmail.com>
References: <332260b1-0dad-2808-97dd-150aa7687dd3@gmail.com>
Message-ID: <4f14e5b0-c969-f97c-56a3-129cd05e5e3e@statistik.tu-dortmund.de>

Thank you, Tomas, for your hard work on the new toolchain, its 
documentation, and all your efforts in providing patches for R and for 
several contributed packages.

Best,
Uwe



On 08.12.2021 14:56, Tomas Kalibera wrote:
> Please note an update concerning the support of UTF-8 as native encoding 
> on Windows, which may at this point be of interest particularly to 
> developers of packages with native code and to R users using R-devel 
> (the development version of R) on Windows:
> 
> https://developer.r-project.org/Blog/public/2021/12/07/upcoming-changes-in-r-4.2-on-windows/ 
> 
> 
> The key part is that CRAN will switch the incoming checks of R packages 
> on Windows to a new toolchain targeting UCRT on Monday, December 13.
> 
> It may take up to several days for all systems to synchronize and during 
> this time, it may be difficult to build R-devel on Windows from source 
> or to install packages.? After the switch, the snapshot R-devel builds 
> and binary package builds provided by CRAN will be built using the new 
> toolchain for UCRT. These new builds will use UTF-8 as the native 
> encoding on recent Windows.
> 
> These builds will be incompatible with the previous builds for MSVCRT 
> and installed/binary packages will be incompatible as well. The 
> recommended/simplest course of action for R-devel users is to uninstall 
> the old build of R-devel, RTools, delete the old package libraries, and 
> then install the new versions.
> 
> Checks of CRAN packages with the new toolchain have been running since 
> March with results available on CRAN pages. By now, most packages are 
> working, but some packages using native (C, C++, Fortran) code still 
> have to be updated. The Winbuilder service and R-hub support the new 
> toolchain, there is also support/example for using github actions. The 
> builds of R-devel and CRAN (and recommended binary packages) with the 
> new toolchain are available regularly since March.
> 
> I've created patches for CRAN (and required Bioconductor packages) which 
> are installed automatically at package installation time by R. This 
> feature will be also in R-devel after the switch and will be used 
> temporarily to give package authors more time to fix their packages. Uwe 
> Ligges, other CRAN team members and I have also been in touch with some 
> package authors, providing advice how to fix their packages, when the 
> issues required more explanation. I am prepared to help the remaining 
> authors as well if needed.
> 
> Please see the blog post and materials linked from there for more 
> details and feel free to ask questions.
> 
> Thanks
> Tomas
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From t|m@t@y|or @end|ng |rom h|ddene|eph@nt@@co@uk  Wed Dec  8 15:44:00 2021
From: t|m@t@y|or @end|ng |rom h|ddene|eph@nt@@co@uk (Tim Taylor)
Date: Wed, 8 Dec 2021 14:44:00 +0000
Subject: [Rd] R/CRAN switch to UCRT on Windows
In-Reply-To: <4f14e5b0-c969-f97c-56a3-129cd05e5e3e@statistik.tu-dortmund.de>
References: <332260b1-0dad-2808-97dd-150aa7687dd3@gmail.com>
 <4f14e5b0-c969-f97c-56a3-129cd05e5e3e@statistik.tu-dortmund.de>
Message-ID: <LO2P265MB2605E88A271188B9D5CCFA0BDD6F9@LO2P265MB2605.GBRP265.PROD.OUTLOOK.COM>

Hear, hear! Also thank you Uwe and the rest of the CRAN team for all the work you put in. It is much appreciated!

________________________________________
From: R-devel <r-devel-bounces at r-project.org> on behalf of Uwe Ligges <ligges at statistik.tu-dortmund.de>
Sent: 08 December 2021 14:24
To: Tomas Kalibera; r-devel
Subject: Re: [Rd] R/CRAN switch to UCRT on Windows

Thank you, Tomas, for your hard work on the new toolchain, its
documentation, and all your efforts in providing patches for R and for
several contributed packages.

Best,
Uwe



On 08.12.2021 14:56, Tomas Kalibera wrote:
> Please note an update concerning the support of UTF-8 as native encoding
> on Windows, which may at this point be of interest particularly to
> developers of packages with native code and to R users using R-devel
> (the development version of R) on Windows:
>
> https://developer.r-project.org/Blog/public/2021/12/07/upcoming-changes-in-r-4.2-on-windows/
>
>
> The key part is that CRAN will switch the incoming checks of R packages
> on Windows to a new toolchain targeting UCRT on Monday, December 13.
>
> It may take up to several days for all systems to synchronize and during
> this time, it may be difficult to build R-devel on Windows from source
> or to install packages.  After the switch, the snapshot R-devel builds
> and binary package builds provided by CRAN will be built using the new
> toolchain for UCRT. These new builds will use UTF-8 as the native
> encoding on recent Windows.
>
> These builds will be incompatible with the previous builds for MSVCRT
> and installed/binary packages will be incompatible as well. The
> recommended/simplest course of action for R-devel users is to uninstall
> the old build of R-devel, RTools, delete the old package libraries, and
> then install the new versions.
>
> Checks of CRAN packages with the new toolchain have been running since
> March with results available on CRAN pages. By now, most packages are
> working, but some packages using native (C, C++, Fortran) code still
> have to be updated. The Winbuilder service and R-hub support the new
> toolchain, there is also support/example for using github actions. The
> builds of R-devel and CRAN (and recommended binary packages) with the
> new toolchain are available regularly since March.
>
> I've created patches for CRAN (and required Bioconductor packages) which
> are installed automatically at package installation time by R. This
> feature will be also in R-devel after the switch and will be used
> temporarily to give package authors more time to fix their packages. Uwe
> Ligges, other CRAN team members and I have also been in touch with some
> package authors, providing advice how to fix their packages, when the
> issues required more explanation. I am prepared to help the remaining
> authors as well if needed.
>
> Please see the blog post and materials linked from there for more
> details and feel free to ask questions.
>
> Thanks
> Tomas
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From m@tth|@@-gond@n @end|ng |rom gmx@de  Wed Dec  8 19:37:09 2021
From: m@tth|@@-gond@n @end|ng |rom gmx@de (Matthias Gondan)
Date: Wed, 8 Dec 2021 19:37:09 +0100
Subject: [Rd] plogis (and other p* functions), vectorized lower.tail
Message-ID: <1MCKBm-1mmk5c180A-009QA7@mail.gmx.net>

Dear R developers,

I have seen that plogis silently ignores vector elements of lower.tail,

> plogis(q=0.5, location=1, lower.tail=TRUE) 
[1] 0.3775407
> plogis(q=0.5, location=1, lower.tail=FALSE) 
[1] 0.6224593
> plogis(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE)) 
[1] 0.3775407 0.3775407

For those familiar with psychological measurement: A use case of the above function is the so-called Rasch model, where the probability that a person with some specific ability (q) makes a correct (lower.tail=TRUE) or wrong response (lower.tail=FALSE) to an item with a specific difficulty (location). A vectorized version of plogis would enable to determine the likelihood of an entire response vector in a single call. My current workaround is an intermediate call to ?Vectorize?.

I am wondering if the logical argument of lower.tail can be vectorized (?). I see that this may be a substantial change in many places (basically, all p and q functions of probability distributions), but in my understanding, it would not break existing code which assumes lower.tail to be a single element. If that?s not
possible/feasible, I suggest to issue a warning if a vector of length > 1 is given in lower.tail. I am aware that the documentation clearly states that lower.tail is a single boolean.

Thank you for your consideration.

With best wishes,

Matthias



	[[alternative HTML version deleted]]


From therne@u @end|ng |rom m@yo@edu  Thu Dec  9 15:30:28 2021
From: therne@u @end|ng |rom m@yo@edu (Therneau, Terry M., Ph.D.)
Date: Thu, 09 Dec 2021 08:30:28 -0600
Subject: [Rd] Question about the UCRT switch
Message-ID: <f03410$h3f44e@ironport10.mayo.edu>

The connected blog has the statement? "Most authors will not have to do anything as the 
number of CRAN packages that will need some attention is below 1%, but authors of packages 
using native (C, C++ or Fortran) code should read the following lines."

My packages do use a lot of C, but I never use Windows.?? My reading of "the following 
lines" is that? I don't have to do anything.?? Is this correct?

Terry T.


-- 
Terry M Therneau, PhD
Department of Quantitative Health Sciences
Mayo Clinic
therneau at mayo.edu

"TERR-ree THUR-noh"


	[[alternative HTML version deleted]]


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Thu Dec  9 16:03:31 2021
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Thu, 9 Dec 2021 16:03:31 +0100
Subject: [Rd] plogis (and other p* functions), vectorized lower.tail
In-Reply-To: <1MCKBm-1mmk5c180A-009QA7@mail.gmx.net>
References: <1MCKBm-1mmk5c180A-009QA7@mail.gmx.net>
Message-ID: <25010.6851.980357.14339@stat.math.ethz.ch>

>>>>> Matthias Gondan 
>>>>>     on Wed, 8 Dec 2021 19:37:09 +0100 writes:

    > Dear R developers,
    > I have seen that plogis silently ignores vector elements of lower.tail,

and also of 'log'.
This is indeed the case for all d*, p*, q* functions.

Yes, this has been on purpose and therefore documented, in the
case of plogis, e.g. in the 'Value' section of ?plogis :

     The length of the result is determined by ?n? for ?rlogis?, and is
     the maximum of the lengths of the numerical arguments for the
     other functions.

 (note: *numerical* arguments: the logical ones are not recycled)

     The numerical arguments other than ?n? are recycled to the length
     of the result.  Only the first elements of the logical arguments
     are used.

 (above, we even explicitly mention the logical arguments ..)


Recycling happens for the first argument (x,p,q) of these
functions and for "parameters" of the distribution, but not for
lower.tail, log.p (or 'log').


    >> plogis(q=0.5, location=1, lower.tail=TRUE) 
    > [1] 0.3775407
    >> plogis(q=0.5, location=1, lower.tail=FALSE) 
    > [1] 0.6224593
    >> plogis(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE)) 
    > [1] 0.3775407 0.3775407

    > For those familiar with psychological measurement: A use case of the above function is the so-called Rasch model, where the probability that a person with some specific ability (q) makes a correct (lower.tail=TRUE) or wrong response (lower.tail=FALSE) to an item with a specific difficulty (location). A vectorized version of plogis would enable to determine the likelihood of an entire response vector in a single call. My current workaround is an intermediate call to ?Vectorize?.

    > I am wondering if the logical argument of lower.tail can be vectorized (?). I see that this may be a substantial change in many places (basically, all p and q functions of probability distributions), but in my understanding, it would not break existing code which assumes lower.tail to be a single element. If that?s not
    > possible/feasible, I suggest to issue a warning if a vector of length > 1 is given in lower.tail. I am aware that the documentation clearly states that lower.tail is a single boolean.

aah ok, here you say you know that the current behavior is documented.

    > Thank you for your consideration.


As you mention, changing this would be quite a large endeavor.
I had thought about doing that many years ago, not remembering
details, but seeing that in almost all situations you really
only need one of the two tails  (for Gaussian- or t- based confidence
intervals you also only need one, for symmetry reason).

Allowing the recycling there would make the intermediate C code
(which does the recycling) larger and probably slightly
slower because of conceptually two more for loops which would in
99.9% only have one case ..

I'd have found that ugly to add. ... ...
... but of course, if you can prove that the code bloat would not be large
and not deteriorate speed in a measurable way and if you'd find
someone to produce a comprehensive and tested patch ...

Martin


    > With best wishes,
    > Matthias



    > [[alternative HTML version deleted]]

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Thu Dec  9 16:12:24 2021
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Thu, 9 Dec 2021 16:12:24 +0100
Subject: [Rd] Question about the UCRT switch
In-Reply-To: <f03410$h3f44e@ironport10.mayo.edu>
References: <f03410$h3f44e@ironport10.mayo.edu>
Message-ID: <80aae714-0ec5-90f9-5c5a-14b929bb1a92@gmail.com>


On 12/9/21 3:30 PM, Therneau, Terry M., Ph.D. via R-devel wrote:
> The connected blog has the statement? "Most authors will not have to do anything as the
> number of CRAN packages that will need some attention is below 1%, but authors of packages
> using native (C, C++ or Fortran) code should read the following lines."
>
> My packages do use a lot of C, but I never use Windows.?? My reading of "the following
> lines" is that? I don't have to do anything.?? Is this correct?

Well but your users might be using Windows, so as long as your package 
is on CRAN and you are maintaining it to support Windows, the blog might 
have useful information for you - for instance how to check whether you 
need to update your packages or not, but see below.

Specifically for your case, CRAN packages bdsmatrix, coxme, deming, 
noweb and survival are passing their checks with the new toolchain, as 
can be seen from the result pages such as

https://cran.r-project.org/web/checks/check_results_survival.html

They do not use any installation-time patches, as can be seen from

https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/r_packages/patches/CRAN/

So, you really don't have to do anything, as most package authors with 
native code who don't use Windows.

Best
Tomas

>
> Terry T.
>
>


From bbo|ker @end|ng |rom gm@||@com  Thu Dec  9 16:55:17 2021
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Thu, 9 Dec 2021 10:55:17 -0500
Subject: [Rd] plogis (and other p* functions), vectorized lower.tail
In-Reply-To: <25010.6851.980357.14339@stat.math.ethz.ch>
References: <1MCKBm-1mmk5c180A-009QA7@mail.gmx.net>
 <25010.6851.980357.14339@stat.math.ethz.ch>
Message-ID: <0bd8b088-40c6-f62d-a296-9b540c1c1e55@gmail.com>



On 12/9/21 10:03 AM, Martin Maechler wrote:
>>>>>> Matthias Gondan
>>>>>>      on Wed, 8 Dec 2021 19:37:09 +0100 writes:
> 
>      > Dear R developers,
>      > I have seen that plogis silently ignores vector elements of lower.tail,
> 
> and also of 'log'.
> This is indeed the case for all d*, p*, q* functions.
> 
> Yes, this has been on purpose and therefore documented, in the
> case of plogis, e.g. in the 'Value' section of ?plogis :
> 
>       The length of the result is determined by ?n? for ?rlogis?, and is
>       the maximum of the lengths of the numerical arguments for the
>       other functions.
> 
>   (note: *numerical* arguments: the logical ones are not recycled)
> 
>       The numerical arguments other than ?n? are recycled to the length
>       of the result.  Only the first elements of the logical arguments
>       are used.
> 
>   (above, we even explicitly mention the logical arguments ..)
> 
> 
> Recycling happens for the first argument (x,p,q) of these
> functions and for "parameters" of the distribution, but not for
> lower.tail, log.p (or 'log').
> 
> 
>      >> plogis(q=0.5, location=1, lower.tail=TRUE)
>      > [1] 0.3775407
>      >> plogis(q=0.5, location=1, lower.tail=FALSE)
>      > [1] 0.6224593
>      >> plogis(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
>      > [1] 0.3775407 0.3775407
> 
>      > For those familiar with psychological measurement: A use case of the above function is the so-called Rasch model, where the probability that a person with some specific ability (q) makes a correct (lower.tail=TRUE) or wrong response (lower.tail=FALSE) to an item with a specific difficulty (location). A vectorized version of plogis would enable to determine the likelihood of an entire response vector in a single call. My current workaround is an intermediate call to ?Vectorize?.
> 
>      > I am wondering if the logical argument of lower.tail can be vectorized (?). I see that this may be a substantial change in many places (basically, all p and q functions of probability distributions), but in my understanding, it would not break existing code which assumes lower.tail to be a single element. If that?s not
>      > possible/feasible, I suggest to issue a warning if a vector of length > 1 is given in lower.tail. I am aware that the documentation clearly states that lower.tail is a single boolean.
> 
> aah ok, here you say you know that the current behavior is documented.
> 
>      > Thank you for your consideration.
> 
> 
> As you mention, changing this would be quite a large endeavor.
> I had thought about doing that many years ago, not remembering
> details, but seeing that in almost all situations you really
> only need one of the two tails  (for Gaussian- or t- based confidence
> intervals you also only need one, for symmetry reason).
> 
> Allowing the recycling there would make the intermediate C code
> (which does the recycling) larger and probably slightly
> slower because of conceptually two more for loops which would in
> 99.9% only have one case ..
> 
> I'd have found that ugly to add. ... ...
> ... but of course, if you can prove that the code bloat would not be large
> and not deteriorate speed in a measurable way and if you'd find
> someone to produce a comprehensive and tested patch ...
> 
> Martin
> 
> 
>      > With best wishes,
>      > Matthias
> 
> 
> 
>      > [[alternative HTML version deleted]]
> 
>      > ______________________________________________
>      > R-devel at r-project.org mailing list
>      > https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 

   I agree with everything said above, but think that adding a warning 
when length(lower.tail) > 1 (rather than silently ignoring) might be 
helpful ...  ??

   As for the vectorization, it seems almost trivial to do at the user 
level when needed (albeit it's probably a little bit inefficient):

pv <- Vectorize(plogis, c("q", "location", "scale", "lower.tail"))
pv(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
[1] 0.3775407 0.6224593


From @oko| @end|ng |rom |n@@-tou|ou@e@|r  Thu Dec  9 17:13:36 2021
From: @oko| @end|ng |rom |n@@-tou|ou@e@|r (Sokol Serguei)
Date: Thu, 9 Dec 2021 17:13:36 +0100
Subject: [Rd] plogis (and other p* functions), vectorized lower.tail
In-Reply-To: <0bd8b088-40c6-f62d-a296-9b540c1c1e55@gmail.com>
References: <1MCKBm-1mmk5c180A-009QA7@mail.gmx.net>
 <25010.6851.980357.14339@stat.math.ethz.ch>
 <0bd8b088-40c6-f62d-a296-9b540c1c1e55@gmail.com>
Message-ID: <a8c1428c-e7a5-d5c9-a437-efe448aef2ae@insa-toulouse.fr>

On 09/12/2021 16:55, Ben Bolker wrote:
>
>
> On 12/9/21 10:03 AM, Martin Maechler wrote:
>>>>>>> Matthias Gondan
>>>>>>> ???? on Wed, 8 Dec 2021 19:37:09 +0100 writes:
>>
>> ???? > Dear R developers,
>> ???? > I have seen that plogis silently ignores vector elements of 
>> lower.tail,
>>
>> and also of 'log'.
>> This is indeed the case for all d*, p*, q* functions.
>>
>> Yes, this has been on purpose and therefore documented, in the
>> case of plogis, e.g. in the 'Value' section of ?plogis :
>>
>> ????? The length of the result is determined by ?n? for ?rlogis?, and is
>> ????? the maximum of the lengths of the numerical arguments for the
>> ????? other functions.
>>
>> ? (note: *numerical* arguments: the logical ones are not recycled)
>>
>> ????? The numerical arguments other than ?n? are recycled to the length
>> ????? of the result.? Only the first elements of the logical arguments
>> ????? are used.
>>
>> ? (above, we even explicitly mention the logical arguments ..)
>>
>>
>> Recycling happens for the first argument (x,p,q) of these
>> functions and for "parameters" of the distribution, but not for
>> lower.tail, log.p (or 'log').
>>
>>
>> ???? >> plogis(q=0.5, location=1, lower.tail=TRUE)
>> ???? > [1] 0.3775407
>> ???? >> plogis(q=0.5, location=1, lower.tail=FALSE)
>> ???? > [1] 0.6224593
>> ???? >> plogis(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
>> ???? > [1] 0.3775407 0.3775407
>>
>> ???? > For those familiar with psychological measurement: A use case 
>> of the above function is the so-called Rasch model, where the 
>> probability that a person with some specific ability (q) makes a 
>> correct (lower.tail=TRUE) or wrong response (lower.tail=FALSE) to an 
>> item with a specific difficulty (location). A vectorized version of 
>> plogis would enable to determine the likelihood of an entire response 
>> vector in a single call. My current workaround is an intermediate 
>> call to ?Vectorize?.
>>
>> ???? > I am wondering if the logical argument of lower.tail can be 
>> vectorized (?). I see that this may be a substantial change in many 
>> places (basically, all p and q functions of probability 
>> distributions), but in my understanding, it would not break existing 
>> code which assumes lower.tail to be a single element. If that?s not
>> ???? > possible/feasible, I suggest to issue a warning if a vector of 
>> length > 1 is given in lower.tail. I am aware that the documentation 
>> clearly states that lower.tail is a single boolean.
>>
>> aah ok, here you say you know that the current behavior is documented.
>>
>> ???? > Thank you for your consideration.
>>
>>
>> As you mention, changing this would be quite a large endeavor.
>> I had thought about doing that many years ago, not remembering
>> details, but seeing that in almost all situations you really
>> only need one of the two tails? (for Gaussian- or t- based confidence
>> intervals you also only need one, for symmetry reason).
>>
>> Allowing the recycling there would make the intermediate C code
>> (which does the recycling) larger and probably slightly
>> slower because of conceptually two more for loops which would in
>> 99.9% only have one case ..
>>
>> I'd have found that ugly to add. ... ...
>> ... but of course, if you can prove that the code bloat would not be 
>> large
>> and not deteriorate speed in a measurable way and if you'd find
>> someone to produce a comprehensive and tested patch ...
>>
>> Martin
>>
>>
>> ???? > With best wishes,
>> ???? > Matthias
>>
>>
>>
>> ???? > [[alternative HTML version deleted]]
>>
>> ???? > ______________________________________________
>> ???? > R-devel at r-project.org mailing list
>> ???? > https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>
> ? I agree with everything said above, but think that adding a warning 
> when length(lower.tail) > 1 (rather than silently ignoring) might be 
> helpful ...? ??
>
> ? As for the vectorization, it seems almost trivial to do at the user 
> level when needed (albeit it's probably a little bit inefficient):
>
> pv <- Vectorize(plogis, c("q", "location", "scale", "lower.tail"))
> pv(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
> [1] 0.3775407 0.6224593

.. or directly use mapply()

mapply(plogis, q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
[1] 0.3775407 0.6224593


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Thu Dec  9 17:35:33 2021
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Thu, 9 Dec 2021 17:35:33 +0100
Subject: [Rd] plogis (and other p* functions), vectorized lower.tail
In-Reply-To: <a8c1428c-e7a5-d5c9-a437-efe448aef2ae@insa-toulouse.fr>
References: <1MCKBm-1mmk5c180A-009QA7@mail.gmx.net>
 <25010.6851.980357.14339@stat.math.ethz.ch>
 <0bd8b088-40c6-f62d-a296-9b540c1c1e55@gmail.com>
 <a8c1428c-e7a5-d5c9-a437-efe448aef2ae@insa-toulouse.fr>
Message-ID: <25010.12373.335441.351617@stat.math.ethz.ch>

>>>>> Sokol Serguei on Thu, 9 Dec 2021 17:13:36 +0100 writes:

    > On 09/12/2021 16:55, Ben Bolker wrote:
    >> 
    >> 
    >> On 12/9/21 10:03 AM, Martin Maechler wrote:
    >>>>>>>> Matthias Gondan
    >>>>>>>> ???? on Wed, 8 Dec 2021 19:37:09 +0100 writes:
    >>> 
    >>> ???? > Dear R developers,
    >>> ???? > I have seen that plogis silently ignores vector elements of 
    >>> lower.tail,
    >>> 
    >>> and also of 'log'.
    >>> This is indeed the case for all d*, p*, q* functions.
    >>> 
    >>> Yes, this has been on purpose and therefore documented, in the
    >>> case of plogis, e.g. in the 'Value' section of ?plogis :
    >>> 
    >>> ????? The length of the result is determined by ?n? for ?rlogis?, and is
    >>> ????? the maximum of the lengths of the numerical arguments for the
    >>> ????? other functions.
    >>> 
    >>> ? (note: *numerical* arguments: the logical ones are not recycled)
    >>> 
    >>> ????? The numerical arguments other than ?n? are recycled to the length
    >>> ????? of the result.? Only the first elements of the logical arguments
    >>> ????? are used.
    >>> 
    >>> ? (above, we even explicitly mention the logical arguments ..)
    >>> 
    >>> 
    >>> Recycling happens for the first argument (x,p,q) of these
    >>> functions and for "parameters" of the distribution, but not for
    >>> lower.tail, log.p (or 'log').
    >>> 
    >>> 
    >>> ???? >> plogis(q=0.5, location=1, lower.tail=TRUE)
    >>> ???? > [1] 0.3775407
    >>> ???? >> plogis(q=0.5, location=1, lower.tail=FALSE)
    >>> ???? > [1] 0.6224593
    >>> ???? >> plogis(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
    >>> ???? > [1] 0.3775407 0.3775407
    >>> 
    >>> ???? > For those familiar with psychological measurement: A use case 
    >>> of the above function is the so-called Rasch model, where the 
    >>> probability that a person with some specific ability (q) makes a 
    >>> correct (lower.tail=TRUE) or wrong response (lower.tail=FALSE) to an 
    >>> item with a specific difficulty (location). A vectorized version of 
    >>> plogis would enable to determine the likelihood of an entire response 
    >>> vector in a single call. My current workaround is an intermediate 
    >>> call to ?Vectorize?.
    >>> 
    >>> ???? > I am wondering if the logical argument of lower.tail can be 
    >>> vectorized (?). I see that this may be a substantial change in many 
    >>> places (basically, all p and q functions of probability 
    >>> distributions), but in my understanding, it would not break existing 
    >>> code which assumes lower.tail to be a single element. If that?s not
    >>> ???? > possible/feasible, I suggest to issue a warning if a vector of 
    >>> length > 1 is given in lower.tail. I am aware that the documentation 
    >>> clearly states that lower.tail is a single boolean.
    >>> 
    >>> aah ok, here you say you know that the current behavior is documented.
    >>> 
    >>> ???? > Thank you for your consideration.
    >>> 
    >>> 
    >>> As you mention, changing this would be quite a large endeavor.
    >>> I had thought about doing that many years ago, not remembering
    >>> details, but seeing that in almost all situations you really
    >>> only need one of the two tails? (for Gaussian- or t- based confidence
    >>> intervals you also only need one, for symmetry reason).
    >>> 
    >>> Allowing the recycling there would make the intermediate C code
    >>> (which does the recycling) larger and probably slightly
    >>> slower because of conceptually two more for loops which would in
    >>> 99.9% only have one case ..
    >>> 
    >>> I'd have found that ugly to add. ... ...
    >>> ... but of course, if you can prove that the code bloat would not be 
    >>> large
    >>> and not deteriorate speed in a measurable way and if you'd find
    >>> someone to produce a comprehensive and tested patch ...
    >>> 
    >>> Martin
    >>> 
    >>> 
    >>> ???? > With best wishes,
    >>> ???? > Matthias
    >>> 
    >>> 
    >>> 
    >>> ???? > [[alternative HTML version deleted]]
    >>> 
    >>> ???? > ______________________________________________
    >>> ???? > R-devel at r-project.org mailing list
    >>> ???? > https://stat.ethz.ch/mailman/listinfo/r-devel
    >>> 
    >>> ______________________________________________
    >>> R-devel at r-project.org mailing list
    >>> https://stat.ethz.ch/mailman/listinfo/r-devel
    >>> 
    >> 
    >> ? I agree with everything said above, but think that adding a warning 
    >> when length(lower.tail) > 1 (rather than silently ignoring) might be 
    >> helpful ...? ??
    >> 
    >> ? As for the vectorization, it seems almost trivial to do at the user 
    >> level when needed (albeit it's probably a little bit inefficient):
    >> 
    >> pv <- Vectorize(plogis, c("q", "location", "scale", "lower.tail"))
    >> pv(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
    >> [1] 0.3775407 0.6224593

    > .. or directly use mapply()

    > mapply(plogis, q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
    > [1] 0.3775407 0.6224593

Very nice, yes.  Also, there's no need to recycle/vectorize yourself:
 q=0.5  is sufficient:

 > mapply(plogis, q=0.5, location=1, lower.tail=c(TRUE, FALSE))
 [1] 0.3775407 0.6224593


Martin


From m@tth|@@-gond@n @end|ng |rom gmx@de  Thu Dec  9 20:12:32 2021
From: m@tth|@@-gond@n @end|ng |rom gmx@de (Matthias Gondan)
Date: Thu, 9 Dec 2021 20:12:32 +0100
Subject: [Rd] plogis (and other p* functions), vectorized lower.tail
In-Reply-To: <25010.6851.980357.14339@stat.math.ethz.ch>
References: <1MCKBm-1mmk5c180A-009QA7@mail.gmx.net>
 <25010.6851.980357.14339@stat.math.ethz.ch>
Message-ID: <1N63Vi-1mStfH2pse-016PUK@mail.gmx.net>

Ok, I see. It?s a nontrivial change, since the present setup (DEFMATH3_2 & friends) only allows the real-valued function arguments to be vectorized. If this is to be changed, all these macros would need to be rewritten. Case closed.

Best wishes,

Matthias

Von: Martin Maechler
Gesendet: Donnerstag, 9. Dezember 2021 16:03
An: Matthias Gondan
Cc: r-devel at r-project.org
Betreff: Re: [Rd] plogis (and other p* functions), vectorized lower.tail

>>>>> Matthias Gondan 
>>>>>     on Wed, 8 Dec 2021 19:37:09 +0100 writes:

    > Dear R developers,
    > I have seen that plogis silently ignores vector elements of lower.tail,

and also of 'log'.
This is indeed the case for all d*, p*, q* functions.

Yes, this has been on purpose and therefore documented, in the
case of plogis, e.g. in the 'Value' section of ?plogis :

     The length of the result is determined by ?n? for ?rlogis?, and is
     the maximum of the lengths of the numerical arguments for the
     other functions.

 (note: *numerical* arguments: the logical ones are not recycled)

     The numerical arguments other than ?n? are recycled to the length
     of the result.  Only the first elements of the logical arguments
     are used.

 (above, we even explicitly mention the logical arguments ..)


Recycling happens for the first argument (x,p,q) of these
functions and for "parameters" of the distribution, but not for
lower.tail, log.p (or 'log').


    >> plogis(q=0.5, location=1, lower.tail=TRUE) 
    > [1] 0.3775407
    >> plogis(q=0.5, location=1, lower.tail=FALSE) 
    > [1] 0.6224593
    >> plogis(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE)) 
    > [1] 0.3775407 0.3775407

    > For those familiar with psychological measurement: A use case of the above function is the so-called Rasch model, where the probability that a person with some specific ability (q) makes a correct (lower.tail=TRUE) or wrong response (lower.tail=FALSE) to an item with a specific difficulty (location). A vectorized version of plogis would enable to determine the likelihood of an entire response vector in a single call. My current workaround is an intermediate call to ?Vectorize?.

    > I am wondering if the logical argument of lower.tail can be vectorized (?). I see that this may be a substantial change in many places (basically, all p and q functions of probability distributions), but in my understanding, it would not break existing code which assumes lower.tail to be a single element. If that?s not
    > possible/feasible, I suggest to issue a warning if a vector of length > 1 is given in lower.tail. I am aware that the documentation clearly states that lower.tail is a single boolean.

aah ok, here you say you know that the current behavior is documented.

    > Thank you for your consideration.


As you mention, changing this would be quite a large endeavor.
I had thought about doing that many years ago, not remembering
details, but seeing that in almost all situations you really
only need one of the two tails  (for Gaussian- or t- based confidence
intervals you also only need one, for symmetry reason).

Allowing the recycling there would make the intermediate C code
(which does the recycling) larger and probably slightly
slower because of conceptually two more for loops which would in
99.9% only have one case ..

I'd have found that ugly to add. ... ...
... but of course, if you can prove that the code bloat would not be large
and not deteriorate speed in a measurable way and if you'd find
someone to produce a comprehensive and tested patch ...

Martin


    > With best wishes,
    > Matthias



    > [[alternative HTML version deleted]]

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


	[[alternative HTML version deleted]]


From gr@ntmcd @end|ng |rom uoregon@edu  Fri Dec 10 19:57:12 2021
From: gr@ntmcd @end|ng |rom uoregon@edu (Grant McDermott)
Date: Fri, 10 Dec 2021 18:57:12 +0000
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
References: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
Message-ID: <MWHPR1001MB2384713F140C2375DFF83998CF719@MWHPR1001MB2384.namprd10.prod.outlook.com>

Sorry I haven't had a chance to reply to anyone. I feel like I dropped a grenade in a room and promptly bolted...

Just to say, then, that I really appreciate everyone's comments and suggestions. While I'm tempted to push back on some points, I don't think it's worth on balance, or will add much beyond what's already been said.

It's interesting to see that there appears to be at least some appetite for additional (f)string operators in base R... notwithstanding the valid objections and the difficulties raised in this thread.

Cheers,
Grant

Get Outlook for Android<https://aka.ms/AAb9ysg>
________________________________
From: Grant McDermott
Sent: Saturday, December 4, 2021 12:36:44 PM
To: r-devel at r-project.org <r-devel at r-project.org>
Subject: string concatenation operator (revisited)

Hi all,

I wonder if the R Core team might reconsider an old feature request, as detailed in this 2005 thread: https://stat.ethz.ch/pipermail/r-help/2005-February/thread.html#66698

The TL;DR version is base R support for a `+.character` method. This would essentially provide a shortcut to `paste?0`, in much the same way that `\(x)` now provides a shortcut to `function(x)`.

> a = "hello "; b = "world"
> a + b
> [1] "hello world"

I appreciate some of the original concerns raised against a native "string1 + string2" implementation. The above thread also provides several use-at-your-own-risk workarounds. But sixteen years is a long time in software development and R now stands as something of an exception on this score. Python, Julia, Stata, and SQL (among various others) all support native string concatenation/interpolation using binary/arithmetic operators. It's been a surprising source of frustration for students in some of the classes I teach, particularly those coming from another language.

Many thanks for considering.

PS. I hope I didn't miss any additional discussion of this issue beyond the original 2005 thread. My search efforts didn't turn anything else up, except this popular Stackoverflow question: https://stackoverflow.com/questions/4730551/making-a-string-concatenation-operator-in-r

Grant McDermott
Assistant Professor
Department of Economics
University of Oregon
www.grantmcdermott.com


	[[alternative HTML version deleted]]


From bob @end|ng |rom rud@|@  Sun Dec 12 15:33:06 2021
From: bob @end|ng |rom rud@|@ (Bob Rudis)
Date: Sun, 12 Dec 2021 09:33:06 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <MWHPR1001MB2384713F140C2375DFF83998CF719@MWHPR1001MB2384.namprd10.prod.outlook.com>
References: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
 <MWHPR1001MB2384713F140C2375DFF83998CF719@MWHPR1001MB2384.namprd10.prod.outlook.com>
Message-ID: <CAA-FpKXkHXb1YYNbwmOr3P8zdiC==DBOR75sv92DVfkvr=NX9g@mail.gmail.com>

FWIW {stringi} has %+% for this functionality (and I occasionally use
it), tho I do enough processing of quite ughly string content that I
pretty much always have {stringi} loaded. That may not be true for
many other folks.

On Fri, Dec 10, 2021 at 2:07 PM Grant McDermott <grantmcd at uoregon.edu> wrote:
>
> Sorry I haven't had a chance to reply to anyone. I feel like I dropped a grenade in a room and promptly bolted...
>
> Just to say, then, that I really appreciate everyone's comments and suggestions. While I'm tempted to push back on some points, I don't think it's worth on balance, or will add much beyond what's already been said.
>
> It's interesting to see that there appears to be at least some appetite for additional (f)string operators in base R... notwithstanding the valid objections and the difficulties raised in this thread.
>
> Cheers,
> Grant
>
> Get Outlook for Android<https://aka.ms/AAb9ysg>
> ________________________________
> From: Grant McDermott
> Sent: Saturday, December 4, 2021 12:36:44 PM
> To: r-devel at r-project.org <r-devel at r-project.org>
> Subject: string concatenation operator (revisited)
>
> Hi all,
>
> I wonder if the R Core team might reconsider an old feature request, as detailed in this 2005 thread: https://stat.ethz.ch/pipermail/r-help/2005-February/thread.html#66698
>
> The TL;DR version is base R support for a `+.character` method. This would essentially provide a shortcut to `paste0`, in much the same way that `\(x)` now provides a shortcut to `function(x)`.
>
> > a = "hello "; b = "world"
> > a + b
> > [1] "hello world"
>
> I appreciate some of the original concerns raised against a native "string1 + string2" implementation. The above thread also provides several use-at-your-own-risk workarounds. But sixteen years is a long time in software development and R now stands as something of an exception on this score. Python, Julia, Stata, and SQL (among various others) all support native string concatenation/interpolation using binary/arithmetic operators. It's been a surprising source of frustration for students in some of the classes I teach, particularly those coming from another language.
>
> Many thanks for considering.
>
> PS. I hope I didn't miss any additional discussion of this issue beyond the original 2005 thread. My search efforts didn't turn anything else up, except this popular Stackoverflow question: https://stackoverflow.com/questions/4730551/making-a-string-concatenation-operator-in-r
>
> Grant McDermott
> Assistant Professor
> Department of Economics
> University of Oregon
> www.grantmcdermott.com
>
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From j@jh@|| @end|ng |rom ed@@c@uk  Sun Dec 12 16:42:42 2021
From: j@jh@|| @end|ng |rom ed@@c@uk (Julian Hall)
Date: Sun, 12 Dec 2021 15:42:42 +0000
Subject: [Rd] Improved LP/MIP solver
Message-ID: <398833eb-b071-f2d0-5813-7f49fe48cb42@ed.ac.uk>

Dear All,

I am leading the development of HiGHS, which is now the top performing open source linear optimization software on the industry standard benchmarks. In particular, our MIP solver out-performs SCIP, and is way ahead of the COIN-OR solver Cbc.

HiGHS solves LPs via simplex or interior point, MIPs via branch-and-cut, and QPs via an active set method.

We were wondering what interest there would be in developing an R interface to HiGHS. I'm not an R user, but have done a bit of searching and see references to Rsymphony and an interface to Lpsolve.

Performance-wise Lpsolve is very poor, but I know that it has a community of devoted followers. I've not seen benchmark results for Symphony, but I know that Cbc is the preferred COIN-OR MIP solver when it comes to general performance.  And, as I observed, the performance of HiGHS is way better than Cbc.

Are people in the R community tearing their hair out over the performance of software requiring the solution of LPs or MIPs?

Would a significantly better LP/MIP solver be valuable to the R community?

Thanks,

Julian
--
Dr. J. A. Julian Hall, Reader, School of Mathematics,
University of Edinburgh, James Clerk Maxwell Building,
Peter Guthrie Tait Road, EDINBURGH, EH9 3FD, UK.
Room: 5418 Phone: [+44](131) 650 5075 Email: J.A.J.Hall at ed.ac.uk<mailto:J.A.J.Hall at ed.ac.uk>
Web: https://www.maths.ed.ac.uk/school-of-mathematics/people/a-z?person=47
[HiGHS]<http://www.highs.dev>

My working hours may not be your working hours. Do not feel pressure to reply to this email outside your working hours.
The University of Edinburgh is a charitable body, registered in Scotland, with registration number SC005336. Is e buidheann carthannais a th? ann an Oilthigh Dh?n ?ideann, cl?raichte an Alba, ?ireamh cl?raidh SC005336.

	[[alternative HTML version deleted]]


From @vr@h@m@@d|er @end|ng |rom gm@||@com  Sun Dec 12 17:24:42 2021
From: @vr@h@m@@d|er @end|ng |rom gm@||@com (Avraham Adler)
Date: Sun, 12 Dec 2021 16:24:42 +0000
Subject: [Rd] Improved LP/MIP solver
In-Reply-To: <398833eb-b071-f2d0-5813-7f49fe48cb42@ed.ac.uk>
References: <398833eb-b071-f2d0-5813-7f49fe48cb42@ed.ac.uk>
Message-ID: <CAL6gwn+1eM7jSJFwif7b66cCTe=64r4U7fvxXnQuigfnLOqo3g@mail.gmail.com>

On Sun, Dec 12, 2021 at 3:44 PM Julian Hall <jajhall at ed.ac.uk> wrote:
>
> Dear All,
>
> I am leading the development of HiGHS, which is now the top performing open source linear optimization software on the industry standard benchmarks. In particular, our MIP solver out-performs SCIP, and is way ahead of the COIN-OR solver Cbc.
>
> HiGHS solves LPs via simplex or interior point, MIPs via branch-and-cut, and QPs via an active set method.
>
> We were wondering what interest there would be in developing an R interface to HiGHS. I'm not an R user, but have done a bit of searching and see references to Rsymphony and an interface to Lpsolve.
>
> Performance-wise Lpsolve is very poor, but I know that it has a community of devoted followers. I've not seen benchmark results for Symphony, but I know that Cbc is the preferred COIN-OR MIP solver when it comes to general performance.  And, as I observed, the performance of HiGHS is way better than Cbc.
>
> Are people in the R community tearing their hair out over the performance of software requiring the solution of LPs or MIPs?
>
> Would a significantly better LP/MIP solver be valuable to the R community?
>
> Thanks,
>
> Julian
> --
> Dr. J. A. Julian Hall, Reader, School of Mathematics,
> University of Edinburgh, James Clerk Maxwell Building,
> Peter Guthrie Tait Road, EDINBURGH, EH9 3FD, UK.
> Room: 5418 Phone: [+44](131) 650 5075 Email: J.A.J.Hall at ed.ac.uk<mailto:J.A.J.Hall at ed.ac.uk>
> Web: https://www.maths.ed.ac.uk/school-of-mathematics/people/a-z?person=47
> [HiGHS]<http://www.highs.dev>
>
> My working hours may not be your working hours. Do not feel pressure to reply to this email outside your working hours.
> The University of Edinburgh is a charitable body, registered in Scotland, with registration number SC005336. Is e buidheann carthannais a th? ann an Oilthigh Dh?n ?ideann, cl?raichte an Alba, ?ireamh cl?raidh SC005336.

Hello, Julian.

I cannot speak for the R community, but as someone who needs
optimization on a regular basis, this sounds intriguing. The fact that
HiGHS appears to be FLOSS, and thus usable as-is in the corporate
setting, appeals to those of us who use R in industry. Would you have
any statistics on how the solvers in HiGHS compare with similar ones
currently available in R, specifically the following in NLOPT [1]
(which is called through nloptr): SLSQP (gradient-based) and COBYLA
(gradient-free) both of which support equality and inequality
constraints, and MMA/CCSA (gradient based) which supports inequality
constraints? As for integer or mixed integer programming, I believe
that there is a lot of room for improvement in R. Personally, I've
resorted to using DEOptim with the "fnMap" entry calling a round
function similar to [2]. So speaking for myself, giving richer options
for optimization is a good thing, especially if the installation
procedure can be simplified!

Thank you,

Avi

[1] https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/
[2] https://stackoverflow.com/questions/42197353/how-to-set-integer-constraint-using-fnmap-in-deoptim-r


From @vr@h@m@@d|er @end|ng |rom gm@||@com  Sun Dec 12 17:27:02 2021
From: @vr@h@m@@d|er @end|ng |rom gm@||@com (Avraham Adler)
Date: Sun, 12 Dec 2021 16:27:02 +0000
Subject: [Rd] Improved LP/MIP solver
In-Reply-To: <CAL6gwn+1eM7jSJFwif7b66cCTe=64r4U7fvxXnQuigfnLOqo3g@mail.gmail.com>
References: <398833eb-b071-f2d0-5813-7f49fe48cb42@ed.ac.uk>
 <CAL6gwn+1eM7jSJFwif7b66cCTe=64r4U7fvxXnQuigfnLOqo3g@mail.gmail.com>
Message-ID: <CAL6gwnKQwnFj8UPBqiH4Uu71i5QiVgti+jSuyqG5KjOkmsws7g@mail.gmail.com>

On Sun, Dec 12, 2021 at 4:24 PM Avraham Adler <avraham.adler at gmail.com> wrote:
>
> On Sun, Dec 12, 2021 at 3:44 PM Julian Hall <jajhall at ed.ac.uk> wrote:
> >
> > Dear All,
> >
> > I am leading the development of HiGHS, which is now the top performing open source linear optimization software on the industry standard benchmarks. In particular, our MIP solver out-performs SCIP, and is way ahead of the COIN-OR solver Cbc.
> >
> > HiGHS solves LPs via simplex or interior point, MIPs via branch-and-cut, and QPs via an active set method.
> >
> > We were wondering what interest there would be in developing an R interface to HiGHS. I'm not an R user, but have done a bit of searching and see references to Rsymphony and an interface to Lpsolve.
> >
> > Performance-wise Lpsolve is very poor, but I know that it has a community of devoted followers. I've not seen benchmark results for Symphony, but I know that Cbc is the preferred COIN-OR MIP solver when it comes to general performance.  And, as I observed, the performance of HiGHS is way better than Cbc.
> >
> > Are people in the R community tearing their hair out over the performance of software requiring the solution of LPs or MIPs?
> >
> > Would a significantly better LP/MIP solver be valuable to the R community?
> >
> > Thanks,
> >
> > Julian
> > --
> > Dr. J. A. Julian Hall, Reader, School of Mathematics,
> > University of Edinburgh, James Clerk Maxwell Building,
> > Peter Guthrie Tait Road, EDINBURGH, EH9 3FD, UK.
> > Room: 5418 Phone: [+44](131) 650 5075 Email: J.A.J.Hall at ed.ac.uk<mailto:J.A.J.Hall at ed.ac.uk>
> > Web: https://www.maths.ed.ac.uk/school-of-mathematics/people/a-z?person=47
> > [HiGHS]<http://www.highs.dev>
> >
> > My working hours may not be your working hours. Do not feel pressure to reply to this email outside your working hours.
> > The University of Edinburgh is a charitable body, registered in Scotland, with registration number SC005336. Is e buidheann carthannais a th? ann an Oilthigh Dh?n ?ideann, cl?raichte an Alba, ?ireamh cl?raidh SC005336.
>
> Hello, Julian.
>
> I cannot speak for the R community, but as someone who needs
> optimization on a regular basis, this sounds intriguing. The fact that
> HiGHS appears to be FLOSS, and thus usable as-is in the corporate
> setting, appeals to those of us who use R in industry. Would you have
> any statistics on how the solvers in HiGHS compare with similar ones
> currently available in R, specifically the following in NLOPT [1]
> (which is called through nloptr): SLSQP (gradient-based) and COBYLA
> (gradient-free) both of which support equality and inequality
> constraints, and MMA/CCSA (gradient based) which supports inequality
> constraints? As for integer or mixed integer programming, I believe
> that there is a lot of room for improvement in R. Personally, I've
> resorted to using DEOptim with the "fnMap" entry calling a round
> function similar to [2]. So speaking for myself, giving richer options
> for optimization is a good thing, especially if the installation
> procedure can be simplified!
>
> Thank you,
>
> Avi
>
> [1] https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/
> [2] https://stackoverflow.com/questions/42197353/how-to-set-integer-constraint-using-fnmap-in-deoptim-r

Also, to be good R-citizens, this thread should probably be moved to
R-package-devel [1].

Thanks,

Avi

[1] https://stat.ethz.ch/mailman/listinfo/r-package-devel


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Mon Dec 13 13:02:14 2021
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Mon, 13 Dec 2021 13:02:14 +0100
Subject: [Rd] Feature request: Change default library path on Windows
In-Reply-To: <1973d4dc-b514-2993-5dbc-28668fcaa2ce@gmail.com>
References: <CAJhjiQmEP6Rw_jM8PEz4gD1VXWWW9E0p7Pw31dyk4TQsEPJRdw@mail.gmail.com>
 <CABFfbXvEQGejh069Ni7UZKub7UPA26QfvcH6waPcw+Z1jGSMMA@mail.gmail.com>
 <CAJhjiQmLUqHJW8PFGdqJU1T3cYX7bQQ7-6DRb34UZ_r7vKqBbw@mail.gmail.com>
 <b09f5373-4d0e-64d7-1d5e-91e948e12a28@gmail.com>
 <CAJhjiQnbggTG_7Hicp1PgbujhrJ5FW8mPRAgb7YhhpSPOx5syw@mail.gmail.com>
 <522686cd-645d-4a62-9dcf-5f701f3f9ab1@gmail.com>
 <CAJhjiQnBAucSkeQmONTz1oBDoO4eC=b_0WJVZ=bg89bqw0SYTw@mail.gmail.com>
 <c8e8bbda-35b4-c61f-46df-91708e1a88d8@gmail.com>
 <CAJhjiQk6H_Fb=fxKqRmZiZcX+Cb7vSiiDeJnSaJ1t8Fj_Bmyjw@mail.gmail.com>
 <1973d4dc-b514-2993-5dbc-28668fcaa2ce@gmail.com>
Message-ID: <d49767c9-11dc-5f50-49a8-c400a448afec@gmail.com>

The default was now changed in R-devel to the local application data 
(e.g. C:\Users\username\AppData\Local), which should solve the issues 
with synchronization/backup/etc services and seems to be more in line 
with conventions for the OS. It is a hidden folder, to open in Windows 
explorer one can use e.g. shell.exec() from R.

Best
Tomas

On 7/27/21 1:12 PM, Tomas Kalibera wrote:
> On 7/26/21 1:44 AM, Steve Haroz wrote:
>> Thanks Ben. I just sent a request for a bugzilla login.
>> Jeroen chimed in earlier in support.
>
> Please note this has been reported, discussed and considered already, 
> last time in PR#17842 (though proposing a different replacement for 
> the default).
>
> I think changing the default from user documents to something else 
> would make sense to consider together with some other breaking change 
> for users, not in isolation, if at all. While the change may help 
> users with a quota on the documents directory (e.g. shared on a cloud, 
> backup, etc), it will make it harder to find the library for others, 
> who would not notice the change to the documented behavior, and I 
> assume that would still be a much larger group.
>
> Of course it does not help that it is not clear what the correct 
> location should be now, and certainly there is little hope it won't 
> change again, soon. My understanding is that the choice was originally 
> correct when made, following the Microsoft guidelines.
>
> As discussed here as well, users may choose their own library path 
> (?.libPaths).
>
> The installation location for R itself can be changed e.g. via /DIR 
> option of the installer (see /?). This is useful e.g. when installing 
> R only for the current user (/CURRENTUSER) and it impacts also the 
> location of the library - it is then inside the given tree.
>
> Best
> Tomas
>
>
>
>>
>> Cheers,
>> Steve
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Mon Dec 13 16:59:15 2021
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Mon, 13 Dec 2021 16:59:15 +0100
Subject: [Rd] Appropriate mailing list for " Improved LP/MIP solver "
In-Reply-To: <CAL6gwnKQwnFj8UPBqiH4Uu71i5QiVgti+jSuyqG5KjOkmsws7g@mail.gmail.com>
References: <398833eb-b071-f2d0-5813-7f49fe48cb42@ed.ac.uk>
 <CAL6gwn+1eM7jSJFwif7b66cCTe=64r4U7fvxXnQuigfnLOqo3g@mail.gmail.com>
 <CAL6gwnKQwnFj8UPBqiH4Uu71i5QiVgti+jSuyqG5KjOkmsws7g@mail.gmail.com>
Message-ID: <25015.28115.450016.486300@stat.math.ethz.ch>

>>>>> Avraham Adler 
>>>>>     on Sun, 12 Dec 2021 16:27:02 +0000 writes:

 [........................]

Thank you, Julian and Avi,  on the topic of asking and replying
if there's interest on getting improved LP / MIP  (and QP, I think was
mentioned too!) solver interfaces for R.

However, Avi writes

    > Also, to be good R-citizens, this thread should probably be moved to
    > R-package-devel [1].

    > Thanks,
    > Avi

and I'm of an entirely different opinion.

R-package-devel  has been created, aons after R-devel,  to
*help* R package developers to get their packaging problems
solved, notably to get advice in making their packages ready for
CRAN.

Julian's question was really addressing the whole R developer
community asking if some functionality was desirable to be added
to the R-package space.

For me one *the* appropriate topics for this R-devel mailing
list.

Best,
Martin

---
Martin Maechler
ETH Zurich  and  R Core
(and original creator of R-help, R-devel, .. lists)

    > [1] https://stat.ethz.ch/mailman/listinfo/r-package-devel


From @vr@h@m@@d|er @end|ng |rom gm@||@com  Mon Dec 13 17:10:38 2021
From: @vr@h@m@@d|er @end|ng |rom gm@||@com (Avraham Adler)
Date: Mon, 13 Dec 2021 11:10:38 -0500
Subject: [Rd] Appropriate mailing list for " Improved LP/MIP solver "
In-Reply-To: <25015.28115.450016.486300@stat.math.ethz.ch>
References: <398833eb-b071-f2d0-5813-7f49fe48cb42@ed.ac.uk>
 <CAL6gwn+1eM7jSJFwif7b66cCTe=64r4U7fvxXnQuigfnLOqo3g@mail.gmail.com>
 <CAL6gwnKQwnFj8UPBqiH4Uu71i5QiVgti+jSuyqG5KjOkmsws7g@mail.gmail.com>
 <25015.28115.450016.486300@stat.math.ethz.ch>
Message-ID: <CAL6gwn+=WWxv2JmMWpNbyVCej0mufGwtoufycU3MbSO2jeA4vw@mail.gmail.com>

I defer completely and totally to Martin!

Apologies,

Avi

On Mon, Dec 13, 2021 at 10:59 AM Martin Maechler <maechler at stat.math.ethz.ch>
wrote:

> >>>>> Avraham Adler
> >>>>>     on Sun, 12 Dec 2021 16:27:02 +0000 writes:
>
>  [........................]
>
> Thank you, Julian and Avi,  on the topic of asking and replying
> if there's interest on getting improved LP / MIP  (and QP, I think was
> mentioned too!) solver interfaces for R.
>
> However, Avi writes
>
>     > Also, to be good R-citizens, this thread should probably be moved to
>     > R-package-devel [1].
>
>     > Thanks,
>     > Avi
>
> and I'm of an entirely different opinion.
>
> R-package-devel  has been created, aons after R-devel,  to
> *help* R package developers to get their packaging problems
> solved, notably to get advice in making their packages ready for
> CRAN.
>
> Julian's question was really addressing the whole R developer
> community asking if some functionality was desirable to be added
> to the R-package space.
>
> For me one *the* appropriate topics for this R-devel mailing
> list.
>
> Best,
> Martin
>
> ---
> Martin Maechler
> ETH Zurich  and  R Core
> (and original creator of R-help, R-devel, .. lists)
>
>     > [1] https://stat.ethz.ch/mailman/listinfo/r-package-devel
>
>
> --
Sent from Gmail Mobile

	[[alternative HTML version deleted]]


From mb|@ckwe|| @end|ng |rom gov@h@rv@rd@edu  Tue Dec 14 21:26:39 2021
From: mb|@ckwe|| @end|ng |rom gov@h@rv@rd@edu (Blackwell, Matthew)
Date: Tue, 14 Dec 2021 15:26:39 -0500
Subject: [Rd] Dropping RHS of a formula using NULL assignment
Message-ID: <CAAPQmtrttounH_f0kCpVH=cRxCdWCPUC1TXH-ZYSi=gKH4kUCA@mail.gmail.com>

Hello all,

In attempting to create a one-sided formula from a two-sided formula,
I discovered that the following syntax will successfully complete this
operation:

> f <- y ~ x + z
> f[2] <- NULL
> f
~x + z
> str(f)
Class 'formula'  language ~x + z
  ..- attr(*, ".Environment")=<environment: R_GlobalEnv>

In searching through the formula documentation, I couldn't find this
technique as documented and wondered whether or not it is expected and
if it makes sense to develop a package against the behavior. I'm using
R 4.1.0, but I see the same on R-devel (r81303). I asked on Twitter,
but someone thought this list might be a better venue.

Apologies if I missed some documentation and thanks in advance.

Cheers,
Matt

~~~~~~~~~~
Matthew Blackwell
Associate Professor of Government
Harvard University
https://www.mattblackwell.org


From murdoch@dunc@n @end|ng |rom gm@||@com  Tue Dec 14 21:56:19 2021
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Tue, 14 Dec 2021 15:56:19 -0500
Subject: [Rd] Dropping RHS of a formula using NULL assignment
In-Reply-To: <CAAPQmtrttounH_f0kCpVH=cRxCdWCPUC1TXH-ZYSi=gKH4kUCA@mail.gmail.com>
References: <CAAPQmtrttounH_f0kCpVH=cRxCdWCPUC1TXH-ZYSi=gKH4kUCA@mail.gmail.com>
Message-ID: <b689ca48-6b3d-aeb7-2e1f-ae3c030c231b@gmail.com>

On 14/12/2021 3:26 p.m., Blackwell, Matthew wrote:
> Hello all,
> 
> In attempting to create a one-sided formula from a two-sided formula,
> I discovered that the following syntax will successfully complete this
> operation:
> 
>> f <- y ~ x + z
>> f[2] <- NULL
>> f
> ~x + z
>> str(f)
> Class 'formula'  language ~x + z
>    ..- attr(*, ".Environment")=<environment: R_GlobalEnv>
> 
> In searching through the formula documentation, I couldn't find this
> technique as documented and wondered whether or not it is expected and
> if it makes sense to develop a package against the behavior. I'm using
> R 4.1.0, but I see the same on R-devel (r81303). I asked on Twitter,
> but someone thought this list might be a better venue.
> 
> Apologies if I missed some documentation and thanks in advance.

The source "y ~ x + z" parses to a call to the `~` function with 
arguments y and x + z.  Calls have the function as the first element, 
and arguments follow:  so f[1] would be ~, f[2] would be y, f[3] would 
be x + z.

You can see this if you pass f through as.list():

 > as.list(f)
[[1]]
`~`

[[2]]
y

[[3]]
x + z

Setting element 2 to NULL removes it, so you see

 > f[2] <- NULL
 > as.list(f)
[[1]]
`~`

[[2]]
x + z

I think it's safe to make use of this even if it's undocumented.  It's a 
pretty basic aspect of formulas.  I'd guess there are lots of packages 
already using it, but I can't point to any particular examples.

(I've ignored the difference between an unevaluated formula and an 
evaluated one, but they're almost the same, the only important 
difference in the attributes:  evaluating it gives it a class and an 
environment.)

Duncan Murdoch


From r|p|ey @end|ng |rom @t@t@@ox@@c@uk  Tue Dec 14 21:57:27 2021
From: r|p|ey @end|ng |rom @t@t@@ox@@c@uk (Prof Brian Ripley)
Date: Tue, 14 Dec 2021 20:57:27 +0000
Subject: [Rd] Dropping RHS of a formula using NULL assignment
In-Reply-To: <CAAPQmtrttounH_f0kCpVH=cRxCdWCPUC1TXH-ZYSi=gKH4kUCA@mail.gmail.com>
References: <CAAPQmtrttounH_f0kCpVH=cRxCdWCPUC1TXH-ZYSi=gKH4kUCA@mail.gmail.com>
Message-ID: <9da14ffb-03c8-4dec-2b8d-46987ffd014a@stats.ox.ac.uk>

On 14/12/2021 20:26, Blackwell, Matthew wrote:
> Hello all,
> 
> In attempting to create a one-sided formula from a two-sided formula,
> I discovered that the following syntax will successfully complete this
> operation:
> 
>> f <- y ~ x + z
>> f[2] <- NULL
>> f
> ~x + z
>> str(f)
> Class 'formula'  language ~x + z
>    ..- attr(*, ".Environment")=<environment: R_GlobalEnv>
> 
> In searching through the formula documentation, I couldn't find this
> technique as documented and wondered whether or not it is expected and
> if it makes sense to develop a package against the behavior. I'm using
> R 4.1.0, but I see the same on R-devel (r81303). I asked on Twitter,
> but someone thought this list might be a better venue.
> 
> Apologies if I missed some documentation and thanks in advance.

See ?"~", which says

      A formula has mode ?call?.  It can be subsetted by ?[[?: the
      components are ?~?, the left-hand side (if present) and the
      right-hand side _in that order_.

That would suggest that

f <- y ~ x + z
f[[2]] <- NULL

was the documented way (and the one I would have used).   However, ?"[" says

      ?[? and ?[[? are sometimes applied to other recursive objects such
      as calls and expressions.  Pairlists are coerced to lists for
      extraction by ?[?, but all three operators can be used for
      replacement.


> 
> Cheers,
> Matt
> 
> ~~~~~~~~~~
> Matthew Blackwell
> Associate Professor of Government
> Harvard University
> https://www.mattblackwell.org

-- 
Brian D. Ripley,                  ripley at stats.ox.ac.uk
Emeritus Professor of Applied Statistics, University of Oxford


From @eb@meyer @end|ng |rom |@u@de  Tue Dec 14 22:38:50 2021
From: @eb@meyer @end|ng |rom |@u@de (Sebastian Meyer)
Date: Tue, 14 Dec 2021 22:38:50 +0100
Subject: [Rd] Dropping RHS of a formula using NULL assignment
In-Reply-To: <9da14ffb-03c8-4dec-2b8d-46987ffd014a@stats.ox.ac.uk>
References: <CAAPQmtrttounH_f0kCpVH=cRxCdWCPUC1TXH-ZYSi=gKH4kUCA@mail.gmail.com>
 <9da14ffb-03c8-4dec-2b8d-46987ffd014a@stats.ox.ac.uk>
Message-ID: <cb0b301d-7a22-f681-38d8-2ae41a12b8f1@fau.de>

Am 14.12.21 um 21:57 schrieb Prof Brian Ripley:
> On 14/12/2021 20:26, Blackwell, Matthew wrote:
>> Hello all,
>>
>> In attempting to create a one-sided formula from a two-sided formula,
>> I discovered that the following syntax will successfully complete this
>> operation:
>>
>>> f <- y ~ x + z
>>> f[2] <- NULL
>>> f
>> ~x + z
>>> str(f)
>> Class 'formula'? language ~x + z
>> ?? ..- attr(*, ".Environment")=<environment: R_GlobalEnv>
>>
>> In searching through the formula documentation, I couldn't find this
>> technique as documented and wondered whether or not it is expected and
>> if it makes sense to develop a package against the behavior. I'm using
>> R 4.1.0, but I see the same on R-devel (r81303). I asked on Twitter,
>> but someone thought this list might be a better venue.
>>
>> Apologies if I missed some documentation and thanks in advance.
> 
> See ?"~", which says
> 
>  ???? A formula has mode ?call?.? It can be subsetted by ?[[?: the
>  ???? components are ?~?, the left-hand side (if present) and the
>  ???? right-hand side _in that order_.
> 
> That would suggest that
> 
> f <- y ~ x + z
> f[[2]] <- NULL
> 
> was the documented way (and the one I would have used).   

I'd also mention delete.response() here. It takes a "terms" object (a 
formula with attributes) and uses the same technique internally to 
remove the response -- if there is one... I.e., be sure that 
length(f)==3 before dropping the second element.

Best regards,

	Sebastian Meyer

> However, ?"[" 
> says
> 
>  ???? ?[? and ?[[? are sometimes applied to other recursive objects such
>  ???? as calls and expressions.? Pairlists are coerced to lists for
>  ???? extraction by ?[?, but all three operators can be used for
>  ???? replacement.
> 
> 
>>
>> Cheers,
>> Matt
>>
>> ~~~~~~~~~~
>> Matthew Blackwell
>> Associate Professor of Government
>> Harvard University
>> https://www.mattblackwell.org
>


From henr|k@bengt@@on @end|ng |rom gm@||@com  Wed Dec 15 22:48:18 2021
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Wed, 15 Dec 2021 13:48:18 -0800
Subject: [Rd] MS Windows: R does not escape quotes in CLI options the same
 way as Rterm and Rscript
Message-ID: <CAFDcVCSmebs6oiJMSEx6SaVvkgpVgMk1YyyFZ13DyM8c-Bt5Lg@mail.gmail.com>

On MS Windows 10, the following works:

> Rscript --vanilla -e "\"abc\""
[1] "abc"

and also:

> Rterm --vanilla --no-echo -e "\"abc.txt\""
[1] "abc.txt"

whereas attempting the same with 'R' fails;

> R --vanilla --no-echo -e "\"abc.txt\""
Error: object 'abc' not found
Execution halted

I get this with R 4.1.2 and R Under development (unstable) (2021-12-14
r81376 ucrt).

Is this a bug?

/Henrik


From |reder|k @end|ng |rom o|b@net  Thu Dec 16 05:09:46 2021
From: |reder|k @end|ng |rom o|b@net (Frederick Eaton)
Date: Wed, 15 Dec 2021 20:09:46 -0800
Subject: [Rd] 
 meaning of browser(skipCalls=) [and multiple mouse buttons]
In-Reply-To: <20211208082447.vd3hpq4gxd37llqy@localhost>
References: <20211122171358.7rej26rdwpq5ywrm@localhost>
 <20211208082447.vd3hpq4gxd37llqy@localhost>
Message-ID: <20211216040946.pgtjmlgvtyhimmh4@localhost>

Just following up to check if anyone has had time to look over these patches.

Frederick

On Wed, Dec 08, 2021 at 12:24:47AM -0800, Frederick Eaton wrote:
>Dear R Core Team,
>
>I'm attaching a proposed patch to hopefully address my confusions regarding the documentation of browser(). I'm not sure if all the material I added is correct, but I made experiments to confirm that the behavior is at least roughly as described.
>
>    patch ./src/library/base/man/browser.Rd < browser.patch
>
>Also, here is a patch to support multiple mouse buttons in getGraphicsEvent(). This must be edited before it can be applied, I decided to keep the old code in an 'if(0)' to help make it clearer that my code is essentially doing the same thing.
>
>    https://github.com/navarum/tweaks/blob/master/r/patches/0001-Add-support-for-multiple-mouse-buttons.patch
>    wget -O - https://raw.githubusercontent.com/navarum/tweaks/master/r/patches/0001-Add-support-for-multiple-mouse-buttons.patch | patch -p1
>
>It would be useful to have support in R for more than three mouse buttons because this enables the use of the mouse wheel (buttons 4 and 5), which can provide a more convenient interface when adjusting numbers and graphics and so on. I also have shift+wheel bound to buttons 6 and 7 via xbindkeys and xte, which I use for horizontal scrolling, via a trick from the web somewhere:
>
>    $ cat .xbindkeysrc.scm | grep xte
>    (xbindkey '(shift "b:4") "xte 'mouseclick 6'")
>    (xbindkey '(shift "b:5") "xte 'mouseclick 7'")
>
>I hope that these contributions can be found acceptable.
>
>Thank you in advance,
>
>Frederick
>
>
>
>On Mon, Nov 22, 2021 at 09:13:58AM -0800, Frederick Eaton wrote:
>>Dear R Devel,
>>
>>I have been advised to use "options(error=recover)" to enable
>>debugging on errors. But sometimes it would seem more convenient to
>>override "stopifnot", for example:
>>
>>   stopifnot = function(b) { if(!b) { browser(skipCalls=1); } }
>>
>>However, this doesn't do what I expected. On looking closer I find
>>that the "skipCalls" argument seems to be ignored except when printing
>>the "Called from: " message; it does not affect the evaluation context
>>or the output of 'where':
>>
>>   > var=2; f=function(){var=1; browser(skipCalls=0)}; f()
>>   Called from: f()
>>   Browse[1]> var
>>   [1] 1
>>   Browse[1]> where
>>   where 1: f()
>>
>>   Browse[1]> Q
>>   > var=2; f=function(){var=1; browser(skipCalls=1)}; f()
>>   Called from: top level     Browse[1]> var
>>   [1] 1
>>   Browse[1]> where
>>   where 1: f()
>>
>>   Browse[1]> Q
>>   > var=2; f=function(){var=1; browser(skipCalls=2)}; f()
>>   Called from: top level     Browse[1]> var
>>   [1] 1
>>   Browse[1]> where
>>   where 1: f()
>>
>>   Browse[1]> Q
>>
>>So it appears that the "browser()" API does not actually make it
>>possible to call this built-in function from within another R function
>>and thereby emulate the same behavior as calling browser() directly.
>>
>>If this is the case, it might be good to have it fixed or documented.
>>I am aware of "browser(expr=)", but this requires editing the
>>particular call that failed. The documentation for "browser()" led me
>>to hope that my use case would be supported, if only because it admits
>>that users might want to build other debugging functions with
>>browser(): "The 'skipCalls' argument should be used when the
>>'browser()' call is nested within another debugging function". An
>>example where this 'skipCalls' parameter is used to build a useful
>>debugging function would help to clarify its English description in
>>the manual.
>>
>>Also, from the browser() command line I could not find a way to step
>>*out* of the current function. This would have been a way to recover
>>from skipCalls not working as expected. Am I missing something? For
>>example is there some command other than "n", where the below
>>interaction could pause before "hi" and "bye"?
>>
>>   > f=function(){browser(); message("in f"); message("out f")}; f(); message("hi"); message("bye")
>>   Called from: f()
>>   Browse[1]> n
>>   debug at #1: message("in f")
>>   Browse[2]> n
>>   in f
>>   debug at #1: message("out f")
>>   Browse[2]> n
>>   out f
>>   hi
>>   bye
>>
>>If it is not possible for the R debugger to step out of a function, it
>>would be good to document that too, maybe after the list of browser
>>prompt commands in "?browser". Being confined within a single function
>>is not an obvious disability for a debugger to have.
>>
>>I feel that R is an excellent tool, but sometimes I think that if the
>>shortcomings of the system were better documented, then this would
>>save users a lot of time in certain cases.
>>
>>Thank you,
>>
>>Frederick
>>

>--- browser-orig.Rd	2021-12-07 22:35:51.991222137 -0800
>+++ browser-new.Rd	2021-12-07 23:53:36.414106296 -0800
>@@ -45,8 +45,16 @@
>   will be simpler.
>
>   The \code{skipCalls} argument should be used when the \code{browser()}
>-  call is nested within another debugging function:  it will look further
>-  up the call stack to report its location.
>+  call is nested within another debugging function: it will look further
>+  up the call stack to report its location. However, currently this
>+  argument only affects the \code{Called from:} message printed before
>+  the first \code{Browse>} prompt, and does not change the evaluation
>+  environment of the expressions entered there, nor the output of the
>+  \code{where} command. It is not clear when this argument would be
>+  useful. It is for example currently impossible to change occurrences
>+  of \code{stopifnot(x)} to act like \code{browser(expr=!x)} by
>+  redefining \code{stopifnot()}; this must instead be done through a
>+  textual search-and-replace or \code{options(error=recover)}.
>
>   At the browser prompt the user can enter commands or \R expressions,
>   followed by a newline.  The commands are
>@@ -58,11 +66,9 @@
>     \item{\code{f}}{finish execution of the current loop or function}
>     \item{\code{help}}{print this list of commands}
>     \item{\code{n}}{evaluate the next statement, stepping over
>-      function calls.  For byte compiled functions interrupted by
>-      \code{browser} calls, \code{n} is equivalent to \code{c}.}
>+      function calls.}
>     \item{\code{s}}{evaluate the next statement, stepping into
>-      function calls.  Again, byte compiled functions make
>-      \code{s} equivalent to \code{c}.}
>+      function calls.}
>     \item{\code{where}}{print a stack trace of all active function calls.}
>     \item{\code{r}}{invoke a \code{"resume"} restart if one is
>       available; interpreted as an \R expression otherwise. Typically
>@@ -71,6 +77,15 @@
>     \item{\code{Q}}{exit the browser and the current evaluation and
>       return to the top-level prompt.}
>   }
>+
>+  Both \code{n} and \code{s} also step out of function calls. However,
>+  it is currently not possible with these commands to step out of the
>+  function which called \code{browser()}. At the end of the function
>+  which called \code{browser}, \code{n} and \code{s} are both equivalent
>+  to \code{c}. These commands (\code{n} and \code{s}) are also
>+  equivalent to \code{c} when trying to use them inside byte compiled
>+  functions interrupted by \code{browser} calls.
>+
>   Leading and trailing whitespace is ignored, except for an empty line.
>   Handling of empty lines depends on the \code{"browserNLdisabled"}
>   \link[=options]{option}; if it is \code{TRUE}, empty lines are ignored.


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Thu Dec 16 10:02:13 2021
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Thu, 16 Dec 2021 10:02:13 +0100
Subject: [Rd] 
 meaning of browser(skipCalls=) [and multiple mouse buttons]
In-Reply-To: <20211216040946.pgtjmlgvtyhimmh4@localhost>
References: <20211122171358.7rej26rdwpq5ywrm@localhost>
 <20211208082447.vd3hpq4gxd37llqy@localhost>
 <20211216040946.pgtjmlgvtyhimmh4@localhost>
Message-ID: <25019.149.79336.502549@stat.math.ethz.ch>

>>>>> Frederick Eaton 
>>>>>     on Wed, 15 Dec 2021 20:09:46 -0800 writes:

    > Just following up to check if anyone has had time to look over these patches.
    > Frederick

I strongly guess that nobody has.

Let me give you my perception of what you have tried to
propose/use,  and why I hadn't thought I should put in time for it:

You had started the thread by proposing "to override stopifnot()",
something which I (even though principal author of the function)
don't find a good idea at all:

stopifnot() is just one important utility function that will
call stop() under some circumstances.
If you want to tweak  error handling / debugging / browser, ..
you need to work on the level of error conditions, their
handlers, etc. 

Secondly, you've mixed this up with mouse button
action/interrupt/.. handling  which may be a cool and nice idea,
but then your  `xbindkey`-etc code is, I think, only/entirely
for X11-based R interfaces, and I think this would only be a
Linux console, possibly one from using ESS (Emacs Speaks Statistics),
but most probably (but I'm guessing here) not even relevant when
using Rstudio on Linux, and even less relevant for any of the
other ways R is used interactively on non-Linux platforms. Maybe
it would also apply to *some* uses of R on the Mac, but not even
the default R-Mac GUI..

Sorry that this not as much encouraging as it probably should
be, but I though you'd rather want *some* feedback than none...

Best,
Martin



    > On Wed, Dec 08, 2021 at 12:24:47AM -0800, Frederick Eaton wrote:
    >> Dear R Core Team,
    >> 
    >> I'm attaching a proposed patch to hopefully address my confusions regarding the documentation of browser(). I'm not sure if all the material I added is correct, but I made experiments to confirm that the behavior is at least roughly as described.
    >> 
    >> patch ./src/library/base/man/browser.Rd < browser.patch
    >> 
    >> Also, here is a patch to support multiple mouse buttons in getGraphicsEvent(). This must be edited before it can be applied, I decided to keep the old code in an 'if(0)' to help make it clearer that my code is essentially doing the same thing.
    >> 
    >> https://github.com/navarum/tweaks/blob/master/r/patches/0001-Add-support-for-multiple-mouse-buttons.patch
    >> wget -O - https://raw.githubusercontent.com/navarum/tweaks/master/r/patches/0001-Add-support-for-multiple-mouse-buttons.patch | patch -p1
    >> 
    >> It would be useful to have support in R for more than three mouse buttons because this enables the use of the mouse wheel (buttons 4 and 5), which can provide a more convenient interface when adjusting numbers and graphics and so on. I also have shift+wheel bound to buttons 6 and 7 via xbindkeys and xte, which I use for horizontal scrolling, via a trick from the web somewhere:
    >> 
    >> $ cat .xbindkeysrc.scm | grep xte
    >> (xbindkey '(shift "b:4") "xte 'mouseclick 6'")
    >> (xbindkey '(shift "b:5") "xte 'mouseclick 7'")
    >> 
    >> I hope that these contributions can be found acceptable.
    >> 
    >> Thank you in advance,
    >> 
    >> Frederick
    >> 
    >> 
    >> 
    >> On Mon, Nov 22, 2021 at 09:13:58AM -0800, Frederick Eaton wrote:
    >>> Dear R Devel,
    >>> 
    >>> I have been advised to use "options(error=recover)" to enable
    >>> debugging on errors. But sometimes it would seem more convenient to
    >>> override "stopifnot", for example:
    >>> 
    >>> stopifnot = function(b) { if(!b) { browser(skipCalls=1); } }
    >>> 
    >>> However, this doesn't do what I expected. On looking closer I find
    >>> that the "skipCalls" argument seems to be ignored except when printing
    >>> the "Called from: " message; it does not affect the evaluation context
    >>> or the output of 'where':
    >>> 
    >>> > var=2; f=function(){var=1; browser(skipCalls=0)}; f()
    >>> Called from: f()
    >>> Browse[1]> var
    >>> [1] 1
    >>> Browse[1]> where
    >>> where 1: f()
    >>> 
    >>> Browse[1]> Q
    >>> > var=2; f=function(){var=1; browser(skipCalls=1)}; f()
    >>> Called from: top level     Browse[1]> var
    >>> [1] 1
    >>> Browse[1]> where
    >>> where 1: f()
    >>> 
    >>> Browse[1]> Q
    >>> > var=2; f=function(){var=1; browser(skipCalls=2)}; f()
    >>> Called from: top level     Browse[1]> var
    >>> [1] 1
    >>> Browse[1]> where
    >>> where 1: f()
    >>> 
    >>> Browse[1]> Q
    >>> 
    >>> So it appears that the "browser()" API does not actually make it
    >>> possible to call this built-in function from within another R function
    >>> and thereby emulate the same behavior as calling browser() directly.
    >>> 
    >>> If this is the case, it might be good to have it fixed or documented.
    >>> I am aware of "browser(expr=)", but this requires editing the
    >>> particular call that failed. The documentation for "browser()" led me
    >>> to hope that my use case would be supported, if only because it admits
    >>> that users might want to build other debugging functions with
    >>> browser(): "The 'skipCalls' argument should be used when the
    >>> 'browser()' call is nested within another debugging function". An
    >>> example where this 'skipCalls' parameter is used to build a useful
    >>> debugging function would help to clarify its English description in
    >>> the manual.
    >>> 
    >>> Also, from the browser() command line I could not find a way to step
    >>> *out* of the current function. This would have been a way to recover
    >>> from skipCalls not working as expected. Am I missing something? For
    >>> example is there some command other than "n", where the below
    >>> interaction could pause before "hi" and "bye"?
    >>> 
    >>> > f=function(){browser(); message("in f"); message("out f")}; f(); message("hi"); message("bye")
    >>> Called from: f()
    >>> Browse[1]> n
    >>> debug at #1: message("in f")
    >>> Browse[2]> n
    >>> in f
    >>> debug at #1: message("out f")
    >>> Browse[2]> n
    >>> out f
    >>> hi
    >>> bye
    >>> 
    >>> If it is not possible for the R debugger to step out of a function, it
    >>> would be good to document that too, maybe after the list of browser
    >>> prompt commands in "?browser". Being confined within a single function
    >>> is not an obvious disability for a debugger to have.
    >>> 
    >>> I feel that R is an excellent tool, but sometimes I think that if the
    >>> shortcomings of the system were better documented, then this would
    >>> save users a lot of time in certain cases.
    >>> 
    >>> Thank you,
    >>> 
    >>> Frederick
    >>> 

    >> --- browser-orig.Rd	2021-12-07 22:35:51.991222137 -0800
    >> +++ browser-new.Rd	2021-12-07 23:53:36.414106296 -0800
    >> @@ -45,8 +45,16 @@
    >> will be simpler.
    >> 
    >> The \code{skipCalls} argument should be used when the \code{browser()}
    >> -  call is nested within another debugging function:  it will look further
    >> -  up the call stack to report its location.
    >> +  call is nested within another debugging function: it will look further
    >> +  up the call stack to report its location. However, currently this
    >> +  argument only affects the \code{Called from:} message printed before
    >> +  the first \code{Browse>} prompt, and does not change the evaluation
    >> +  environment of the expressions entered there, nor the output of the
    >> +  \code{where} command. It is not clear when this argument would be
    >> +  useful. It is for example currently impossible to change occurrences
    >> +  of \code{stopifnot(x)} to act like \code{browser(expr=!x)} by
    >> +  redefining \code{stopifnot()}; this must instead be done through a
    >> +  textual search-and-replace or \code{options(error=recover)}.
    >> 
    >> At the browser prompt the user can enter commands or \R expressions,
    >> followed by a newline.  The commands are
    >> @@ -58,11 +66,9 @@
    >> \item{\code{f}}{finish execution of the current loop or function}
    >> \item{\code{help}}{print this list of commands}
    >> \item{\code{n}}{evaluate the next statement, stepping over
    >> -      function calls.  For byte compiled functions interrupted by
    >> -      \code{browser} calls, \code{n} is equivalent to \code{c}.}
    >> +      function calls.}
    >> \item{\code{s}}{evaluate the next statement, stepping into
    >> -      function calls.  Again, byte compiled functions make
    >> -      \code{s} equivalent to \code{c}.}
    >> +      function calls.}
    >> \item{\code{where}}{print a stack trace of all active function calls.}
    >> \item{\code{r}}{invoke a \code{"resume"} restart if one is
    >> available; interpreted as an \R expression otherwise. Typically
    >> @@ -71,6 +77,15 @@
    >> \item{\code{Q}}{exit the browser and the current evaluation and
    >> return to the top-level prompt.}
    >> }
    >> +
    >> +  Both \code{n} and \code{s} also step out of function calls. However,
    >> +  it is currently not possible with these commands to step out of the
    >> +  function which called \code{browser()}. At the end of the function
    >> +  which called \code{browser}, \code{n} and \code{s} are both equivalent
    >> +  to \code{c}. These commands (\code{n} and \code{s}) are also
    >> +  equivalent to \code{c} when trying to use them inside byte compiled
    >> +  functions interrupted by \code{browser} calls.
    >> +
    >> Leading and trailing whitespace is ignored, except for an empty line.
    >> Handling of empty lines depends on the \code{"browserNLdisabled"}
    >> \link[=options]{option}; if it is \code{TRUE}, empty lines are ignored.


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Thu Dec 16 10:22:59 2021
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Thu, 16 Dec 2021 10:22:59 +0100
Subject: [Rd] 
 MS Windows: R does not escape quotes in CLI options the same
 way as Rterm and Rscript
In-Reply-To: <CAFDcVCSmebs6oiJMSEx6SaVvkgpVgMk1YyyFZ13DyM8c-Bt5Lg@mail.gmail.com>
References: <CAFDcVCSmebs6oiJMSEx6SaVvkgpVgMk1YyyFZ13DyM8c-Bt5Lg@mail.gmail.com>
Message-ID: <4a6b6123-1a05-8709-75d9-ff6e1cbda681@gmail.com>


On 12/15/21 10:48 PM, Henrik Bengtsson wrote:
> On MS Windows 10, the following works:
>
>> Rscript --vanilla -e "\"abc\""
> [1] "abc"
>
> and also:
>
>> Rterm --vanilla --no-echo -e "\"abc.txt\""
> [1] "abc.txt"
>
> whereas attempting the same with 'R' fails;
>
>> R --vanilla --no-echo -e "\"abc.txt\""
> Error: object 'abc' not found
> Execution halted
>
> I get this with R 4.1.2 and R Under development (unstable) (2021-12-14
> r81376 ucrt).
>
> Is this a bug?

Yes, R.exe does not properly handle quotes (and backslashes preceding a 
quote, and trailing backslashes). This is the same as PR#18139 for 
shQuote(). I will put that on my list

Best
Tomas

>
> /Henrik
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @teve@h@roz @end|ng |rom gm@||@com  Thu Dec 16 10:31:26 2021
From: @teve@h@roz @end|ng |rom gm@||@com (Steve Haroz)
Date: Thu, 16 Dec 2021 10:31:26 +0100
Subject: [Rd] Feature request: Change default library path on Windows
In-Reply-To: <d49767c9-11dc-5f50-49a8-c400a448afec@gmail.com>
References: <CAJhjiQmEP6Rw_jM8PEz4gD1VXWWW9E0p7Pw31dyk4TQsEPJRdw@mail.gmail.com>
 <CABFfbXvEQGejh069Ni7UZKub7UPA26QfvcH6waPcw+Z1jGSMMA@mail.gmail.com>
 <CAJhjiQmLUqHJW8PFGdqJU1T3cYX7bQQ7-6DRb34UZ_r7vKqBbw@mail.gmail.com>
 <b09f5373-4d0e-64d7-1d5e-91e948e12a28@gmail.com>
 <CAJhjiQnbggTG_7Hicp1PgbujhrJ5FW8mPRAgb7YhhpSPOx5syw@mail.gmail.com>
 <522686cd-645d-4a62-9dcf-5f701f3f9ab1@gmail.com>
 <CAJhjiQnBAucSkeQmONTz1oBDoO4eC=b_0WJVZ=bg89bqw0SYTw@mail.gmail.com>
 <c8e8bbda-35b4-c61f-46df-91708e1a88d8@gmail.com>
 <CAJhjiQk6H_Fb=fxKqRmZiZcX+Cb7vSiiDeJnSaJ1t8Fj_Bmyjw@mail.gmail.com>
 <1973d4dc-b514-2993-5dbc-28668fcaa2ce@gmail.com>
 <d49767c9-11dc-5f50-49a8-c400a448afec@gmail.com>
Message-ID: <CAJhjiQm5V6nKFHVZr-6xEXOELEvhi7Gs+2A0LTD6dHaut7fYsQ@mail.gmail.com>

Thank you for the update. Really helpful!
Between this and the unicode changes, the next version will have a very
positive impact on Windows users.

Best,
Steve

On Mon, Dec 13, 2021 at 1:02 PM Tomas Kalibera <tomas.kalibera at gmail.com>
wrote:

> The default was now changed in R-devel to the local application data
> (e.g. C:\Users\username\AppData\Local), which should solve the issues
> with synchronization/backup/etc services and seems to be more in line
> with conventions for the OS. It is a hidden folder, to open in Windows
> explorer one can use e.g. shell.exec() from R.
>
> Best
> Tomas
>
> On 7/27/21 1:12 PM, Tomas Kalibera wrote:
> > On 7/26/21 1:44 AM, Steve Haroz wrote:
> >> Thanks Ben. I just sent a request for a bugzilla login.
> >> Jeroen chimed in earlier in support.
> >
> > Please note this has been reported, discussed and considered already,
> > last time in PR#17842 (though proposing a different replacement for
> > the default).
> >
> > I think changing the default from user documents to something else
> > would make sense to consider together with some other breaking change
> > for users, not in isolation, if at all. While the change may help
> > users with a quota on the documents directory (e.g. shared on a cloud,
> > backup, etc), it will make it harder to find the library for others,
> > who would not notice the change to the documented behavior, and I
> > assume that would still be a much larger group.
> >
> > Of course it does not help that it is not clear what the correct
> > location should be now, and certainly there is little hope it won't
> > change again, soon. My understanding is that the choice was originally
> > correct when made, following the Microsoft guidelines.
> >
> > As discussed here as well, users may choose their own library path
> > (?.libPaths).
> >
> > The installation location for R itself can be changed e.g. via /DIR
> > option of the installer (see /?). This is useful e.g. when installing
> > R only for the current user (/CURRENTUSER) and it impacts also the
> > location of the library - it is then inside the given tree.
> >
> > Best
> > Tomas
> >
> >
> >
> >>
> >> Cheers,
> >> Steve
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From @tephen@berm@n @end|ng |rom gmx@net  Thu Dec 16 10:13:11 2021
From: @tephen@berm@n @end|ng |rom gmx@net (Stephen Berman)
Date: Thu, 16 Dec 2021 10:13:11 +0100
Subject: [Rd] build failure: 'hashtab' is not an exported object from
 'namespace:utils'
Message-ID: <87a6h0c3q0.fsf@gmx.net>

I just did `svn up' on the R development sources, switched to the build
directory (I build R out of tree), ran make, and got this:

make[6]: Entering directory '/home/steve/build/r-devel/src/library/tools/src'
../../../../library/tools/libs/tools.so is unchanged
make[6]: Leaving directory '/home/steve/build/r-devel/src/library/tools/src'
make[5]: Leaving directory '/home/steve/build/r-devel/src/library/tools/src'
make[4]: Leaving directory '/home/steve/build/r-devel/src/library/tools'
make[4]: Entering directory '/home/steve/build/r-devel/src/library/tools'
installing 'sysdata.rda'
Error: 'hashtab' is not an exported object from 'namespace:utils'
Execution halted
make[4]: *** [/home/steve/src/R/r-devel/share/make/basepkg.mk:151: sysdata] Error 1
make[4]: Leaving directory '/home/steve/build/r-devel/src/library/tools'
make[3]: *** [Makefile:36: all] Error 2
make[3]: Leaving directory '/home/steve/build/r-devel/src/library/tools'
make[2]: *** [Makefile:37: R] Error 1
make[2]: Leaving directory '/home/steve/build/r-devel/src/library'
make[1]: *** [Makefile:28: R] Error 1
make[1]: Leaving directory '/home/steve/build/r-devel/src'
make: *** [Makefile:61: R] Error 1

I then did `make clean', ran configure and make again, and got the same
failure.  Is this a known issue and is there a fix?

Steve Berman


From kry|ov@r00t @end|ng |rom gm@||@com  Thu Dec 16 10:58:55 2021
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Thu, 16 Dec 2021 12:58:55 +0300
Subject: [Rd] build failure: 'hashtab' is not an exported object from
 'namespace:utils'
In-Reply-To: <87a6h0c3q0.fsf@gmx.net>
References: <87a6h0c3q0.fsf@gmx.net>
Message-ID: <20211216125855.02504416@arachnoid>

On Thu, 16 Dec 2021 10:13:11 +0100
Stephen Berman <stephen.berman at gmx.net> wrote:

> Is this a known issue and is there a fix?

For me, the fix was to remove the already-installed
$SVNROOT/library/utils (which didn't yet contain hashtab) and re-run
make, letting the R build process re-install it from scratch.

-- 
Best regards,
Ivan


From r|p|ey @end|ng |rom @t@t@@ox@@c@uk  Thu Dec 16 10:57:40 2021
From: r|p|ey @end|ng |rom @t@t@@ox@@c@uk (Prof Brian Ripley)
Date: Thu, 16 Dec 2021 09:57:40 +0000
Subject: [Rd] build failure: 'hashtab' is not an exported object from
 'namespace:utils'
In-Reply-To: <87a6h0c3q0.fsf@gmx.net>
References: <87a6h0c3q0.fsf@gmx.net>
Message-ID: <1f9b0292-9d4c-5209-88cf-93a988a78c10@stats.ox.ac.uk>

On 16/12/2021 09:13, Stephen Berman wrote:
> I just did `svn up' on the R development sources, switched to the build
> directory (I build R out of tree), ran make, and got this:

Precisely which version of R-devel updating from which version? -- this 
is an area that has changed frequently in the last several days.

I suspect 'make clean' is not enough -- use 'make distclean' for an ab 
initio build.

> 
> make[6]: Entering directory '/home/steve/build/r-devel/src/library/tools/src'
> ../../../../library/tools/libs/tools.so is unchanged
> make[6]: Leaving directory '/home/steve/build/r-devel/src/library/tools/src'
> make[5]: Leaving directory '/home/steve/build/r-devel/src/library/tools/src'
> make[4]: Leaving directory '/home/steve/build/r-devel/src/library/tools'
> make[4]: Entering directory '/home/steve/build/r-devel/src/library/tools'
> installing 'sysdata.rda'
> Error: 'hashtab' is not an exported object from 'namespace:utils'
> Execution halted
> make[4]: *** [/home/steve/src/R/r-devel/share/make/basepkg.mk:151: sysdata] Error 1
> make[4]: Leaving directory '/home/steve/build/r-devel/src/library/tools'
> make[3]: *** [Makefile:36: all] Error 2
> make[3]: Leaving directory '/home/steve/build/r-devel/src/library/tools'
> make[2]: *** [Makefile:37: R] Error 1
> make[2]: Leaving directory '/home/steve/build/r-devel/src/library'
> make[1]: *** [Makefile:28: R] Error 1
> make[1]: Leaving directory '/home/steve/build/r-devel/src'
> make: *** [Makefile:61: R] Error 1
> 
> I then did `make clean', ran configure and make again, and got the same
> failure.  Is this a known issue and is there a fix?
> 
> Steve Berman
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


-- 
Brian D. Ripley,                  ripley at stats.ox.ac.uk
Emeritus Professor of Applied Statistics, University of Oxford


From @tephen@berm@n @end|ng |rom gmx@net  Thu Dec 16 11:34:10 2021
From: @tephen@berm@n @end|ng |rom gmx@net (Stephen Berman)
Date: Thu, 16 Dec 2021 11:34:10 +0100
Subject: [Rd] build failure: 'hashtab' is not an exported object from
 'namespace:utils'
In-Reply-To: <1f9b0292-9d4c-5209-88cf-93a988a78c10@stats.ox.ac.uk> (Brian
 Ripley's message of "Thu, 16 Dec 2021 09:57:40 +0000")
References: <87a6h0c3q0.fsf@gmx.net>
 <1f9b0292-9d4c-5209-88cf-93a988a78c10@stats.ox.ac.uk>
Message-ID: <8735msbzz1.fsf@gmx.net>

On Thu, 16 Dec 2021 09:57:40 +0000 Prof Brian Ripley <ripley at stats.ox.ac.uk> wrote:

> On 16/12/2021 09:13, Stephen Berman wrote:
>> I just did `svn up' on the R development sources, switched to the build
>> directory (I build R out of tree), ran make, and got this:
>
> Precisely which version of R-devel updating from which version? -- this is an
> area that has changed frequently in the last several days.

Yes, it's been more than a month since my last build: I updated from

r81161 | maechler | 2021-11-08 14:30:50 +0100 (Mon, 08 Nov 2021) | 1 line

to

r81384 | pd | 2021-12-16 01:20:16 +0100 (Thu, 16 Dec 2021) | 1 line

> I suspect 'make clean' is not enough -- use 'make distclean' for an ab initio
> build.

That certainly gave me a clean slate -- and the build then succeeded.
Thanks.

On Thu, 16 Dec 2021 12:58:55 +0300 Ivan Krylov <krylov.r00t at gmail.com> wrote:

> On Thu, 16 Dec 2021 10:13:11 +0100
> Stephen Berman <stephen.berman at gmx.net> wrote:
>
>> Is this a known issue and is there a fix?
>
> For me, the fix was to remove the already-installed
> $SVNROOT/library/utils (which didn't yet contain hashtab) and re-run
> make, letting the R build process re-install it from scratch.

I guess that would have been $BUILD/library/utils for me?  Perhaps that
would have shortened the build time, but I had already done `make
distclean' and a complete rebuild was quick enough.  But thanks for the
reply.

Steve Berman


From w|n@tonch@ng1 @end|ng |rom gm@||@com  Fri Dec 17 20:32:13 2021
From: w|n@tonch@ng1 @end|ng |rom gm@||@com (Winston Chang)
Date: Fri, 17 Dec 2021 13:32:13 -0600
Subject: [Rd] Rtools42 and included libraries
Message-ID: <CAFOpNVF3T9L3SnE7UiJ5Dshh1BKJVu9NJ7K6gCHOicbf_Hu=rQ@mail.gmail.com>

Rtools42 includes the pre-compiled libraries needed to build most CRAN
packages. From the blog (
https://developer.r-project.org/Blog/public/2021/12/07/upcoming-changes-in-r-4.2-on-windows/
):

> Most of the required package changes were due to downloading incompatible
pre-compiled libraries at installation time. Rtools42 includes libraries
for almost all CRAN packages, which can and should be used, instead.

Will these libraries be updated on a regular schedule? I'm wondering how to
manage library updates in the future.

-Winston

	[[alternative HTML version deleted]]


From @rn@ud@|e|dm@nn @end|ng |rom gm@||@com  Sat Dec 18 11:50:54 2021
From: @rn@ud@|e|dm@nn @end|ng |rom gm@||@com (Arnaud FELD)
Date: Sat, 18 Dec 2021 11:50:54 +0100
Subject: [Rd] hashtab address arg
Message-ID: <CAGho6Qs+TEDh4CqaSq8mWvM0_E9HtCq1AUtX49yyOjnRxYnJTA@mail.gmail.com>

Hi everyone,

I've seen and tried in R Devel the new hashtabs experimental feature, which
is fine and fast. It could be a new possibility for developers ! However,
I'm a bit troubled about the "address" argument. What is it intended for
since (as far as I know) "address equality" is until now something that
isn't really let for the user to decide within R.
At my modest level, the only time I've encountered address equality within
base R is for s3 double dispatch, and that's also the only time I've had
managed to get non-crossplatform code with standard base R code, and
without searching for it.
So what is it for ?

Sorry if the answer is obvious (but unknown to me) and thanks for your work,

Arnaud

	[[alternative HTML version deleted]]


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Mon Dec 20 12:05:24 2021
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Mon, 20 Dec 2021 12:05:24 +0100
Subject: [Rd] Rtools42 and included libraries
In-Reply-To: <CAFOpNVF3T9L3SnE7UiJ5Dshh1BKJVu9NJ7K6gCHOicbf_Hu=rQ@mail.gmail.com>
References: <CAFOpNVF3T9L3SnE7UiJ5Dshh1BKJVu9NJ7K6gCHOicbf_Hu=rQ@mail.gmail.com>
Message-ID: <e9fb1ae5-0a3c-7182-78cd-481b55be0809@gmail.com>


On 12/17/21 8:32 PM, Winston Chang wrote:
> Rtools42 includes the pre-compiled libraries needed to build most CRAN
> packages. From the blog (
> https://developer.r-project.org/Blog/public/2021/12/07/upcoming-changes-in-r-4.2-on-windows/
> ):
>
>> Most of the required package changes were due to downloading incompatible
> pre-compiled libraries at installation time. Rtools42 includes libraries
> for almost all CRAN packages, which can and should be used, instead.
>
> Will these libraries be updated on a regular schedule? I'm wondering how to
> manage library updates in the future.

Yes, both the libraries and the toolchain will have to be updated. I've 
already done that several times when working on this.

In more detail:

The toolchain and libraries are built using MXE and if you need to 
update a library or add a new one, you would ideally send a pull request 
to MXE or file an issue there. See also "Adding/updating MXE package" in

https://developer.r-project.org/WindowsBuilds/winutf8/ucrt3/howto.html

After it is in upstream MXE, you would then ping the Rtools42 maintainer 
(now me) if it is a new library or if you need the update quickly. Time 
to time all MXE library updates will be merged into RTools42, which will 
include testing on CRAN packages and in some cases some R packages will 
have to be updated. The updates of upstream MXE packages happen as 
needed by various users, some are upgraded frequently (so you as R 
package author would not have to do anything), but not all.

There are also some updated/customized/added MXE packages used in 
Rtools42, not yet in upstream MXE. The amount of customization should be 
minimal and R packages should be written to work with the configuration 
choices made by MXE, as they work with the choices made by various Linux 
distributions and macOS recipes. If there? was a significant problem 
with the MXE configuration choices, one should file an issue to MXE.? 
Still, in the case when the review of an upstream pull request was 
taking too long, particularly MXE library updates or additions could be 
ale made only for Rtools42. If you need to update an MXE package that is 
in this "custom" set, you can send a patch to the Rtools42 maintainer, 
and of course if you wanted to help getting that MXE package upstream, 
let me know.

In practice I expect some R package authors will need help with this and 
ask on R-devel (or R-pkg-devel).

Best
Tomas

>
> -Winston
>
> 	[[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From edd @end|ng |rom deb|@n@org  Mon Dec 20 15:47:49 2021
From: edd @end|ng |rom deb|@n@org (Dirk Eddelbuettel)
Date: Mon, 20 Dec 2021 08:47:49 -0600
Subject: [Rd] Status of '=>'
In-Reply-To: <e9fb1ae5-0a3c-7182-78cd-481b55be0809@gmail.com>
References: <CAFOpNVF3T9L3SnE7UiJ5Dshh1BKJVu9NJ7K6gCHOicbf_Hu=rQ@mail.gmail.com>
 <e9fb1ae5-0a3c-7182-78cd-481b55be0809@gmail.com>
Message-ID: <25024.38805.501447.73086@rob.eddelbuettel.com>


R 4.1.0 brought the native pipe and the related ability to use '=>' if one
opted into it by setting _R_USE_PIPEBIND_. I often forget about '=>' and
sadly can never find anything in the docs either (particularly no 'see als'
from '|>' docs) which is not all that heplful.

Can we anticipate a change with R 4.2.0, or will it remain as is, somewhat
available but not really documented or enabled? Clarifications welcome,
otherwise 'time will tell' as usual. 

Thanks,  Dirk

-- 
https://dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org


From iuke-tier@ey m@iii@g oii uiow@@edu  Mon Dec 20 16:05:22 2021
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Mon, 20 Dec 2021 09:05:22 -0600 (CST)
Subject: [Rd] [External]  Status of '=>'
In-Reply-To: <25024.38805.501447.73086@rob.eddelbuettel.com>
References: <CAFOpNVF3T9L3SnE7UiJ5Dshh1BKJVu9NJ7K6gCHOicbf_Hu=rQ@mail.gmail.com>
 <e9fb1ae5-0a3c-7182-78cd-481b55be0809@gmail.com>
 <25024.38805.501447.73086@rob.eddelbuettel.com>
Message-ID: <alpine.DEB.2.22.394.2112200903590.385153@luke-Latitude-7480>

It's still work in progress. Probably => will be dropped in favor of
limited use of _ for non-first-argument passing.

Best,

luke

On Mon, 20 Dec 2021, Dirk Eddelbuettel wrote:

>
> R 4.1.0 brought the native pipe and the related ability to use '=>' if one
> opted into it by setting _R_USE_PIPEBIND_. I often forget about '=>' and
> sadly can never find anything in the docs either (particularly no 'see als'
> from '|>' docs) which is not all that heplful.
>
> Can we anticipate a change with R 4.2.0, or will it remain as is, somewhat
> available but not really documented or enabled? Clarifications welcome,
> otherwise 'time will tell' as usual.
>
> Thanks,  Dirk
>
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu


From yut@n|@|n| @end|ng |rom gm@||@com  Tue Dec 21 06:34:32 2021
From: yut@n|@|n| @end|ng |rom gm@||@com (Hiroaki Yutani)
Date: Tue, 21 Dec 2021 14:34:32 +0900
Subject: [Rd] R on Windows with UCRT and the system encoding
Message-ID: <CALyqOb_q=fy-ezTOHLrtEc-eW3TevUEy38az4tXtfeVFPrELxA@mail.gmail.com>

Hi,

I'm more than excited about the announcement about the upcoming UTF-8
R on Windows. Let me confirm my understanding. Is R 4.2 supposed to
work on Windows with non-UTF-8 encoding as the system locale? I think
this blog post indicates so (as this describes the older Windows than
the UTF-8 era), but I'm not fully confident if I understand the
details correctly.

https://developer.r-project.org/Blog/public/2021/12/07/upcoming-changes-in-r-4.2-on-windows/index.html

If so, I'm curious what the package authors should do when the locales
are different between OS and R. For example (disclaimer: I don't
intend to blame processx at all. Just for an example), the CRAN check
on the processx package currently fails with this warning on R-devel
Windows.

>     1. UTF-8 in stdout (test-utf8.R:85:3) - Invalid multi-byte character at end of stream ignored
https://cran.r-project.org/web/checks/check_results_processx.html

As far as I know, processx launches an external process and captures
its output, and I suspect the problem is that the output of the
process is encoded in non-UTF-8 while R assumes it's UTF-8. I
experienced similar problems with other packages as well, which
disappear if I switch the locale to the same one as the OS by
Sys.setlocale(). So, I think it would be great if there's some
guidance for the package authors on how to handle these properly.

Any suggestions?

Best,
Yutani


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Tue Dec 21 09:26:24 2021
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Tue, 21 Dec 2021 09:26:24 +0100
Subject: [Rd] R on Windows with UCRT and the system encoding
In-Reply-To: <CALyqOb_q=fy-ezTOHLrtEc-eW3TevUEy38az4tXtfeVFPrELxA@mail.gmail.com>
References: <CALyqOb_q=fy-ezTOHLrtEc-eW3TevUEy38az4tXtfeVFPrELxA@mail.gmail.com>
Message-ID: <449fe4b6-206e-c011-8cc9-f704f55ee886@gmail.com>

Hi Yutani,

On 12/21/21 6:34 AM, Hiroaki Yutani wrote:
> Hi,
>
> I'm more than excited about the announcement about the upcoming UTF-8
> R on Windows. Let me confirm my understanding. Is R 4.2 supposed to
> work on Windows with non-UTF-8 encoding as the system locale? I think
> this blog post indicates so (as this describes the older Windows than
> the UTF-8 era), but I'm not fully confident if I understand the
> details correctly.

R 4.2 will automatically use UTF-8 as the active code page (system 
locale) and the C library encoding and the R current native encoding on 
systems which allow this (recent Windows 10 and newer, Windows Server 
2022, etc). There is no way to opt-out from that, and of course no 
reason to, either. It does not matter of what is the system locale set 
in Windows for the whole system - these recent Windows allow individual 
applications to override the system-wide setting to UTF-8, which is what 
R does. Typically the system-wide setting will not be UTF-8, because 
many applications will not work with that.

On older systems, R 4.2 will run in some other system locale and the 
same C library encoding and R current native encoding - the same system 
default as R 4.1 would run on that system. So for some time, encoding 
support for this in R will have to stay, but eventually will be removed. 
But yes, R 4.2 is still supposed to work on such systems.

> https://developer.r-project.org/Blog/public/2021/12/07/upcoming-changes-in-r-4.2-on-windows/index.html
>
> If so, I'm curious what the package authors should do when the locales
> are different between OS and R. For example (disclaimer: I don't
> intend to blame processx at all. Just for an example), the CRAN check
> on the processx package currently fails with this warning on R-devel
> Windows.
>
>>      1. UTF-8 in stdout (test-utf8.R:85:3) - Invalid multi-byte character at end of stream ignored
> https://cran.r-project.org/web/checks/check_results_processx.html
>
> As far as I know, processx launches an external process and captures
> its output, and I suspect the problem is that the output of the
> process is encoded in non-UTF-8 while R assumes it's UTF-8. I
> experienced similar problems with other packages as well, which
> disappear if I switch the locale to the same one as the OS by
> Sys.setlocale(). So, I think it would be great if there's some
> guidance for the package authors on how to handle these properly.

Incidentally I've debugged this case and sent a detailed analysis to the 
maintainer, so he knows about the problem.

In short, you cannot assume in Windows that different applications use 
the same system encoding. That is not true at least with the invention 
of the fusion manifests which allow an application to switch to UTF-8 as 
system encoding, which R does. So, when using an external application on 
Windows, you need to know and respect a specific encoding used by that 
application on input and output.

As an example based on processx, you have an application which prints 
its argument to standard output. If you do it this way:

$ cat pr.c
#include <stdio.h>
#include <locale.h>
#include <string.h>
int main(int argc, char **argv) {

 ??????? printf("Locale set to: %s\n", setlocale(LC_ALL, ""));
 ??????? int i;
 ??????? for(i = 0; i < argc; i++) {
 ??????????????? printf("Argument %d\n", i);
 ??????????????? printf("%s\n", argv[i]);
 ??????????????? for(int j = 0; j < strlen(argv[i]); j++) {
 ??????????????????????? printf("byte[%d] is %x (%d)\n", i, (unsigned 
char)argv[i][j], (unsigned char)
 ??????????????? }
 ??????? }
 ??????? return 0;
}

the argument and hence output will be in the current native encoding of 
pr.c, because that's the encoding in which the argument will be received 
from Windows, so by default the system locale encoding, so by default 
not UTF-8 (on my system in Latin-1, as well as on CRAN check systems). 
One should also only use such programs with characters representable in 
Latin-1 on such systems. When you call such application from R with 
UTF-8 as native encoding, Windows will automatically convert the 
arguments to Latin-1.

The old Windows way to avoid this problem is to use the wide-character 
API (now UTF-16LE):

$ cat prw.c
#include <stdio.h>
#include <locale.h>
#include <string.h>

int wmain(int argc, wchar_t **argv) {

 ??????? int i;
 ??????? for(i = 0; i < argc; i++) {
 ??????????????? wprintf(L"Argument %d\n", i);
 ??????????????? wprintf(argv[i]);
 ??????????????? wprintf(L"\n");
 ??????????????? for(int j = 0; j < wcslen(argv[i]); j++)
 ??????????????????????? wprintf(L"Word[%d] %x\n", j, 
(unsigned)argv[i][j]);
 ??????? }
 ??????? return 0;
}

When you call such program from R with UTF-8 as native encoding, Windows 
will convert the arguments to UTF-16LE (so all characters will be 
representable). But you need to write Windows-specific code for this.

The new Windows way to avoid this problem is to use UTF-8 as the native 
encoding via the fusion manifest, as R does. You can use the "pr.c" as 
above, but with something like

$ cat pr.rc
#include <windows.h>
CREATEPROCESS_MANIFEST_RESOURCE_ID RT_MANIFEST "pr.manifest"

$ cat pr.manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
<assemblyIdentity
 ??? version="1.0.0.0"
 ??? processorArchitecture="amd64"
 ??? name="pr.exe"
 ??? type="win32"
/>
<application>
 ? <windowsSettings>
 ??? <activeCodePage 
xmlns="http://schemas.microsoft.com/SMI/2019/WindowsSettings">UTF-8</activeCodePage>
 ? </windowsSettings>
</application>
</assembly>

windres.exe -i pr.rc -o pr_rc.o
gcc -o pr pr.c pr_rc.o

When you build the application this way, it will use UTF-8 as native 
encoding, so when you call it from R (with UTF-8) as native encoding, no 
input conversion will occur. However, when you do this, the output from 
the application will also be in UTF-8.

So, for applications you control, my recommendation would be to make 
them use Unicode one of these two ways. Preferably the new one, with the 
fusion manifest. Only if it were a Windows-only application, and had to 
work on older Windows, then the wide-character version (but such apps 
are probably not in R packages).

When working with external applications you don't control, it is harder 
- you need to know which encoding they are expecting and producing, in 
whatever interface you use, and convert that, e.g. using iconv(). By the 
interface I mean that e.g., the command-line arguments are converted by 
Windows, but the input/output sent over a file/stream will not be.

Of course, this works the other way around as well. If you were using R 
with some other external applications expecting a different encoding, 
you would need to handle that (by conversions). With applications you 
control, it would make sense using this opportunity to switch to UTF-8. 
But, in principle, you can use iconv() from R directly or indirectly to 
convert input/output streams to/from a known encoding.

I am happy to give more suggestions if there is interest, but for that 
it would be useful to have a specific example (with processx, it is 
clear what the options R, there the application is controlled by the 
package).

Best
Tomas
>
> Any suggestions?
>
> Best,
> Yutani
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @|gbert @end|ng |rom w|w|@hu-ber||n@de  Tue Dec 21 14:58:46 2021
From: @|gbert @end|ng |rom w|w|@hu-ber||n@de (Sigbert Klinke)
Date: Tue, 21 Dec 2021 14:58:46 +0100
Subject: [Rd] Feature request: compareVersion
Message-ID: <c2d39aaf-807b-0ac9-38cc-f8bd8a4a00be@wiwi.hu-berlin.de>

Hi,

currently I have to use

compareVersion(as.character(packageVersion("shiny")), "0.11")

It would be nice if compareVersion would make the as.character 
internally, rather then force the user to do it.

Thanks

Sigbert

-- 
https://hu.berlin/sk
https://www.stat.de/faqs
https://hu.berlin/mmstat
https://hu.berlin/mmstat-int
https://hu.berlin/mmstat-ar


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Tue Dec 21 15:19:14 2021
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Tue, 21 Dec 2021 15:19:14 +0100
Subject: [Rd] Feature request: compareVersion
In-Reply-To: <c2d39aaf-807b-0ac9-38cc-f8bd8a4a00be@wiwi.hu-berlin.de>
References: <c2d39aaf-807b-0ac9-38cc-f8bd8a4a00be@wiwi.hu-berlin.de>
Message-ID: <25025.57954.319849.301131@stat.math.ethz.ch>


> Hi,
> currently I have to use

> compareVersion(as.character(packageVersion("shiny")), "0.11")

> It would be nice if compareVersion would make the as.character 
> internally, rather then force the user to do it.

> Thanks
> Sigbert

Well, if you follow the help page examples of packageVersion()
you would use

> packageVersion("Matrix") >= "1.4.0"
[1] TRUE
> packageVersion("shiny") >= "0.11"
[1] TRUE
>


From @|gbert @end|ng |rom w|w|@hu-ber||n@de  Tue Dec 21 15:41:07 2021
From: @|gbert @end|ng |rom w|w|@hu-ber||n@de (Sigbert Klinke)
Date: Tue, 21 Dec 2021 15:41:07 +0100
Subject: [Rd] Feature request: compareVersion
In-Reply-To: <25025.57954.319849.301131@stat.math.ethz.ch>
References: <c2d39aaf-807b-0ac9-38cc-f8bd8a4a00be@wiwi.hu-berlin.de>
 <25025.57954.319849.301131@stat.math.ethz.ch>
Message-ID: <1470a7d1-6dcb-46a0-4029-b1ae6c22faa4@wiwi.hu-berlin.de>

Hi,

compareVersion returns -1, 0, or 1 rather than TRUE or FALSE which could 
be used in computing.

Sigbert

Am 21.12.21 um 15:19 schrieb Martin Maechler:
> 
>> Hi,
>> currently I have to use
> 
>> compareVersion(as.character(packageVersion("shiny")), "0.11")
> 
>> It would be nice if compareVersion would make the as.character
>> internally, rather then force the user to do it.
> 
>> Thanks
>> Sigbert
> 
> Well, if you follow the help page examples of packageVersion()
> you would use
> 
>> packageVersion("Matrix") >= "1.4.0"
> [1] TRUE
>> packageVersion("shiny") >= "0.11"
> [1] TRUE
>>


-- 
https://hu.berlin/sk
https://www.stat.de/faqs
https://hu.berlin/mmstat
https://hu.berlin/mmstat-int
https://hu.berlin/mmstat-ar


From yut@n|@|n| @end|ng |rom gm@||@com  Tue Dec 21 15:47:51 2021
From: yut@n|@|n| @end|ng |rom gm@||@com (Hiroaki Yutani)
Date: Tue, 21 Dec 2021 23:47:51 +0900
Subject: [Rd] R on Windows with UCRT and the system encoding
In-Reply-To: <449fe4b6-206e-c011-8cc9-f704f55ee886@gmail.com>
References: <CALyqOb_q=fy-ezTOHLrtEc-eW3TevUEy38az4tXtfeVFPrELxA@mail.gmail.com>
 <449fe4b6-206e-c011-8cc9-f704f55ee886@gmail.com>
Message-ID: <CALyqOb9c5jKEshXuL+CGu1mxNkzx3660yqep6LSOtwf=6Ua8FA@mail.gmail.com>

Hi Tomas,

Thank you very much for the detailed explanation! I think now I have a
bit better understanding on how the things work; at least now I know I
didn't understand the concept of "active code page". I'll follow your
advice when I need to fix the packages that need some tweaks to handle
UTF-8 properly.

Sorry, I'd like to ask one more question related to locale. If I copy
the following text and execute `read.csv("clipboard")`, it returns
"uao" instead of "???" (the characters are transliterated).

    "col1","col2"
    "???","???"


While this is probably the status quo (the same behavior on R 4.1) on
Latin-1 encoding, things are worse on CJK locales. If I try,

    "col1","col2"
    "?","?"

I get the following error:

    > read.csv("clipboard")
    Error in type.convert.default(data[[i]], as.is = as.is[i], dec = dec,  :
      invalid multibyte string at '<82><a0>'

Is this supposed to work? It seems the characters are encoded as CP932
(my system locale) but marked as UTF-8.

    > x <- utils:::readClipboard()
    > x
    [1] "\"col1\",\"col2\""         "\"\x82\xa0\",\"\x82\xa2\""
    > iconv(x, from = "CP932", to = "UTF-8")
    [1] "\"col1\",\"col2\"" "\"?\",\"?\""

I read the source code of readClipboard() in
src/library/utils/src/windows/util.c, but have no idea if there's
anything that needs to be fixed.

Best,
Yutani

2021?12?21?(?) 17:26 Tomas Kalibera <tomas.kalibera at gmail.com>:





>
> Hi Yutani,
>
> On 12/21/21 6:34 AM, Hiroaki Yutani wrote:
> > Hi,
> >
> > I'm more than excited about the announcement about the upcoming UTF-8
> > R on Windows. Let me confirm my understanding. Is R 4.2 supposed to
> > work on Windows with non-UTF-8 encoding as the system locale? I think
> > this blog post indicates so (as this describes the older Windows than
> > the UTF-8 era), but I'm not fully confident if I understand the
> > details correctly.
>
> R 4.2 will automatically use UTF-8 as the active code page (system
> locale) and the C library encoding and the R current native encoding on
> systems which allow this (recent Windows 10 and newer, Windows Server
> 2022, etc). There is no way to opt-out from that, and of course no
> reason to, either. It does not matter of what is the system locale set
> in Windows for the whole system - these recent Windows allow individual
> applications to override the system-wide setting to UTF-8, which is what
> R does. Typically the system-wide setting will not be UTF-8, because
> many applications will not work with that.
>
> On older systems, R 4.2 will run in some other system locale and the
> same C library encoding and R current native encoding - the same system
> default as R 4.1 would run on that system. So for some time, encoding
> support for this in R will have to stay, but eventually will be removed.
> But yes, R 4.2 is still supposed to work on such systems.
>
> > https://developer.r-project.org/Blog/public/2021/12/07/upcoming-changes-in-r-4.2-on-windows/index.html
> >
> > If so, I'm curious what the package authors should do when the locales
> > are different between OS and R. For example (disclaimer: I don't
> > intend to blame processx at all. Just for an example), the CRAN check
> > on the processx package currently fails with this warning on R-devel
> > Windows.
> >
> >>      1. UTF-8 in stdout (test-utf8.R:85:3) - Invalid multi-byte character at end of stream ignored
> > https://cran.r-project.org/web/checks/check_results_processx.html
> >
> > As far as I know, processx launches an external process and captures
> > its output, and I suspect the problem is that the output of the
> > process is encoded in non-UTF-8 while R assumes it's UTF-8. I
> > experienced similar problems with other packages as well, which
> > disappear if I switch the locale to the same one as the OS by
> > Sys.setlocale(). So, I think it would be great if there's some
> > guidance for the package authors on how to handle these properly.
>
> Incidentally I've debugged this case and sent a detailed analysis to the
> maintainer, so he knows about the problem.
>
> In short, you cannot assume in Windows that different applications use
> the same system encoding. That is not true at least with the invention
> of the fusion manifests which allow an application to switch to UTF-8 as
> system encoding, which R does. So, when using an external application on
> Windows, you need to know and respect a specific encoding used by that
> application on input and output.
>
> As an example based on processx, you have an application which prints
> its argument to standard output. If you do it this way:
>
> $ cat pr.c
> #include <stdio.h>
> #include <locale.h>
> #include <string.h>
> int main(int argc, char **argv) {
>
>          printf("Locale set to: %s\n", setlocale(LC_ALL, ""));
>          int i;
>          for(i = 0; i < argc; i++) {
>                  printf("Argument %d\n", i);
>                  printf("%s\n", argv[i]);
>                  for(int j = 0; j < strlen(argv[i]); j++) {
>                          printf("byte[%d] is %x (%d)\n", i, (unsigned
> char)argv[i][j], (unsigned char)
>                  }
>          }
>          return 0;
> }
>
> the argument and hence output will be in the current native encoding of
> pr.c, because that's the encoding in which the argument will be received
> from Windows, so by default the system locale encoding, so by default
> not UTF-8 (on my system in Latin-1, as well as on CRAN check systems).
> One should also only use such programs with characters representable in
> Latin-1 on such systems. When you call such application from R with
> UTF-8 as native encoding, Windows will automatically convert the
> arguments to Latin-1.
>
> The old Windows way to avoid this problem is to use the wide-character
> API (now UTF-16LE):
>
> $ cat prw.c
> #include <stdio.h>
> #include <locale.h>
> #include <string.h>
>
> int wmain(int argc, wchar_t **argv) {
>
>          int i;
>          for(i = 0; i < argc; i++) {
>                  wprintf(L"Argument %d\n", i);
>                  wprintf(argv[i]);
>                  wprintf(L"\n");
>                  for(int j = 0; j < wcslen(argv[i]); j++)
>                          wprintf(L"Word[%d] %x\n", j,
> (unsigned)argv[i][j]);
>          }
>          return 0;
> }
>
> When you call such program from R with UTF-8 as native encoding, Windows
> will convert the arguments to UTF-16LE (so all characters will be
> representable). But you need to write Windows-specific code for this.
>
> The new Windows way to avoid this problem is to use UTF-8 as the native
> encoding via the fusion manifest, as R does. You can use the "pr.c" as
> above, but with something like
>
> $ cat pr.rc
> #include <windows.h>
> CREATEPROCESS_MANIFEST_RESOURCE_ID RT_MANIFEST "pr.manifest"
>
> $ cat pr.manifest
> <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
> <assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
> <assemblyIdentity
>      version="1.0.0.0"
>      processorArchitecture="amd64"
>      name="pr.exe"
>      type="win32"
> />
> <application>
>    <windowsSettings>
>      <activeCodePage
> xmlns="http://schemas.microsoft.com/SMI/2019/WindowsSettings">UTF-8</activeCodePage>
>    </windowsSettings>
> </application>
> </assembly>
>
> windres.exe -i pr.rc -o pr_rc.o
> gcc -o pr pr.c pr_rc.o
>
> When you build the application this way, it will use UTF-8 as native
> encoding, so when you call it from R (with UTF-8) as native encoding, no
> input conversion will occur. However, when you do this, the output from
> the application will also be in UTF-8.
>
> So, for applications you control, my recommendation would be to make
> them use Unicode one of these two ways. Preferably the new one, with the
> fusion manifest. Only if it were a Windows-only application, and had to
> work on older Windows, then the wide-character version (but such apps
> are probably not in R packages).
>
> When working with external applications you don't control, it is harder
> - you need to know which encoding they are expecting and producing, in
> whatever interface you use, and convert that, e.g. using iconv(). By the
> interface I mean that e.g., the command-line arguments are converted by
> Windows, but the input/output sent over a file/stream will not be.
>
> Of course, this works the other way around as well. If you were using R
> with some other external applications expecting a different encoding,
> you would need to handle that (by conversions). With applications you
> control, it would make sense using this opportunity to switch to UTF-8.
> But, in principle, you can use iconv() from R directly or indirectly to
> convert input/output streams to/from a known encoding.
>
> I am happy to give more suggestions if there is interest, but for that
> it would be useful to have a specific example (with processx, it is
> clear what the options R, there the application is controlled by the
> package).
>
> Best
> Tomas
> >
> > Any suggestions?
> >
> > Best,
> > Yutani
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Tue Dec 21 16:23:49 2021
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Tue, 21 Dec 2021 16:23:49 +0100
Subject: [Rd] R on Windows with UCRT and the system encoding
In-Reply-To: <CALyqOb9c5jKEshXuL+CGu1mxNkzx3660yqep6LSOtwf=6Ua8FA@mail.gmail.com>
References: <CALyqOb_q=fy-ezTOHLrtEc-eW3TevUEy38az4tXtfeVFPrELxA@mail.gmail.com>
 <449fe4b6-206e-c011-8cc9-f704f55ee886@gmail.com>
 <CALyqOb9c5jKEshXuL+CGu1mxNkzx3660yqep6LSOtwf=6Ua8FA@mail.gmail.com>
Message-ID: <a543a46b-64cf-f616-3f23-69e5e482db22@gmail.com>

Hi Yutani,

On 12/21/21 3:47 PM, Hiroaki Yutani wrote:
> Hi Tomas,
>
> Thank you very much for the detailed explanation! I think now I have a
> bit better understanding on how the things work; at least now I know I
> didn't understand the concept of "active code page". I'll follow your
> advice when I need to fix the packages that need some tweaks to handle
> UTF-8 properly.
>
> Sorry, I'd like to ask one more question related to locale. If I copy
> the following text and execute `read.csv("clipboard")`, it returns
> "uao" instead of "???" (the characters are transliterated).
>
>      "col1","col2"
>      "???","???"
>
>
> While this is probably the status quo (the same behavior on R 4.1) on
> Latin-1 encoding, things are worse on CJK locales. If I try,
>
>      "col1","col2"
>      "?","?"
>
> I get the following error:
>
>      > read.csv("clipboard")
>      Error in type.convert.default(data[[i]], as.is = as.is[i], dec = dec,  :
>        invalid multibyte string at '<82><a0>'
>
> Is this supposed to work? It seems the characters are encoded as CP932
> (my system locale) but marked as UTF-8.
>
>      > x <- utils:::readClipboard()
>      > x
>      [1] "\"col1\",\"col2\""         "\"\x82\xa0\",\"\x82\xa2\""
>      > iconv(x, from = "CP932", to = "UTF-8")
>      [1] "\"col1\",\"col2\"" "\"?\",\"?\""
>
> I read the source code of readClipboard() in
> src/library/utils/src/windows/util.c, but have no idea if there's
> anything that needs to be fixed.

Yes, this should work. I can reproduce the problem on my system, the 
clipboard apparently contains the Unicode characters, but R does not get 
them correctly, and from my quick read, it is a bug in R.

My guess is this is in connections.c, where we call 
GetClipboardData(CF_TEXT). Perhaps if we used CF_UNICODETEXT, it would 
work (or alternatively CF_TEXT but also CF_LOCALE to find out what is 
the locale used, but CF_UNICODETEXT seems simpler). See
https://docs.microsoft.com/en-us/windows/win32/dataxchg/standard-clipboard-formats

As you started looking at the code, would you like to try 
debugging/fixing this?

Best
Tomas

>
> Best,
> Yutani
>
> 2021?12?21?(?) 17:26 Tomas Kalibera <tomas.kalibera at gmail.com>:
>
>
>
>
>
>> Hi Yutani,
>>
>> On 12/21/21 6:34 AM, Hiroaki Yutani wrote:
>>> Hi,
>>>
>>> I'm more than excited about the announcement about the upcoming UTF-8
>>> R on Windows. Let me confirm my understanding. Is R 4.2 supposed to
>>> work on Windows with non-UTF-8 encoding as the system locale? I think
>>> this blog post indicates so (as this describes the older Windows than
>>> the UTF-8 era), but I'm not fully confident if I understand the
>>> details correctly.
>> R 4.2 will automatically use UTF-8 as the active code page (system
>> locale) and the C library encoding and the R current native encoding on
>> systems which allow this (recent Windows 10 and newer, Windows Server
>> 2022, etc). There is no way to opt-out from that, and of course no
>> reason to, either. It does not matter of what is the system locale set
>> in Windows for the whole system - these recent Windows allow individual
>> applications to override the system-wide setting to UTF-8, which is what
>> R does. Typically the system-wide setting will not be UTF-8, because
>> many applications will not work with that.
>>
>> On older systems, R 4.2 will run in some other system locale and the
>> same C library encoding and R current native encoding - the same system
>> default as R 4.1 would run on that system. So for some time, encoding
>> support for this in R will have to stay, but eventually will be removed.
>> But yes, R 4.2 is still supposed to work on such systems.
>>
>>> https://developer.r-project.org/Blog/public/2021/12/07/upcoming-changes-in-r-4.2-on-windows/index.html
>>>
>>> If so, I'm curious what the package authors should do when the locales
>>> are different between OS and R. For example (disclaimer: I don't
>>> intend to blame processx at all. Just for an example), the CRAN check
>>> on the processx package currently fails with this warning on R-devel
>>> Windows.
>>>
>>>>       1. UTF-8 in stdout (test-utf8.R:85:3) - Invalid multi-byte character at end of stream ignored
>>> https://cran.r-project.org/web/checks/check_results_processx.html
>>>
>>> As far as I know, processx launches an external process and captures
>>> its output, and I suspect the problem is that the output of the
>>> process is encoded in non-UTF-8 while R assumes it's UTF-8. I
>>> experienced similar problems with other packages as well, which
>>> disappear if I switch the locale to the same one as the OS by
>>> Sys.setlocale(). So, I think it would be great if there's some
>>> guidance for the package authors on how to handle these properly.
>> Incidentally I've debugged this case and sent a detailed analysis to the
>> maintainer, so he knows about the problem.
>>
>> In short, you cannot assume in Windows that different applications use
>> the same system encoding. That is not true at least with the invention
>> of the fusion manifests which allow an application to switch to UTF-8 as
>> system encoding, which R does. So, when using an external application on
>> Windows, you need to know and respect a specific encoding used by that
>> application on input and output.
>>
>> As an example based on processx, you have an application which prints
>> its argument to standard output. If you do it this way:
>>
>> $ cat pr.c
>> #include <stdio.h>
>> #include <locale.h>
>> #include <string.h>
>> int main(int argc, char **argv) {
>>
>>           printf("Locale set to: %s\n", setlocale(LC_ALL, ""));
>>           int i;
>>           for(i = 0; i < argc; i++) {
>>                   printf("Argument %d\n", i);
>>                   printf("%s\n", argv[i]);
>>                   for(int j = 0; j < strlen(argv[i]); j++) {
>>                           printf("byte[%d] is %x (%d)\n", i, (unsigned
>> char)argv[i][j], (unsigned char)
>>                   }
>>           }
>>           return 0;
>> }
>>
>> the argument and hence output will be in the current native encoding of
>> pr.c, because that's the encoding in which the argument will be received
>> from Windows, so by default the system locale encoding, so by default
>> not UTF-8 (on my system in Latin-1, as well as on CRAN check systems).
>> One should also only use such programs with characters representable in
>> Latin-1 on such systems. When you call such application from R with
>> UTF-8 as native encoding, Windows will automatically convert the
>> arguments to Latin-1.
>>
>> The old Windows way to avoid this problem is to use the wide-character
>> API (now UTF-16LE):
>>
>> $ cat prw.c
>> #include <stdio.h>
>> #include <locale.h>
>> #include <string.h>
>>
>> int wmain(int argc, wchar_t **argv) {
>>
>>           int i;
>>           for(i = 0; i < argc; i++) {
>>                   wprintf(L"Argument %d\n", i);
>>                   wprintf(argv[i]);
>>                   wprintf(L"\n");
>>                   for(int j = 0; j < wcslen(argv[i]); j++)
>>                           wprintf(L"Word[%d] %x\n", j,
>> (unsigned)argv[i][j]);
>>           }
>>           return 0;
>> }
>>
>> When you call such program from R with UTF-8 as native encoding, Windows
>> will convert the arguments to UTF-16LE (so all characters will be
>> representable). But you need to write Windows-specific code for this.
>>
>> The new Windows way to avoid this problem is to use UTF-8 as the native
>> encoding via the fusion manifest, as R does. You can use the "pr.c" as
>> above, but with something like
>>
>> $ cat pr.rc
>> #include <windows.h>
>> CREATEPROCESS_MANIFEST_RESOURCE_ID RT_MANIFEST "pr.manifest"
>>
>> $ cat pr.manifest
>> <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
>> <assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
>> <assemblyIdentity
>>       version="1.0.0.0"
>>       processorArchitecture="amd64"
>>       name="pr.exe"
>>       type="win32"
>> />
>> <application>
>>     <windowsSettings>
>>       <activeCodePage
>> xmlns="http://schemas.microsoft.com/SMI/2019/WindowsSettings">UTF-8</activeCodePage>
>>     </windowsSettings>
>> </application>
>> </assembly>
>>
>> windres.exe -i pr.rc -o pr_rc.o
>> gcc -o pr pr.c pr_rc.o
>>
>> When you build the application this way, it will use UTF-8 as native
>> encoding, so when you call it from R (with UTF-8) as native encoding, no
>> input conversion will occur. However, when you do this, the output from
>> the application will also be in UTF-8.
>>
>> So, for applications you control, my recommendation would be to make
>> them use Unicode one of these two ways. Preferably the new one, with the
>> fusion manifest. Only if it were a Windows-only application, and had to
>> work on older Windows, then the wide-character version (but such apps
>> are probably not in R packages).
>>
>> When working with external applications you don't control, it is harder
>> - you need to know which encoding they are expecting and producing, in
>> whatever interface you use, and convert that, e.g. using iconv(). By the
>> interface I mean that e.g., the command-line arguments are converted by
>> Windows, but the input/output sent over a file/stream will not be.
>>
>> Of course, this works the other way around as well. If you were using R
>> with some other external applications expecting a different encoding,
>> you would need to handle that (by conversions). With applications you
>> control, it would make sense using this opportunity to switch to UTF-8.
>> But, in principle, you can use iconv() from R directly or indirectly to
>> convert input/output streams to/from a known encoding.
>>
>> I am happy to give more suggestions if there is interest, but for that
>> it would be useful to have a specific example (with processx, it is
>> clear what the options R, there the application is controlled by the
>> package).
>>
>> Best
>> Tomas
>>> Any suggestions?
>>>
>>> Best,
>>> Yutani
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Tue Dec 21 17:03:18 2021
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Tue, 21 Dec 2021 11:03:18 -0500
Subject: [Rd] Feature request: compareVersion
In-Reply-To: <1470a7d1-6dcb-46a0-4029-b1ae6c22faa4@wiwi.hu-berlin.de>
References: <c2d39aaf-807b-0ac9-38cc-f8bd8a4a00be@wiwi.hu-berlin.de>
 <25025.57954.319849.301131@stat.math.ethz.ch>
 <1470a7d1-6dcb-46a0-4029-b1ae6c22faa4@wiwi.hu-berlin.de>
Message-ID: <aa26d0b5-5ad2-2fb2-d958-52543eb40a00@gmail.com>

On 21/12/2021 9:41 a.m., Sigbert Klinke wrote:
> Hi,
> 
> compareVersion returns -1, 0, or 1 rather than TRUE or FALSE which could
> be used in computing.
> 

I'm not sure where you would need the 3 level value, but this would give 
it to you:

(packageVersion("shiny") > "0.11") - (pacageVersion("shiny") < "0.11")

Duncan Murdoch

> Sigbert
> 
> Am 21.12.21 um 15:19 schrieb Martin Maechler:
>>
>>> Hi,
>>> currently I have to use
>>
>>> compareVersion(as.character(packageVersion("shiny")), "0.11")
>>
>>> It would be nice if compareVersion would make the as.character
>>> internally, rather then force the user to do it.
>>
>>> Thanks
>>> Sigbert
>>
>> Well, if you follow the help page examples of packageVersion()
>> you would use
>>
>>> packageVersion("Matrix") >= "1.4.0"
>> [1] TRUE
>>> packageVersion("shiny") >= "0.11"
>> [1] TRUE
>>>
> 
>


From yut@n|@|n| @end|ng |rom gm@||@com  Wed Dec 22 03:40:21 2021
From: yut@n|@|n| @end|ng |rom gm@||@com (Hiroaki Yutani)
Date: Wed, 22 Dec 2021 11:40:21 +0900
Subject: [Rd] R on Windows with UCRT and the system encoding
In-Reply-To: <a543a46b-64cf-f616-3f23-69e5e482db22@gmail.com>
References: <CALyqOb_q=fy-ezTOHLrtEc-eW3TevUEy38az4tXtfeVFPrELxA@mail.gmail.com>
 <449fe4b6-206e-c011-8cc9-f704f55ee886@gmail.com>
 <CALyqOb9c5jKEshXuL+CGu1mxNkzx3660yqep6LSOtwf=6Ua8FA@mail.gmail.com>
 <a543a46b-64cf-f616-3f23-69e5e482db22@gmail.com>
Message-ID: <CALyqOb977pgRvezqNZ4ig-hm_jQ9DQnNmxSWoRXKyrdNcJr8EA@mail.gmail.com>

Hi Tomas,

Thanks for your prompt reply and spotting the right place. While I'm
not good at C/C++ things, I'll try investigating this and, if
possible, creating some patch to fix the issue. As the UTF-8 R on
Windows is really exciting news to us in CJK locale, I'd like to do my
best to help making the upcoming release a success.

I'll report on Bugzilla with more thetails first. Thanks for your support.

Best,
Yutani

2021?12?22?(?) 0:23 Tomas Kalibera <tomas.kalibera at gmail.com>:

>
> Hi Yutani,
>
> On 12/21/21 3:47 PM, Hiroaki Yutani wrote:
> > Hi Tomas,
> >
> > Thank you very much for the detailed explanation! I think now I have a
> > bit better understanding on how the things work; at least now I know I
> > didn't understand the concept of "active code page". I'll follow your
> > advice when I need to fix the packages that need some tweaks to handle
> > UTF-8 properly.
> >
> > Sorry, I'd like to ask one more question related to locale. If I copy
> > the following text and execute `read.csv("clipboard")`, it returns
> > "uao" instead of "???" (the characters are transliterated).
> >
> >      "col1","col2"
> >      "???","???"
> >
> >
> > While this is probably the status quo (the same behavior on R 4.1) on
> > Latin-1 encoding, things are worse on CJK locales. If I try,
> >
> >      "col1","col2"
> >      "?","?"
> >
> > I get the following error:
> >
> >      > read.csv("clipboard")
> >      Error in type.convert.default(data[[i]], as.is = as.is[i], dec = dec,  :
> >        invalid multibyte string at '<82><a0>'
> >
> > Is this supposed to work? It seems the characters are encoded as CP932
> > (my system locale) but marked as UTF-8.
> >
> >      > x <- utils:::readClipboard()
> >      > x
> >      [1] "\"col1\",\"col2\""         "\"\x82\xa0\",\"\x82\xa2\""
> >      > iconv(x, from = "CP932", to = "UTF-8")
> >      [1] "\"col1\",\"col2\"" "\"?\",\"?\""
> >
> > I read the source code of readClipboard() in
> > src/library/utils/src/windows/util.c, but have no idea if there's
> > anything that needs to be fixed.
>
> Yes, this should work. I can reproduce the problem on my system, the
> clipboard apparently contains the Unicode characters, but R does not get
> them correctly, and from my quick read, it is a bug in R.
>
> My guess is this is in connections.c, where we call
> GetClipboardData(CF_TEXT). Perhaps if we used CF_UNICODETEXT, it would
> work (or alternatively CF_TEXT but also CF_LOCALE to find out what is
> the locale used, but CF_UNICODETEXT seems simpler). See
> https://docs.microsoft.com/en-us/windows/win32/dataxchg/standard-clipboard-formats
>
> As you started looking at the code, would you like to try
> debugging/fixing this?
>
> Best
> Tomas
>
> >
> > Best,
> > Yutani
> >
> > 2021?12?21?(?) 17:26 Tomas Kalibera <tomas.kalibera at gmail.com>:
> >
> >
> >
> >
> >
> >> Hi Yutani,
> >>
> >> On 12/21/21 6:34 AM, Hiroaki Yutani wrote:
> >>> Hi,
> >>>
> >>> I'm more than excited about the announcement about the upcoming UTF-8
> >>> R on Windows. Let me confirm my understanding. Is R 4.2 supposed to
> >>> work on Windows with non-UTF-8 encoding as the system locale? I think
> >>> this blog post indicates so (as this describes the older Windows than
> >>> the UTF-8 era), but I'm not fully confident if I understand the
> >>> details correctly.
> >> R 4.2 will automatically use UTF-8 as the active code page (system
> >> locale) and the C library encoding and the R current native encoding on
> >> systems which allow this (recent Windows 10 and newer, Windows Server
> >> 2022, etc). There is no way to opt-out from that, and of course no
> >> reason to, either. It does not matter of what is the system locale set
> >> in Windows for the whole system - these recent Windows allow individual
> >> applications to override the system-wide setting to UTF-8, which is what
> >> R does. Typically the system-wide setting will not be UTF-8, because
> >> many applications will not work with that.
> >>
> >> On older systems, R 4.2 will run in some other system locale and the
> >> same C library encoding and R current native encoding - the same system
> >> default as R 4.1 would run on that system. So for some time, encoding
> >> support for this in R will have to stay, but eventually will be removed.
> >> But yes, R 4.2 is still supposed to work on such systems.
> >>
> >>> https://developer.r-project.org/Blog/public/2021/12/07/upcoming-changes-in-r-4.2-on-windows/index.html
> >>>
> >>> If so, I'm curious what the package authors should do when the locales
> >>> are different between OS and R. For example (disclaimer: I don't
> >>> intend to blame processx at all. Just for an example), the CRAN check
> >>> on the processx package currently fails with this warning on R-devel
> >>> Windows.
> >>>
> >>>>       1. UTF-8 in stdout (test-utf8.R:85:3) - Invalid multi-byte character at end of stream ignored
> >>> https://cran.r-project.org/web/checks/check_results_processx.html
> >>>
> >>> As far as I know, processx launches an external process and captures
> >>> its output, and I suspect the problem is that the output of the
> >>> process is encoded in non-UTF-8 while R assumes it's UTF-8. I
> >>> experienced similar problems with other packages as well, which
> >>> disappear if I switch the locale to the same one as the OS by
> >>> Sys.setlocale(). So, I think it would be great if there's some
> >>> guidance for the package authors on how to handle these properly.
> >> Incidentally I've debugged this case and sent a detailed analysis to the
> >> maintainer, so he knows about the problem.
> >>
> >> In short, you cannot assume in Windows that different applications use
> >> the same system encoding. That is not true at least with the invention
> >> of the fusion manifests which allow an application to switch to UTF-8 as
> >> system encoding, which R does. So, when using an external application on
> >> Windows, you need to know and respect a specific encoding used by that
> >> application on input and output.
> >>
> >> As an example based on processx, you have an application which prints
> >> its argument to standard output. If you do it this way:
> >>
> >> $ cat pr.c
> >> #include <stdio.h>
> >> #include <locale.h>
> >> #include <string.h>
> >> int main(int argc, char **argv) {
> >>
> >>           printf("Locale set to: %s\n", setlocale(LC_ALL, ""));
> >>           int i;
> >>           for(i = 0; i < argc; i++) {
> >>                   printf("Argument %d\n", i);
> >>                   printf("%s\n", argv[i]);
> >>                   for(int j = 0; j < strlen(argv[i]); j++) {
> >>                           printf("byte[%d] is %x (%d)\n", i, (unsigned
> >> char)argv[i][j], (unsigned char)
> >>                   }
> >>           }
> >>           return 0;
> >> }
> >>
> >> the argument and hence output will be in the current native encoding of
> >> pr.c, because that's the encoding in which the argument will be received
> >> from Windows, so by default the system locale encoding, so by default
> >> not UTF-8 (on my system in Latin-1, as well as on CRAN check systems).
> >> One should also only use such programs with characters representable in
> >> Latin-1 on such systems. When you call such application from R with
> >> UTF-8 as native encoding, Windows will automatically convert the
> >> arguments to Latin-1.
> >>
> >> The old Windows way to avoid this problem is to use the wide-character
> >> API (now UTF-16LE):
> >>
> >> $ cat prw.c
> >> #include <stdio.h>
> >> #include <locale.h>
> >> #include <string.h>
> >>
> >> int wmain(int argc, wchar_t **argv) {
> >>
> >>           int i;
> >>           for(i = 0; i < argc; i++) {
> >>                   wprintf(L"Argument %d\n", i);
> >>                   wprintf(argv[i]);
> >>                   wprintf(L"\n");
> >>                   for(int j = 0; j < wcslen(argv[i]); j++)
> >>                           wprintf(L"Word[%d] %x\n", j,
> >> (unsigned)argv[i][j]);
> >>           }
> >>           return 0;
> >> }
> >>
> >> When you call such program from R with UTF-8 as native encoding, Windows
> >> will convert the arguments to UTF-16LE (so all characters will be
> >> representable). But you need to write Windows-specific code for this.
> >>
> >> The new Windows way to avoid this problem is to use UTF-8 as the native
> >> encoding via the fusion manifest, as R does. You can use the "pr.c" as
> >> above, but with something like
> >>
> >> $ cat pr.rc
> >> #include <windows.h>
> >> CREATEPROCESS_MANIFEST_RESOURCE_ID RT_MANIFEST "pr.manifest"
> >>
> >> $ cat pr.manifest
> >> <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
> >> <assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
> >> <assemblyIdentity
> >>       version="1.0.0.0"
> >>       processorArchitecture="amd64"
> >>       name="pr.exe"
> >>       type="win32"
> >> />
> >> <application>
> >>     <windowsSettings>
> >>       <activeCodePage
> >> xmlns="http://schemas.microsoft.com/SMI/2019/WindowsSettings">UTF-8</activeCodePage>
> >>     </windowsSettings>
> >> </application>
> >> </assembly>
> >>
> >> windres.exe -i pr.rc -o pr_rc.o
> >> gcc -o pr pr.c pr_rc.o
> >>
> >> When you build the application this way, it will use UTF-8 as native
> >> encoding, so when you call it from R (with UTF-8) as native encoding, no
> >> input conversion will occur. However, when you do this, the output from
> >> the application will also be in UTF-8.
> >>
> >> So, for applications you control, my recommendation would be to make
> >> them use Unicode one of these two ways. Preferably the new one, with the
> >> fusion manifest. Only if it were a Windows-only application, and had to
> >> work on older Windows, then the wide-character version (but such apps
> >> are probably not in R packages).
> >>
> >> When working with external applications you don't control, it is harder
> >> - you need to know which encoding they are expecting and producing, in
> >> whatever interface you use, and convert that, e.g. using iconv(). By the
> >> interface I mean that e.g., the command-line arguments are converted by
> >> Windows, but the input/output sent over a file/stream will not be.
> >>
> >> Of course, this works the other way around as well. If you were using R
> >> with some other external applications expecting a different encoding,
> >> you would need to handle that (by conversions). With applications you
> >> control, it would make sense using this opportunity to switch to UTF-8.
> >> But, in principle, you can use iconv() from R directly or indirectly to
> >> convert input/output streams to/from a known encoding.
> >>
> >> I am happy to give more suggestions if there is interest, but for that
> >> it would be useful to have a specific example (with processx, it is
> >> clear what the options R, there the application is controlled by the
> >> package).
> >>
> >> Best
> >> Tomas
> >>> Any suggestions?
> >>>
> >>> Best,
> >>> Yutani
> >>>
> >>> ______________________________________________
> >>> R-devel at r-project.org mailing list
> >>> https://stat.ethz.ch/mailman/listinfo/r-devel


From kry|ov@r00t @end|ng |rom gm@||@com  Wed Dec 22 14:55:09 2021
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Wed, 22 Dec 2021 16:55:09 +0300
Subject: [Rd] hashtab address arg
In-Reply-To: <CAGho6Qs+TEDh4CqaSq8mWvM0_E9HtCq1AUtX49yyOjnRxYnJTA@mail.gmail.com>
References: <CAGho6Qs+TEDh4CqaSq8mWvM0_E9HtCq1AUtX49yyOjnRxYnJTA@mail.gmail.com>
Message-ID: <20211222165509.079abe35@arachnoid>

On Sat, 18 Dec 2021 11:50:54 +0100
Arnaud FELD <arnaud.feldmann at gmail.com> wrote:

> However, I'm a bit troubled about the "address" argument. What is it
> intended for since (as far as I know) "address equality" is until now
> something that isn't really let for the user to decide within R.

Using the words from "Extending R" by John M. Chambers, the concept of
address identity could be related to the question:

>> If some of the data in the object has changed, is this still the
>> same object?

Most objects in R are defined by their content. If you had a 100x100
matrix and changed an element at [50,50], it's now a different matrix,
even if it's stored in the same variable. If you create another 100x100
matrix in a different variable but fill it with the same numbers, it
should still compare equal to your original matrix.

Not all types of R objects are like that. Environments are good
candidates for pointer equality comparison. For example, the contents
of the global environment change every time you assign some variable in
the R command line, but it remains the same global environment. Indeed,
identical() for environments just compares their pointers: even if two
different environments only contain objects that compare equal, they
cannot be considered the same environment, because different closures
might be referring to them. Similar are data.tables: if you had a giant
dataset and, as part of cleaning it up, removed some outliers, perhaps
it should be considered the same dataset, even if the contents aren't
strictly the same any more. Same goes for reference class and R6
objects: unlike the pass-by-value semantics associated with most
objects in R, these are assumed to carry global state within them, and
modifications to them are reflected everywhere they are referenced, not
limited to the current function call.

I *think* that most (if not all) objects with reference semantics
already use pointer comparison when being compared by identical(), so
the default of "identical" is, as the help page says, almost always the
right choice, but if it matters to your code whether the objects are
actually stored in the same area in the memory, use hashes of type
"address".

(Perhaps this topic could be a better fit for R-help.)

-- 
Best regards,
Ivan


From iuke-tier@ey m@iii@g oii uiow@@edu  Wed Dec 22 16:11:49 2021
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Wed, 22 Dec 2021 09:11:49 -0600 (CST)
Subject: [Rd] [External] Re:  hashtab address arg
In-Reply-To: <20211222165509.079abe35@arachnoid>
References: <CAGho6Qs+TEDh4CqaSq8mWvM0_E9HtCq1AUtX49yyOjnRxYnJTA@mail.gmail.com>
 <20211222165509.079abe35@arachnoid>
Message-ID: <alpine.DEB.2.22.394.2112220906080.385153@luke-Latitude-7480>

On Wed, 22 Dec 2021, Ivan Krylov wrote:

> On Sat, 18 Dec 2021 11:50:54 +0100
> Arnaud FELD <arnaud.feldmann at gmail.com> wrote:
>
>> However, I'm a bit troubled about the "address" argument. What is it
>> intended for since (as far as I know) "address equality" is until now
>> something that isn't really let for the user to decide within R.
>
> Using the words from "Extending R" by John M. Chambers, the concept of
> address identity could be related to the question:
>
>>> If some of the data in the object has changed, is this still the
>>> same object?
>
> Most objects in R are defined by their content. If you had a 100x100
> matrix and changed an element at [50,50], it's now a different matrix,
> even if it's stored in the same variable. If you create another 100x100
> matrix in a different variable but fill it with the same numbers, it
> should still compare equal to your original matrix.
>
> Not all types of R objects are like that. Environments are good
> candidates for pointer equality comparison. For example, the contents
> of the global environment change every time you assign some variable in
> the R command line, but it remains the same global environment. Indeed,
> identical() for environments just compares their pointers: even if two
> different environments only contain objects that compare equal, they
> cannot be considered the same environment, because different closures
> might be referring to them. Similar are data.tables: if you had a giant
> dataset and, as part of cleaning it up, removed some outliers, perhaps
> it should be considered the same dataset, even if the contents aren't
> strictly the same any more. Same goes for reference class and R6
> objects: unlike the pass-by-value semantics associated with most
> objects in R, these are assumed to carry global state within them, and
> modifications to them are reflected everywhere they are referenced, not
> limited to the current function call.

This is still experimental and the 'address' option may not survive at
the R level. There are some C level applications where it can be
useful; maybe it will only be retained there.

> I *think* that most (if not all) objects with reference semantics
> already use pointer comparison when being compared by identical(), so
> the default of "identical" is, as the help page says, almost always the
> right choice, but if it matters to your code whether the objects are
> actually stored in the same area in the memory, use hashes of type
> "address".

Unfortunately not all: External pointer objects are reference objects
but by default are not compared based on object address. Fixing the
default is not an option in the short term as it breaks too much code
(mostly through dependencies on a few packages).

> (Perhaps this topic could be a better fit for R-help.)

R-devel is the right place for this.

Best,

luke

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Wed Dec 22 17:45:41 2021
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Wed, 22 Dec 2021 17:45:41 +0100
Subject: [Rd] 
 MS Windows: R does not escape quotes in CLI options the same
 way as Rterm and Rscript
In-Reply-To: <4a6b6123-1a05-8709-75d9-ff6e1cbda681@gmail.com>
References: <CAFDcVCSmebs6oiJMSEx6SaVvkgpVgMk1YyyFZ13DyM8c-Bt5Lg@mail.gmail.com>
 <4a6b6123-1a05-8709-75d9-ff6e1cbda681@gmail.com>
Message-ID: <f48478d4-a5eb-ee02-b987-0842b61d4aa1@gmail.com>

Now fixed in R-devel

Best
Tomas

On 12/16/21 10:22 AM, Tomas Kalibera wrote:
>
> On 12/15/21 10:48 PM, Henrik Bengtsson wrote:
>> On MS Windows 10, the following works:
>>
>>> Rscript --vanilla -e "\"abc\""
>> [1] "abc"
>>
>> and also:
>>
>>> Rterm --vanilla --no-echo -e "\"abc.txt\""
>> [1] "abc.txt"
>>
>> whereas attempting the same with 'R' fails;
>>
>>> R --vanilla --no-echo -e "\"abc.txt\""
>> Error: object 'abc' not found
>> Execution halted
>>
>> I get this with R 4.1.2 and R Under development (unstable) (2021-12-14
>> r81376 ucrt).
>>
>> Is this a bug?
>
> Yes, R.exe does not properly handle quotes (and backslashes preceding 
> a quote, and trailing backslashes). This is the same as PR#18139 for 
> shQuote(). I will put that on my list
>
> Best
> Tomas
>
>>
>> /Henrik
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel


From t@r@@@z@kh@rko @end|ng |rom uzh@ch  Wed Dec 22 18:17:33 2021
From: t@r@@@z@kh@rko @end|ng |rom uzh@ch (Taras Zakharko)
Date: Wed, 22 Dec 2021 18:17:33 +0100
Subject: [Rd] [External]  hashtab implementation
In-Reply-To: <alpine.DEB.2.22.394.2112220906080.385153@luke-Latitude-7480>
References: <CAGho6Qs+TEDh4CqaSq8mWvM0_E9HtCq1AUtX49yyOjnRxYnJTA@mail.gmail.com>
 <20211222165509.079abe35@arachnoid>
 <alpine.DEB.2.22.394.2112220906080.385153@luke-Latitude-7480>
Message-ID: <9D9755D1-9898-4E40-8C3A-9F9D310254E7@uzh.ch>

Since this topic has came up, may I dare to add some other comments? 

- it would be great if fast hash computation would be exposed at the R level (existing implementations such as rlang and digest rely on serialisation which adds unnessesry overhead), that would be very useful for many applications. 

- It might be useful if hash tables supported `==` operator for equality as well. This would mean making the hash function generic. 


Best, 

Taras
	[[alternative HTML version deleted]]


From |reder|k @end|ng |rom o|b@net  Thu Dec 23 01:43:09 2021
From: |reder|k @end|ng |rom o|b@net (Frederick Eaton)
Date: Wed, 22 Dec 2021 16:43:09 -0800
Subject: [Rd] 
 meaning of browser(skipCalls=) [and multiple mouse buttons]
In-Reply-To: <25019.149.79336.502549@stat.math.ethz.ch>
References: <20211122171358.7rej26rdwpq5ywrm@localhost>
 <20211208082447.vd3hpq4gxd37llqy@localhost>
 <20211216040946.pgtjmlgvtyhimmh4@localhost>
 <25019.149.79336.502549@stat.math.ethz.ch>
Message-ID: <20211223004309.y3a6ktjktuymzvd6@localhost>

Hi Martin,

The help documentation for browser() doesn't seem to mention anywhere
that it is impossible to step outside of the function that called
browser(). Is that indeed true? Can I use the debugger effectively
without knowing it? Is there some other documentation where this fact
is mentioned?

Why is it not in the documentation? Why not put it there? Why not talk
about it?

So confused,

Frederick

On Thu, Dec 16, 2021 at 10:02:13AM +0100, Martin Maechler wrote:
>>>>>> Frederick Eaton
>>>>>>     on Wed, 15 Dec 2021 20:09:46 -0800 writes:
>
>    > Just following up to check if anyone has had time to look over these patches.
>    > Frederick
>
>I strongly guess that nobody has.
>
>Let me give you my perception of what you have tried to
>propose/use,  and why I hadn't thought I should put in time for it:
>
>You had started the thread by proposing "to override stopifnot()",
>something which I (even though principal author of the function)
>don't find a good idea at all:
>
>stopifnot() is just one important utility function that will
>call stop() under some circumstances.
>If you want to tweak  error handling / debugging / browser, ..
>you need to work on the level of error conditions, their
>handlers, etc.
>
>Secondly, you've mixed this up with mouse button
>action/interrupt/.. handling  which may be a cool and nice idea,
>but then your  `xbindkey`-etc code is, I think, only/entirely
>for X11-based R interfaces, and I think this would only be a
>Linux console, possibly one from using ESS (Emacs Speaks Statistics),
>but most probably (but I'm guessing here) not even relevant when
>using Rstudio on Linux, and even less relevant for any of the
>other ways R is used interactively on non-Linux platforms. Maybe
>it would also apply to *some* uses of R on the Mac, but not even
>the default R-Mac GUI..
>
>Sorry that this not as much encouraging as it probably should
>be, but I though you'd rather want *some* feedback than none...
>
>Best,
>Martin
>
>
>
>    > On Wed, Dec 08, 2021 at 12:24:47AM -0800, Frederick Eaton wrote:
>    >> Dear R Core Team,
>    >>
>    >> I'm attaching a proposed patch to hopefully address my confusions regarding the documentation of browser(). I'm not sure if all the material I added is correct, but I made experiments to confirm that the behavior is at least roughly as described.
>    >>
>    >> patch ./src/library/base/man/browser.Rd < browser.patch
>    >>
>    >> Also, here is a patch to support multiple mouse buttons in getGraphicsEvent(). This must be edited before it can be applied, I decided to keep the old code in an 'if(0)' to help make it clearer that my code is essentially doing the same thing.
>    >>
>    >> https://github.com/navarum/tweaks/blob/master/r/patches/0001-Add-support-for-multiple-mouse-buttons.patch
>    >> wget -O - https://raw.githubusercontent.com/navarum/tweaks/master/r/patches/0001-Add-support-for-multiple-mouse-buttons.patch | patch -p1
>    >>
>    >> It would be useful to have support in R for more than three mouse buttons because this enables the use of the mouse wheel (buttons 4 and 5), which can provide a more convenient interface when adjusting numbers and graphics and so on. I also have shift+wheel bound to buttons 6 and 7 via xbindkeys and xte, which I use for horizontal scrolling, via a trick from the web somewhere:
>    >>
>    >> $ cat .xbindkeysrc.scm | grep xte
>    >> (xbindkey '(shift "b:4") "xte 'mouseclick 6'")
>    >> (xbindkey '(shift "b:5") "xte 'mouseclick 7'")
>    >>
>    >> I hope that these contributions can be found acceptable.
>    >>
>    >> Thank you in advance,
>    >>
>    >> Frederick
>    >>
>    >>
>    >>
>    >> On Mon, Nov 22, 2021 at 09:13:58AM -0800, Frederick Eaton wrote:
>    >>> Dear R Devel,
>    >>>
>    >>> I have been advised to use "options(error=recover)" to enable
>    >>> debugging on errors. But sometimes it would seem more convenient to
>    >>> override "stopifnot", for example:
>    >>>
>    >>> stopifnot = function(b) { if(!b) { browser(skipCalls=1); } }
>    >>>
>    >>> However, this doesn't do what I expected. On looking closer I find
>    >>> that the "skipCalls" argument seems to be ignored except when printing
>    >>> the "Called from: " message; it does not affect the evaluation context
>    >>> or the output of 'where':
>    >>>
>    >>> > var=2; f=function(){var=1; browser(skipCalls=0)}; f()
>    >>> Called from: f()
>    >>> Browse[1]> var
>    >>> [1] 1
>    >>> Browse[1]> where
>    >>> where 1: f()
>    >>>
>    >>> Browse[1]> Q
>    >>> > var=2; f=function(){var=1; browser(skipCalls=1)}; f()
>    >>> Called from: top level     Browse[1]> var
>    >>> [1] 1
>    >>> Browse[1]> where
>    >>> where 1: f()
>    >>>
>    >>> Browse[1]> Q
>    >>> > var=2; f=function(){var=1; browser(skipCalls=2)}; f()
>    >>> Called from: top level     Browse[1]> var
>    >>> [1] 1
>    >>> Browse[1]> where
>    >>> where 1: f()
>    >>>
>    >>> Browse[1]> Q
>    >>>
>    >>> So it appears that the "browser()" API does not actually make it
>    >>> possible to call this built-in function from within another R function
>    >>> and thereby emulate the same behavior as calling browser() directly.
>    >>>
>    >>> If this is the case, it might be good to have it fixed or documented.
>    >>> I am aware of "browser(expr=)", but this requires editing the
>    >>> particular call that failed. The documentation for "browser()" led me
>    >>> to hope that my use case would be supported, if only because it admits
>    >>> that users might want to build other debugging functions with
>    >>> browser(): "The 'skipCalls' argument should be used when the
>    >>> 'browser()' call is nested within another debugging function". An
>    >>> example where this 'skipCalls' parameter is used to build a useful
>    >>> debugging function would help to clarify its English description in
>    >>> the manual.
>    >>>
>    >>> Also, from the browser() command line I could not find a way to step
>    >>> *out* of the current function. This would have been a way to recover
>    >>> from skipCalls not working as expected. Am I missing something? For
>    >>> example is there some command other than "n", where the below
>    >>> interaction could pause before "hi" and "bye"?
>    >>>
>    >>> > f=function(){browser(); message("in f"); message("out f")}; f(); message("hi"); message("bye")
>    >>> Called from: f()
>    >>> Browse[1]> n
>    >>> debug at #1: message("in f")
>    >>> Browse[2]> n
>    >>> in f
>    >>> debug at #1: message("out f")
>    >>> Browse[2]> n
>    >>> out f
>    >>> hi
>    >>> bye
>    >>>
>    >>> If it is not possible for the R debugger to step out of a function, it
>    >>> would be good to document that too, maybe after the list of browser
>    >>> prompt commands in "?browser". Being confined within a single function
>    >>> is not an obvious disability for a debugger to have.
>    >>>
>    >>> I feel that R is an excellent tool, but sometimes I think that if the
>    >>> shortcomings of the system were better documented, then this would
>    >>> save users a lot of time in certain cases.
>    >>>
>    >>> Thank you,
>    >>>
>    >>> Frederick
>    >>>
>
>    >> --- browser-orig.Rd	2021-12-07 22:35:51.991222137 -0800
>    >> +++ browser-new.Rd	2021-12-07 23:53:36.414106296 -0800
>    >> @@ -45,8 +45,16 @@
>    >> will be simpler.
>    >>
>    >> The \code{skipCalls} argument should be used when the \code{browser()}
>    >> -  call is nested within another debugging function:  it will look further
>    >> -  up the call stack to report its location.
>    >> +  call is nested within another debugging function: it will look further
>    >> +  up the call stack to report its location. However, currently this
>    >> +  argument only affects the \code{Called from:} message printed before
>    >> +  the first \code{Browse>} prompt, and does not change the evaluation
>    >> +  environment of the expressions entered there, nor the output of the
>    >> +  \code{where} command. It is not clear when this argument would be
>    >> +  useful. It is for example currently impossible to change occurrences
>    >> +  of \code{stopifnot(x)} to act like \code{browser(expr=!x)} by
>    >> +  redefining \code{stopifnot()}; this must instead be done through a
>    >> +  textual search-and-replace or \code{options(error=recover)}.
>    >>
>    >> At the browser prompt the user can enter commands or \R expressions,
>    >> followed by a newline.  The commands are
>    >> @@ -58,11 +66,9 @@
>    >> \item{\code{f}}{finish execution of the current loop or function}
>    >> \item{\code{help}}{print this list of commands}
>    >> \item{\code{n}}{evaluate the next statement, stepping over
>    >> -      function calls.  For byte compiled functions interrupted by
>    >> -      \code{browser} calls, \code{n} is equivalent to \code{c}.}
>    >> +      function calls.}
>    >> \item{\code{s}}{evaluate the next statement, stepping into
>    >> -      function calls.  Again, byte compiled functions make
>    >> -      \code{s} equivalent to \code{c}.}
>    >> +      function calls.}
>    >> \item{\code{where}}{print a stack trace of all active function calls.}
>    >> \item{\code{r}}{invoke a \code{"resume"} restart if one is
>    >> available; interpreted as an \R expression otherwise. Typically
>    >> @@ -71,6 +77,15 @@
>    >> \item{\code{Q}}{exit the browser and the current evaluation and
>    >> return to the top-level prompt.}
>    >> }
>    >> +
>    >> +  Both \code{n} and \code{s} also step out of function calls. However,
>    >> +  it is currently not possible with these commands to step out of the
>    >> +  function which called \code{browser()}. At the end of the function
>    >> +  which called \code{browser}, \code{n} and \code{s} are both equivalent
>    >> +  to \code{c}. These commands (\code{n} and \code{s}) are also
>    >> +  equivalent to \code{c} when trying to use them inside byte compiled
>    >> +  functions interrupted by \code{browser} calls.
>    >> +
>    >> Leading and trailing whitespace is ignored, except for an empty line.
>    >> Handling of empty lines depends on the \code{"browserNLdisabled"}
>    >> \link[=options]{option}; if it is \code{TRUE}, empty lines are ignored.
>


From ggrothend|eck @end|ng |rom gm@||@com  Mon Dec 27 14:33:57 2021
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Mon, 27 Dec 2021 08:33:57 -0500
Subject: [Rd] assignment
Message-ID: <CAP01uRnLVZCygSM5ax697NFpQt-WeBCMCHa5XMTY556Qn6AStg@mail.gmail.com>

In a recent SO post this came up (changed example to simplify it
here).  It seems that `test` still has the value sin.

  test <- sin
  environment(test)$test <- cos
  test(0)
  ## [1] 0

It appears to be related to the double use of `test` in `$<-` since if
we break it up it works as expected:

  test <- sin
  e <- environment(test)
  e$test <- cos
  test(0)
  ## [1] 1

`assign` also works:

  test <- sin
  assign("test", cos, environment(test))
  test(0)
  ## [1] 1

Can anyone shed some light on this?


-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From b@||@e @end|ng |rom m|@m|@edu  Mon Dec 27 02:35:17 2021
From: b@||@e @end|ng |rom m|@m|@edu (Balise, Raymond R)
Date: Mon, 27 Dec 2021 01:35:17 +0000
Subject: [Rd] Why does lm() with the subset argument give a different answer
 than subsetting in advance?
Message-ID: <B29E2C41-2EB5-465D-8EA2-6E9E3B9906A3@miami.edu>

Hello R folks,
Today I noticed that using the subset argument in lm() with a polynomial gives a different result than using the polynomial when the data has already been subsetted. This was not at all intuitive for me.    You can see an example here: https://stackoverflow.com/questions/70490599/why-does-lm-with-the-subset-argument-give-a-different-answer-than-subsetting-i

                If this is a design feature that you don?t think should be fixed, can you please include it in the documentation and explain why it makes sense to figure out the orthogonal polynomials on the entire dataset?  This feels like a serous leak of information when evaluating train and test datasets in a statistical learning framework.

Ray

Raymond R. Balise, PhD
Assistant  Professor
Department of Public Health Sciences, Biostatistics

University of Miami, Miller School of Medicine
1120 N.W. 14th Street
Don Soffer Clinical Research Center - Room 1061
Miami, Florida 33136



	[[alternative HTML version deleted]]


From bbo|ker @end|ng |rom gm@||@com  Mon Dec 27 15:43:42 2021
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Mon, 27 Dec 2021 09:43:42 -0500
Subject: [Rd] 
 Why does lm() with the subset argument give a different answer
 than subsetting in advance?
In-Reply-To: <B29E2C41-2EB5-465D-8EA2-6E9E3B9906A3@miami.edu>
References: <B29E2C41-2EB5-465D-8EA2-6E9E3B9906A3@miami.edu>
Message-ID: <82962536-60a4-8a71-eaa0-ce79f5025d2e@gmail.com>

   I agree that it seems non-intuitive (I can't think of a design reason 
for it to look this way), but I'd like to stress that it's *not* an 
information leak; the predictions of the model are independent of the 
parameterization, which is all this issue affects. In a worst case there 
might be some unfortunate effects on numerical stability if the 
data-dependent bases are computed on a very different set of data than 
the model fitting actually uses.

   I've attached a suggested documentation patch (I hope it makes it 
through to the list, if not I can add it to the body of a message.)



On 12/26/21 8:35 PM, Balise, Raymond R wrote:
> Hello R folks,
> Today I noticed that using the subset argument in lm() with a polynomial gives a different result than using the polynomial when the data has already been subsetted. This was not at all intuitive for me.    You can see an example here: https://stackoverflow.com/questions/70490599/why-does-lm-with-the-subset-argument-give-a-different-answer-than-subsetting-i
> 
>                  If this is a design feature that you don?t think should be fixed, can you please include it in the documentation and explain why it makes sense to figure out the orthogonal polynomials on the entire dataset?  This feels like a serous leak of information when evaluating train and test datasets in a statistical learning framework.
> 
> Ray
> 
> Raymond R. Balise, PhD
> Assistant  Professor
> Department of Public Health Sciences, Biostatistics
> 
> University of Miami, Miller School of Medicine
> 1120 N.W. 14th Street
> Don Soffer Clinical Research Center - Room 1061
> Miami, Florida 33136
> 
> 
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 

-- 
Dr. Benjamin Bolker
Professor, Mathematics & Statistics and Biology, McMaster University
Director, School of Computational Science and Engineering
Graduate chair, Mathematics & Statistics

-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: subset_patch.txt
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20211227/47cc2f5a/attachment.txt>

From iuke-tier@ey m@iii@g oii uiow@@edu  Mon Dec 27 17:14:05 2021
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Mon, 27 Dec 2021 10:14:05 -0600 (CST)
Subject: [Rd] [External]  assignment
In-Reply-To: <CAP01uRnLVZCygSM5ax697NFpQt-WeBCMCHa5XMTY556Qn6AStg@mail.gmail.com>
References: <CAP01uRnLVZCygSM5ax697NFpQt-WeBCMCHa5XMTY556Qn6AStg@mail.gmail.com>
Message-ID: <alpine.DEB.2.22.394.2112271013340.385153@luke-Latitude-7480>

On Mon, 27 Dec 2021, Gabor Grothendieck wrote:

> In a recent SO post this came up (changed example to simplify it
> here).  It seems that `test` still has the value sin.
>
>  test <- sin
>  environment(test)$test <- cos
>  test(0)
>  ## [1] 0
>
> It appears to be related to the double use of `test` in `$<-` since if
> we break it up it works as expected:
>
>  test <- sin
>  e <- environment(test)
>  e$test <- cos
>  test(0)
>  ## [1] 1
>
> `assign` also works:
>
>  test <- sin
>  assign("test", cos, environment(test))
>  test(0)
>  ## [1] 1
>
> Can anyone shed some light on this?

See my response in

https://bugs.r-project.org/show_bug.cgi?id=18269

Best,

luke

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu


From hugh@p@r@on@ge @end|ng |rom gm@||@com  Tue Dec 28 14:36:51 2021
From: hugh@p@r@on@ge @end|ng |rom gm@||@com (Hugh Parsonage)
Date: Wed, 29 Dec 2021 00:36:51 +1100
Subject: [Rd] "getOption(max.print) omitted %d entries" may be negative
Message-ID: <CAJmOi+MFUrn+hx9PVj1ALWwMFPq518dTYGPDToqF92TB4w9xgw@mail.gmail.com>

In src/main/printvector.c in the definition of printVector and
printNamedVector  (and elsewhere):

Rprintf(" [ reached getOption(\"max.print\") -- omitted %d entries ]\n",
n - n_pr);

Though n - n_pr is of type R_xlen_t so may not be representable as
int. In practice negative values may be observed for long vectors.

Rprintf(" [ reached getOption(\"max.print\") -- omitted %lld entries ]\n",
n - n_pr);


