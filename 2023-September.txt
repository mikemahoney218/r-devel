From AHL27 @end|ng |rom p|tt@edu  Fri Sep  1 11:17:57 2023
From: AHL27 @end|ng |rom p|tt@edu (Lakshman, Aidan H)
Date: Fri, 1 Sep 2023 09:17:57 +0000
Subject: [Rd] Updated `dendrapply`
Message-ID: <BL0PR04MB470648B7E324632897EF4EEDD9E5A@BL0PR04MB4706.namprd04.prod.outlook.com>

Hi everyone,
Ivan and I had a few discussions several months ago regarding `dendrapply`, but now that I've had the chance to work on it more specifically and discuss it Martin Maechler at the R Project Sprint, I figured it would be a good idea to start a new email chain.
I've refactored `dendrapply`, and the current implementation is available in my bugzilla report (https://bugs.r-project.org/show_bug.cgi?id=18480). This project started due to the help page for `dendrapply`, which specifically requested users to contribute improvements to the function. I'm including a lot of writeup here because I'm very aware that this is a relatively large contribution for someone that doesn't have a history of contributing a lot of code to base, and I'd like to justify the inclusion.
Feel free to skip everything I've written and instead use the following links. A thorough discussion follows.
- Bugzilla with patch: https://bugs.r-project.org/show_bug.cgi?id=18480
- R Checks: https://github.com/r-devel/r-svn/pull/111
- Discussion at R Project Sprint: https://github.com/r-devel/r-project-sprint-2023/discussions/6
- Original blog post about this (long, code out of date, but has a simpler explanation of the implementation): https://www.ahl27.com/posts/2023/02/dendrapply/

Responses to common questions:
- Why does this project need to be done?
The current implementation in `stats::dendrapply` is recursive, and thus has issues with deeply nested dendrogram objects. As of 2015, users experienced issues with recursive operations on dendrograms causing stack overflow issues (see https://bugs.r-project.org/show_bug.cgi?id=15215). This has been alleviated by better computers and short-term workarounds, but many users have limited resources and/or need for large trees. Even with sufficient memory, a recursive implementation incurs a nontrivial amount of unneccessary computational overhead. I'll also add that this is a feature that was requested in R itself (see Note section in `?dendrapply`), and Martin Maechler has been supportive of the work thus far on it.
- What does this implementation do?
There are a few improvements in this implementation. The first is that function application to dendrogram objects is no longer recursive. This implementation is also based in C, providing a performance boost of at least 4x (see later question for details). Finally, iterative application of functions in C allows for flexibility in *how* the dendrogram is traversed, which gives end-users a significant amount of power to work with tree-like structures in an intuitive way. An easy example is subsetting based on leaf values--if a user wanted to subset a dendrogram to only certain leaves, there isn't a good way to do this in base R (even with dendrapply). `how='post.order'` fixes this problem. I'm happy to provide additional examples if needed.
- Why C? This is harder to maintain than R.
This is a valid point. I did my best to include as much documentation as possible, and I'm also volunteering myself to help maintain this function. C provides a lot of power in working with dendrograms, since R's toolkit for tree-like structures is relatively lacking. This refactor is theoretically doable in R, but the implementation would involve an immense amount of memory overhead to ensure we can preserve the node states as we traverse the tree. There is precedence for a C implementation of dendrapply (see other `*apply` functions). Additionally, this decreases function application overhead, and allows future extensions to be written purely in R in a much simpler way. I think this tradeoff is worth it, but I am happy to discuss implementation specifics with anyone that is interested.
- Ivan previously mentioned issues with user specific `[[.dendrogram` implementations, and it doesn't seem that you've fixed that.
This is correct. I discovered during the R project sprint that `stats::dendrapply` does not respect user-specific implementations of `[[.dendrogram`. stats::`[[.dendrogram` has its own issues; if the user defines multiple classes for a dendrogram object, double bracket subsetting will remove the class (a bug report will be filed for this shortly). My implementation exactly replicates the performance of stats::`[[.dendrogram`, and if users are in need of a function that can respect custom subset overloading, I can address those feature requests if/when they are submitted.
- Backwards compatibility?
>From current testing, this is a drop-in replacement for `stats::dendrapply`. R builds successfully, and all >400 tests in the CRAN package that uses `dendrapply` the most (dendextend) pass with no changes from the original. The additional argument `how=c('pre.order', 'post.order')` is the same syntax as `rapply`, and additional documentation has been added to the `dendrapply.Rd` to reflect this change. This is still an unfinished TODO; the internal R testing for `dendrapply` is very sparse. I haven't been able to find any differences between stats::dendrapply and this implementation, but I am planning to run a full check against all CRAN packages that use `dendrapply`. I'm also planning to add additional regression testing to R either as part of this patch in a separate patch.
- You mentioned there was more to the listed '4x improvement'
Yes. I haven't yet put together a comprehensive benchmark for highly unbalanced trees, and in truth there are so many possible tree structures that it would be challenging to test them all. However, on trees with 5 leaves the performance is roughly identical to that of `stats`, and benchmarking with `microbenchmark` demonstrates performance gains of roughly 5x on fully balanced trees with 10-5000 leaves. This should be a lower bound for performance, since fully balanced trees minimize internal nodes and thus have less recursion...so on reasonably sized trees of arbitrary structure we should have at least around a 4x improvement. I'll also stress that the focus of this patch is not a runtime improvement--it's nice that we get a speedup, but the added value here is the removal of recursive calls.
- Why not just put this in a package?
I think there's value in fleshing out the structures included in base R. Dendrograms are a general tree structure, and few programming languages provide support for these out of the box. Dendrogram objects are currently rarely used, but with a little bit of additional functionality, they could be a very powerful tool for users. These have applications in a variety of fields that are not just phylogenetics; implementations of domain-specific tools (e.g. `ape`, `DECIPHER`) are better suited to 3rd party packages. However, `dendrograms` already exist in base and have poor support, which is even admitted in their help files. `dendrapply`. While it's currently limited to acting on dendrogram objects, a solid implementation would open the door to generalizing dendrapply to work on any nested list. This is my personal opinion, and there is certainly an argument to be made that `dendrapply` (and even `dendrogram` as a whole) could live outside of base.
- Why/how were the included traversal strategies chosen?
The default, pre.order, was chosen because it replicates existing functionality. post.order was included because it lends itself well to a lot of applications. Between these two methods, we have a way to apply a function to trees ensuring that parents are evaluated before children, and ensuring children are evaluated before parents. Future extensions to support an in.order or BFS/level.order traversal is definitely an option, but I don't think the added implementation effort and complexity adds a lot of functionality over the two that have been included.
There's also been previous comments regarding the structure of dendrograms. While hclust will return a bifurcating tree, dendrogram objects (and dendrapply) support arbitrary multifurcations and edge weights.
Apologies for the lengthy email. If you've read even half, thanks for your time. There?s likely some optimizations that could be made in the C code dealing with R structures; I?m still learning the intricacies of some of the more specific points of this. One that comes to mind is converting the repeated `lang2` calls to instead initialize a `lang2` call and then change the symbol in the call, as is done in `lapply` (and was mentioned by Ivan in my last submission). I?ll test that as well.
Further feedback is welcome and much appreciated.
-Aidan

-----------------------
Aidan Lakshman (he/him)<https://www.ahl27.com/>
Doctoral Fellow, Wright Lab<https://www.wrightlabscience.com/>
University of Pittsburgh School of Medicine
Department of Biomedical Informatics
ahl27 at pitt.edu
(724) 612-9940


	[[alternative HTML version deleted]]


From kry|ov@r00t @end|ng |rom gm@||@com  Fri Sep  1 16:24:43 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Fri, 1 Sep 2023 17:24:43 +0300
Subject: [Rd] Updated `dendrapply`
In-Reply-To: <BL0PR04MB470648B7E324632897EF4EEDD9E5A@BL0PR04MB4706.namprd04.prod.outlook.com>
References: <BL0PR04MB470648B7E324632897EF4EEDD9E5A@BL0PR04MB4706.namprd04.prod.outlook.com>
Message-ID: <20230901172443.20f904a2@arachnoid>

? Fri, 1 Sep 2023 09:17:57 +0000
"Lakshman, Aidan H" <AHL27 at pitt.edu> ?????:

> - Ivan previously mentioned issues with user specific `[[.dendrogram`
> implementations, and it doesn't seem that you've fixed that.

> This is correct. I discovered during the R project sprint that
> `stats::dendrapply` does not respect user-specific implementations of
> `[[.dendrogram`. stats::`[[.dendrogram` has its own issues; if the
> user defines multiple classes for a dendrogram object, double bracket
> subsetting will remove the class (a bug report will be filed for this
> shortly).

True, my warning about not handing potential subclasses of dendrogram
was purely theoretical.

(A hypothetical subclass of dendrogram could work with the current
[[.dendrogram if it ensured that its own class name always precedes
'dendrogram' in the class vector, thus never being downstream from
stats:::`[[.dendrogram` in a chain of NextMethod() calls. But that's
still hypothetical.)

I see that your current implementation very nicely bounds the PROTECT()
stack usage and avoids the need to deallocate arbitrary SEXPs, which is
awkward to do with R's garbage collector API. Congratulations!

-- 
Best regards,
Ivan


From murdoch@dunc@n @end|ng |rom gm@||@com  Mon Sep  4 12:01:50 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Mon, 4 Sep 2023 06:01:50 -0400
Subject: [Rd] Bug in PCRE interface code
Message-ID: <c0079cbe-0ec0-4e8a-09d1-b6d3a0bce9cd@gmail.com>

This Stackoverflow question https://stackoverflow.com/q/77036362 turned 
up a bug in the R PCRE interface.

The example (currently in an edit to the original question) tried to use 
named capture with more than 127 named groups.  Here's the code:

append_unique_id <- function(x) {
   for (i in seq_along(x)) {
     x[i] <- paste0("<", paste(sample(letters, 10), collapse = ""), ">", 
x[i])
   }
   x
}

list_regexes <- sample(letters, 128, TRUE) # <<<<<<<<<<< change this to
                                            #             127 and it works
regex2 <- append_unique_id(list_regexes)
regex2 <- paste0("(?", regex2, ")")
regex2 <- paste(regex2, collapse = "|")

out <- gregexpr(regex2, "Cyprus", perl = TRUE, ignore.case = TRUE)
#> Error in gregexpr(regex2, "Cyprus", perl = TRUE, ignore.case = TRUE): 
attempt to set index -129/128 in SET_STRING_ELT

I think the bug is in R, here: 
https://github.com/wch/r-source/blob/57d15d68235dd9bcfaa51fce83aaa71163a020e1/src/main/grep.c#L3079

This is the line

	    int capture_num = (entry[0]<<8) + entry[1] - 1;

where entry is declared as a pointer to a char.  What this is doing is 
extracting a 16 bit number from the first two bytes of a character 
string holding the name of the capture group.  Since char is a signed 
type, the conversion of bytes to integer gets messed up and the value 
comes out wrong.

Duncan Murdoch


From tdhock5 @end|ng |rom gm@||@com  Tue Sep  5 23:06:49 2023
From: tdhock5 @end|ng |rom gm@||@com (Toby Hocking)
Date: Tue, 5 Sep 2023 14:06:49 -0700
Subject: [Rd] Bug in PCRE interface code
In-Reply-To: <c0079cbe-0ec0-4e8a-09d1-b6d3a0bce9cd@gmail.com>
References: <c0079cbe-0ec0-4e8a-09d1-b6d3a0bce9cd@gmail.com>
Message-ID: <CALK03d3c7HMcbF5rZZTNN6yBcX8=-6N-sGK48=GfZu8kiUyGQg@mail.gmail.com>

BTW this is documented here
http://pcre.org/current/doc/html/pcre2api.html#infoaboutpattern with a
helpful example, copied below.

As a simple example of the name/number table, consider the following
pattern after compilation by the 8-bit library (assume PCRE2_EXTENDED
is set, so white space - including newlines - is ignored):

  (?<date> (?<year>(\d\d)?\d\d) - (?<month>\d\d) - (?<day>\d\d) )

There are four named capture groups, so the table has four entries,
and each entry in the table is eight bytes long. The table is as
follows, with non-printing bytes shows in hexadecimal, and undefined
bytes shown as ??:

  00 01 d  a  t  e  00 ??
  00 05 d  a  y  00 ?? ??
  00 04 m  o  n  t  h  00
  00 02 y  e  a  r  00 ??

On Mon, Sep 4, 2023 at 3:02?AM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>
> This Stackoverflow question https://stackoverflow.com/q/77036362 turned
> up a bug in the R PCRE interface.
>
> The example (currently in an edit to the original question) tried to use
> named capture with more than 127 named groups.  Here's the code:
>
> append_unique_id <- function(x) {
>    for (i in seq_along(x)) {
>      x[i] <- paste0("<", paste(sample(letters, 10), collapse = ""), ">",
> x[i])
>    }
>    x
> }
>
> list_regexes <- sample(letters, 128, TRUE) # <<<<<<<<<<< change this to
>                                             #             127 and it works
> regex2 <- append_unique_id(list_regexes)
> regex2 <- paste0("(?", regex2, ")")
> regex2 <- paste(regex2, collapse = "|")
>
> out <- gregexpr(regex2, "Cyprus", perl = TRUE, ignore.case = TRUE)
> #> Error in gregexpr(regex2, "Cyprus", perl = TRUE, ignore.case = TRUE):
> attempt to set index -129/128 in SET_STRING_ELT
>
> I think the bug is in R, here:
> https://github.com/wch/r-source/blob/57d15d68235dd9bcfaa51fce83aaa71163a020e1/src/main/grep.c#L3079
>
> This is the line
>
>             int capture_num = (entry[0]<<8) + entry[1] - 1;
>
> where entry is declared as a pointer to a char.  What this is doing is
> extracting a 16 bit number from the first two bytes of a character
> string holding the name of the capture group.  Since char is a signed
> type, the conversion of bytes to integer gets messed up and the value
> comes out wrong.
>
> Duncan Murdoch
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Fri Sep  8 15:44:48 2023
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Fri, 8 Sep 2023 15:44:48 +0200
Subject: [Rd] FYI: daily R source tarballs from ETH: *.xz instead of *.bz2)
Message-ID: <25851.9552.398085.384361@stat.math.ethz.ch>

A quick notice for anyone who uses cron-like scripts to get
R source tarballs from the ETH  R/daily/ s:

I've finally switched to replace *.bz2 by *.xz which does save
quite a bit of bandwidth.

Currently, you can see the 2 day old *.bz2 (and their sizes) and
compare with the new  *.xz one  (sorted newest first):

  https://stat.ethz.ch/R/daily/?C=M;O=D


Best,
Martin


From hp@ge@@on@g|thub @end|ng |rom gm@||@com  Sat Sep  9 02:56:20 2023
From: hp@ge@@on@g|thub @end|ng |rom gm@||@com (=?UTF-8?B?SGVydsOpIFBhZ8Oocw==?=)
Date: Fri, 8 Sep 2023 17:56:20 -0700
Subject: [Rd] 
 FYI: daily R source tarballs from ETH: *.xz instead of *.bz2)
In-Reply-To: <25851.9552.398085.384361@stat.math.ethz.ch>
References: <25851.9552.398085.384361@stat.math.ethz.ch>
Message-ID: <27378572-a2e2-eb29-1e7d-9c8d7020bd3a@gmail.com>

Hi Martin,

Sounds good. Are there any plans to support the xz compression for 
package source tarballs?

Thanks,

H.

On 9/8/23 06:44, Martin Maechler wrote:
> A quick notice for anyone who uses cron-like scripts to get
> R source tarballs from the ETH  R/daily/ s:
>
> I've finally switched to replace *.bz2 by *.xz which does save
> quite a bit of bandwidth.
>
> Currently, you can see the 2 day old *.bz2 (and their sizes) and
> compare with the new  *.xz one  (sorted newest first):
>
>    https://stat.ethz.ch/R/daily/?C=M;O=D
>
>
> Best,
> Martin
>
> ______________________________________________
> R-devel at r-project.org  mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Herv? Pag?s

Bioconductor Core Team
hpages.on.github at gmail.com

	[[alternative HTML version deleted]]


From trevor@|@d@v|@ @end|ng |rom gm@||@com  Mon Sep 11 18:29:26 2023
From: trevor@|@d@v|@ @end|ng |rom gm@||@com (Trevor Davis)
Date: Mon, 11 Sep 2023 09:29:26 -0700
Subject: [Rd] List's `[[` method with "" tag
Message-ID: <CAMigB8FTRq5BeY8nHfukwyk=kBNQ1k6EHfsKRv6EEZytLC9=og@mail.gmail.com>

Hi,

I notice that one can assign a variable to an R list by using an empty
string key but one cannot get that variable back from the list by using the
empty string key:

```r
l <- list()
l[[""]] <- "An empty string as list key"
names(l)
l[[""]] # Returns a `NULL`
l[[names(l) == ""]] # Returns first value with `""` tag
```

Instead of `l[[""]]` returning a `NULL` I'd "expect" it to instead return
the first variable named `""`  i.e. in this case "An empty string as list
key".  It would be nice if the `[[` method of a list was updated to "fix"
this.

Additionally, I observe that if a list is named but has certain elements
without names then those are currently "named" `""`:

```r
names(list(a = 1, 2, c = 3, 4))
```

This latter change may be a breaking change but I speculate that perhaps it
may be more intuitive if missing names were indicated with `NA_character_`
instead of `""`.

Thanks,

Trevor

	[[alternative HTML version deleted]]


From @oko| @end|ng |rom |n@@-tou|ou@e@|r  Mon Sep 11 18:52:51 2023
From: @oko| @end|ng |rom |n@@-tou|ou@e@|r (=?UTF-8?Q?Sergue=C3=AF_Sokol?=)
Date: Mon, 11 Sep 2023 18:52:51 +0200
Subject: [Rd] List's `[[` method with "" tag
In-Reply-To: <CAMigB8FTRq5BeY8nHfukwyk=kBNQ1k6EHfsKRv6EEZytLC9=og@mail.gmail.com>
References: <CAMigB8FTRq5BeY8nHfukwyk=kBNQ1k6EHfsKRv6EEZytLC9=og@mail.gmail.com>
Message-ID: <fdf54c1464d0e0d9a45fae138c050ef1@198c5bc6.internal>

It's per design: 

?names
...
The name '""' is special: it is used to
indicate that there is no
name associated with an element of a (atomic
or generic) vector.
Subscripting by '""' will match nothing (not even
elements which
have no name).
... 

Best,
Serguei. 

Le 2023-09-11
18:29, Trevor Davis a ?crit :

> Hi,
> 
> I notice that one can assign a
variable to an R list by using an empty
> string key but one cannot get
that variable back from the list by using the
> empty string key:
> 
>
```r
> l <- list()
> l[[""]] <- "An empty string as list key"
>
names(l)
> l[[""]] # Returns a `NULL`
> l[[names(l) == ""]] # Returns
first value with `""` tag
> ```
> 
> Instead of `l[[""]]` returning a
`NULL` I'd "expect" it to instead return
> the first variable named `""`
i.e. in this case "An empty string as list
> key".  It would be nice if
the `[[` method of a list was updated to "fix"
> this.
> 
>
Additionally, I observe that if a list is named but has certain
elements
> without names then those are currently "named" `""`:
> 
>
```r
> names(list(a = 1, 2, c = 3, 4))
> ```
> 
> This latter change may
be a breaking change but I speculate that perhaps it
> may be more
intuitive if missing names were indicated with `NA_character_`
> instead
of `""`.
> 
> Thanks,
> 
> Trevor
> 
> [[alternative HTML version
deleted]]
> 
> ______________________________________________
>
R-devel at r-project.org mailing list
>
https://stat.ethz.ch/mailman/listinfo/r-devel
 
	[[alternative HTML version deleted]]


From r|p|ey @end|ng |rom @t@t@@ox@@c@uk  Tue Sep 12 07:39:47 2023
From: r|p|ey @end|ng |rom @t@t@@ox@@c@uk (Prof Brian Ripley)
Date: Tue, 12 Sep 2023 06:39:47 +0100
Subject: [Rd] 
 FYI: daily R source tarballs from ETH: *.xz instead of *.bz2)
In-Reply-To: <27378572-a2e2-eb29-1e7d-9c8d7020bd3a@gmail.com>
References: <25851.9552.398085.384361@stat.math.ethz.ch>
 <27378572-a2e2-eb29-1e7d-9c8d7020bd3a@gmail.com>
Message-ID: <f84b708a-6ddd-4c02-a97c-8a1331768444@stats.ox.ac.uk>

On 09/09/2023 01:56, Herv? Pag?s wrote:
> Hi Martin,
> 
> Sounds good. Are there any plans to support the xz compression for
> package source tarballs?

What makes you think it is not supported?

R CMD INSTALL happily installs .tar.xz files, and the name is not used 
to detect compression so .tar.gz files could be bzip2- or xz-compressed.

Note that tarball compression is pretty much irrelevant where the 
tarball contains large compressed files, for example .rda files or 
vendor.tar.xz files of Rust sources.  You have to arrange that the first 
compression is the bast possible.

-- 
Brian D. Ripley,                  ripley at stats.ox.ac.uk
Emeritus Professor of Applied Statistics, University of Oxford


From hp@ge@@on@g|thub @end|ng |rom gm@||@com  Wed Sep 13 02:05:25 2023
From: hp@ge@@on@g|thub @end|ng |rom gm@||@com (=?UTF-8?B?SGVydsOpIFBhZ8Oocw==?=)
Date: Tue, 12 Sep 2023 17:05:25 -0700
Subject: [Rd] 
 FYI: daily R source tarballs from ETH: *.xz instead of *.bz2)
In-Reply-To: <f84b708a-6ddd-4c02-a97c-8a1331768444@stats.ox.ac.uk>
References: <25851.9552.398085.384361@stat.math.ethz.ch>
 <27378572-a2e2-eb29-1e7d-9c8d7020bd3a@gmail.com>
 <f84b708a-6ddd-4c02-a97c-8a1331768444@stats.ox.ac.uk>
Message-ID: <c31fd49d-3249-881b-64e5-a6ad9895be4e@gmail.com>

On 9/11/23 22:39, Prof Brian Ripley wrote:

> On 09/09/2023 01:56, Herv? Pag?s wrote:
>> Hi Martin,
>>
>> Sounds good. Are there any plans to support the xz compression for
>> package source tarballs?
>
> What makes you think it is not supported?

I guess because I've never seen source tarballs distributed as .xz files 
but it's good to know that 'R CMD build' and 'R CMD INSTALL' support that.

So let me reformulate my question: do CRAN have any plans to switch from 
.tar.gz to .xz for the distribution of source tarballs? Is this 
something that tools like write_PACKAGES(), available.packages(), and 
install.packages() would be able to handle? Would they be able to handle 
a mix of .tar.gz and .xz packages? (Which would be important for a 
smooth transition from .tar.gz to .xz across CRAN/Bioconductor.)

I'm just trying to get a sense if the effort to reduce bandwidth will go 
beyond the distribution of R source snapshots.

Thanks,

H.

-- 
Herv? Pag?s

Bioconductor Core Team
hpages.on.github at gmail.com

	[[alternative HTML version deleted]]


From m@rchywk@ @end|ng |rom hotm@||@com  Thu Sep 14 15:22:51 2023
From: m@rchywk@ @end|ng |rom hotm@||@com (Mike Marchywka)
Date: Thu, 14 Sep 2023 13:22:51 +0000
Subject: [Rd] R packages to send plottable data to external apps
In-Reply-To: <CALEXWq15oiL58nitHfNvKH00Chr07DeoMpiFpyXdqwbcxV_rZg@mail.gmail.com>
References: <BL3PR11MB6338324A0CEDD90C3DDD013CBEE1A@BL3PR11MB6338.namprd11.prod.outlook.com>
 <CALEXWq15oiL58nitHfNvKH00Chr07DeoMpiFpyXdqwbcxV_rZg@mail.gmail.com>
Message-ID: <BL3PR11MB6338D11AC8641C479D04F51EBEF7A@BL3PR11MB6338.namprd11.prod.outlook.com>

I put this up on github in current form where it sort of
works and I can use it for my needs but if anyone 
thinks it fills a niche I guess I could clean it up.

https://github.com/mmarchywka/mjmdatascope

Definitely not ready for users but maybe a deverloper.
In terms of the "Trend" package you mentioned 
maybe one interface would be to emulate that action
too as that was my original interest circa 2007 lol. 

fwiw.
Thanks. 


?Mike Marchywka?
44 Crosscreek Trail
Jasper GA 30143
was 306 Charles Cox Drive? Canton, GA 30115
470-758-0799
404-788-1216?




________________________________________
From: I?aki Ucar <iucar at fedoraproject.org>
Sent: Sunday, August 27, 2023 7:12 PM
To: Mike Marchywka
Cc: r-devel; R Package Development
Subject: Re: [Rd] R packages to send plottable data to external apps

I think r-package-devel is a better place for this. CC'ing there.

On Sun, 27 Aug 2023 at 23:50, Mike Marchywka <marchywka at hotmail.com> wrote:
>
> I was curious what R packages, or indeed any other applications, exist
> to plot streamed data from arbitrary data generators. It need not
> be publication quality plotting but it should be easy to use  like
> an oscilloscope.

The last time I checked, there wasn't any R package suitable for
plotting high-throughput streaming data.

There's a nice command-line utility called trend [1] that I
extensively used in the past as an oscilloscope to visualize the
output from a DAQ card. I don't see any new development there, but it
does exactly what it promises; it's easy to use, quite configurable
and very fast. Old but gold.

I also explored VisPy, which is much more ambitious, but at that time
the API had a limitation that didn't allow me to achieve what I
required, and I haven't looked at it ever since, but the project seems
in good shape.

[1] https://www.thregr.org/wavexx/software/trend/
[2] https://vispy.org/

Hope it helps,
I?aki

> I was working on something called datascope that I
> am using for 1D finite difference monitoring and recently interfaced it
> to freefem. I also created an R package. If there is any interest in something
> like this I guess I could put it up somewhere when it is more usable
> or if you can suggest some similar popular packages that would be good
> too. Is there something I could drop-in to the attached code and get
> something like the attached output that could also be switched to other
> data sources?  This right now works via linux fifo and somewhat by UDP.
> It can queue data and stop making it if no one seems to be  consuming
> it depending on the channel.
>
> Thanks.
>
>  Mike Marchywka
> 44 Crosscreek Trail
> Jasper GA 30143
> was 306 Charles Cox Drive  Canton, GA 30115
> 470-758-0799
> 404-788-1216
>
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



--
I?aki ?car


From kry|ov@r00t @end|ng |rom gm@||@com  Mon Sep 18 23:33:56 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Tue, 19 Sep 2023 00:33:56 +0300
Subject: [Rd] On PRINTNAME() encoding, EncodeChar(),
 and being painted into a corner
Message-ID: <20230919003356.13a97d6e@Tarkus>

Hello R-devel,

I have originally learned about this from the following GitHub issue:
<https://github.com/r-devel/r-project-sprint-2023/issues/65>. In short,
in various places of the R source code, symbol names are accessed using
translateChar(), EncodeChar(), and CHAR(), and it might help to unify
their use.

Currently, R is very careful to only create symbols with names in the
native encoding. I have verified this by tracing the ways a symbol can
be created (allocSExp) or have a name assigned (SET_PRINTNAME) using
static analysis (Coccinelle). While it's possible to create a symbol
with a name in an encoding different from the native encoding using
SET_PRINTNAME(symbol, mkCharCE(...)), neither R nor CRAN packages
invoke code like this for an arbitrary encoding; symbols are always
created using either install() or installTrChar(). (install("invalid
byte sequence") is, of course, still possible, but is a different
problem.)

This means that translateChar(PRINTNAME(...)) is currently unnecessary,
but it may be worth adding a check (opt-in, applicable only during R
CMD check, to avoid a performance hit?) to SET_PRINTNAME() to ensure
that only native-encoding (or ASCII) symbol names are used. I could also
suggest a patch for Writing R Extensions or R Internals to document this
assumption.

The following translateChar() doesn't hurt (it returns CHAR(x) right
away without allocating any memory), but it stands out against most
uses of CHAR(PRINTNAME(.)) and EncodeChar(PRINTNAME(.)):

--- src/main/subscript.c	(revision 85160)
+++ src/main/subscript.c	(working copy)
@@ -186,7 +186,7 @@
 	    PROTECT(names);
 	    for (i = 0; i < nx; i++)
 		if (streql(translateChar(STRING_ELT(names, i)),
-			   translateChar(PRINTNAME(s)))) {
+			   CHAR(PRINTNAME(s)))) {
 		    indx = i;
 		    break;
 		}

The following translateChar() can be safely replaced with EncodeChar(),
correctly printing funnily-named functions in tracemem() reports:

--- src/main/debug.c	(revision 85160)
+++ src/main/debug.c	(working copy)
@@ -203,7 +203,7 @@
 	    && TYPEOF(cptr->call) == LANGSXP) {
 	    SEXP fun = CAR(cptr->call);
 	    Rprintf("%s ",
-		    TYPEOF(fun) == SYMSXP ? translateChar(PRINTNAME(fun)) :
+		    TYPEOF(fun) == SYMSXP ? EncodeChar(PRINTNAME(fun)) : "<Anonymous>");
 	}
     }

tracemem(a <- 1:10)
`\r\v\t\n` <- function(x) x[1] <- 0
`\r\v\t\n`(a)
# Now correctly prints:
# tracemem[0x55fd11e61e00 -> 0x55fd1081d2a8]: \r\v\t\n
# tracemem[0x55fd1081d2a8 -> 0x55fd113277e8]: \r\v\t\n

What about EncodeChar(PRINTNAME(.))? This is the intended way to report
symbols in error messages. Without EncodeChar(),
.Internal(`\r\v\t\n`()) actually prints the newlines to standard output
as part of the error message instead of escaping them. Unfortunately,
EncodeChar() uses a statically-allocated buffer for its return value,
*and* the comments say that it's unsafe to use together with
errorcall(): errorcall_cpy() must be used instead. I think that's
because EncodeChar() may be called while deparsing the call,
overwriting the statically-allocated buffer before the format arguments
(which also contain the return value of EncodeChar()) are processed. In
particular, this means that EncodeChar() is unsafe to use with any kind
of warnings. The following Coccinelle script locates uses of
CHAR(PRINTNAME(.)) inside errors and warnings:

@@
expression x;
expression list arg1, arg2;
identifier fun =~ "(Rf_)?(error|warning)(call)?(_cpy)?";
@@
 fun(
  arg1,
* CHAR(PRINTNAME(x)),
  arg2
 )

Some of these, which already use errorcall(), are trivial to fix by
replacing CHAR() with EncodeChar() and upgrading errorcall() to
errorcall_cpy():

--- src/main/names.c
+++ src/main/names.c
@@ -1367,7 +1367,7 @@ attribute_hidden SEXP do_internal(SEXP c
 	errorcall(call, _("invalid .Internal() argument"));
     if (INTERNAL(fun) == R_NilValue)
-	errorcall(call, _("there is no .Internal function '%s'"),
+	errorcall_cpy(call, _("there is no .Internal function '%s'"),
-		  CHAR(PRINTNAME(fun)));
+		  EncodeChar(PRINTNAME(fun)));
 
 #ifdef CHECK_INTERNALS
     if(R_Is_Running > 1 && getenv("_R_CHECK_INTERNALS2_")) {

--- src/main/eval.c
+++ src/main/eval.c
@@ -1161,7 +1161,7 @@ SEXP eval(SEXP e, SEXP rho)
 	    const char *n = CHAR(PRINTNAME(e));
-	    if(*n) errorcall(getLexicalCall(rho),
+	    if(*n) errorcall_cpy(getLexicalCall(rho),
 			     _("argument \"%s\" is missing, with no default"),
-			     CHAR(PRINTNAME(e)));
+			     EncodeChar(PRINTNAME(e)));
 	    else errorcall(getLexicalCall(rho),
 			   _("argument is missing, with no default"));
 	}

--- src/main/match.c
+++ src/main/match.c
@@ -229,7 +229,7 @@ attribute_hidden SEXP matchArgs_NR(SEXP
 		      if (fargused[arg_i] == 2)
-			  errorcall(call,
+			  errorcall_cpy(call,
 	                      _("formal argument \"%s\" matched by multiple actual arguments"),
-	                      CHAR(PRINTNAME(TAG(f))));
+	                      EncodeChar(PRINTNAME(TAG(f))));
 		      if (ARGUSED(b) == 2)
 			  errorcall(call,
 	                      _("argument %d matches multiple formal arguments"),
@@ -272,12 +271,12 @@ attribute_hidden SEXP matchArgs_NR(SEXP
 			if (fargused[arg_i] == 1)
-			    errorcall(call,
+			    errorcall_cpy(call,
 				_("formal argument \"%s\" matched by multiple actual arguments"),
-				CHAR(PRINTNAME(TAG(f))));
+				EncodeChar(PRINTNAME(TAG(f))));
 			if (R_warn_partial_match_args) {
 			    warningcall(call,
 					_("partial argument match of '%s' to '%s'"), CHAR(PRINTNAME(TAG(b))),
 					CHAR(PRINTNAME(TAG(f))) );
 			}
 			SETCAR(a, CAR(b));
 			if (CAR(b) != R_MissingArg) SET_MISSING(a, 0);

The changes become more complicated with a plain error() (have to
figure out the current call and provide it to errorcall_cpy), still
more complicated with warnings (there's currently no warningcall_cpy(),
though one can be implemented) and even more complicated when multiple
symbols are used in the same warning or error, like in the last
warningcall() above (EncodeChar() can only be called once at a time).

The only solution to the latter problem is an EncodeChar() variant that
allocates its memory dynamically. Would R_alloc() be acceptable in this
context? With errors, the allocation stack would be quickly reset
(except when withCallingHandlers() is in effect?), but with warnings,
the code would have to restore it manually every time. Is it even worth
the effort to try to handle the (pretty rare) non-syntactic symbol names
while constructing error messages? Other languages (like Lua or SQLite)
provide a special printf specifier (typically %q) to create
quoted/escaped string representations, but we're not yet at the point
of providing a C-level printf implementation.

-- 
Best regards,
Ivan


From murdoch@dunc@n @end|ng |rom gm@||@com  Tue Sep 19 16:44:07 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Tue, 19 Sep 2023 10:44:07 -0400
Subject: [Rd] Strange behaviour of do.call()
Message-ID: <a20d1359-7097-42a9-903e-2b505bdb3343@gmail.com>

The knitr::kable() function does some internal setup, including 
determining the target format, and then calls an internal function using

   do.call(paste("kable", format, sep = "_"), list(x = x,
         caption = caption, escape = escape, ...))

I was interested in setting the `vlign` argument to knitr:::kable_latex, 
using this code:

   knitr::kable(head(mtcars), format="latex", align = "c", vlign="")

If I debug knitr::kable, I can see that `vlign = ""` is part of 
list(...).  However, if I debug knitr:::kable_latex, I get weird results:

   > debug(knitr:::kable_latex)
   > knitr::kable(head(mtcars), format="latex", align = "c", vlign="")
   debugging in: kable_latex(x = c("Mazda RX4", "Mazda RX4 Wag", "Datsun 
710",
   "Hornet 4 Drive", "Hornet Sportabout", "Valiant", "21.0", "21.0",
   "22.8", "21.4", "18.7", "18.1", "6", "6", "4", "6", "8", "6",
   "160", "160", "108", "258", "360", "225", "110", "110", "93",
   "110", "175", "105", "3.90", "3.90", "3.85", "3.08", "3.15",
   "2.76", "2.620", "2.875", "2.320", "3.215", "3.440", "3.460",
   "16.46", "17.02", "18.61", "19.44", "17.02", "20.22", "0", "0",
   "1", "1", "0", "1", "1", "1", "1", "0", "0", "0", "4", "4", "4",
   "3", "3", "3", "4", "4", "1", "1", "2", "1"), caption = NULL,
       escape = TRUE, vlign = "")
debug: {

   [rest of function display omitted]

I see here that vlign = "" is being shown as an argument.  However, when 
I print vlign, sometimes I get "object not found", and somethings I get

   Browse[2]> vline
   debug: [1] "|"

(which is what the default value would be).  In the latter case, I also see

   Browse[2]> list(...)
   $vlign
   [1] ""

i.e. vlign remains part of the ... list, it wasn't bound to the argument 
named vlign.

I can't spot anything particularly strange in the way knitr is handling 
this; can anyone else?  My sessionInfo() is below.

Duncan Murdoch

 > sessionInfo()
R version 4.3.1 (2023-06-16)
Platform: x86_64-apple-darwin20 (64-bit)
Running under: macOS Monterey 12.6.9

Matrix products: default
BLAS: 
/Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRblas.0.dylib 

LAPACK: 
/Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRlapack.dylib; 
  LAPACK version 3.11.0

locale:
[1] en_CA.UTF-8/en_CA.UTF-8/en_CA.UTF-8/C/en_CA.UTF-8/en_CA.UTF-8

time zone: America/Toronto
tzcode source: internal

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base

loaded via a namespace (and not attached):
[1] compiler_4.3.1 tools_4.3.1    knitr_1.44     xfun_0.40


From murdoch@dunc@n @end|ng |rom gm@||@com  Tue Sep 19 16:57:59 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Tue, 19 Sep 2023 10:57:59 -0400
Subject: [Rd] Strange behaviour of do.call()
In-Reply-To: <a20d1359-7097-42a9-903e-2b505bdb3343@gmail.com>
References: <a20d1359-7097-42a9-903e-2b505bdb3343@gmail.com>
Message-ID: <9b386333-6b31-4e7d-8a15-678ed1c8bef6@gmail.com>

Sorry, it's a silly thinko.  I misspelled the vline argument.  Thanks 
Ivan for the gentle nudge!

Duncan Murdoch

On 19/09/2023 10:44 a.m., Duncan Murdoch wrote:
> The knitr::kable() function does some internal setup, including
> determining the target format, and then calls an internal function using
> 
>     do.call(paste("kable", format, sep = "_"), list(x = x,
>           caption = caption, escape = escape, ...))
> 
> I was interested in setting the `vlign` argument to knitr:::kable_latex,
> using this code:
> 
>     knitr::kable(head(mtcars), format="latex", align = "c", vlign="")
> 
> If I debug knitr::kable, I can see that `vlign = ""` is part of
> list(...).  However, if I debug knitr:::kable_latex, I get weird results:
> 
>     > debug(knitr:::kable_latex)
>     > knitr::kable(head(mtcars), format="latex", align = "c", vlign="")
>     debugging in: kable_latex(x = c("Mazda RX4", "Mazda RX4 Wag", "Datsun
> 710",
>     "Hornet 4 Drive", "Hornet Sportabout", "Valiant", "21.0", "21.0",
>     "22.8", "21.4", "18.7", "18.1", "6", "6", "4", "6", "8", "6",
>     "160", "160", "108", "258", "360", "225", "110", "110", "93",
>     "110", "175", "105", "3.90", "3.90", "3.85", "3.08", "3.15",
>     "2.76", "2.620", "2.875", "2.320", "3.215", "3.440", "3.460",
>     "16.46", "17.02", "18.61", "19.44", "17.02", "20.22", "0", "0",
>     "1", "1", "0", "1", "1", "1", "1", "0", "0", "0", "4", "4", "4",
>     "3", "3", "3", "4", "4", "1", "1", "2", "1"), caption = NULL,
>         escape = TRUE, vlign = "")
> debug: {
> 
>     [rest of function display omitted]
> 
> I see here that vlign = "" is being shown as an argument.  However, when
> I print vlign, sometimes I get "object not found", and somethings I get
> 
>     Browse[2]> vline
>     debug: [1] "|"
> 
> (which is what the default value would be).  In the latter case, I also see
> 
>     Browse[2]> list(...)
>     $vlign
>     [1] ""
> 
> i.e. vlign remains part of the ... list, it wasn't bound to the argument
> named vlign.
> 
> I can't spot anything particularly strange in the way knitr is handling
> this; can anyone else?  My sessionInfo() is below.
> 
> Duncan Murdoch
> 
>   > sessionInfo()
> R version 4.3.1 (2023-06-16)
> Platform: x86_64-apple-darwin20 (64-bit)
> Running under: macOS Monterey 12.6.9
> 
> Matrix products: default
> BLAS:
> /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRblas.0.dylib
> 
> LAPACK:
> /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRlapack.dylib;
>    LAPACK version 3.11.0
> 
> locale:
> [1] en_CA.UTF-8/en_CA.UTF-8/en_CA.UTF-8/C/en_CA.UTF-8/en_CA.UTF-8
> 
> time zone: America/Toronto
> tzcode source: internal
> 
> attached base packages:
> [1] stats     graphics  grDevices utils     datasets  methods   base
> 
> loaded via a namespace (and not attached):
> [1] compiler_4.3.1 tools_4.3.1    knitr_1.44     xfun_0.40


From @oko| @end|ng |rom |n@@-tou|ou@e@|r  Tue Sep 19 17:05:57 2023
From: @oko| @end|ng |rom |n@@-tou|ou@e@|r (Serguei Sokol)
Date: Tue, 19 Sep 2023 17:05:57 +0200
Subject: [Rd] Strange behaviour of do.call()
In-Reply-To: <a20d1359-7097-42a9-903e-2b505bdb3343@gmail.com>
References: <a20d1359-7097-42a9-903e-2b505bdb3343@gmail.com>
Message-ID: <6c558a4d-d398-28ef-94ed-ab4ee4a639ef@insa-toulouse.fr>

Le 19/09/2023 ? 16:44, Duncan Murdoch a ?crit?:
> The knitr::kable() function does some internal setup, including 
> determining the target format, and then calls an internal function using
>
> ? do.call(paste("kable", format, sep = "_"), list(x = x,
> ??????? caption = caption, escape = escape, ...))
>
> I was interested in setting the `vlign` argument to 
> knitr:::kable_latex, using this code:
>
> ? knitr::kable(head(mtcars), format="latex", align = "c", vlign="")
>
> If I debug knitr::kable, I can see that `vlign = ""` is part of 
> list(...).? However, if I debug knitr:::kable_latex, I get weird results:
>
> ? > debug(knitr:::kable_latex)
> ? > knitr::kable(head(mtcars), format="latex", align = "c", vlign="")
If I do this in my R v4.3.1 on linux, I get:

 > debug(knitr:::kable_latex)
 > knitr::kable(head(mtcars), format="latex", align = "c", vlign="")
Error in kable_latex(x = c("Mazda RX4", "Mazda RX4 Wag", "Datsun 710",? :
 ? unused argument (vlign = "")

By looking at args(knitr:::kable_latex), I see 2 similar arguments 
'valign' and 'vline' but no 'vlign'.
Can it be just a typo in your code?


> debugging in: kable_latex(x = c("Mazda RX4", "Mazda RX4 Wag", "Datsun 
> 710",
> ? "Hornet 4 Drive", "Hornet Sportabout", "Valiant", "21.0", "21.0",
> ? "22.8", "21.4", "18.7", "18.1", "6", "6", "4", "6", "8", "6",
> ? "160", "160", "108", "258", "360", "225", "110", "110", "93",
> ? "110", "175", "105", "3.90", "3.90", "3.85", "3.08", "3.15",
> ? "2.76", "2.620", "2.875", "2.320", "3.215", "3.440", "3.460",
> ? "16.46", "17.02", "18.61", "19.44", "17.02", "20.22", "0", "0",
> ? "1", "1", "0", "1", "1", "1", "1", "0", "0", "0", "4", "4", "4",
> ? "3", "3", "3", "4", "4", "1", "1", "2", "1"), caption = NULL,
> ????? escape = TRUE, vlign = "")
> debug: {
>
> ? [rest of function display omitted]
>
> I see here that vlign = "" is being shown as an argument. However, 
> when I print vlign, sometimes I get "object not found", and somethings 
> I get
>
> ? Browse[2]> vline
> ? debug: [1] "|"
Here again, 'vline' is used on purpose instead of 'vlign'?

Best,
Serguei.

>
> (which is what the default value would be).? In the latter case, I 
> also see
>
> ? Browse[2]> list(...)
> ? $vlign
> ? [1] ""
>
> i.e. vlign remains part of the ... list, it wasn't bound to the 
> argument named vlign.
>
> I can't spot anything particularly strange in the way knitr is 
> handling this; can anyone else?? My sessionInfo() is below.
>
> Duncan Murdoch
>
> > sessionInfo()
> R version 4.3.1 (2023-06-16)
> Platform: x86_64-apple-darwin20 (64-bit)
> Running under: macOS Monterey 12.6.9
>
> Matrix products: default
> BLAS: 
> /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRblas.0.dylib 
>
> LAPACK: 
> /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRlapack.dylib; 
> ?LAPACK version 3.11.0
>
> locale:
> [1] en_CA.UTF-8/en_CA.UTF-8/en_CA.UTF-8/C/en_CA.UTF-8/en_CA.UTF-8
>
> time zone: America/Toronto
> tzcode source: internal
>
> attached base packages:
> [1] stats???? graphics? grDevices utils???? datasets? methods base
>
> loaded via a namespace (and not attached):
> [1] compiler_4.3.1 tools_4.3.1??? knitr_1.44???? xfun_0.40
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


-- 
Serguei Sokol
Ingenieur de recherche INRAE

Cellule Math?matiques
TBI, INSA/INRAE UMR 792, INSA/CNRS UMR 5504
135 Avenue de Rangueil
31077 Toulouse Cedex 04

tel: +33 5 61 55 98 49
email: sokol at insa-toulouse.fr
https://www.toulouse-biotechnology-institute.fr/en/plateformes-plateaux/cellule-mathematiques/


