From d@v|@ @end|ng |rom po@|t@co  Mon May  1 14:46:33 2023
From: d@v|@ @end|ng |rom po@|t@co (Davis Vaughan)
Date: Mon, 1 May 2023 08:46:33 -0400
Subject: [Rd] range() for Date and POSIXct could respect `finite = TRUE`
In-Reply-To: <25677.33376.349216.862139@stat.math.ethz.ch>
References: <CABzLhzyRuxgHnToS4CPn_g8NOsc6M5Tx+14Sf7X+cjD8NvZgRg@mail.gmail.com>
 <25677.33376.349216.862139@stat.math.ethz.ch>
Message-ID: <CABzLhzzq2W3JsDP6KoRfLi0K1roD+3RH8mvnjWs_AnhP3A2SQg@mail.gmail.com>

Martin,

Yes, I missed that those have `Summary.*` methods, thanks!

Tweaking those to respect `finite = TRUE` sounds great. It seems like
it might be a little tricky since the Summary methods call
`NextMethod()`, and `range.default()` uses `is.numeric()` to determine
whether or not to apply `finite`. Because `is.numeric.Date()` is
defined, that always returns `FALSE` for Dates (and POSIXt). Because
of that, it may still be easier to just write a specific
`range.Date()` method, but I'm not sure.

-Davis

On Sat, Apr 29, 2023 at 4:47?PM Martin Maechler
<maechler at stat.math.ethz.ch> wrote:
>
> >>>>> Davis Vaughan via R-devel
> >>>>>     on Fri, 28 Apr 2023 11:12:27 -0400 writes:
>
>     > Hi all,
>
>     > I noticed that `range.default()` has a nice `finite =
>     > TRUE` argument, but it doesn't actually apply to Date or
>     > POSIXct due to how `is.numeric()` works.
>
> Well, I think it would / should never apply:
>
> range() belongs to the "Summary" group generics (as min, max, ...)
>
> and there  *are*  Summary.Date()  and Summary.POSIX{c,l}t() methods.
>
> Without checking further for now, I think you are indirectly
> suggesting to enhance these three Summary.*() methods so they do
> obey  'finite = TRUE' .
>
> I think I agree they should.
>
> Martin
>
>     > ``` x <- .Date(c(0, Inf, 1, 2, Inf)) x #> [1] "1970-01-01"
>     > "Inf" "1970-01-02" "1970-01-03" "Inf"
>
>     > # Darn!  range(x, finite = TRUE) #> [1] "1970-01-01" "Inf"
>
>     > # What I want .Date(range(unclass(x), finite = TRUE)) #>
>     > [1] "1970-01-01" "1970-01-03" ```
>
>     > I think `finite = TRUE` would be pretty nice for Dates in
>     > particular.
>
>     > As a motivating example, sometimes you have ranges of
>     > dates represented by start/end pairs. It is fairly natural
>     > to represent an event that hasn't ended yet with an
>     > infinite date. If you need to then compute a sequence of
>     > dates spanning the full range of the start/end pairs, it
>     > would be nice to be able to use `range(finite = TRUE)` to
>     > do so:
>
>     > ``` start <- as.Date(c("2019-01-05", "2019-01-10",
>     > "2019-01-11", "2019-01-14")) end <-
>     > as.Date(c("2019-01-07", NA, "2019-01-14", NA))
>     > end[is.na(end)] <- Inf
>
>     > # `end = Inf` means that the event hasn't "ended" yet
>     > data.frame(start, end) #> start end #> 1 2019-01-05
>     > 2019-01-07 #> 2 2019-01-10 Inf #> 3 2019-01-11 2019-01-14
>     > #> 4 2019-01-14 Inf
>
>     > # Create a full sequence along all days in start/end range
>     > <- .Date(range(unclass(c(start, end)), finite = TRUE))
>     > seq(range[1], range[2], by = 1) #> [1] "2019-01-05"
>     > "2019-01-06" "2019-01-07" "2019-01-08" "2019-01-09" #> [6]
>     > "2019-01-10" "2019-01-11" "2019-01-12" "2019-01-13"
>     > "2019-01-14" ```
>
>     > It seems like one option is to create a `range.Date()`
>     > method that unclasses, forwards the arguments on to a
>     > second call to `range()`, and then reclasses?
>
>     > ``` range.Date <- function(x, ..., na.rm = FALSE, finite =
>     > FALSE) { .Date(range(unclass(x), na.rm = na.rm, finite =
>     > finite), oldClass(x)) } ```
>
>     > This is similar to how `rep.Date()` works.
>
>     > Thanks, Davis Vaughan
>
>     > ______________________________________________
>     > R-devel at r-project.org mailing list
>     > https://stat.ethz.ch/mailman/listinfo/r-devel


From kry|ov@r00t @end|ng |rom gm@||@com  Tue May  2 13:59:36 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Tue, 2 May 2023 14:59:36 +0300
Subject: [Rd] save.image Non-responsive to Interrupt
In-Reply-To: <SY2PR01MB300358E3EDF589B5A20227C8CD6B9@SY2PR01MB3003.ausprd01.prod.outlook.com>
References: <SY2PR01MB300358E3EDF589B5A20227C8CD6B9@SY2PR01MB3003.ausprd01.prod.outlook.com>
Message-ID: <20230502145936.0ee6dc91@arachnoid>

? Sat, 29 Apr 2023 00:00:02 +0000
Dario Strbenac via R-devel <r-devel at r-project.org> ?????:

> Could save.image() be redesigned so that it promptly responds to
> Ctrl+C? It prevents the command line from being used for a number of
> hours if the contents of the workspace are large.

This is ultimately caused by serialize() being non-interruptible. A
relatively simple way to hang an R session for a long-ish time would
therefore be:

f <- xzfile(nullfile(), 'a+b')
x <- rep(0, 1e9) # approx. 8 gigabytes, adjust for your RAM size
serialize(x, f)
close(f)

This means that calling R_CheckUserInterrupt() between saving
individual objects is not enough: R also needs to check for interrupts
while saving sufficiently long vectors.

Since the serialize() infrastructure is carefully written to avoid
resource leaks on allocation failures, it looks relatively safe to
liberally sprinkle R_CheckUserInterrupt() where it makes sense to do
so, i.e. once per WriteItem() (which calls itself recursively and
non-recursively) and once per every downstream for loop iteration.
Valgrind doesn't show any new leaks if I apply the patch, interrupt
serialize() and then exit. R also passes make check after the applied
patch.

Do these changes make sense, or am I overlooking some other problem?

-- 
Best regards,
Ivan

-------------- next part --------------
A non-text attachment was scrubbed...
Name: interrupt-serialize.patch
Type: text/x-patch
Size: 4173 bytes
Desc: not available
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20230502/ab1d7f31/attachment.bin>

From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Tue May  2 15:28:48 2023
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Tue, 2 May 2023 15:28:48 +0200
Subject: [Rd] save.image Non-responsive to Interrupt
In-Reply-To: <20230502145936.0ee6dc91@arachnoid>
References: <SY2PR01MB300358E3EDF589B5A20227C8CD6B9@SY2PR01MB3003.ausprd01.prod.outlook.com>
 <20230502145936.0ee6dc91@arachnoid>
Message-ID: <25681.4112.978286.30568@stat.math.ethz.ch>

>>>>> Ivan Krylov 
>>>>>     on Tue, 2 May 2023 14:59:36 +0300 writes:

    > ? Sat, 29 Apr 2023 00:00:02 +0000
    > Dario Strbenac via R-devel <r-devel at r-project.org> ?????:

    >> Could save.image() be redesigned so that it promptly responds to
    >> Ctrl+C? It prevents the command line from being used for a number of
    >> hours if the contents of the workspace are large.

    > This is ultimately caused by serialize() being non-interruptible. A
    > relatively simple way to hang an R session for a long-ish time would
    > therefore be:

    > f <- xzfile(nullfile(), 'a+b')
    > x <- rep(0, 1e9) # approx. 8 gigabytes, adjust for your RAM size
    > serialize(x, f)
    > close(f)

    > This means that calling R_CheckUserInterrupt() between saving
    > individual objects is not enough: R also needs to check for interrupts
    > while saving sufficiently long vectors.

    > Since the serialize() infrastructure is carefully written to avoid
    > resource leaks on allocation failures, it looks relatively safe to
    > liberally sprinkle R_CheckUserInterrupt() where it makes sense to do
    > so, i.e. once per WriteItem() (which calls itself recursively and
    > non-recursively) and once per every downstream for loop iteration.
    > Valgrind doesn't show any new leaks if I apply the patch, interrupt
    > serialize() and then exit. R also passes make check after the applied
    > patch.

    > Do these changes make sense, or am I overlooking some other problem?

Thank you, Ivan!

They do make sense... but :

OTOH, in the past we have had to *disable*  R_CheckUserInterrupt()
in parts of R's code because it was too expensive,
{see current src/main/{seq.c,unique.c}  for a series of commented-out
 R_CheckUserInterrupt() for such speed-loss reasons}

so  adding these may need a lot of care when we simultaneously
want to remain  efficient for "morally valid" use of serialization...
where we really don't want to pay too much of a premium.

{{ saving the whole user workspace is not "valid" in that sense
   in my view.  I tell all my (non-beginner) Rstudio-using
   students they should turn *off* the automatic saving and
   loading at session end / beginning; and for reproducibility
   only saveRDS() [or save()] *explicitly* a few precious
   objects ..
}}

Again, we don't want to punish people who know what they are
doing, just because other R users manage to hang their R session
by too little thinking ... 

Your patch adds 15 such interrupt checking calls which may
really be too much -- I'm not claiming they are: with our
recursive objects it's surely not very easy to determine the
"minimally necessary" such calls.

In addition, we may still consider adding an extra optional
argument, say   `check.interrupt = TRUE`
which we may default to TRUE when  save.image() is called
but e.g., not when serialize() is called..

Martin

    > -- 
    > Best regards,
    > Ivan
    > x[DELETED ATTACHMENT external: Rd_IvanKrylov_interrupt-serialize.patch, text/x-patch]
    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From ru@@e|| @end|ng |rom r@|mond@net  Tue May  2 22:42:47 2023
From: ru@@e|| @end|ng |rom r@|mond@net (Russell Almond)
Date: Tue, 2 May 2023 16:42:47 -0400
Subject: [Rd] is(x,"ANY") is FALSE
Message-ID: <7BAB2953-CF25-484C-925F-CD460AC90A23@ralmond.net>

I?m somewhat puzzled by the following bit of code on R 4.2.3 (also R 4.2.2)

> df <- data.frame(x=1:3)
> is (df,"ANY")
[1] FALSE

This seem to be false when the first argument is any S3 class, while I would think that ?ANY? would be true for S3, S4 and reference classes, as well as primitive types.

This also seems to be a regression, as code that was previously working no longer works.


A little more context on my use.

I?m defining a slot for a reference class using a type union, 
setClass(?MongoDB?,c(?NULL?,?ANY?))

[I should be using setOldClass(?mongo?) here, but I was having trouble promoting the S3 ?mongo? class I was getting from the library.]

Then when I try to set the corresopnding slot I?m getting an error, because ?mongo? is not of type MongoDB (even through that is a class union which contains ?ANY?).  

I can work around the problem by setting the slot to type ?ANY?, but then I loose the documentation that the intention is that it should a mongo database connection.

Did I miss something here?  Or is this an unintended consequence of some other change?

Thanks,
  ?Russell Almond




	[[alternative HTML version deleted]]


From jeroenoom@ @end|ng |rom gm@||@com  Wed May  3 00:55:48 2023
From: jeroenoom@ @end|ng |rom gm@||@com (Jeroen Ooms)
Date: Wed, 3 May 2023 00:55:48 +0200
Subject: [Rd] save.image Non-responsive to Interrupt
In-Reply-To: <25681.4112.978286.30568@stat.math.ethz.ch>
References: <SY2PR01MB300358E3EDF589B5A20227C8CD6B9@SY2PR01MB3003.ausprd01.prod.outlook.com>
 <20230502145936.0ee6dc91@arachnoid>
 <25681.4112.978286.30568@stat.math.ethz.ch>
Message-ID: <CABFfbXtru7PyV_1ecknsSLg6C3HqzVw9Mja2rybvwM76oOiT5A@mail.gmail.com>

On Tue, May 2, 2023 at 3:29?PM Martin Maechler
<maechler at stat.math.ethz.ch> wrote:
>
> >>>>> Ivan Krylov
> >>>>>     on Tue, 2 May 2023 14:59:36 +0300 writes:
>
>     > ? Sat, 29 Apr 2023 00:00:02 +0000
>     > Dario Strbenac via R-devel <r-devel at r-project.org> ?????:
>
>     >> Could save.image() be redesigned so that it promptly responds to
>     >> Ctrl+C? It prevents the command line from being used for a number of
>     >> hours if the contents of the workspace are large.
>
>     > This is ultimately caused by serialize() being non-interruptible. A
>     > relatively simple way to hang an R session for a long-ish time would
>     > therefore be:
>
>     > f <- xzfile(nullfile(), 'a+b')
>     > x <- rep(0, 1e9) # approx. 8 gigabytes, adjust for your RAM size
>     > serialize(x, f)
>     > close(f)
>
>     > This means that calling R_CheckUserInterrupt() between saving
>     > individual objects is not enough: R also needs to check for interrupts
>     > while saving sufficiently long vectors.
>
>     > Since the serialize() infrastructure is carefully written to avoid
>     > resource leaks on allocation failures, it looks relatively safe to
>     > liberally sprinkle R_CheckUserInterrupt() where it makes sense to do
>     > so, i.e. once per WriteItem() (which calls itself recursively and
>     > non-recursively) and once per every downstream for loop iteration.
>     > Valgrind doesn't show any new leaks if I apply the patch, interrupt
>     > serialize() and then exit. R also passes make check after the applied
>     > patch.
>
>     > Do these changes make sense, or am I overlooking some other problem?
>
> Thank you, Ivan!
>
> They do make sense... but :
>
> OTOH, in the past we have had to *disable*  R_CheckUserInterrupt()
> in parts of R's code because it was too expensive,
> {see current src/main/{seq.c,unique.c}  for a series of commented-out
>  R_CheckUserInterrupt() for such speed-loss reasons}
>
> so  adding these may need a lot of care when we simultaneously
> want to remain  efficient for "morally valid" use of serialization...
> where we really don't want to pay too much of a premium.

Alternatively, one could consider making R throttle or debounce calls
to R_CheckUserInterrupt such that a repeated calls within x time are
ignored, cf: https://www.freecodecamp.org/news/javascript-debounce-example/

The reasoning being that it may be difficult for (contributed) code to
determine when/where it is appropriate to check for interrupts, given
varying code paths and cpu speed. Maybe it makes more sense to call
R_CheckUserInterrupt frequently wherever it is safe to do so, and let
R decide if reasonable time has elapsed to actually run the (possibly
expensive) ui check again.

Basic example: https://github.com/r-devel/r-svn/pull/125/files




>
> {{ saving the whole user workspace is not "valid" in that sense
>    in my view.  I tell all my (non-beginner) Rstudio-using
>    students they should turn *off* the automatic saving and
>    loading at session end / beginning; and for reproducibility
>    only saveRDS() [or save()] *explicitly* a few precious
>    objects ..
> }}
>
> Again, we don't want to punish people who know what they are
> doing, just because other R users manage to hang their R session
> by too little thinking ...
>
> Your patch adds 15 such interrupt checking calls which may
> really be too much -- I'm not claiming they are: with our
> recursive objects it's surely not very easy to determine the
> "minimally necessary" such calls.
>
> In addition, we may still consider adding an extra optional
> argument, say   `check.interrupt = TRUE`
> which we may default to TRUE when  save.image() is called
> but e.g., not when serialize() is called..
>
> Martin
>
>     > --
>     > Best regards,
>     > Ivan
>     > x[DELETED ATTACHMENT external: Rd_IvanKrylov_interrupt-serialize.patch, text/x-patch]
>     > ______________________________________________
>     > R-devel at r-project.org mailing list
>     > https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From |@wrence@m|ch@e| @end|ng |rom gene@com  Wed May  3 01:01:41 2023
From: |@wrence@m|ch@e| @end|ng |rom gene@com (Michael Lawrence (MICHAFLA))
Date: Tue, 2 May 2023 16:01:41 -0700
Subject: [Rd] [Sender Not Verified]  is(x,"ANY") is FALSE
In-Reply-To: <7BAB2953-CF25-484C-925F-CD460AC90A23@ralmond.net>
References: <7BAB2953-CF25-484C-925F-CD460AC90A23@ralmond.net>
Message-ID: <CAOQ5Nyes-9gU1=efynk66nEbZc0XvaGVhgky_4o79g9iD6+1mA@mail.gmail.com>

Hi,

This does seem to be a bug in is(); I'll take a look. I'm curious
about what stopped you from using setOldClass(), since that seems to
be the most appropriate solution.

Michael

On Tue, May 2, 2023 at 2:59?PM Russell Almond <russell at ralmond.net> wrote:
>
> I?m somewhat puzzled by the following bit of code on R 4.2.3 (also R 4.2.2)
>
> > df <- data.frame(x=1:3)
> > is (df,"ANY")
> [1] FALSE
>
> This seem to be false when the first argument is any S3 class, while I would think that ?ANY? would be true for S3, S4 and reference classes, as well as primitive types.
>
> This also seems to be a regression, as code that was previously working no longer works.
>
>
> A little more context on my use.
>
> I?m defining a slot for a reference class using a type union,
> setClass(?MongoDB?,c(?NULL?,?ANY?))
>
> [I should be using setOldClass(?mongo?) here, but I was having trouble promoting the S3 ?mongo? class I was getting from the library.]
>
> Then when I try to set the corresopnding slot I?m getting an error, because ?mongo? is not of type MongoDB (even through that is a class union which contains ?ANY?).
>
> I can work around the problem by setting the slot to type ?ANY?, but then I loose the documentation that the intention is that it should a mongo database connection.
>
> Did I miss something here?  Or is this an unintended consequence of some other change?
>
> Thanks,
>   ?Russell Almond
>
>
>
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Michael Lawrence
Senior Principal Scientist, Director of Data Science and Statistical Computing
Genentech, A Member of the Roche Group
Office +1 (650) 225-7760
michafla at gene.com

Join Genentech on LinkedIn | Twitter | Facebook | Instagram | YouTube


From henr|k@bengt@@on @end|ng |rom gm@||@com  Wed May  3 01:25:41 2023
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Tue, 2 May 2023 16:25:41 -0700
Subject: [Rd] save.image Non-responsive to Interrupt
In-Reply-To: <CABFfbXtru7PyV_1ecknsSLg6C3HqzVw9Mja2rybvwM76oOiT5A@mail.gmail.com>
References: <SY2PR01MB300358E3EDF589B5A20227C8CD6B9@SY2PR01MB3003.ausprd01.prod.outlook.com>
 <20230502145936.0ee6dc91@arachnoid>
 <25681.4112.978286.30568@stat.math.ethz.ch>
 <CABFfbXtru7PyV_1ecknsSLg6C3HqzVw9Mja2rybvwM76oOiT5A@mail.gmail.com>
Message-ID: <CAFDcVCRxU8KiDcT7yNxxDGWzMgckg2gDQQ7f-mmqGhYhseVcJA@mail.gmail.com>

Along the lines of calling R_CheckUserInterrupt() only onces in a while:

> OTOH, in the past we have had to *disable*  R_CheckUserInterrupt()
> in parts of R's code because it was too expensive,
> {see current src/main/{seq.c,unique.c}  for a series of commented-out
> R_CheckUserInterrupt() for such speed-loss reasons}

First, here are links to these two files viewable online:

 * https://github.com/wch/r-source/blob/trunk/src/main/seq.c

 * https://github.com/wch/r-source/blob/trunk/src/main/unique.c

When not commented out, R_CheckUserInterrupt() would have been called
every 1,000,000 times per:

  /* interval at which to check interrupts */
  #define NINTERRUPT 1000000

and

  if ((i+1) % NINTERRUPT == 0) R_CheckUserInterrupt()

in each iteration. That '(i+1) % NINTERRUPT == 0' expression can be
quite expensive too.  However, if we change the code to use NINTERRUPT
= 2^k where k = {1, 2, ...}, say

  #define NINTERRUPT 1048576

the compiler would optimize the condition to use "the modulo of powers
of 2 can alternatively be expressed as a bitwise AND operation"
(Thomas Lumley, 2015-06-15).  The speedup is quite impressive, cf.
<https://www.jottr.org/2015/06/05/checkuserinterrupt/>.
Alternatively, one can increment a counter and reset to zero after
calling R_CheckUserInterrupt(); I think that's equally performant.

Regarding making serialize() / unserialize() interruptible: I think
can be a good idea since we work with larger objects these days.
However, if we implement this, we probably have to consider what
happens when an interrupt happens. For example, transfers between a
client and a server are no longer atomic at this level, which means we
might end up in a corrupt state. This may, for instance, happen to
database transactions, and PSOCK parallel worker communication.  A
quick fix would be to use base::suspendInterrupts(), but better would
of course be to handle interrupts gracefully.

My $.02 + $0.02

/Henrik

On Tue, May 2, 2023 at 3:56?PM Jeroen Ooms <jeroenooms at gmail.com> wrote:
>
> On Tue, May 2, 2023 at 3:29?PM Martin Maechler
> <maechler at stat.math.ethz.ch> wrote:
> >
> > >>>>> Ivan Krylov
> > >>>>>     on Tue, 2 May 2023 14:59:36 +0300 writes:
> >
> >     > ? Sat, 29 Apr 2023 00:00:02 +0000
> >     > Dario Strbenac via R-devel <r-devel at r-project.org> ?????:
> >
> >     >> Could save.image() be redesigned so that it promptly responds to
> >     >> Ctrl+C? It prevents the command line from being used for a number of
> >     >> hours if the contents of the workspace are large.
> >
> >     > This is ultimately caused by serialize() being non-interruptible. A
> >     > relatively simple way to hang an R session for a long-ish time would
> >     > therefore be:
> >
> >     > f <- xzfile(nullfile(), 'a+b')
> >     > x <- rep(0, 1e9) # approx. 8 gigabytes, adjust for your RAM size
> >     > serialize(x, f)
> >     > close(f)
> >
> >     > This means that calling R_CheckUserInterrupt() between saving
> >     > individual objects is not enough: R also needs to check for interrupts
> >     > while saving sufficiently long vectors.
> >
> >     > Since the serialize() infrastructure is carefully written to avoid
> >     > resource leaks on allocation failures, it looks relatively safe to
> >     > liberally sprinkle R_CheckUserInterrupt() where it makes sense to do
> >     > so, i.e. once per WriteItem() (which calls itself recursively and
> >     > non-recursively) and once per every downstream for loop iteration.
> >     > Valgrind doesn't show any new leaks if I apply the patch, interrupt
> >     > serialize() and then exit. R also passes make check after the applied
> >     > patch.
> >
> >     > Do these changes make sense, or am I overlooking some other problem?
> >
> > Thank you, Ivan!
> >
> > They do make sense... but :
> >
> > OTOH, in the past we have had to *disable*  R_CheckUserInterrupt()
> > in parts of R's code because it was too expensive,
> > {see current src/main/{seq.c,unique.c}  for a series of commented-out
> >  R_CheckUserInterrupt() for such speed-loss reasons}
> >
> > so  adding these may need a lot of care when we simultaneously
> > want to remain  efficient for "morally valid" use of serialization...
> > where we really don't want to pay too much of a premium.
>
> Alternatively, one could consider making R throttle or debounce calls
> to R_CheckUserInterrupt such that a repeated calls within x time are
> ignored, cf: https://www.freecodecamp.org/news/javascript-debounce-example/
>
> The reasoning being that it may be difficult for (contributed) code to
> determine when/where it is appropriate to check for interrupts, given
> varying code paths and cpu speed. Maybe it makes more sense to call
> R_CheckUserInterrupt frequently wherever it is safe to do so, and let
> R decide if reasonable time has elapsed to actually run the (possibly
> expensive) ui check again.
>
> Basic example: https://github.com/r-devel/r-svn/pull/125/files
>
>
>
>
> >
> > {{ saving the whole user workspace is not "valid" in that sense
> >    in my view.  I tell all my (non-beginner) Rstudio-using
> >    students they should turn *off* the automatic saving and
> >    loading at session end / beginning; and for reproducibility
> >    only saveRDS() [or save()] *explicitly* a few precious
> >    objects ..
> > }}
> >
> > Again, we don't want to punish people who know what they are
> > doing, just because other R users manage to hang their R session
> > by too little thinking ...
> >
> > Your patch adds 15 such interrupt checking calls which may
> > really be too much -- I'm not claiming they are: with our
> > recursive objects it's surely not very easy to determine the
> > "minimally necessary" such calls.
> >
> > In addition, we may still consider adding an extra optional
> > argument, say   `check.interrupt = TRUE`
> > which we may default to TRUE when  save.image() is called
> > but e.g., not when serialize() is called..
> >
> > Martin
> >
> >     > --
> >     > Best regards,
> >     > Ivan
> >     > x[DELETED ATTACHMENT external: Rd_IvanKrylov_interrupt-serialize.patch, text/x-patch]
> >     > ______________________________________________
> >     > R-devel at r-project.org mailing list
> >     > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From k@ro||@@koncev|c|u@ @end|ng |rom gm@||@com  Wed May  3 09:36:30 2023
From: k@ro||@@koncev|c|u@ @end|ng |rom gm@||@com (=?utf-8?Q?Karolis_Koncevi=C4=8Dius?=)
Date: Wed, 3 May 2023 10:36:30 +0300
Subject: [Rd] Inquiry about the behaviour of subsetting and names in matrices
Message-ID: <EC0F4F60-0817-4FAB-90DC-F5C0B7FD1125@gmail.com>

Hello,

I have stumbled upon a few cases where the behaviour of naming and subsetting in matrices seems unintuitive.
All those look related so wanted to put everything in one message.


1. Why row/col selection by names with NAs is not allowed?

  x <- setNames(1:10, letters[1:10])
  X <- matrix(x, nrow=2, dimnames = list(letters[1:2], LETTERS[1:5]))

  x[c(1, NA, 3)]       # vector: works and adds "NA"
  x[c("a", NA, "c")]   # vector: works and adds "NA"
  X[,c(1, NA, 3)]      # works and selects "NA" column
  X[,c("A", NA, "C")]  # <error>


2. Should setting names() for a matrix be allowed?

  names(X) <- paste0("e", 1:length(X))
  X["e4"]  # works

  # but any operation on a matrix drops the names
  X <- X[,-1]  # all names are gone
  X["e4"]      # <error>

  Maybe names() should not be allowed on a matrix?


3. Should selection of non-existent dimension names really be an error?

  x[22]   # works on a vector - gives "NA"
  X[,22]  # <error>


  A potential useful use-case is matching a smaller matrix to a larger one:
  A <- matrix(rnorm(10), nrow=2, dimnames = list(c("a","c")))
  B <- matrix(rnorm(20), nrow=4, dimnames = list(c("a", "b", "c", "d")))

  # matching larger matrix to the smaller one <works>
  B[rownames(A),]

  # matching smaller matrix to the larger one <error>
  A[rownames(B),]


These also doesn't seem to be documented in '[', 'names', 'rownames?.

Interested if there specific reasons for this behaviour, or could these potentially be adjusted?

Kind regards,
Karolis K.


From Andre@G||||bert @end|ng |rom chu-rouen@|r  Wed May  3 10:15:52 2023
From: Andre@G||||bert @end|ng |rom chu-rouen@|r (GILLIBERT, Andre)
Date: Wed, 3 May 2023 08:15:52 +0000
Subject: [Rd] Inquiry about the behaviour of subsetting and names in
 matrices
In-Reply-To: <EC0F4F60-0817-4FAB-90DC-F5C0B7FD1125@gmail.com>
References: <EC0F4F60-0817-4FAB-90DC-F5C0B7FD1125@gmail.com>
Message-ID: <55788649253e44f7b5fb4bcb46cde7c6@chu-rouen.fr>


Karolis wrote:
> Hello,

> I have stumbled upon a few cases where the behaviour of naming and subsetting in matrices seems unintuitive.
> All those look related so wanted to put everything in one message.


> 1. Why row/col selection by names with NAs is not allowed?

>   x <- setNames(1:10, letters[1:10])
>   X <- matrix(x, nrow=2, dimnames = list(letters[1:2], LETTERS[1:5]))

>   x[c(1, NA, 3)]       # vector: works and adds "NA"
>   x[c("a", NA, "c")]   # vector: works and adds "NA"
>   X[,c(1, NA, 3)]      # works and selects "NA" column
>   X[,c("A", NA, "C")]  # <error>

I would state the question the other way : why are NAs integer indices allowed?
In my experience, they are sometimes useful but they often delay the detection of bugs. However, due to backward compatibility, this feature cannot be removed. Adding this feature to character indices would worsen the problem.

I see another reason to keep the behavior as is currently : character indices are most often used with column names in contexts were they are unlikely to be NAs except as a consequence of a bug. In other words, I fear that the valid-use-case/bug ratio would be quite poor with this feature.

> 2. Should setting names() for a matrix be allowed?
>
>   names(X) <- paste0("e", 1:length(X))
>   X["e4"]  # works
>
>   # but any operation on a matrix drops the names
>   X <- X[,-1]  # all names are gone
>   X["e4"]      # <error>
>
>   Maybe names() should not be allowed on a matrix?

Setting names() on a matrix is a rarely used feature that has practically no positive and no negative consequences. I see no incentive to change the behavior and break existing code.

> 3. Should selection of non-existent dimension names really be an error?
>
>   x[22]   # works on a vector - gives "NA"
>   X[,22]  # <error>

This is very often a bug on vectors and should not have been allowed on vectors in the first place... But for backwards compatibility, it is hard to remove. Adding this unsafe feature to matrices is a poor idea in my opinion.

>   A potential useful use-case is matching a smaller matrix to a larger one:

This is a valid use-case, but in my opinion, it adds more problems than it solves.

> These also doesn't seem to be documented in '[', 'names', 'rownames?.

Indeed, the documentation of '[' seems to be unclear on indices out of range. It can be improved.

> Interested if there specific reasons for this behaviour, or could these potentially be adjusted?

In my opinion adding these features would improve the consistency of R but would add more sources of bugs in an already unsafe language.

Sincerely
Andr? GILLIBERT

From k@ro||@@koncev|c|u@ @end|ng |rom gm@||@com  Wed May  3 11:08:28 2023
From: k@ro||@@koncev|c|u@ @end|ng |rom gm@||@com (=?utf-8?Q?Karolis_Koncevi=C4=8Dius?=)
Date: Wed, 3 May 2023 12:08:28 +0300
Subject: [Rd] Inquiry about the behaviour of subsetting and names in
 matrices
In-Reply-To: <55788649253e44f7b5fb4bcb46cde7c6@chu-rouen.fr>
References: <EC0F4F60-0817-4FAB-90DC-F5C0B7FD1125@gmail.com>
 <55788649253e44f7b5fb4bcb46cde7c6@chu-rouen.fr>
Message-ID: <DC33ED02-B1F4-4252-BB22-BDBC09207855@gmail.com>

Thank you for such a quick reply, here are some points that I think might have been missed:

> I would state the question the other way : why are NAs integer indices allowed?
> In my experience, they are sometimes useful but they often delay the detection of bugs. However, due to backward compatibility, this feature cannot be removed. Adding this feature to character indices would worsen the problem.

But please also note that character indices with NA are allowed for vectors. This is more an inconsistency between vectors and matrices. In vectors both numeric and character sub-setting works with NAs. In matrices only numberic and not character sub-setting works with NAs. Potentially this in itself can also be a source of bugs, or, at least surprises.

> Setting names() on a matrix is a rarely used feature that has practically no positive and no negative consequences. I see no incentive to change the behavior and break existing code.

When writing this message I had the opposite opinion. That this 2nd point is one of the most bug-probe points of all 3. As I would assume most users setting names() on a matrix would only do it by accident.

> In my opinion adding these features would improve the consistency of R but would add more sources of bugs in an already unsafe language.

I think this maybe is a crux of the thing.

My original impression was that R was ?clever? about the usage of NAs by design. i.e. when you choose an unknown object from a set of objects the result is an object, but nobody knows which - hence NA. Is it really accepted now that such a decision was a mistake and lead to bugs in user code?

Kind regards,
Karolis K.

> On May 3, 2023, at 11:15 AM, GILLIBERT, Andre <Andre.Gillibert at chu-rouen.fr> wrote:
> 
> 
> Karolis wrote:
>> Hello,
> 
>> I have stumbled upon a few cases where the behaviour of naming and subsetting in matrices seems unintuitive.
>> All those look related so wanted to put everything in one message.
> 
> 
>> 1. Why row/col selection by names with NAs is not allowed?
> 
>>  x <- setNames(1:10, letters[1:10])
>>  X <- matrix(x, nrow=2, dimnames = list(letters[1:2], LETTERS[1:5]))
> 
>>  x[c(1, NA, 3)]       # vector: works and adds "NA"
>>  x[c("a", NA, "c")]   # vector: works and adds "NA"
>>  X[,c(1, NA, 3)]      # works and selects "NA" column
>>  X[,c("A", NA, "C")]  # <error>
> 
> I would state the question the other way : why are NAs integer indices allowed?
> In my experience, they are sometimes useful but they often delay the detection of bugs. However, due to backward compatibility, this feature cannot be removed. Adding this feature to character indices would worsen the problem.
> 
> I see another reason to keep the behavior as is currently : character indices are most often used with column names in contexts were they are unlikely to be NAs except as a consequence of a bug. In other words, I fear that the valid-use-case/bug ratio would be quite poor with this feature.
> 
>> 2. Should setting names() for a matrix be allowed?
>> 
>>  names(X) <- paste0("e", 1:length(X))
>>  X["e4"]  # works
>> 
>>  # but any operation on a matrix drops the names
>>  X <- X[,-1]  # all names are gone
>>  X["e4"]      # <error>
>> 
>>  Maybe names() should not be allowed on a matrix?
> 
> Setting names() on a matrix is a rarely used feature that has practically no positive and no negative consequences. I see no incentive to change the behavior and break existing code.
> 
>> 3. Should selection of non-existent dimension names really be an error?
>> 
>>  x[22]   # works on a vector - gives "NA"
>>  X[,22]  # <error>
> 
> This is very often a bug on vectors and should not have been allowed on vectors in the first place... But for backwards compatibility, it is hard to remove. Adding this unsafe feature to matrices is a poor idea in my opinion.
> 
>>  A potential useful use-case is matching a smaller matrix to a larger one:
> 
> This is a valid use-case, but in my opinion, it adds more problems than it solves.
> 
>> These also doesn't seem to be documented in '[', 'names', 'rownames?.
> 
> Indeed, the documentation of '[' seems to be unclear on indices out of range. It can be improved.
> 
>> Interested if there specific reasons for this behaviour, or could these potentially be adjusted?
> 
> In my opinion adding these features would improve the consistency of R but would add more sources of bugs in an already unsafe language.
> 
> Sincerely
> Andr? GILLIBERT


	[[alternative HTML version deleted]]


From Andre@G||||bert @end|ng |rom chu-rouen@|r  Wed May  3 23:11:07 2023
From: Andre@G||||bert @end|ng |rom chu-rouen@|r (GILLIBERT, Andre)
Date: Wed, 3 May 2023 21:11:07 +0000
Subject: [Rd] Inquiry about the behaviour of subsetting and names in
 matrices
In-Reply-To: <DC33ED02-B1F4-4252-BB22-BDBC09207855@gmail.com>
References: <EC0F4F60-0817-4FAB-90DC-F5C0B7FD1125@gmail.com>
 <55788649253e44f7b5fb4bcb46cde7c6@chu-rouen.fr>,
 <DC33ED02-B1F4-4252-BB22-BDBC09207855@gmail.com>
Message-ID: <e9c6873bbafe420b8e27542998d9bf70@chu-rouen.fr>


Karolis K wrote:

> This is more an inconsistency between vectors and matrices.

> In vectors both numeric and character sub-setting works with NAs.

> In matrices only numberic and not character sub-setting works with NAs.

> Potentially this in itself can also be a source of bugs, or, at least surprises.


Indeed.


Karolis K wrote:

> My original impression was that R was ?clever? about the usage of NAs by design. i.e. when you choose an unknown object

> from a set of objects the result is an object, but nobody knows which - hence NA. Is it really accepted now that such a

> decision was a mistake and lead to bugs in user code?


This makes sense but my personal opinion (I do not speak for R developers, as I am not an R developer at all) is that the R language is so "clever" that it often becomes unsafe.

Sometimes, this cleverness is handy for fast programming, such as NA propagation at many places. Other times, it causes more bugs than it helps, such as partial matching for the '$' operator. Indexation of column names in a matrix is probably not the place where NA propagation is the most useful, although it has its use cases. Consistency may be the main reason to add that feature, but I am not sure that this is a major incentive.


Of course, the opinion of R developers would be more useful than my own personal views.


--

Sincerely

Andr? GILLIBERT

________________________________
De : Karolis Koncevi?ius <karolis.koncevicius at gmail.com>
Envoy? : mercredi 3 mai 2023 11:08:28
? : GILLIBERT, Andre
Cc : r-devel at r-project.org
Objet : Re: [Rd] Inquiry about the behaviour of subsetting and names in matrices


ATTENTION: Cet e-mail provient d?une adresse mail ext?rieure au CHU de Rouen. Ne cliquez pas sur les liens ou n'ouvrez pas les pi?ces jointes ? moins de conna?tre l'exp?diteur et de savoir que le contenu est s?r. En cas de doute, transf?rer le mail ? ? DSI, S?curit? ? pour analyse. Merci de votre vigilance


Thank you for such a quick reply, here are some points that I think might have been missed:

I would state the question the other way : why are NAs integer indices allowed?
In my experience, they are sometimes useful but they often delay the detection of bugs. However, due to backward compatibility, this feature cannot be removed. Adding this feature to character indices would worsen the problem.

But please also note that character indices with NA are allowed for vectors. This is more an inconsistency between vectors and matrices. In vectors both numeric and character sub-setting works with NAs. In matrices only numberic and not character sub-setting works with NAs. Potentially this in itself can also be a source of bugs, or, at least surprises.

Setting names() on a matrix is a rarely used feature that has practically no positive and no negative consequences. I see no incentive to change the behavior and break existing code.

When writing this message I had the opposite opinion. That this 2nd point is one of the most bug-probe points of all 3. As I would assume most users setting names() on a matrix would only do it by accident.

In my opinion adding these features would improve the consistency of R but would add more sources of bugs in an already unsafe language.

I think this maybe is a crux of the thing.

My original impression was that R was ?clever? about the usage of NAs by design. i.e. when you choose an unknown object from a set of objects the result is an object, but nobody knows which - hence NA. Is it really accepted now that such a decision was a mistake and lead to bugs in user code?

Kind regards,
Karolis K.

On May 3, 2023, at 11:15 AM, GILLIBERT, Andre <Andre.Gillibert at chu-rouen.fr> wrote:


Karolis wrote:
Hello,

I have stumbled upon a few cases where the behaviour of naming and subsetting in matrices seems unintuitive.
All those look related so wanted to put everything in one message.


1. Why row/col selection by names with NAs is not allowed?

 x <- setNames(1:10, letters[1:10])
 X <- matrix(x, nrow=2, dimnames = list(letters[1:2], LETTERS[1:5]))

 x[c(1, NA, 3)]       # vector: works and adds "NA"
 x[c("a", NA, "c")]   # vector: works and adds "NA"
 X[,c(1, NA, 3)]      # works and selects "NA" column
 X[,c("A", NA, "C")]  # <error>

I would state the question the other way : why are NAs integer indices allowed?
In my experience, they are sometimes useful but they often delay the detection of bugs. However, due to backward compatibility, this feature cannot be removed. Adding this feature to character indices would worsen the problem.

I see another reason to keep the behavior as is currently : character indices are most often used with column names in contexts were they are unlikely to be NAs except as a consequence of a bug. In other words, I fear that the valid-use-case/bug ratio would be quite poor with this feature.

2. Should setting names() for a matrix be allowed?

 names(X) <- paste0("e", 1:length(X))
 X["e4"]  # works

 # but any operation on a matrix drops the names
 X <- X[,-1]  # all names are gone
 X["e4"]      # <error>

 Maybe names() should not be allowed on a matrix?

Setting names() on a matrix is a rarely used feature that has practically no positive and no negative consequences. I see no incentive to change the behavior and break existing code.

3. Should selection of non-existent dimension names really be an error?

 x[22]   # works on a vector - gives "NA"
 X[,22]  # <error>

This is very often a bug on vectors and should not have been allowed on vectors in the first place... But for backwards compatibility, it is hard to remove. Adding this unsafe feature to matrices is a poor idea in my opinion.

 A potential useful use-case is matching a smaller matrix to a larger one:

This is a valid use-case, but in my opinion, it adds more problems than it solves.

These also doesn't seem to be documented in '[', 'names', 'rownames?.

Indeed, the documentation of '[' seems to be unclear on indices out of range. It can be improved.

Interested if there specific reasons for this behaviour, or could these potentially be adjusted?

In my opinion adding these features would improve the consistency of R but would add more sources of bugs in an already unsafe language.

Sincerely
Andr? GILLIBERT


	[[alternative HTML version deleted]]


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Thu May  4 11:29:52 2023
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Thu, 4 May 2023 11:29:52 +0200
Subject: [Rd] range() for Date and POSIXct could respect `finite = TRUE`
In-Reply-To: <CABzLhzzq2W3JsDP6KoRfLi0K1roD+3RH8mvnjWs_AnhP3A2SQg@mail.gmail.com>
References: <CABzLhzyRuxgHnToS4CPn_g8NOsc6M5Tx+14Sf7X+cjD8NvZgRg@mail.gmail.com>
 <25677.33376.349216.862139@stat.math.ethz.ch>
 <CABzLhzzq2W3JsDP6KoRfLi0K1roD+3RH8mvnjWs_AnhP3A2SQg@mail.gmail.com>
Message-ID: <25683.31504.509548.721569@stat.math.ethz.ch>

>>>>> Davis Vaughan 
>>>>>     on Mon, 1 May 2023 08:46:33 -0400 writes:

    > Martin,
    > Yes, I missed that those have `Summary.*` methods, thanks!

    > Tweaking those to respect `finite = TRUE` sounds great. It seems like
    > it might be a little tricky since the Summary methods call
    > `NextMethod()`, and `range.default()` uses `is.numeric()` to determine
    > whether or not to apply `finite`. Because `is.numeric.Date()` is
    > defined, that always returns `FALSE` for Dates (and POSIXt). Because
    > of that, it may still be easier to just write a specific
    > `range.Date()` method, but I'm not sure.

    > -Davis

I've looked more closely now, and indeed,
range() is the only function in the  Summary  group
where (only) the default method has a 'finite' argument.
which strikes me as somewhat asymmetric / inconsequential, as
after all,  range(.) := c(min(.), max(.)) ,
but  min() and max() do not obey an finite=TRUE setting, note

> min(c(-Inf,3:5), finite=TRUE)
Error: attempt to use zero-length variable name

where the error message also is not particularly friendly
and of course has nothing to with 'finite' :

> max(1:4, foo="bar")
Error: attempt to use zero-length variable name
> 

... but that is diverting;  coming back to the topic:  Given
that 'finite' only applies to range() {and there is just a convenience},
I do agree that from my own work & support to make `Date` and
`POSIX(c)t` behave more number-like, it would be "nice" to have
range() obey a `finite=TRUE` also for these.

OTOH, there are quite a few other 'number-like' thingies for
which I would then like to have  range(*, finite=TRUE) work,
e.g.,  "mpfr" (package {Rmpfr}) or "bigz" {gmp} numbers, numeric
sparse matrices, ...

To keep such methods all internally consistent with
range.default(), I could envision something like this


.rangeNum <- function(..., na.rm = FALSE, finite = FALSE, isNumeric)
{
    x <- c(..., recursive = TRUE)
    if(isNumeric(x)) {
        if(finite) x <- x[is.finite(x)]
        else if(na.rm) x <- x[!is.na(x)]
	c(min(x), max(x))
    } else {
        if(finite) na.rm <- TRUE
        c(min(x, na.rm=na.rm), max(x, na.rm=na.rm))
    }
}

range.default <- function(..., na.rm = FALSE, finite = FALSE)
    .rangeNum(..., na.rm=na.rm, finite=finite, isNumeric = is.numeric)

range.POSIXct <- range.Date <- function(..., na.rm = FALSE, finite = FALSE)
    .rangeNum(..., na.rm=na.rm, finite=finite, isNumeric = function(.)TRUE)



which would also provide .rangeNum() to be used by implementors
of other numeric-like classes to provide their own range()
method as a 1-liner *and* be future-consistent with the default method..




    > On Sat, Apr 29, 2023 at 4:47?PM Martin Maechler
    > <maechler at stat.math.ethz.ch> wrote:
    >> 
    >> >>>>> Davis Vaughan via R-devel
    >> >>>>>     on Fri, 28 Apr 2023 11:12:27 -0400 writes:
    >> 
    >> > Hi all,
    >> 
    >> > I noticed that `range.default()` has a nice `finite =
    >> > TRUE` argument, but it doesn't actually apply to Date or
    >> > POSIXct due to how `is.numeric()` works.
    >> 
    >> Well, I think it would / should never apply:
    >> 
    >> range() belongs to the "Summary" group generics (as min, max, ...)
    >> 
    >> and there  *are*  Summary.Date()  and Summary.POSIX{c,l}t() methods.
    >> 
    >> Without checking further for now, I think you are indirectly
    >> suggesting to enhance these three Summary.*() methods so they do
    >> obey  'finite = TRUE' .
    >> 
    >> I think I agree they should.
    >> 
    >> Martin
    >> 
    >> > ``` x <- .Date(c(0, Inf, 1, 2, Inf)) x #> [1] "1970-01-01"
    >> > "Inf" "1970-01-02" "1970-01-03" "Inf"
    >> 
    >> > # Darn!  range(x, finite = TRUE) #> [1] "1970-01-01" "Inf"
    >> 
    >> > # What I want .Date(range(unclass(x), finite = TRUE)) #>
    >> > [1] "1970-01-01" "1970-01-03" ```
    >> 
    >> > I think `finite = TRUE` would be pretty nice for Dates in
    >> > particular.
    >> 
    >> > As a motivating example, sometimes you have ranges of
    >> > dates represented by start/end pairs. It is fairly natural
    >> > to represent an event that hasn't ended yet with an
    >> > infinite date. If you need to then compute a sequence of
    >> > dates spanning the full range of the start/end pairs, it
    >> > would be nice to be able to use `range(finite = TRUE)` to
    >> > do so:
    >> 
    >> > ``` start <- as.Date(c("2019-01-05", "2019-01-10",
    >> > "2019-01-11", "2019-01-14")) end <-
    >> > as.Date(c("2019-01-07", NA, "2019-01-14", NA))
    >> > end[is.na(end)] <- Inf
    >> 
    >> > # `end = Inf` means that the event hasn't "ended" yet
    >> > data.frame(start, end) #> start end #> 1 2019-01-05
    >> > 2019-01-07 #> 2 2019-01-10 Inf #> 3 2019-01-11 2019-01-14
    >> > #> 4 2019-01-14 Inf
    >> 
    >> > # Create a full sequence along all days in start/end range
    >> > <- .Date(range(unclass(c(start, end)), finite = TRUE))
    >> > seq(range[1], range[2], by = 1) #> [1] "2019-01-05"
    >> > "2019-01-06" "2019-01-07" "2019-01-08" "2019-01-09" #> [6]
    >> > "2019-01-10" "2019-01-11" "2019-01-12" "2019-01-13"
    >> > "2019-01-14" ```
    >> 
    >> > It seems like one option is to create a `range.Date()`
    >> > method that unclasses, forwards the arguments on to a
    >> > second call to `range()`, and then reclasses?
    >> 
    >> > ``` range.Date <- function(x, ..., na.rm = FALSE, finite =
    >> > FALSE) { .Date(range(unclass(x), na.rm = na.rm, finite =
    >> > finite), oldClass(x)) } ```
    >> 
    >> > This is similar to how `rep.Date()` works.
    >> 
    >> > Thanks, Davis Vaughan
    >> 
    >> > ______________________________________________
    >> > R-devel at r-project.org mailing list
    >> > https://stat.ethz.ch/mailman/listinfo/r-devel


From @oko| @end|ng |rom |n@@-tou|ou@e@|r  Thu May  4 15:01:53 2023
From: @oko| @end|ng |rom |n@@-tou|ou@e@|r (Serguei Sokol)
Date: Thu, 4 May 2023 15:01:53 +0200
Subject: [Rd] save.image Non-responsive to Interrupt
In-Reply-To: <CAFDcVCRxU8KiDcT7yNxxDGWzMgckg2gDQQ7f-mmqGhYhseVcJA@mail.gmail.com>
References: <SY2PR01MB300358E3EDF589B5A20227C8CD6B9@SY2PR01MB3003.ausprd01.prod.outlook.com>
 <20230502145936.0ee6dc91@arachnoid>
 <25681.4112.978286.30568@stat.math.ethz.ch>
 <CABFfbXtru7PyV_1ecknsSLg6C3HqzVw9Mja2rybvwM76oOiT5A@mail.gmail.com>
 <CAFDcVCRxU8KiDcT7yNxxDGWzMgckg2gDQQ7f-mmqGhYhseVcJA@mail.gmail.com>
Message-ID: <18059965-1c70-a509-6ffb-81663d87e8f6@insa-toulouse.fr>

Le 03/05/2023 ? 01:25, Henrik Bengtsson a ?crit?:
> Along the lines of calling R_CheckUserInterrupt() only onces in a while:
>
>> OTOH, in the past we have had to *disable*  R_CheckUserInterrupt()
>> in parts of R's code because it was too expensive,
>> {see current src/main/{seq.c,unique.c}  for a series of commented-out
>> R_CheckUserInterrupt() for such speed-loss reasons}
> First, here are links to these two files viewable online:
>
>   * https://github.com/wch/r-source/blob/trunk/src/main/seq.c
>
>   * https://github.com/wch/r-source/blob/trunk/src/main/unique.c
>
> When not commented out, R_CheckUserInterrupt() would have been called
> every 1,000,000 times per:
>
>    /* interval at which to check interrupts */
>    #define NINTERRUPT 1000000
>
> and
>
>    if ((i+1) % NINTERRUPT == 0) R_CheckUserInterrupt()
>
> in each iteration. That '(i+1) % NINTERRUPT == 0' expression can be
> quite expensive too.
I vaguely remember a hack that was mentioned on this list as close to 
0-cost. It looked something like:

iint = NINTERRUPT;
for (...) {
 ?? if (--iint == 0) {
 ????? R_CheckUserInterrupt();
 ????? iint = NINTERRUPT;
 ? }
}

Best,
Serguei.

>    However, if we change the code to use NINTERRUPT
> = 2^k where k = {1, 2, ...}, say
>
>    #define NINTERRUPT 1048576
>
> the compiler would optimize the condition to use "the modulo of powers
> of 2 can alternatively be expressed as a bitwise AND operation"
> (Thomas Lumley, 2015-06-15).  The speedup is quite impressive, cf.
> <https://www.jottr.org/2015/06/05/checkuserinterrupt/>.
> Alternatively, one can increment a counter and reset to zero after
> calling R_CheckUserInterrupt(); I think that's equally performant.
>
> Regarding making serialize() / unserialize() interruptible: I think
> can be a good idea since we work with larger objects these days.
> However, if we implement this, we probably have to consider what
> happens when an interrupt happens. For example, transfers between a
> client and a server are no longer atomic at this level, which means we
> might end up in a corrupt state. This may, for instance, happen to
> database transactions, and PSOCK parallel worker communication.  A
> quick fix would be to use base::suspendInterrupts(), but better would
> of course be to handle interrupts gracefully.
>
> My $.02 + $0.02
>
> /Henrik
>
> On Tue, May 2, 2023 at 3:56?PM Jeroen Ooms <jeroenooms at gmail.com> wrote:
>> On Tue, May 2, 2023 at 3:29?PM Martin Maechler
>> <maechler at stat.math.ethz.ch> wrote:
>>>>>>>> Ivan Krylov
>>>>>>>>      on Tue, 2 May 2023 14:59:36 +0300 writes:
>>>      > ? Sat, 29 Apr 2023 00:00:02 +0000
>>>      > Dario Strbenac via R-devel <r-devel at r-project.org> ?????:
>>>
>>>      >> Could save.image() be redesigned so that it promptly responds to
>>>      >> Ctrl+C? It prevents the command line from being used for a number of
>>>      >> hours if the contents of the workspace are large.
>>>
>>>      > This is ultimately caused by serialize() being non-interruptible. A
>>>      > relatively simple way to hang an R session for a long-ish time would
>>>      > therefore be:
>>>
>>>      > f <- xzfile(nullfile(), 'a+b')
>>>      > x <- rep(0, 1e9) # approx. 8 gigabytes, adjust for your RAM size
>>>      > serialize(x, f)
>>>      > close(f)
>>>
>>>      > This means that calling R_CheckUserInterrupt() between saving
>>>      > individual objects is not enough: R also needs to check for interrupts
>>>      > while saving sufficiently long vectors.
>>>
>>>      > Since the serialize() infrastructure is carefully written to avoid
>>>      > resource leaks on allocation failures, it looks relatively safe to
>>>      > liberally sprinkle R_CheckUserInterrupt() where it makes sense to do
>>>      > so, i.e. once per WriteItem() (which calls itself recursively and
>>>      > non-recursively) and once per every downstream for loop iteration.
>>>      > Valgrind doesn't show any new leaks if I apply the patch, interrupt
>>>      > serialize() and then exit. R also passes make check after the applied
>>>      > patch.
>>>
>>>      > Do these changes make sense, or am I overlooking some other problem?
>>>
>>> Thank you, Ivan!
>>>
>>> They do make sense... but :
>>>
>>> OTOH, in the past we have had to *disable*  R_CheckUserInterrupt()
>>> in parts of R's code because it was too expensive,
>>> {see current src/main/{seq.c,unique.c}  for a series of commented-out
>>>   R_CheckUserInterrupt() for such speed-loss reasons}
>>>
>>> so  adding these may need a lot of care when we simultaneously
>>> want to remain  efficient for "morally valid" use of serialization...
>>> where we really don't want to pay too much of a premium.
>> Alternatively, one could consider making R throttle or debounce calls
>> to R_CheckUserInterrupt such that a repeated calls within x time are
>> ignored, cf: https://www.freecodecamp.org/news/javascript-debounce-example/
>>
>> The reasoning being that it may be difficult for (contributed) code to
>> determine when/where it is appropriate to check for interrupts, given
>> varying code paths and cpu speed. Maybe it makes more sense to call
>> R_CheckUserInterrupt frequently wherever it is safe to do so, and let
>> R decide if reasonable time has elapsed to actually run the (possibly
>> expensive) ui check again.
>>
>> Basic example: https://github.com/r-devel/r-svn/pull/125/files
>>
>>
>>
>>
>>> {{ saving the whole user workspace is not "valid" in that sense
>>>     in my view.  I tell all my (non-beginner) Rstudio-using
>>>     students they should turn *off* the automatic saving and
>>>     loading at session end / beginning; and for reproducibility
>>>     only saveRDS() [or save()] *explicitly* a few precious
>>>     objects ..
>>> }}
>>>
>>> Again, we don't want to punish people who know what they are
>>> doing, just because other R users manage to hang their R session
>>> by too little thinking ...
>>>
>>> Your patch adds 15 such interrupt checking calls which may
>>> really be too much -- I'm not claiming they are: with our
>>> recursive objects it's surely not very easy to determine the
>>> "minimally necessary" such calls.
>>>
>>> In addition, we may still consider adding an extra optional
>>> argument, say   `check.interrupt = TRUE`
>>> which we may default to TRUE when  save.image() is called
>>> but e.g., not when serialize() is called..
>>>
>>> Martin
>>>
>>>      > --
>>>      > Best regards,
>>>      > Ivan
>>>      > x[DELETED ATTACHMENT external: Rd_IvanKrylov_interrupt-serialize.patch, text/x-patch]
>>>      > ______________________________________________
>>>      > R-devel at r-project.org mailing list
>>>      > https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


-- 
Serguei Sokol
Ingenieur de recherche INRAE

Cellule Math?matiques
TBI, INSA/INRAE UMR 792, INSA/CNRS UMR 5504
135 Avenue de Rangueil
31077 Toulouse Cedex 04

tel: +33 5 61 55 98 49
email: sokol at insa-toulouse.fr
http://www.toulouse-biotechnology-institute.fr/en/technology_platforms/mathematics-cell.html


From henr|k@bengt@@on @end|ng |rom gm@||@com  Thu May  4 18:38:14 2023
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Thu, 4 May 2023 18:38:14 +0200
Subject: [Rd] save.image Non-responsive to Interrupt
In-Reply-To: <18059965-1c70-a509-6ffb-81663d87e8f6@insa-toulouse.fr>
References: <SY2PR01MB300358E3EDF589B5A20227C8CD6B9@SY2PR01MB3003.ausprd01.prod.outlook.com>
 <20230502145936.0ee6dc91@arachnoid>
 <25681.4112.978286.30568@stat.math.ethz.ch>
 <CABFfbXtru7PyV_1ecknsSLg6C3HqzVw9Mja2rybvwM76oOiT5A@mail.gmail.com>
 <CAFDcVCRxU8KiDcT7yNxxDGWzMgckg2gDQQ7f-mmqGhYhseVcJA@mail.gmail.com>
 <18059965-1c70-a509-6ffb-81663d87e8f6@insa-toulouse.fr>
Message-ID: <CAFDcVCQezw-LOnR2YecByQC+pGdT7UYrSdQ5DmYmaQwWoOCNkw@mail.gmail.com>

On Thu, May 4, 2023 at 3:02?PM Serguei Sokol via R-devel
<r-devel at r-project.org> wrote:
>
> Le 03/05/2023 ? 01:25, Henrik Bengtsson a ?crit :
> > Along the lines of calling R_CheckUserInterrupt() only onces in a while:
> >
> >> OTOH, in the past we have had to *disable*  R_CheckUserInterrupt()
> >> in parts of R's code because it was too expensive,
> >> {see current src/main/{seq.c,unique.c}  for a series of commented-out
> >> R_CheckUserInterrupt() for such speed-loss reasons}
> > First, here are links to these two files viewable online:
> >
> >   * https://github.com/wch/r-source/blob/trunk/src/main/seq.c
> >
> >   * https://github.com/wch/r-source/blob/trunk/src/main/unique.c
> >
> > When not commented out, R_CheckUserInterrupt() would have been called
> > every 1,000,000 times per:
> >
> >    /* interval at which to check interrupts */
> >    #define NINTERRUPT 1000000
> >
> > and
> >
> >    if ((i+1) % NINTERRUPT == 0) R_CheckUserInterrupt()
> >
> > in each iteration. That '(i+1) % NINTERRUPT == 0' expression can be
> > quite expensive too.
> I vaguely remember a hack that was mentioned on this list as close to
> 0-cost. It looked something like:
>
> iint = NINTERRUPT;
> for (...) {
>     if (--iint == 0) {
>        R_CheckUserInterrupt();
>        iint = NINTERRUPT;
>    }
> }
>
> Best,
> Serguei.

> > Alternatively, one can increment a counter and reset to zero after
> > calling R_CheckUserInterrupt(); I think that's equally performant.

Yes, that's the one, e.g. Tomas K migrated some "modulo" ones in
R-devel to this one yesterday
(https://github.com/wch/r-source/commit/1ca6c6c6246629c6a98a526a2906595e5cfcd45e).

/Henrik

>
> >    However, if we change the code to use NINTERRUPT
> > = 2^k where k = {1, 2, ...}, say
> >
> >    #define NINTERRUPT 1048576
> >
> > the compiler would optimize the condition to use "the modulo of powers
> > of 2 can alternatively be expressed as a bitwise AND operation"
> > (Thomas Lumley, 2015-06-15).  The speedup is quite impressive, cf.
> > <https://www.jottr.org/2015/06/05/checkuserinterrupt/>.
> > Alternatively, one can increment a counter and reset to zero after
> > calling R_CheckUserInterrupt(); I think that's equally performant.
> >
> > Regarding making serialize() / unserialize() interruptible: I think
> > can be a good idea since we work with larger objects these days.
> > However, if we implement this, we probably have to consider what
> > happens when an interrupt happens. For example, transfers between a
> > client and a server are no longer atomic at this level, which means we
> > might end up in a corrupt state. This may, for instance, happen to
> > database transactions, and PSOCK parallel worker communication.  A
> > quick fix would be to use base::suspendInterrupts(), but better would
> > of course be to handle interrupts gracefully.
> >
> > My $.02 + $0.02
> >
> > /Henrik
> >
> > On Tue, May 2, 2023 at 3:56?PM Jeroen Ooms <jeroenooms at gmail.com> wrote:
> >> On Tue, May 2, 2023 at 3:29?PM Martin Maechler
> >> <maechler at stat.math.ethz.ch> wrote:
> >>>>>>>> Ivan Krylov
> >>>>>>>>      on Tue, 2 May 2023 14:59:36 +0300 writes:
> >>>      > ? Sat, 29 Apr 2023 00:00:02 +0000
> >>>      > Dario Strbenac via R-devel <r-devel at r-project.org> ?????:
> >>>
> >>>      >> Could save.image() be redesigned so that it promptly responds to
> >>>      >> Ctrl+C? It prevents the command line from being used for a number of
> >>>      >> hours if the contents of the workspace are large.
> >>>
> >>>      > This is ultimately caused by serialize() being non-interruptible. A
> >>>      > relatively simple way to hang an R session for a long-ish time would
> >>>      > therefore be:
> >>>
> >>>      > f <- xzfile(nullfile(), 'a+b')
> >>>      > x <- rep(0, 1e9) # approx. 8 gigabytes, adjust for your RAM size
> >>>      > serialize(x, f)
> >>>      > close(f)
> >>>
> >>>      > This means that calling R_CheckUserInterrupt() between saving
> >>>      > individual objects is not enough: R also needs to check for interrupts
> >>>      > while saving sufficiently long vectors.
> >>>
> >>>      > Since the serialize() infrastructure is carefully written to avoid
> >>>      > resource leaks on allocation failures, it looks relatively safe to
> >>>      > liberally sprinkle R_CheckUserInterrupt() where it makes sense to do
> >>>      > so, i.e. once per WriteItem() (which calls itself recursively and
> >>>      > non-recursively) and once per every downstream for loop iteration.
> >>>      > Valgrind doesn't show any new leaks if I apply the patch, interrupt
> >>>      > serialize() and then exit. R also passes make check after the applied
> >>>      > patch.
> >>>
> >>>      > Do these changes make sense, or am I overlooking some other problem?
> >>>
> >>> Thank you, Ivan!
> >>>
> >>> They do make sense... but :
> >>>
> >>> OTOH, in the past we have had to *disable*  R_CheckUserInterrupt()
> >>> in parts of R's code because it was too expensive,
> >>> {see current src/main/{seq.c,unique.c}  for a series of commented-out
> >>>   R_CheckUserInterrupt() for such speed-loss reasons}
> >>>
> >>> so  adding these may need a lot of care when we simultaneously
> >>> want to remain  efficient for "morally valid" use of serialization...
> >>> where we really don't want to pay too much of a premium.
> >> Alternatively, one could consider making R throttle or debounce calls
> >> to R_CheckUserInterrupt such that a repeated calls within x time are
> >> ignored, cf: https://www.freecodecamp.org/news/javascript-debounce-example/
> >>
> >> The reasoning being that it may be difficult for (contributed) code to
> >> determine when/where it is appropriate to check for interrupts, given
> >> varying code paths and cpu speed. Maybe it makes more sense to call
> >> R_CheckUserInterrupt frequently wherever it is safe to do so, and let
> >> R decide if reasonable time has elapsed to actually run the (possibly
> >> expensive) ui check again.
> >>
> >> Basic example: https://github.com/r-devel/r-svn/pull/125/files
> >>
> >>
> >>
> >>
> >>> {{ saving the whole user workspace is not "valid" in that sense
> >>>     in my view.  I tell all my (non-beginner) Rstudio-using
> >>>     students they should turn *off* the automatic saving and
> >>>     loading at session end / beginning; and for reproducibility
> >>>     only saveRDS() [or save()] *explicitly* a few precious
> >>>     objects ..
> >>> }}
> >>>
> >>> Again, we don't want to punish people who know what they are
> >>> doing, just because other R users manage to hang their R session
> >>> by too little thinking ...
> >>>
> >>> Your patch adds 15 such interrupt checking calls which may
> >>> really be too much -- I'm not claiming they are: with our
> >>> recursive objects it's surely not very easy to determine the
> >>> "minimally necessary" such calls.
> >>>
> >>> In addition, we may still consider adding an extra optional
> >>> argument, say   `check.interrupt = TRUE`
> >>> which we may default to TRUE when  save.image() is called
> >>> but e.g., not when serialize() is called..
> >>>
> >>> Martin
> >>>
> >>>      > --
> >>>      > Best regards,
> >>>      > Ivan
> >>>      > x[DELETED ATTACHMENT external: Rd_IvanKrylov_interrupt-serialize.patch, text/x-patch]
> >>>      > ______________________________________________
> >>>      > R-devel at r-project.org mailing list
> >>>      > https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>
> >>> ______________________________________________
> >>> R-devel at r-project.org mailing list
> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
>
> --
> Serguei Sokol
> Ingenieur de recherche INRAE
>
> Cellule Math?matiques
> TBI, INSA/INRAE UMR 792, INSA/CNRS UMR 5504
> 135 Avenue de Rangueil
> 31077 Toulouse Cedex 04
>
> tel: +33 5 61 55 98 49
> email: sokol at insa-toulouse.fr
> http://www.toulouse-biotechnology-institute.fr/en/technology_platforms/mathematics-cell.html
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


