From rub|@n@v|@n@ @end|ng |rom gm@||@com  Mon Jun  3 21:30:25 2024
From: rub|@n@v|@n@ @end|ng |rom gm@||@com (Rubiana Viana)
Date: Mon, 3 Jun 2024 16:30:25 -0300
Subject: [Rd] R for Windows FAQ
Message-ID: <CABz3Tr1qHNdFmL5muFyhQYAjFAEXXu8HZr22-ZzDPXKzHdsjEw@mail.gmail.com>

Hi!

How can I get older versions of R software?

Thank you!

-- 
*Rubiana Viana*
Psic?loga e Mestra em Sociologia Pol?tica
G?nero Ra?a e Direitos Humanos ? Pesquisa ? Projetos ? Cultura e
Diversidade
LinkedIn <https://www.linkedin.com/in/rubiana-viana/>| Portfolio
<https://readymag.website/u2474224357/rubianaviana/> | Lattes
<http://lattes.cnpq.br/1002116427542223>

	[[alternative HTML version deleted]]


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Mon Jun  3 22:00:34 2024
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Mon, 3 Jun 2024 22:00:34 +0200
Subject: [Rd] R for Windows FAQ
In-Reply-To: <CABz3Tr1qHNdFmL5muFyhQYAjFAEXXu8HZr22-ZzDPXKzHdsjEw@mail.gmail.com>
References: <CABz3Tr1qHNdFmL5muFyhQYAjFAEXXu8HZr22-ZzDPXKzHdsjEw@mail.gmail.com>
Message-ID: <a0421657-4a9f-41c3-add3-18d766e14f8d@gmail.com>

https://cran.r-project.org/bin/windows/base/old/

Tomas

On 6/3/24 21:30, Rubiana Viana wrote:
> Hi!
>
> How can I get older versions of R software?
>
> Thank you!
>


From iuke-tier@ey m@iii@g oii uiow@@edu  Thu Jun  6 16:47:02 2024
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Thu, 6 Jun 2024 09:47:02 -0500 (CDT)
Subject: [Rd] clarifying and adjusting the C API for R
Message-ID: <5a1ccb59-3e90-31eb-132a-35c3a1839bbf@uiowa.edu>

This is an update on some current work on the C API for use in R
extensions.

The internal R implementation makes use of tens of thousands of C
entry points. On Linux and Windows, which support visibility
restrictions, most of these are visible only within the R executble or
shared library. About 1500 are not hidden and are visible to
dynamically loaded shared libraries, such as ones in packages, and to
embedding applications.

There are two main reasons for limiting access to entry points in a
software framework:

- Some entry points are very easy to use in ways that corrupt internal
   data, leading to segfaults or, worse, incorrect computations without
   segfaults.

- Some entry point expose internal structure and other implementation
   details, which makes it hard to make improvements without breaking
   client code that has come to depend on these details.

The API of C entry points that can be used in R extensions, both for
packages and embedding, has evolved organically over many years. The
definition for the current release expressed in the Writing R
Extensions manual (WRE) is roughly:

     An entry point can be used if (1) it is declared in a header file
     in R.home("include"), and (2) if it is documented for use in WRE.

Ideally, (1) would be necessary and sufficient, but for a variety of
reasons that isn't achievable, at least not in the near term. (2) can
be challenging to determine; in particular, it is not amenable to a
computational answer.

An experimental effort is underway to add annotations to the WRE
Texinfo source to allow (2) to be answered unambiguously. The
annotations so far mostly reflect my reading or WRE and may be revised
as they are reviewed by others. The annotated document can be used for
programmatically identifying what is currently considered part of the C
API. The result so far is an experimental function tools:::funAPI():

     > head(tools:::funAPI())
 		     name                    loc apitype
     1 Rf_AdobeSymbol2utf8 R_ext/GraphicsDevice.h    eapi
     2        alloc3DArray                    WRE     api
     3          allocArray                    WRE     api
     4           allocLang                    WRE     api
     5           allocList                    WRE     api
     6         allocMatrix                    WRE     api

The 'apitype' field has three possible levels

     | api  | stable (ideally) API |
     | eapi | experimental API     |
     | emb  | embedding API        |

Entry points in the embedded API would typically only be used in
applications embedding R or providing new front ends, but might be
reasonable to use in packages that support embedding.

The 'loc' field indicates how the entry point is identified as part of
an API: explicit mention in WRE, or declaration in a header file
identified as fully part of an API.

[tools:::funAPI() may not be completely accurate as it relies on
regular expressions for examining header files considered part of the
API rather than proper parsing. But it seems to be pretty close to
what can be achieved with proper parsing.  Proper parsing would add
dependencies on additional tools, which I would like to avoid for
now. One dependency already present is that a C compiler has to be on
the search path and cc -E has to run the C pre-processor.]

Two additional experimental functions are available for analyzing
package compliance: tools:::checkPkgAPI and tools:::checkAllPkgsAPI.
These examine installed packages.

[These may produce some false positives on macOS; they may or may not
work on Windows at this point.]

Using these tools initially showed around 200 non-API entry points
used across packages on CRAN and BIOC. Ideally this number should be
reduced to zero. This will require a combination of additions to the
API and changes in packages.

Some entry points can safely be added to the API. Around 40 have
already been added to WRE with API annotations; another 40 or so can
probably be added after review.

The remainder mostly fall into two groups:

- Entry points that should never be used in packages, such as
   SET_OBJECT or SETLENGTH (or any non-API SETXYZ functions for that
   matter) that can create inconsistent or corrupt internal state.

- Entry points that depend on the existence of internal structure that
   might be subject to change, such as the existence of promise objects
   or internal structure of environments.

Many, if not most, of these seem to be used in idioms that can either
be accomplished with existing higher-level functions already in the
API, or by new higher level functions that can be created and
added. Working through these will take some time and coordination
between R-core and maintainers of affected packages.

Once things have gelled a bit more I hope to turn this into a blog
post that will include some examples of moving non-API entry point
uses into compliance.

Best,

luke

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu


From h@w|ckh@m @end|ng |rom gm@||@com  Fri Jun  7 15:00:44 2024
From: h@w|ckh@m @end|ng |rom gm@||@com (Hadley Wickham)
Date: Fri, 7 Jun 2024 08:00:44 -0500
Subject: [Rd] clarifying and adjusting the C API for R
In-Reply-To: <5a1ccb59-3e90-31eb-132a-35c3a1839bbf@uiowa.edu>
References: <5a1ccb59-3e90-31eb-132a-35c3a1839bbf@uiowa.edu>
Message-ID: <CABdHhvHJcQdty3KzeCVKMOusokBRKWH=znu1HJM6722ROsY1Mg@mail.gmail.com>

Thanks for working on this Luke! We appreciate your efforts to make it
easier to tell what's in the exported API and we're very happy to work with
you on any changes needed to tidyverse/r-lib packages.

Hadley

On Thu, Jun 6, 2024 at 9:47?AM luke-tierney--- via R-devel <
r-devel at r-project.org> wrote:

> This is an update on some current work on the C API for use in R
> extensions.
>
> The internal R implementation makes use of tens of thousands of C
> entry points. On Linux and Windows, which support visibility
> restrictions, most of these are visible only within the R executble or
> shared library. About 1500 are not hidden and are visible to
> dynamically loaded shared libraries, such as ones in packages, and to
> embedding applications.
>
> There are two main reasons for limiting access to entry points in a
> software framework:
>
> - Some entry points are very easy to use in ways that corrupt internal
>    data, leading to segfaults or, worse, incorrect computations without
>    segfaults.
>
> - Some entry point expose internal structure and other implementation
>    details, which makes it hard to make improvements without breaking
>    client code that has come to depend on these details.
>
> The API of C entry points that can be used in R extensions, both for
> packages and embedding, has evolved organically over many years. The
> definition for the current release expressed in the Writing R
> Extensions manual (WRE) is roughly:
>
>      An entry point can be used if (1) it is declared in a header file
>      in R.home("include"), and (2) if it is documented for use in WRE.
>
> Ideally, (1) would be necessary and sufficient, but for a variety of
> reasons that isn't achievable, at least not in the near term. (2) can
> be challenging to determine; in particular, it is not amenable to a
> computational answer.
>
> An experimental effort is underway to add annotations to the WRE
> Texinfo source to allow (2) to be answered unambiguously. The
> annotations so far mostly reflect my reading or WRE and may be revised
> as they are reviewed by others. The annotated document can be used for
> programmatically identifying what is currently considered part of the C
> API. The result so far is an experimental function tools:::funAPI():
>
>      > head(tools:::funAPI())
>                      name                    loc apitype
>      1 Rf_AdobeSymbol2utf8 R_ext/GraphicsDevice.h    eapi
>      2        alloc3DArray                    WRE     api
>      3          allocArray                    WRE     api
>      4           allocLang                    WRE     api
>      5           allocList                    WRE     api
>      6         allocMatrix                    WRE     api
>
> The 'apitype' field has three possible levels
>
>      | api  | stable (ideally) API |
>      | eapi | experimental API     |
>      | emb  | embedding API        |
>
> Entry points in the embedded API would typically only be used in
> applications embedding R or providing new front ends, but might be
> reasonable to use in packages that support embedding.
>
> The 'loc' field indicates how the entry point is identified as part of
> an API: explicit mention in WRE, or declaration in a header file
> identified as fully part of an API.
>
> [tools:::funAPI() may not be completely accurate as it relies on
> regular expressions for examining header files considered part of the
> API rather than proper parsing. But it seems to be pretty close to
> what can be achieved with proper parsing.  Proper parsing would add
> dependencies on additional tools, which I would like to avoid for
> now. One dependency already present is that a C compiler has to be on
> the search path and cc -E has to run the C pre-processor.]
>
> Two additional experimental functions are available for analyzing
> package compliance: tools:::checkPkgAPI and tools:::checkAllPkgsAPI.
> These examine installed packages.
>
> [These may produce some false positives on macOS; they may or may not
> work on Windows at this point.]
>
> Using these tools initially showed around 200 non-API entry points
> used across packages on CRAN and BIOC. Ideally this number should be
> reduced to zero. This will require a combination of additions to the
> API and changes in packages.
>
> Some entry points can safely be added to the API. Around 40 have
> already been added to WRE with API annotations; another 40 or so can
> probably be added after review.
>
> The remainder mostly fall into two groups:
>
> - Entry points that should never be used in packages, such as
>    SET_OBJECT or SETLENGTH (or any non-API SETXYZ functions for that
>    matter) that can create inconsistent or corrupt internal state.
>
> - Entry points that depend on the existence of internal structure that
>    might be subject to change, such as the existence of promise objects
>    or internal structure of environments.
>
> Many, if not most, of these seem to be used in idioms that can either
> be accomplished with existing higher-level functions already in the
> API, or by new higher level functions that can be created and
> added. Working through these will take some time and coordination
> between R-core and maintainers of affected packages.
>
> Once things have gelled a bit more I hope to turn this into a blog
> post that will include some examples of moving non-API entry point
> uses into compliance.
>
> Best,
>
> luke
>
> --
> Luke Tierney
> Ralph E. Wareham Professor of Mathematical Sciences
> University of Iowa                  Phone:             319-335-3386
> Department of Statistics and        Fax:               319-335-3017
>     Actuarial Science
> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


-- 
http://hadley.nz

	[[alternative HTML version deleted]]


From @d|rk@e @end|ng |rom g@m@@com  Fri Jun  7 15:24:57 2024
From: @d|rk@e @end|ng |rom g@m@@com (Steven Dirkse)
Date: Fri, 7 Jun 2024 09:24:57 -0400
Subject: [Rd] clarifying and adjusting the C API for R
In-Reply-To: <5a1ccb59-3e90-31eb-132a-35c3a1839bbf@uiowa.edu>
References: <5a1ccb59-3e90-31eb-132a-35c3a1839bbf@uiowa.edu>
Message-ID: <CAHiA-ZnQK238zu6yXAxCNBASP6LX+74S8LjvOfmC-9ujiAcU+g@mail.gmail.com>

Thanks for sharing this overview of an interesting and much-needed project.

You mention that R exports about 1500 symbols (on platforms supporting
visibility) but this subject isn't mentioned explicitly again in your note,
so I'm wondering how things tie together.  Un-exported symbols cannot be
part of the API - how would people use them in this case?  In a perfect
world the set of exported symbols could define the API or match it exactly,
but I guess that isn't the case at present.  So I conclude that R exports
extra (i.e. non-API) symbols.  Is part of the goal to remove these extra
exports?

-Steve

On Thu, Jun 6, 2024 at 10:47?AM luke-tierney--- via R-devel <
r-devel at r-project.org> wrote:

> This is an update on some current work on the C API for use in R
> extensions.
>
> The internal R implementation makes use of tens of thousands of C
> entry points. On Linux and Windows, which support visibility
> restrictions, most of these are visible only within the R executble or
> shared library. About 1500 are not hidden and are visible to
> dynamically loaded shared libraries, such as ones in packages, and to
> embedding applications.
>
> There are two main reasons for limiting access to entry points in a
> software framework:
>
> - Some entry points are very easy to use in ways that corrupt internal
>    data, leading to segfaults or, worse, incorrect computations without
>    segfaults.
>
> - Some entry point expose internal structure and other implementation
>    details, which makes it hard to make improvements without breaking
>    client code that has come to depend on these details.
>
> The API of C entry points that can be used in R extensions, both for
> packages and embedding, has evolved organically over many years. The
> definition for the current release expressed in the Writing R
> Extensions manual (WRE) is roughly:
>
>      An entry point can be used if (1) it is declared in a header file
>      in R.home("include"), and (2) if it is documented for use in WRE.
>
> Ideally, (1) would be necessary and sufficient, but for a variety of
> reasons that isn't achievable, at least not in the near term. (2) can
> be challenging to determine; in particular, it is not amenable to a
> computational answer.
>
> An experimental effort is underway to add annotations to the WRE
> Texinfo source to allow (2) to be answered unambiguously. The
> annotations so far mostly reflect my reading or WRE and may be revised
> as they are reviewed by others. The annotated document can be used for
> programmatically identifying what is currently considered part of the C
> API. The result so far is an experimental function tools:::funAPI():
>
>      > head(tools:::funAPI())
>                      name                    loc apitype
>      1 Rf_AdobeSymbol2utf8 R_ext/GraphicsDevice.h    eapi
>      2        alloc3DArray                    WRE     api
>      3          allocArray                    WRE     api
>      4           allocLang                    WRE     api
>      5           allocList                    WRE     api
>      6         allocMatrix                    WRE     api
>
> The 'apitype' field has three possible levels
>
>      | api  | stable (ideally) API |
>      | eapi | experimental API     |
>      | emb  | embedding API        |
>
> Entry points in the embedded API would typically only be used in
> applications embedding R or providing new front ends, but might be
> reasonable to use in packages that support embedding.
>
> The 'loc' field indicates how the entry point is identified as part of
> an API: explicit mention in WRE, or declaration in a header file
> identified as fully part of an API.
>
> [tools:::funAPI() may not be completely accurate as it relies on
> regular expressions for examining header files considered part of the
> API rather than proper parsing. But it seems to be pretty close to
> what can be achieved with proper parsing.  Proper parsing would add
> dependencies on additional tools, which I would like to avoid for
> now. One dependency already present is that a C compiler has to be on
> the search path and cc -E has to run the C pre-processor.]
>
> Two additional experimental functions are available for analyzing
> package compliance: tools:::checkPkgAPI and tools:::checkAllPkgsAPI.
> These examine installed packages.
>
> [These may produce some false positives on macOS; they may or may not
> work on Windows at this point.]
>
> Using these tools initially showed around 200 non-API entry points
> used across packages on CRAN and BIOC. Ideally this number should be
> reduced to zero. This will require a combination of additions to the
> API and changes in packages.
>
> Some entry points can safely be added to the API. Around 40 have
> already been added to WRE with API annotations; another 40 or so can
> probably be added after review.
>
> The remainder mostly fall into two groups:
>
> - Entry points that should never be used in packages, such as
>    SET_OBJECT or SETLENGTH (or any non-API SETXYZ functions for that
>    matter) that can create inconsistent or corrupt internal state.
>
> - Entry points that depend on the existence of internal structure that
>    might be subject to change, such as the existence of promise objects
>    or internal structure of environments.
>
> Many, if not most, of these seem to be used in idioms that can either
> be accomplished with existing higher-level functions already in the
> API, or by new higher level functions that can be created and
> added. Working through these will take some time and coordination
> between R-core and maintainers of affected packages.
>
> Once things have gelled a bit more I hope to turn this into a blog
> post that will include some examples of moving non-API entry point
> uses into compliance.
>
> Best,
>
> luke
>
> --
> Luke Tierney
> Ralph E. Wareham Professor of Mathematical Sciences
> University of Iowa                  Phone:             319-335-3386
> Department of Statistics and        Fax:               319-335-3017
>     Actuarial Science
> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From iuke-tier@ey m@iii@g oii uiow@@edu  Fri Jun  7 16:30:24 2024
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Fri, 7 Jun 2024 09:30:24 -0500 (CDT)
Subject: [Rd] [External] Re:  clarifying and adjusting the C API for R
In-Reply-To: <CAHiA-ZnQK238zu6yXAxCNBASP6LX+74S8LjvOfmC-9ujiAcU+g@mail.gmail.com>
References: <5a1ccb59-3e90-31eb-132a-35c3a1839bbf@uiowa.edu>
 <CAHiA-ZnQK238zu6yXAxCNBASP6LX+74S8LjvOfmC-9ujiAcU+g@mail.gmail.com>
Message-ID: <6ca3dc90-b06d-1678-8faf-4c8d382dd8b3@uiowa.edu>

On Fri, 7 Jun 2024, Steven Dirkse wrote:

> You don't often get email from sdirkse at gams.com. Learn why this is important
> Thanks for sharing this overview of an interesting and much-needed project.
> You mention that R exports about 1500 symbols (on platforms supporting
> visibility) but this subject isn't mentioned explicitly again in your note,
> so I'm wondering how things?tie together.? Un-exported symbols cannot be
> part of the API - how would people use them in this case?? In a perfect
> world the set of exported symbols could define the API or match it exactly,
> but I guess that isn't the case at present.? So I conclude that R exports
> extra (i.e. non-API) symbols.? Is part of the goal to remove these extra
> exports?

No. We'll hide what we can, but base packages for one need access to
some entry points that should not be in the API, so those have to stay
un-hidden.

Best,

luke

> 
> -Steve
> 
> On Thu, Jun 6, 2024 at 10:47?AM luke-tierney--- via R-devel
> <r-devel at r-project.org> wrote:
>       This is an update on some current work on the C API for use in R
>       extensions.
>
>       The internal R implementation makes use of tens of thousands of
>       C
>       entry points. On Linux and Windows, which support visibility
>       restrictions, most of these are visible only within the R
>       executble or
>       shared library. About 1500 are not hidden and are visible to
>       dynamically loaded shared libraries, such as ones in packages,
>       and to
>       embedding applications.
>
>       There are two main reasons for limiting access to entry points
>       in a
>       software framework:
>
>       - Some entry points are very easy to use in ways that corrupt
>       internal
>       ? ?data, leading to segfaults or, worse, incorrect computations
>       without
>       ? ?segfaults.
>
>       - Some entry point expose internal structure and other
>       implementation
>       ? ?details, which makes it hard to make improvements without
>       breaking
>       ? ?client code that has come to depend on these details.
>
>       The API of C entry points that can be used in R extensions, both
>       for
>       packages and embedding, has evolved organically over many years.
>       The
>       definition for the current release expressed in the Writing R
>       Extensions manual (WRE) is roughly:
>
>       ? ? ?An entry point can be used if (1) it is declared in a
>       header file
>       ? ? ?in R.home("include"), and (2) if it is documented for use
>       in WRE.
>
>       Ideally, (1) would be necessary and sufficient, but for a
>       variety of
>       reasons that isn't achievable, at least not in the near term.
>       (2) can
>       be challenging to determine; in particular, it is not amenable
>       to a
>       computational answer.
>
>       An experimental effort is underway to add annotations to the WRE
>       Texinfo source to allow (2) to be answered unambiguously. The
>       annotations so far mostly reflect my reading or WRE and may be
>       revised
>       as they are reviewed by others. The annotated document can be
>       used for
>       programmatically identifying what is currently considered part
>       of the C
>       API. The result so far is an experimental function
>       tools:::funAPI():
>
>       ? ? ?> head(tools:::funAPI())
>       ? ? ? ? ? ? ? ? ? ? ?name? ? ? ? ? ? ? ? ? ? loc apitype
>       ? ? ?1 Rf_AdobeSymbol2utf8 R_ext/GraphicsDevice.h? ? eapi
>       ? ? ?2? ? ? ? alloc3DArray? ? ? ? ? ? ? ? ? ? WRE? ? ?api
>       ? ? ?3? ? ? ? ? allocArray? ? ? ? ? ? ? ? ? ? WRE? ? ?api
>       ? ? ?4? ? ? ? ? ?allocLang? ? ? ? ? ? ? ? ? ? WRE? ? ?api
>       ? ? ?5? ? ? ? ? ?allocList? ? ? ? ? ? ? ? ? ? WRE? ? ?api
>       ? ? ?6? ? ? ? ?allocMatrix? ? ? ? ? ? ? ? ? ? WRE? ? ?api
>
>       The 'apitype' field has three possible levels
>
>       ? ? ?| api? | stable (ideally) API |
>       ? ? ?| eapi | experimental API? ? ?|
>       ? ? ?| emb? | embedding API? ? ? ? |
>
>       Entry points in the embedded API would typically only be used in
>       applications embedding R or providing new front ends, but might
>       be
>       reasonable to use in packages that support embedding.
>
>       The 'loc' field indicates how the entry point is identified as
>       part of
>       an API: explicit mention in WRE, or declaration in a header file
>       identified as fully part of an API.
>
>       [tools:::funAPI() may not be completely accurate as it relies on
>       regular expressions for examining header files considered part
>       of the
>       API rather than proper parsing. But it seems to be pretty close
>       to
>       what can be achieved with proper parsing.? Proper parsing would
>       add
>       dependencies on additional tools, which I would like to avoid
>       for
>       now. One dependency already present is that a C compiler has to
>       be on
>       the search path and cc -E has to run the C pre-processor.]
>
>       Two additional experimental functions are available for
>       analyzing
>       package compliance: tools:::checkPkgAPI and
>       tools:::checkAllPkgsAPI.
>       These examine installed packages.
>
>       [These may produce some false positives on macOS; they may or
>       may not
>       work on Windows at this point.]
>
>       Using these tools initially showed around 200 non-API entry
>       points
>       used across packages on CRAN and BIOC. Ideally this number
>       should be
>       reduced to zero. This will require a combination of additions to
>       the
>       API and changes in packages.
>
>       Some entry points can safely be added to the API. Around 40 have
>       already been added to WRE with API annotations; another 40 or so
>       can
>       probably be added after review.
>
>       The remainder mostly fall into two groups:
>
>       - Entry points that should never be used in packages, such as
>       ? ?SET_OBJECT or SETLENGTH (or any non-API SETXYZ functions for
>       that
>       ? ?matter) that can create inconsistent or corrupt internal
>       state.
>
>       - Entry points that depend on the existence of internal
>       structure that
>       ? ?might be subject to change, such as the existence of promise
>       objects
>       ? ?or internal structure of environments.
>
>       Many, if not most, of these seem to be used in idioms that can
>       either
>       be accomplished with existing higher-level functions already in
>       the
>       API, or by new higher level functions that can be created and
>       added. Working through these will take some time and
>       coordination
>       between R-core and maintainers of affected packages.
>
>       Once things have gelled a bit more I hope to turn this into a
>       blog
>       post that will include some examples of moving non-API entry
>       point
>       uses into compliance.
>
>       Best,
>
>       luke
>
>       --
>       Luke Tierney
>       Ralph E. Wareham Professor of Mathematical Sciences
>       University of Iowa? ? ? ? ? ? ? ? ? Phone:? ? ? ? ? ?
>       ?319-335-3386
>       Department of Statistics and? ? ? ? Fax:? ? ? ? ? ? ?
>       ?319-335-3017
>       ? ? Actuarial Science
>       241 Schaeffer Hall? ? ? ? ? ? ? ? ? email:?
>       ?luke-tierney at uiowa.edu
>       Iowa City, IA 52242? ? ? ? ? ? ? ? ?WWW:?
>       http://www.stat.uiowa.edu
>
>       ______________________________________________
>       R-devel at r-project.org mailing list
>       https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> 
> 
> 
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu

From iuke-tier@ey m@iii@g oii uiow@@edu  Sat Jun  8 01:58:35 2024
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Fri, 7 Jun 2024 18:58:35 -0500 (CDT)
Subject: [Rd] [External] Re:  clarifying and adjusting the C API for R
In-Reply-To: <CABdHhvHJcQdty3KzeCVKMOusokBRKWH=znu1HJM6722ROsY1Mg@mail.gmail.com>
References: <5a1ccb59-3e90-31eb-132a-35c3a1839bbf@uiowa.edu>
 <CABdHhvHJcQdty3KzeCVKMOusokBRKWH=znu1HJM6722ROsY1Mg@mail.gmail.com>
Message-ID: <97c70937-941d-7c64-d8d0-a4e94e88dcb7@uiowa.edu>

On Fri, 7 Jun 2024, Hadley Wickham wrote:

> Thanks for working on this Luke! We appreciate your efforts to make it
> easier to tell what's in the exported API and we're very happy to work with
> you on any changes needed to tidyverse/r-lib packages.
> Hadley

Thanks. Glad to hear -- I may be reminding you when we hit some of the
tougher challenges down the road :-)

Best,

luke

> 
> On Thu, Jun 6, 2024 at 9:47?AM luke-tierney--- via R-devel
> <r-devel at r-project.org> wrote:
>       This is an update on some current work on the C API for use in R
>       extensions.
>
>       The internal R implementation makes use of tens of thousands of
>       C
>       entry points. On Linux and Windows, which support visibility
>       restrictions, most of these are visible only within the R
>       executble or
>       shared library. About 1500 are not hidden and are visible to
>       dynamically loaded shared libraries, such as ones in packages,
>       and to
>       embedding applications.
>
>       There are two main reasons for limiting access to entry points
>       in a
>       software framework:
>
>       - Some entry points are very easy to use in ways that corrupt
>       internal
>       ? ?data, leading to segfaults or, worse, incorrect computations
>       without
>       ? ?segfaults.
>
>       - Some entry point expose internal structure and other
>       implementation
>       ? ?details, which makes it hard to make improvements without
>       breaking
>       ? ?client code that has come to depend on these details.
>
>       The API of C entry points that can be used in R extensions, both
>       for
>       packages and embedding, has evolved organically over many years.
>       The
>       definition for the current release expressed in the Writing R
>       Extensions manual (WRE) is roughly:
>
>       ? ? ?An entry point can be used if (1) it is declared in a
>       header file
>       ? ? ?in R.home("include"), and (2) if it is documented for use
>       in WRE.
>
>       Ideally, (1) would be necessary and sufficient, but for a
>       variety of
>       reasons that isn't achievable, at least not in the near term.
>       (2) can
>       be challenging to determine; in particular, it is not amenable
>       to a
>       computational answer.
>
>       An experimental effort is underway to add annotations to the WRE
>       Texinfo source to allow (2) to be answered unambiguously. The
>       annotations so far mostly reflect my reading or WRE and may be
>       revised
>       as they are reviewed by others. The annotated document can be
>       used for
>       programmatically identifying what is currently considered part
>       of the C
>       API. The result so far is an experimental function
>       tools:::funAPI():
>
>       ? ? ?> head(tools:::funAPI())
>       ? ? ? ? ? ? ? ? ? ? ?name? ? ? ? ? ? ? ? ? ? loc apitype
>       ? ? ?1 Rf_AdobeSymbol2utf8 R_ext/GraphicsDevice.h? ? eapi
>       ? ? ?2? ? ? ? alloc3DArray? ? ? ? ? ? ? ? ? ? WRE? ? ?api
>       ? ? ?3? ? ? ? ? allocArray? ? ? ? ? ? ? ? ? ? WRE? ? ?api
>       ? ? ?4? ? ? ? ? ?allocLang? ? ? ? ? ? ? ? ? ? WRE? ? ?api
>       ? ? ?5? ? ? ? ? ?allocList? ? ? ? ? ? ? ? ? ? WRE? ? ?api
>       ? ? ?6? ? ? ? ?allocMatrix? ? ? ? ? ? ? ? ? ? WRE? ? ?api
>
>       The 'apitype' field has three possible levels
>
>       ? ? ?| api? | stable (ideally) API |
>       ? ? ?| eapi | experimental API? ? ?|
>       ? ? ?| emb? | embedding API? ? ? ? |
>
>       Entry points in the embedded API would typically only be used in
>       applications embedding R or providing new front ends, but might
>       be
>       reasonable to use in packages that support embedding.
>
>       The 'loc' field indicates how the entry point is identified as
>       part of
>       an API: explicit mention in WRE, or declaration in a header file
>       identified as fully part of an API.
>
>       [tools:::funAPI() may not be completely accurate as it relies on
>       regular expressions for examining header files considered part
>       of the
>       API rather than proper parsing. But it seems to be pretty close
>       to
>       what can be achieved with proper parsing.? Proper parsing would
>       add
>       dependencies on additional tools, which I would like to avoid
>       for
>       now. One dependency already present is that a C compiler has to
>       be on
>       the search path and cc -E has to run the C pre-processor.]
>
>       Two additional experimental functions are available for
>       analyzing
>       package compliance: tools:::checkPkgAPI and
>       tools:::checkAllPkgsAPI.
>       These examine installed packages.
>
>       [These may produce some false positives on macOS; they may or
>       may not
>       work on Windows at this point.]
>
>       Using these tools initially showed around 200 non-API entry
>       points
>       used across packages on CRAN and BIOC. Ideally this number
>       should be
>       reduced to zero. This will require a combination of additions to
>       the
>       API and changes in packages.
>
>       Some entry points can safely be added to the API. Around 40 have
>       already been added to WRE with API annotations; another 40 or so
>       can
>       probably be added after review.
>
>       The remainder mostly fall into two groups:
>
>       - Entry points that should never be used in packages, such as
>       ? ?SET_OBJECT or SETLENGTH (or any non-API SETXYZ functions for
>       that
>       ? ?matter) that can create inconsistent or corrupt internal
>       state.
>
>       - Entry points that depend on the existence of internal
>       structure that
>       ? ?might be subject to change, such as the existence of promise
>       objects
>       ? ?or internal structure of environments.
>
>       Many, if not most, of these seem to be used in idioms that can
>       either
>       be accomplished with existing higher-level functions already in
>       the
>       API, or by new higher level functions that can be created and
>       added. Working through these will take some time and
>       coordination
>       between R-core and maintainers of affected packages.
>
>       Once things have gelled a bit more I hope to turn this into a
>       blog
>       post that will include some examples of moving non-API entry
>       point
>       uses into compliance.
>
>       Best,
>
>       luke
>
>       --
>       Luke Tierney
>       Ralph E. Wareham Professor of Mathematical Sciences
>       University of Iowa? ? ? ? ? ? ? ? ? Phone:
>       ?319-335-3386
>       Department of Statistics and? ? ? ? Fax:
>       ?319-335-3017
>       ? ? Actuarial Science
>       241 Schaeffer Hall? ? ? ? ? ? ? ? ? email:
>       ?luke-tierney at uiowa.edu
>       Iowa City, IA 52242? ? ? ? ? ? ? ? ?WWW:
>       http://www.stat.uiowa.edu
>
>       ______________________________________________
>       R-devel at r-project.org mailing list
>       https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> 
> 
> --
> http://hadley.nz
> 
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu

From r@c@rtwr|ght @end|ng |rom gm@||@com  Sat Jun  8 02:06:46 2024
From: r@c@rtwr|ght @end|ng |rom gm@||@com (Reed A. Cartwright)
Date: Fri, 7 Jun 2024 17:06:46 -0700
Subject: [Rd] [External] Re: clarifying and adjusting the C API for R
In-Reply-To: <6ca3dc90-b06d-1678-8faf-4c8d382dd8b3@uiowa.edu>
References: <5a1ccb59-3e90-31eb-132a-35c3a1839bbf@uiowa.edu>
 <CAHiA-ZnQK238zu6yXAxCNBASP6LX+74S8LjvOfmC-9ujiAcU+g@mail.gmail.com>
 <6ca3dc90-b06d-1678-8faf-4c8d382dd8b3@uiowa.edu>
Message-ID: <CALOkxuzKfiGTQ8rzZcM9uy0f+acrdXKeSdxz2qSX2_04+=YAgw@mail.gmail.com>

Would it be reasonable to move the non-API stuff that cannot be hidden
into header files inside a "details" directory (or some other specific
naming scheme)?

That's what I use when I need to separate a public API from an internal API.


On Fri, Jun 7, 2024 at 7:30?AM luke-tierney--- via R-devel
<r-devel at r-project.org> wrote:
>
> On Fri, 7 Jun 2024, Steven Dirkse wrote:
>
> > You don't often get email from sdirkse at gams.com. Learn why this is important
> > Thanks for sharing this overview of an interesting and much-needed project.
> > You mention that R exports about 1500 symbols (on platforms supporting
> > visibility) but this subject isn't mentioned explicitly again in your note,
> > so I'm wondering how things tie together.  Un-exported symbols cannot be
> > part of the API - how would people use them in this case?  In a perfect
> > world the set of exported symbols could define the API or match it exactly,
> > but I guess that isn't the case at present.  So I conclude that R exports
> > extra (i.e. non-API) symbols.  Is part of the goal to remove these extra
> > exports?
>
> No. We'll hide what we can, but base packages for one need access to
> some entry points that should not be in the API, so those have to stay
> un-hidden.
>
> Best,
>
> luke
>
> >
> > -Steve
> >
> > On Thu, Jun 6, 2024 at 10:47?AM luke-tierney--- via R-devel
> > <r-devel at r-project.org> wrote:
> >       This is an update on some current work on the C API for use in R
> >       extensions.
> >
> >       The internal R implementation makes use of tens of thousands of
> >       C
> >       entry points. On Linux and Windows, which support visibility
> >       restrictions, most of these are visible only within the R
> >       executble or
> >       shared library. About 1500 are not hidden and are visible to
> >       dynamically loaded shared libraries, such as ones in packages,
> >       and to
> >       embedding applications.
> >
> >       There are two main reasons for limiting access to entry points
> >       in a
> >       software framework:
> >
> >       - Some entry points are very easy to use in ways that corrupt
> >       internal
> >          data, leading to segfaults or, worse, incorrect computations
> >       without
> >          segfaults.
> >
> >       - Some entry point expose internal structure and other
> >       implementation
> >          details, which makes it hard to make improvements without
> >       breaking
> >          client code that has come to depend on these details.
> >
> >       The API of C entry points that can be used in R extensions, both
> >       for
> >       packages and embedding, has evolved organically over many years.
> >       The
> >       definition for the current release expressed in the Writing R
> >       Extensions manual (WRE) is roughly:
> >
> >            An entry point can be used if (1) it is declared in a
> >       header file
> >            in R.home("include"), and (2) if it is documented for use
> >       in WRE.
> >
> >       Ideally, (1) would be necessary and sufficient, but for a
> >       variety of
> >       reasons that isn't achievable, at least not in the near term.
> >       (2) can
> >       be challenging to determine; in particular, it is not amenable
> >       to a
> >       computational answer.
> >
> >       An experimental effort is underway to add annotations to the WRE
> >       Texinfo source to allow (2) to be answered unambiguously. The
> >       annotations so far mostly reflect my reading or WRE and may be
> >       revised
> >       as they are reviewed by others. The annotated document can be
> >       used for
> >       programmatically identifying what is currently considered part
> >       of the C
> >       API. The result so far is an experimental function
> >       tools:::funAPI():
> >
> >            > head(tools:::funAPI())
> >                            name                    loc apitype
> >            1 Rf_AdobeSymbol2utf8 R_ext/GraphicsDevice.h    eapi
> >            2        alloc3DArray                    WRE     api
> >            3          allocArray                    WRE     api
> >            4           allocLang                    WRE     api
> >            5           allocList                    WRE     api
> >            6         allocMatrix                    WRE     api
> >
> >       The 'apitype' field has three possible levels
> >
> >            | api  | stable (ideally) API |
> >            | eapi | experimental API     |
> >            | emb  | embedding API        |
> >
> >       Entry points in the embedded API would typically only be used in
> >       applications embedding R or providing new front ends, but might
> >       be
> >       reasonable to use in packages that support embedding.
> >
> >       The 'loc' field indicates how the entry point is identified as
> >       part of
> >       an API: explicit mention in WRE, or declaration in a header file
> >       identified as fully part of an API.
> >
> >       [tools:::funAPI() may not be completely accurate as it relies on
> >       regular expressions for examining header files considered part
> >       of the
> >       API rather than proper parsing. But it seems to be pretty close
> >       to
> >       what can be achieved with proper parsing.  Proper parsing would
> >       add
> >       dependencies on additional tools, which I would like to avoid
> >       for
> >       now. One dependency already present is that a C compiler has to
> >       be on
> >       the search path and cc -E has to run the C pre-processor.]
> >
> >       Two additional experimental functions are available for
> >       analyzing
> >       package compliance: tools:::checkPkgAPI and
> >       tools:::checkAllPkgsAPI.
> >       These examine installed packages.
> >
> >       [These may produce some false positives on macOS; they may or
> >       may not
> >       work on Windows at this point.]
> >
> >       Using these tools initially showed around 200 non-API entry
> >       points
> >       used across packages on CRAN and BIOC. Ideally this number
> >       should be
> >       reduced to zero. This will require a combination of additions to
> >       the
> >       API and changes in packages.
> >
> >       Some entry points can safely be added to the API. Around 40 have
> >       already been added to WRE with API annotations; another 40 or so
> >       can
> >       probably be added after review.
> >
> >       The remainder mostly fall into two groups:
> >
> >       - Entry points that should never be used in packages, such as
> >          SET_OBJECT or SETLENGTH (or any non-API SETXYZ functions for
> >       that
> >          matter) that can create inconsistent or corrupt internal
> >       state.
> >
> >       - Entry points that depend on the existence of internal
> >       structure that
> >          might be subject to change, such as the existence of promise
> >       objects
> >          or internal structure of environments.
> >
> >       Many, if not most, of these seem to be used in idioms that can
> >       either
> >       be accomplished with existing higher-level functions already in
> >       the
> >       API, or by new higher level functions that can be created and
> >       added. Working through these will take some time and
> >       coordination
> >       between R-core and maintainers of affected packages.
> >
> >       Once things have gelled a bit more I hope to turn this into a
> >       blog
> >       post that will include some examples of moving non-API entry
> >       point
> >       uses into compliance.
> >
> >       Best,
> >
> >       luke
> >
> >       --
> >       Luke Tierney
> >       Ralph E. Wareham Professor of Mathematical Sciences
> >       University of Iowa                  Phone:
> >        319-335-3386
> >       Department of Statistics and        Fax:
> >        319-335-3017
> >           Actuarial Science
> >       241 Schaeffer Hall                  email:
> >        luke-tierney at uiowa.edu
> >       Iowa City, IA 52242                 WWW:
> >       https://urldefense.com/v3/__http://www.stat.uiowa.edu__;!!IKRxdwAv5BmarQ!foNGcMBk1Ky20Cgz66006bUDTWTxmZhh2ntk8-PLXUqCy2s6xw68UOo-fy7OsIRpHBwgMtfQyBkcYZUZBvMvo18$
> >
> >       ______________________________________________
> >       R-devel at r-project.org mailing list
> >       https://urldefense.com/v3/__https://stat.ethz.ch/mailman/listinfo/r-devel__;!!IKRxdwAv5BmarQ!foNGcMBk1Ky20Cgz66006bUDTWTxmZhh2ntk8-PLXUqCy2s6xw68UOo-fy7OsIRpHBwgMtfQyBkcYZUZnVX5taE$
> >
> >
> >
> >
> >
>
> --
> Luke Tierney
> Ralph E. Wareham Professor of Mathematical Sciences
> University of Iowa                  Phone:             319-335-3386
> Department of Statistics and        Fax:               319-335-3017
>     Actuarial Science
> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> Iowa City, IA 52242                 WWW:  https://urldefense.com/v3/__http://www.stat.uiowa.edu__;!!IKRxdwAv5BmarQ!foNGcMBk1Ky20Cgz66006bUDTWTxmZhh2ntk8-PLXUqCy2s6xw68UOo-fy7OsIRpHBwgMtfQyBkcYZUZBvMvo18$
> ______________________________________________
> R-devel at r-project.org mailing list
> https://urldefense.com/v3/__https://stat.ethz.ch/mailman/listinfo/r-devel__;!!IKRxdwAv5BmarQ!foNGcMBk1Ky20Cgz66006bUDTWTxmZhh2ntk8-PLXUqCy2s6xw68UOo-fy7OsIRpHBwgMtfQyBkcYZUZnVX5taE$


From iuke-tier@ey m@iii@g oii uiow@@edu  Sat Jun  8 02:52:43 2024
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Fri, 7 Jun 2024 19:52:43 -0500 (CDT)
Subject: [Rd] [External] Re: clarifying and adjusting the C API for R
In-Reply-To: <CALOkxuzKfiGTQ8rzZcM9uy0f+acrdXKeSdxz2qSX2_04+=YAgw@mail.gmail.com>
References: <5a1ccb59-3e90-31eb-132a-35c3a1839bbf@uiowa.edu>
 <CAHiA-ZnQK238zu6yXAxCNBASP6LX+74S8LjvOfmC-9ujiAcU+g@mail.gmail.com>
 <6ca3dc90-b06d-1678-8faf-4c8d382dd8b3@uiowa.edu>
 <CALOkxuzKfiGTQ8rzZcM9uy0f+acrdXKeSdxz2qSX2_04+=YAgw@mail.gmail.com>
Message-ID: <eb46c07e-ba96-9a09-243c-88ef52b6f787@uiowa.edu>

On Sat, 8 Jun 2024, Reed A. Cartwright wrote:

> [You don't often get email from racartwright at gmail.com. Learn why this is important at https://aka.ms/LearnAboutSenderIdentification ]
>
> Would it be reasonable to move the non-API stuff that cannot be hidden
> into header files inside a "details" directory (or some other specific
> naming scheme)?
>
> That's what I use when I need to separate a public API from an internal API.

As do I, as does everyone else. As I wrote originally: " ... for a
variety of reasons that isn't achievable, at least not in the near
term." Can we leave it at that please?

luke

>
> On Fri, Jun 7, 2024 at 7:30?AM luke-tierney--- via R-devel
> <r-devel at r-project.org> wrote:
>>
>> On Fri, 7 Jun 2024, Steven Dirkse wrote:
>>
>>> You don't often get email from sdirkse at gams.com. Learn why this is important
>>> Thanks for sharing this overview of an interesting and much-needed project.
>>> You mention that R exports about 1500 symbols (on platforms supporting
>>> visibility) but this subject isn't mentioned explicitly again in your note,
>>> so I'm wondering how things tie together.  Un-exported symbols cannot be
>>> part of the API - how would people use them in this case?  In a perfect
>>> world the set of exported symbols could define the API or match it exactly,
>>> but I guess that isn't the case at present.  So I conclude that R exports
>>> extra (i.e. non-API) symbols.  Is part of the goal to remove these extra
>>> exports?
>>
>> No. We'll hide what we can, but base packages for one need access to
>> some entry points that should not be in the API, so those have to stay
>> un-hidden.
>>
>> Best,
>>
>> luke
>>
>>>
>>> -Steve
>>>
>>> On Thu, Jun 6, 2024 at 10:47?AM luke-tierney--- via R-devel
>>> <r-devel at r-project.org> wrote:
>>>       This is an update on some current work on the C API for use in R
>>>       extensions.
>>>
>>>       The internal R implementation makes use of tens of thousands of
>>>       C
>>>       entry points. On Linux and Windows, which support visibility
>>>       restrictions, most of these are visible only within the R
>>>       executble or
>>>       shared library. About 1500 are not hidden and are visible to
>>>       dynamically loaded shared libraries, such as ones in packages,
>>>       and to
>>>       embedding applications.
>>>
>>>       There are two main reasons for limiting access to entry points
>>>       in a
>>>       software framework:
>>>
>>>       - Some entry points are very easy to use in ways that corrupt
>>>       internal
>>>          data, leading to segfaults or, worse, incorrect computations
>>>       without
>>>          segfaults.
>>>
>>>       - Some entry point expose internal structure and other
>>>       implementation
>>>          details, which makes it hard to make improvements without
>>>       breaking
>>>          client code that has come to depend on these details.
>>>
>>>       The API of C entry points that can be used in R extensions, both
>>>       for
>>>       packages and embedding, has evolved organically over many years.
>>>       The
>>>       definition for the current release expressed in the Writing R
>>>       Extensions manual (WRE) is roughly:
>>>
>>>            An entry point can be used if (1) it is declared in a
>>>       header file
>>>            in R.home("include"), and (2) if it is documented for use
>>>       in WRE.
>>>
>>>       Ideally, (1) would be necessary and sufficient, but for a
>>>       variety of
>>>       reasons that isn't achievable, at least not in the near term.
>>>       (2) can
>>>       be challenging to determine; in particular, it is not amenable
>>>       to a
>>>       computational answer.
>>>
>>>       An experimental effort is underway to add annotations to the WRE
>>>       Texinfo source to allow (2) to be answered unambiguously. The
>>>       annotations so far mostly reflect my reading or WRE and may be
>>>       revised
>>>       as they are reviewed by others. The annotated document can be
>>>       used for
>>>       programmatically identifying what is currently considered part
>>>       of the C
>>>       API. The result so far is an experimental function
>>>       tools:::funAPI():
>>>
>>>           > head(tools:::funAPI())
>>>                            name                    loc apitype
>>>            1 Rf_AdobeSymbol2utf8 R_ext/GraphicsDevice.h    eapi
>>>            2        alloc3DArray                    WRE     api
>>>            3          allocArray                    WRE     api
>>>            4           allocLang                    WRE     api
>>>            5           allocList                    WRE     api
>>>            6         allocMatrix                    WRE     api
>>>
>>>       The 'apitype' field has three possible levels
>>>
>>>            | api  | stable (ideally) API |
>>>            | eapi | experimental API     |
>>>            | emb  | embedding API        |
>>>
>>>       Entry points in the embedded API would typically only be used in
>>>       applications embedding R or providing new front ends, but might
>>>       be
>>>       reasonable to use in packages that support embedding.
>>>
>>>       The 'loc' field indicates how the entry point is identified as
>>>       part of
>>>       an API: explicit mention in WRE, or declaration in a header file
>>>       identified as fully part of an API.
>>>
>>>       [tools:::funAPI() may not be completely accurate as it relies on
>>>       regular expressions for examining header files considered part
>>>       of the
>>>       API rather than proper parsing. But it seems to be pretty close
>>>       to
>>>       what can be achieved with proper parsing.  Proper parsing would
>>>       add
>>>       dependencies on additional tools, which I would like to avoid
>>>       for
>>>       now. One dependency already present is that a C compiler has to
>>>       be on
>>>       the search path and cc -E has to run the C pre-processor.]
>>>
>>>       Two additional experimental functions are available for
>>>       analyzing
>>>       package compliance: tools:::checkPkgAPI and
>>>       tools:::checkAllPkgsAPI.
>>>       These examine installed packages.
>>>
>>>       [These may produce some false positives on macOS; they may or
>>>       may not
>>>       work on Windows at this point.]
>>>
>>>       Using these tools initially showed around 200 non-API entry
>>>       points
>>>       used across packages on CRAN and BIOC. Ideally this number
>>>       should be
>>>       reduced to zero. This will require a combination of additions to
>>>       the
>>>       API and changes in packages.
>>>
>>>       Some entry points can safely be added to the API. Around 40 have
>>>       already been added to WRE with API annotations; another 40 or so
>>>       can
>>>       probably be added after review.
>>>
>>>       The remainder mostly fall into two groups:
>>>
>>>       - Entry points that should never be used in packages, such as
>>>          SET_OBJECT or SETLENGTH (or any non-API SETXYZ functions for
>>>       that
>>>          matter) that can create inconsistent or corrupt internal
>>>       state.
>>>
>>>       - Entry points that depend on the existence of internal
>>>       structure that
>>>          might be subject to change, such as the existence of promise
>>>       objects
>>>          or internal structure of environments.
>>>
>>>       Many, if not most, of these seem to be used in idioms that can
>>>       either
>>>       be accomplished with existing higher-level functions already in
>>>       the
>>>       API, or by new higher level functions that can be created and
>>>       added. Working through these will take some time and
>>>       coordination
>>>       between R-core and maintainers of affected packages.
>>>
>>>       Once things have gelled a bit more I hope to turn this into a
>>>       blog
>>>       post that will include some examples of moving non-API entry
>>>       point
>>>       uses into compliance.
>>>
>>>       Best,
>>>
>>>       luke
>>>
>>>       --
>>>       Luke Tierney
>>>       Ralph E. Wareham Professor of Mathematical Sciences
>>>       University of Iowa                  Phone:
>>>        319-335-3386
>>>       Department of Statistics and        Fax:
>>>        319-335-3017
>>>           Actuarial Science
>>>       241 Schaeffer Hall                  email:
>>>        luke-tierney at uiowa.edu
>>>       Iowa City, IA 52242                 WWW:
>>>       https://urldefense.com/v3/__http://www.stat.uiowa.edu__;!!IKRxdwAv5BmarQ!foNGcMBk1Ky20Cgz66006bUDTWTxmZhh2ntk8-PLXUqCy2s6xw68UOo-fy7OsIRpHBwgMtfQyBkcYZUZBvMvo18$
>>>
>>>       ______________________________________________
>>>       R-devel at r-project.org mailing list
>>>       https://urldefense.com/v3/__https://stat.ethz.ch/mailman/listinfo/r-devel__;!!IKRxdwAv5BmarQ!foNGcMBk1Ky20Cgz66006bUDTWTxmZhh2ntk8-PLXUqCy2s6xw68UOo-fy7OsIRpHBwgMtfQyBkcYZUZnVX5taE$
>>>
>>>
>>>
>>>
>>>
>>
>> --
>> Luke Tierney
>> Ralph E. Wareham Professor of Mathematical Sciences
>> University of Iowa                  Phone:             319-335-3386
>> Department of Statistics and        Fax:               319-335-3017
>>     Actuarial Science
>> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
>> Iowa City, IA 52242                 WWW:  https://urldefense.com/v3/__http://www.stat.uiowa.edu__;!!IKRxdwAv5BmarQ!foNGcMBk1Ky20Cgz66006bUDTWTxmZhh2ntk8-PLXUqCy2s6xw68UOo-fy7OsIRpHBwgMtfQyBkcYZUZBvMvo18$
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://urldefense.com/v3/__https://stat.ethz.ch/mailman/listinfo/r-devel__;!!IKRxdwAv5BmarQ!foNGcMBk1Ky20Cgz66006bUDTWTxmZhh2ntk8-PLXUqCy2s6xw68UOo-fy7OsIRpHBwgMtfQyBkcYZUZnVX5taE$
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu/

From bbo|ker @end|ng |rom gm@||@com  Sun Jun  9 00:06:14 2024
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Sat, 8 Jun 2024 18:06:14 -0400
Subject: [Rd] changes in R-devel and zero-extent objects in Rcpp
Message-ID: <92af423f-e83b-4b10-899f-0ba22999a44b@gmail.com>


    A change to R-devel (SVN r86629 or 
https://github.com/r-devel/r-svn/commit/92c1d5de23c93576f55062e26d446feface07250 
has changed the handling of pointers to zero-length objects, leading to 
ASAN issues with a number of Rcpp-based packages (the commit message 
reads, in part, "Also define STRICT_TYPECHECK when compiling inlined.c.")

   I'm interested in discussion from the community.

   Details/diagnosis for the issues in the lme4 package are here: 
https://github.com/lme4/lme4/issues/794, with a bit more discussion 
about how zero-length objects should be handled.

   The short(ish) version is that r86629 enables the 
CATCH_ZERO_LENGTH_ACCESS definition. This turns on the CHKZLN macro 
<https://github.com/r-devel/r-svn/blob/4ef83b9dc3c6874e774195d329cbb6c11a71c414/src/main/memory.c#L4090-L4104>, 
which returns a trivial pointer (rather than the data pointer that would 
be returned in the normal control flow) if an object has length 0:

/* Attempts to read or write elements of a zero length vector will
    result in a segfault, rather than read and write random memory.
    Returning NULL would be more natural, but Matrix seems to assume
    that even zero-length vectors have non-NULL data pointers, so
    return (void *) 1 instead. Zero-length CHARSXP objects still have a
    trailing zero byte so they are not handled. */

   In the Rcpp context this leads to an inconsistency, where `REAL(x)` 
is a 'real' external pointer and `DATAPTR(x)` is 0x1, which in turn 
leads to ASAN warnings like

runtime error: reference binding to misaligned address 0x000000000001 
for type 'const double', which requires 8 byte alignment
0x000000000001: note: pointer points here

    I'm in over my head and hoping for insight into whether this problem 
should be resolved by changing R, Rcpp, or downstream Rcpp packages ...

   cheers
    Ben Bolker


From kev|nu@hey @end|ng |rom gm@||@com  Sun Jun  9 00:39:50 2024
From: kev|nu@hey @end|ng |rom gm@||@com (Kevin Ushey)
Date: Sat, 8 Jun 2024 15:39:50 -0700
Subject: [Rd] changes in R-devel and zero-extent objects in Rcpp
In-Reply-To: <92af423f-e83b-4b10-899f-0ba22999a44b@gmail.com>
References: <92af423f-e83b-4b10-899f-0ba22999a44b@gmail.com>
Message-ID: <CAJXgQP3gAbkW-w4kmc3BfJc9gMd=wGGOs2VLu1bEwpwYKQF+bA@mail.gmail.com>

IMHO, this should be changed in both Rcpp and downstream packages:

1. Rcpp could check for out-of-bounds accesses in cases like these, and
emit an R warning / error when such an access is detected;

2. The downstream packages unintentionally making these out-of-bounds
accesses should be fixed to avoid doing that.

That is, I think this is ultimately a bug in the affected packages, but
Rcpp could do better in detecting and handling this for client packages
(avoiding a segfault).

Best,
Kevin


On Sat, Jun 8, 2024, 3:06?PM Ben Bolker <bbolker at gmail.com> wrote:

>
>     A change to R-devel (SVN r86629 or
>
> https://github.com/r-devel/r-svn/commit/92c1d5de23c93576f55062e26d446feface07250
> has changed the handling of pointers to zero-length objects, leading to
> ASAN issues with a number of Rcpp-based packages (the commit message
> reads, in part, "Also define STRICT_TYPECHECK when compiling inlined.c.")
>
>    I'm interested in discussion from the community.
>
>    Details/diagnosis for the issues in the lme4 package are here:
> https://github.com/lme4/lme4/issues/794, with a bit more discussion
> about how zero-length objects should be handled.
>
>    The short(ish) version is that r86629 enables the
> CATCH_ZERO_LENGTH_ACCESS definition. This turns on the CHKZLN macro
> <
> https://github.com/r-devel/r-svn/blob/4ef83b9dc3c6874e774195d329cbb6c11a71c414/src/main/memory.c#L4090-L4104>,
>
> which returns a trivial pointer (rather than the data pointer that would
> be returned in the normal control flow) if an object has length 0:
>
> /* Attempts to read or write elements of a zero length vector will
>     result in a segfault, rather than read and write random memory.
>     Returning NULL would be more natural, but Matrix seems to assume
>     that even zero-length vectors have non-NULL data pointers, so
>     return (void *) 1 instead. Zero-length CHARSXP objects still have a
>     trailing zero byte so they are not handled. */
>
>    In the Rcpp context this leads to an inconsistency, where `REAL(x)`
> is a 'real' external pointer and `DATAPTR(x)` is 0x1, which in turn
> leads to ASAN warnings like
>
> runtime error: reference binding to misaligned address 0x000000000001
> for type 'const double', which requires 8 byte alignment
> 0x000000000001: note: pointer points here
>
>     I'm in over my head and hoping for insight into whether this problem
> should be resolved by changing R, Rcpp, or downstream Rcpp packages ...
>
>    cheers
>     Ben Bolker
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From bbo|ker @end|ng |rom gm@||@com  Sun Jun  9 01:16:22 2024
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Sat, 8 Jun 2024 19:16:22 -0400
Subject: [Rd] changes in R-devel and zero-extent objects in Rcpp
In-Reply-To: <CAJXgQP3gAbkW-w4kmc3BfJc9gMd=wGGOs2VLu1bEwpwYKQF+bA@mail.gmail.com>
References: <92af423f-e83b-4b10-899f-0ba22999a44b@gmail.com>
 <CAJXgQP3gAbkW-w4kmc3BfJc9gMd=wGGOs2VLu1bEwpwYKQF+bA@mail.gmail.com>
Message-ID: <e61b6315-025a-4e88-8087-2eeba0f4fad2@gmail.com>

   The ASAN errors occur *even if the zero-length object is not actually 
accessed*/is used in a perfectly correct manner, i.e. it's perfectly 
legal in base R to define `m <- numeric(0)` or `m <- matrix(nrow = 0, 
ncol = 0)`, whereas doing the equivalent in Rcpp will (now) lead to an 
ASAN error.

   i.e., these are *not* previously cryptic out-of-bounds accesses that 
are now being revealed, but instead sensible and previously legal 
definitions of zero-length objects that are now causing problems.

    I'm pretty sure I'm right about this, but it's absolutely possible 
that I'm just confused at this point; I don't have a super-simple 
example to show you at the moment. The closest is this example by Mikael 
Jagan: https://github.com/lme4/lme4/issues/794#issuecomment-2155093049

   which shows that if x is a pointer to a zero-length vector (in plain 
C++ for R, no Rcpp is involved), DATAPTR(x) and REAL(x) evaluate to 
different values.

   Mikael further points out that "Rcpp seems to cast a (void *) 
returned by DATAPTR to (double *) when constructing a Vector<REALSXP> 
from a SEXP, rather than using the (double *) returned by REAL." So 
perhaps R-core doesn't want to guarantee that these operations give 
identical answers, in which case Rcpp will have to change the way it 
does things ...

   cheers
    Ben



On 2024-06-08 6:39 p.m., Kevin Ushey wrote:
> IMHO, this should be changed in both Rcpp and downstream packages:
> 
> 1. Rcpp could check for out-of-bounds accesses in cases like these, and 
> emit an R warning / error when such an access is detected;
> 
> 2. The downstream packages unintentionally making these out-of-bounds 
> accesses should be fixed to avoid doing that.
> 
> That is, I think this is ultimately a bug in the affected packages, but 
> Rcpp could do better in detecting and handling this for client packages 
> (avoiding a segfault).
> 
> Best,
> Kevin
> 
> 
> On Sat, Jun 8, 2024, 3:06?PM Ben Bolker <bbolker at gmail.com 
> <mailto:bbolker at gmail.com>> wrote:
> 
> 
>      ? ? A change to R-devel (SVN r86629 or
>     https://github.com/r-devel/r-svn/commit/92c1d5de23c93576f55062e26d446feface07250 <https://github.com/r-devel/r-svn/commit/92c1d5de23c93576f55062e26d446feface07250>
>     has changed the handling of pointers to zero-length objects, leading to
>     ASAN issues with a number of Rcpp-based packages (the commit message
>     reads, in part, "Also define STRICT_TYPECHECK when compiling
>     inlined.c.")
> 
>      ? ?I'm interested in discussion from the community.
> 
>      ? ?Details/diagnosis for the issues in the lme4 package are here:
>     https://github.com/lme4/lme4/issues/794
>     <https://github.com/lme4/lme4/issues/794>, with a bit more discussion
>     about how zero-length objects should be handled.
> 
>      ? ?The short(ish) version is that r86629 enables the
>     CATCH_ZERO_LENGTH_ACCESS definition. This turns on the CHKZLN macro
>     <https://github.com/r-devel/r-svn/blob/4ef83b9dc3c6874e774195d329cbb6c11a71c414/src/main/memory.c#L4090-L4104 <https://github.com/r-devel/r-svn/blob/4ef83b9dc3c6874e774195d329cbb6c11a71c414/src/main/memory.c#L4090-L4104>>,
>     which returns a trivial pointer (rather than the data pointer that
>     would
>     be returned in the normal control flow) if an object has length 0:
> 
>     /* Attempts to read or write elements of a zero length vector will
>      ? ? result in a segfault, rather than read and write random memory.
>      ? ? Returning NULL would be more natural, but Matrix seems to assume
>      ? ? that even zero-length vectors have non-NULL data pointers, so
>      ? ? return (void *) 1 instead. Zero-length CHARSXP objects still have a
>      ? ? trailing zero byte so they are not handled. */
> 
>      ? ?In the Rcpp context this leads to an inconsistency, where `REAL(x)`
>     is a 'real' external pointer and `DATAPTR(x)` is 0x1, which in turn
>     leads to ASAN warnings like
> 
>     runtime error: reference binding to misaligned address 0x000000000001
>     for type 'const double', which requires 8 byte alignment
>     0x000000000001: note: pointer points here
> 
>      ? ? I'm in over my head and hoping for insight into whether this
>     problem
>     should be resolved by changing R, Rcpp, or downstream Rcpp packages ...
> 
>      ? ?cheers
>      ? ? Ben Bolker
> 
>     ______________________________________________
>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>     https://stat.ethz.ch/mailman/listinfo/r-devel
>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
> 

-- 
Dr. Benjamin Bolker
Professor, Mathematics & Statistics and Biology, McMaster University
Director, School of Computational Science and Engineering
(Acting) Graduate chair, Mathematics & Statistics
 > E-mail is sent at my convenience; I don't expect replies outside of 
working hours.


From iuke-tier@ey m@iii@g oii uiow@@edu  Sun Jun  9 03:27:41 2024
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Sat, 8 Jun 2024 20:27:41 -0500 (CDT)
Subject: [Rd] 
 [External] Re: changes in R-devel and zero-extent objects in Rcpp
In-Reply-To: <e61b6315-025a-4e88-8087-2eeba0f4fad2@gmail.com>
References: <92af423f-e83b-4b10-899f-0ba22999a44b@gmail.com>
 <CAJXgQP3gAbkW-w4kmc3BfJc9gMd=wGGOs2VLu1bEwpwYKQF+bA@mail.gmail.com>
 <e61b6315-025a-4e88-8087-2eeba0f4fad2@gmail.com>
Message-ID: <9e3e9992-31a6-3f18-d03b-d5bd3f7053f2@uiowa.edu>

On Sat, 8 Jun 2024, Ben Bolker wrote:

>  The ASAN errors occur *even if the zero-length object is not actually 
> accessed*/is used in a perfectly correct manner, i.e. it's perfectly legal in 
> base R to define `m <- numeric(0)` or `m <- matrix(nrow = 0, ncol = 0)`, 
> whereas doing the equivalent in Rcpp will (now) lead to an ASAN error.
>
>  i.e., these are *not* previously cryptic out-of-bounds accesses that are 
> now being revealed, but instead sensible and previously legal definitions of 
> zero-length objects that are now causing problems.
>
>   I'm pretty sure I'm right about this, but it's absolutely possible that 
> I'm just confused at this point; I don't have a super-simple example to show 
> you at the moment. The closest is this example by Mikael Jagan: 
> https://github.com/lme4/lme4/issues/794#issuecomment-2155093049
>
>  which shows that if x is a pointer to a zero-length vector (in plain C++ 
> for R, no Rcpp is involved), DATAPTR(x) and REAL(x) evaluate to different 
> values.
>
>  Mikael further points out that "Rcpp seems to cast a (void *) returned by 
> DATAPTR to (double *) when constructing a Vector<REALSXP> from a SEXP, rather 
> than using the (double *) returned by REAL." So perhaps R-core doesn't want 
> to guarantee that these operations give identical answers, in which case Rcpp 
> will have to change the way it does things ...

It looks like REAL and friends should also get this check, but it's
not high priority at this point, at least to me. DATAPTR has been
using this check for a while in a barrier build, so you might want to
test there as well. I expect we will activate more integrity checks
from the barrier build on the API client side as things are tidied up.

However: DATAPTR is not in the API and can't be at least in this form:
It allows access to a writable pointer to STRSXP and VECSXP data and
that is too dangerous for memory manager integrity. I'm not sure
exactly how this will be resolve, but be prepared for changes.

Best,

luke

>
>  cheers
>   Ben
>
>
>
> On 2024-06-08 6:39 p.m., Kevin Ushey wrote:
>> IMHO, this should be changed in both Rcpp and downstream packages:
>> 
>> 1. Rcpp could check for out-of-bounds accesses in cases like these, and 
>> emit an R warning / error when such an access is detected;
>> 
>> 2. The downstream packages unintentionally making these out-of-bounds 
>> accesses should be fixed to avoid doing that.
>> 
>> That is, I think this is ultimately a bug in the affected packages, but 
>> Rcpp could do better in detecting and handling this for client packages 
>> (avoiding a segfault).
>> 
>> Best,
>> Kevin
>> 
>> 
>> On Sat, Jun 8, 2024, 3:06?PM Ben Bolker <bbolker at gmail.com 
>> <mailto:bbolker at gmail.com>> wrote:
>> 
>>
>>      ? ? A change to R-devel (SVN r86629 or
>>     https://github.com/r-devel/r-svn/commit/92c1d5de23c93576f55062e26d446feface07250 
>> <https://github.com/r-devel/r-svn/commit/92c1d5de23c93576f55062e26d446feface07250>
>>     has changed the handling of pointers to zero-length objects, leading to
>>     ASAN issues with a number of Rcpp-based packages (the commit message
>>     reads, in part, "Also define STRICT_TYPECHECK when compiling
>>     inlined.c.")
>>
>>      ? ?I'm interested in discussion from the community.
>>
>>      ? ?Details/diagnosis for the issues in the lme4 package are here:
>>     https://github.com/lme4/lme4/issues/794
>>     <https://github.com/lme4/lme4/issues/794>, 
>> with a bit more discussion
>>     about how zero-length objects should be handled.
>>
>>      ? ?The short(ish) version is that r86629 enables the
>>     CATCH_ZERO_LENGTH_ACCESS definition. This turns on the CHKZLN macro
>>     <https://github.com/r-devel/r-svn/blob/4ef83b9dc3c6874e774195d329cbb6c11a71c414/src/main/memory.c#L4090-L4104 
>> <https://github.com/r-devel/r-svn/blob/4ef83b9dc3c6874e774195d329cbb6c11a71c414/src/main/memory.c#L4090-L4104>>,
>>     which returns a trivial pointer (rather than the data pointer that
>>     would
>>     be returned in the normal control flow) if an object has length 0:
>>
>>     /* Attempts to read or write elements of a zero length vector will
>>      ? ? result in a segfault, rather than read and write random memory.
>>      ? ? Returning NULL would be more natural, but Matrix seems to assume
>>      ? ? that even zero-length vectors have non-NULL data pointers, so
>>      ? ? return (void *) 1 instead. Zero-length CHARSXP objects still have 
>> a
>>      ? ? trailing zero byte so they are not handled. */
>>
>>      ? ?In the Rcpp context this leads to an inconsistency, where `REAL(x)`
>>     is a 'real' external pointer and `DATAPTR(x)` is 0x1, which in turn
>>     leads to ASAN warnings like
>>
>>     runtime error: reference binding to misaligned address 0x000000000001
>>     for type 'const double', which requires 8 byte alignment
>>     0x000000000001: note: pointer points here
>>
>>      ? ? I'm in over my head and hoping for insight into whether this
>>     problem
>>     should be resolved by changing R, Rcpp, or downstream Rcpp packages ...
>>
>>      ? ?cheers
>>      ? ? Ben Bolker
>>
>>     ______________________________________________
>>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>>     https://stat.ethz.ch/mailman/listinfo/r-devel
>>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>> 
>
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu/

From yut@n|@|n| @end|ng |rom gm@||@com  Sun Jun  9 06:29:19 2024
From: yut@n|@|n| @end|ng |rom gm@||@com (Hiroaki Yutani)
Date: Sun, 9 Jun 2024 13:29:19 +0900
Subject: [Rd] clarifying and adjusting the C API for R
In-Reply-To: <5a1ccb59-3e90-31eb-132a-35c3a1839bbf@uiowa.edu>
References: <5a1ccb59-3e90-31eb-132a-35c3a1839bbf@uiowa.edu>
Message-ID: <CALyqOb-4YHJ3HOMw9aDz0A9QUfRGSfCtbFFQ50EKZHs7CJ_CFA@mail.gmail.com>

Thanks so much for your wonderful work, Luke!
I didn't expect such a clarification to happen this soon. This is really
great.

For convenience, I created a quick web page to search the result of
tools:::funAPI().

https://yutannihilation.github.io/R-fun-API/

Hope this helps those who are too lazy to install R-devel to check.

Best,
Yutani

2024?6?6?(?) 23:47 luke-tierney--- via R-devel <r-devel at r-project.org>:

> This is an update on some current work on the C API for use in R
> extensions.
>
> The internal R implementation makes use of tens of thousands of C
> entry points. On Linux and Windows, which support visibility
> restrictions, most of these are visible only within the R executble or
> shared library. About 1500 are not hidden and are visible to
> dynamically loaded shared libraries, such as ones in packages, and to
> embedding applications.
>
> There are two main reasons for limiting access to entry points in a
> software framework:
>
> - Some entry points are very easy to use in ways that corrupt internal
>    data, leading to segfaults or, worse, incorrect computations without
>    segfaults.
>
> - Some entry point expose internal structure and other implementation
>    details, which makes it hard to make improvements without breaking
>    client code that has come to depend on these details.
>
> The API of C entry points that can be used in R extensions, both for
> packages and embedding, has evolved organically over many years. The
> definition for the current release expressed in the Writing R
> Extensions manual (WRE) is roughly:
>
>      An entry point can be used if (1) it is declared in a header file
>      in R.home("include"), and (2) if it is documented for use in WRE.
>
> Ideally, (1) would be necessary and sufficient, but for a variety of
> reasons that isn't achievable, at least not in the near term. (2) can
> be challenging to determine; in particular, it is not amenable to a
> computational answer.
>
> An experimental effort is underway to add annotations to the WRE
> Texinfo source to allow (2) to be answered unambiguously. The
> annotations so far mostly reflect my reading or WRE and may be revised
> as they are reviewed by others. The annotated document can be used for
> programmatically identifying what is currently considered part of the C
> API. The result so far is an experimental function tools:::funAPI():
>
>      > head(tools:::funAPI())
>                      name                    loc apitype
>      1 Rf_AdobeSymbol2utf8 R_ext/GraphicsDevice.h    eapi
>      2        alloc3DArray                    WRE     api
>      3          allocArray                    WRE     api
>      4           allocLang                    WRE     api
>      5           allocList                    WRE     api
>      6         allocMatrix                    WRE     api
>
> The 'apitype' field has three possible levels
>
>      | api  | stable (ideally) API |
>      | eapi | experimental API     |
>      | emb  | embedding API        |
>
> Entry points in the embedded API would typically only be used in
> applications embedding R or providing new front ends, but might be
> reasonable to use in packages that support embedding.
>
> The 'loc' field indicates how the entry point is identified as part of
> an API: explicit mention in WRE, or declaration in a header file
> identified as fully part of an API.
>
> [tools:::funAPI() may not be completely accurate as it relies on
> regular expressions for examining header files considered part of the
> API rather than proper parsing. But it seems to be pretty close to
> what can be achieved with proper parsing.  Proper parsing would add
> dependencies on additional tools, which I would like to avoid for
> now. One dependency already present is that a C compiler has to be on
> the search path and cc -E has to run the C pre-processor.]
>
> Two additional experimental functions are available for analyzing
> package compliance: tools:::checkPkgAPI and tools:::checkAllPkgsAPI.
> These examine installed packages.
>
> [These may produce some false positives on macOS; they may or may not
> work on Windows at this point.]
>
> Using these tools initially showed around 200 non-API entry points
> used across packages on CRAN and BIOC. Ideally this number should be
> reduced to zero. This will require a combination of additions to the
> API and changes in packages.
>
> Some entry points can safely be added to the API. Around 40 have
> already been added to WRE with API annotations; another 40 or so can
> probably be added after review.
>
> The remainder mostly fall into two groups:
>
> - Entry points that should never be used in packages, such as
>    SET_OBJECT or SETLENGTH (or any non-API SETXYZ functions for that
>    matter) that can create inconsistent or corrupt internal state.
>
> - Entry points that depend on the existence of internal structure that
>    might be subject to change, such as the existence of promise objects
>    or internal structure of environments.
>
> Many, if not most, of these seem to be used in idioms that can either
> be accomplished with existing higher-level functions already in the
> API, or by new higher level functions that can be created and
> added. Working through these will take some time and coordination
> between R-core and maintainers of affected packages.
>
> Once things have gelled a bit more I hope to turn this into a blog
> post that will include some examples of moving non-API entry point
> uses into compliance.
>
> Best,
>
> luke
>
> --
> Luke Tierney
> Ralph E. Wareham Professor of Mathematical Sciences
> University of Iowa                  Phone:             319-335-3386
> Department of Statistics and        Fax:               319-335-3017
>     Actuarial Science
> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From yut@n|@|n| @end|ng |rom gm@||@com  Sun Jun  9 07:13:51 2024
From: yut@n|@|n| @end|ng |rom gm@||@com (Hiroaki Yutani)
Date: Sun, 9 Jun 2024 14:13:51 +0900
Subject: [Rd] 
 [External] Re: changes in R-devel and zero-extent objects in Rcpp
In-Reply-To: <9e3e9992-31a6-3f18-d03b-d5bd3f7053f2@uiowa.edu>
References: <92af423f-e83b-4b10-899f-0ba22999a44b@gmail.com>
 <CAJXgQP3gAbkW-w4kmc3BfJc9gMd=wGGOs2VLu1bEwpwYKQF+bA@mail.gmail.com>
 <e61b6315-025a-4e88-8087-2eeba0f4fad2@gmail.com>
 <9e3e9992-31a6-3f18-d03b-d5bd3f7053f2@uiowa.edu>
Message-ID: <CALyqOb-hshOPQ2VSkJTugdcT_nCFaVddH0C179G6M7cpVxokkQ@mail.gmail.com>

Sorry to ask about a bit drifted topic, but will there be an alternative
API to DATAPTR?

> DATAPTR is not in the API and can't be at least in this form

I believe it's vital for ALTREP to return the pointer to the expanded
version of a SEXP just like the implementation in base R does [1].
At least, VECSXP has no other measure to expose the pointer if I understand
correctly.

Best,
Yutani

[1]:
https://github.com/r-devel/r-svn/blob/a3508b75d28164b0e5bcb2c87f816ce5169729a4/src/main/altclasses.c#L186


2024?6?9?(?) 10:43 luke-tierney--- via R-devel <r-devel at r-project.org>:

> On Sat, 8 Jun 2024, Ben Bolker wrote:
>
> >  The ASAN errors occur *even if the zero-length object is not actually
> > accessed*/is used in a perfectly correct manner, i.e. it's perfectly
> legal in
> > base R to define `m <- numeric(0)` or `m <- matrix(nrow = 0, ncol = 0)`,
> > whereas doing the equivalent in Rcpp will (now) lead to an ASAN error.
> >
> >  i.e., these are *not* previously cryptic out-of-bounds accesses that
> are
> > now being revealed, but instead sensible and previously legal
> definitions of
> > zero-length objects that are now causing problems.
> >
> >   I'm pretty sure I'm right about this, but it's absolutely possible
> that
> > I'm just confused at this point; I don't have a super-simple example to
> show
> > you at the moment. The closest is this example by Mikael Jagan:
> > https://github.com/lme4/lme4/issues/794#issuecomment-2155093049
> >
> >  which shows that if x is a pointer to a zero-length vector (in plain
> C++
> > for R, no Rcpp is involved), DATAPTR(x) and REAL(x) evaluate to
> different
> > values.
> >
> >  Mikael further points out that "Rcpp seems to cast a (void *) returned
> by
> > DATAPTR to (double *) when constructing a Vector<REALSXP> from a SEXP,
> rather
> > than using the (double *) returned by REAL." So perhaps R-core doesn't
> want
> > to guarantee that these operations give identical answers, in which case
> Rcpp
> > will have to change the way it does things ...
>
> It looks like REAL and friends should also get this check, but it's
> not high priority at this point, at least to me. DATAPTR has been
> using this check for a while in a barrier build, so you might want to
> test there as well. I expect we will activate more integrity checks
> from the barrier build on the API client side as things are tidied up.
>
> However: DATAPTR is not in the API and can't be at least in this form:
> It allows access to a writable pointer to STRSXP and VECSXP data and
> that is too dangerous for memory manager integrity. I'm not sure
> exactly how this will be resolve, but be prepared for changes.
>
> Best,
>
> luke
>
> >
> >  cheers
> >   Ben
> >
> >
> >
> > On 2024-06-08 6:39 p.m., Kevin Ushey wrote:
> >> IMHO, this should be changed in both Rcpp and downstream packages:
> >>
> >> 1. Rcpp could check for out-of-bounds accesses in cases like these, and
> >> emit an R warning / error when such an access is detected;
> >>
> >> 2. The downstream packages unintentionally making these out-of-bounds
> >> accesses should be fixed to avoid doing that.
> >>
> >> That is, I think this is ultimately a bug in the affected packages, but
> >> Rcpp could do better in detecting and handling this for client packages
> >> (avoiding a segfault).
> >>
> >> Best,
> >> Kevin
> >>
> >>
> >> On Sat, Jun 8, 2024, 3:06?PM Ben Bolker <bbolker at gmail.com
> >> <mailto:bbolker at gmail.com>> wrote:
> >>
> >>
> >>          A change to R-devel (SVN r86629 or
> >>
> https://github.com/r-devel/r-svn/commit/92c1d5de23c93576f55062e26d446feface07250
> >> <
> https://github.com/r-devel/r-svn/commit/92c1d5de23c93576f55062e26d446feface07250
> >
> >>     has changed the handling of pointers to zero-length objects,
> leading to
> >>     ASAN issues with a number of Rcpp-based packages (the commit message
> >>     reads, in part, "Also define STRICT_TYPECHECK when compiling
> >>     inlined.c.")
> >>
> >>         I'm interested in discussion from the community.
> >>
> >>         Details/diagnosis for the issues in the lme4 package are here:
> >>     https://github.com/lme4/lme4/issues/794
> >>     <https://github.com/lme4/lme4/issues/794>,
> >> with a bit more discussion
> >>     about how zero-length objects should be handled.
> >>
> >>         The short(ish) version is that r86629 enables the
> >>     CATCH_ZERO_LENGTH_ACCESS definition. This turns on the CHKZLN macro
> >>     <
> https://github.com/r-devel/r-svn/blob/4ef83b9dc3c6874e774195d329cbb6c11a71c414/src/main/memory.c#L4090-L4104
> >> <
> https://github.com/r-devel/r-svn/blob/4ef83b9dc3c6874e774195d329cbb6c11a71c414/src/main/memory.c#L4090-L4104
> >>,
> >>     which returns a trivial pointer (rather than the data pointer that
> >>     would
> >>     be returned in the normal control flow) if an object has length 0:
> >>
> >>     /* Attempts to read or write elements of a zero length vector will
> >>          result in a segfault, rather than read and write random memory.
> >>          Returning NULL would be more natural, but Matrix seems to
> assume
> >>          that even zero-length vectors have non-NULL data pointers, so
> >>          return (void *) 1 instead. Zero-length CHARSXP objects still
> have
> >> a
> >>          trailing zero byte so they are not handled. */
> >>
> >>         In the Rcpp context this leads to an inconsistency, where
> `REAL(x)`
> >>     is a 'real' external pointer and `DATAPTR(x)` is 0x1, which in turn
> >>     leads to ASAN warnings like
> >>
> >>     runtime error: reference binding to misaligned address
> 0x000000000001
> >>     for type 'const double', which requires 8 byte alignment
> >>     0x000000000001: note: pointer points here
> >>
> >>          I'm in over my head and hoping for insight into whether this
> >>     problem
> >>     should be resolved by changing R, Rcpp, or downstream Rcpp packages
> ...
> >>
> >>         cheers
> >>          Ben Bolker
> >>
> >>     ______________________________________________
> >>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
> >>     https://stat.ethz.ch/mailman/listinfo/r-devel
> >>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
> >>
> >
> >
>
> --
> Luke Tierney
> Ralph E. Wareham Professor of Mathematical Sciences
> University of Iowa                  Phone:             319-335-3386
> Department of Statistics and        Fax:               319-335-3017
>     Actuarial Science
> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu/
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From yut@n|@|n| @end|ng |rom gm@||@com  Sun Jun  9 12:10:05 2024
From: yut@n|@|n| @end|ng |rom gm@||@com (Hiroaki Yutani)
Date: Sun, 9 Jun 2024 19:10:05 +0900
Subject: [Rd] 
 [External] Re: changes in R-devel and zero-extent objects in Rcpp
In-Reply-To: <CALyqOb-hshOPQ2VSkJTugdcT_nCFaVddH0C179G6M7cpVxokkQ@mail.gmail.com>
References: <92af423f-e83b-4b10-899f-0ba22999a44b@gmail.com>
 <CAJXgQP3gAbkW-w4kmc3BfJc9gMd=wGGOs2VLu1bEwpwYKQF+bA@mail.gmail.com>
 <e61b6315-025a-4e88-8087-2eeba0f4fad2@gmail.com>
 <9e3e9992-31a6-3f18-d03b-d5bd3f7053f2@uiowa.edu>
 <CALyqOb-hshOPQ2VSkJTugdcT_nCFaVddH0C179G6M7cpVxokkQ@mail.gmail.com>
Message-ID: <CALyqOb8k1XcRY1TGgQt-80hA9xPY0ftTOYFso5EEmUkAOmkRyw@mail.gmail.com>

(Mainly reply to self)

I found there's a new API VECTOR_PTR_RO. Thanks for adding this!

https://github.com/r-devel/r-svn/commit/d499fab95b1ba23ee7842293030d4af1e69ae0fe

Best,
Yutani

2024?6?9?(?) 14:13 Hiroaki Yutani <yutani.ini at gmail.com>:

> Sorry to ask about a bit drifted topic, but will there be an alternative
> API to DATAPTR?
>
> > DATAPTR is not in the API and can't be at least in this form
>
> I believe it's vital for ALTREP to return the pointer to the expanded
> version of a SEXP just like the implementation in base R does [1].
> At least, VECSXP has no other measure to expose the pointer if I
> understand correctly.
>
> Best,
> Yutani
>
> [1]:
> https://github.com/r-devel/r-svn/blob/a3508b75d28164b0e5bcb2c87f816ce5169729a4/src/main/altclasses.c#L186
>
>
> 2024?6?9?(?) 10:43 luke-tierney--- via R-devel <r-devel at r-project.org>:
>
>> On Sat, 8 Jun 2024, Ben Bolker wrote:
>>
>> >  The ASAN errors occur *even if the zero-length object is not actually
>> > accessed*/is used in a perfectly correct manner, i.e. it's perfectly
>> legal in
>> > base R to define `m <- numeric(0)` or `m <- matrix(nrow = 0, ncol =
>> 0)`,
>> > whereas doing the equivalent in Rcpp will (now) lead to an ASAN error.
>> >
>> >  i.e., these are *not* previously cryptic out-of-bounds accesses that
>> are
>> > now being revealed, but instead sensible and previously legal
>> definitions of
>> > zero-length objects that are now causing problems.
>> >
>> >   I'm pretty sure I'm right about this, but it's absolutely possible
>> that
>> > I'm just confused at this point; I don't have a super-simple example to
>> show
>> > you at the moment. The closest is this example by Mikael Jagan:
>> > https://github.com/lme4/lme4/issues/794#issuecomment-2155093049
>> >
>> >  which shows that if x is a pointer to a zero-length vector (in plain
>> C++
>> > for R, no Rcpp is involved), DATAPTR(x) and REAL(x) evaluate to
>> different
>> > values.
>> >
>> >  Mikael further points out that "Rcpp seems to cast a (void *) returned
>> by
>> > DATAPTR to (double *) when constructing a Vector<REALSXP> from a SEXP,
>> rather
>> > than using the (double *) returned by REAL." So perhaps R-core doesn't
>> want
>> > to guarantee that these operations give identical answers, in which
>> case Rcpp
>> > will have to change the way it does things ...
>>
>> It looks like REAL and friends should also get this check, but it's
>> not high priority at this point, at least to me. DATAPTR has been
>> using this check for a while in a barrier build, so you might want to
>> test there as well. I expect we will activate more integrity checks
>> from the barrier build on the API client side as things are tidied up.
>>
>> However: DATAPTR is not in the API and can't be at least in this form:
>> It allows access to a writable pointer to STRSXP and VECSXP data and
>> that is too dangerous for memory manager integrity. I'm not sure
>> exactly how this will be resolve, but be prepared for changes.
>>
>> Best,
>>
>> luke
>>
>> >
>> >  cheers
>> >   Ben
>> >
>> >
>> >
>> > On 2024-06-08 6:39 p.m., Kevin Ushey wrote:
>> >> IMHO, this should be changed in both Rcpp and downstream packages:
>> >>
>> >> 1. Rcpp could check for out-of-bounds accesses in cases like these,
>> and
>> >> emit an R warning / error when such an access is detected;
>> >>
>> >> 2. The downstream packages unintentionally making these out-of-bounds
>> >> accesses should be fixed to avoid doing that.
>> >>
>> >> That is, I think this is ultimately a bug in the affected packages,
>> but
>> >> Rcpp could do better in detecting and handling this for client
>> packages
>> >> (avoiding a segfault).
>> >>
>> >> Best,
>> >> Kevin
>> >>
>> >>
>> >> On Sat, Jun 8, 2024, 3:06?PM Ben Bolker <bbolker at gmail.com
>> >> <mailto:bbolker at gmail.com>> wrote:
>> >>
>> >>
>> >>          A change to R-devel (SVN r86629 or
>> >>
>> https://github.com/r-devel/r-svn/commit/92c1d5de23c93576f55062e26d446feface07250
>> >> <
>> https://github.com/r-devel/r-svn/commit/92c1d5de23c93576f55062e26d446feface07250
>> >
>> >>     has changed the handling of pointers to zero-length objects,
>> leading to
>> >>     ASAN issues with a number of Rcpp-based packages (the commit
>> message
>> >>     reads, in part, "Also define STRICT_TYPECHECK when compiling
>> >>     inlined.c.")
>> >>
>> >>         I'm interested in discussion from the community.
>> >>
>> >>         Details/diagnosis for the issues in the lme4 package are here:
>> >>     https://github.com/lme4/lme4/issues/794
>> >>     <https://github.com/lme4/lme4/issues/794>,
>> >> with a bit more discussion
>> >>     about how zero-length objects should be handled.
>> >>
>> >>         The short(ish) version is that r86629 enables the
>> >>     CATCH_ZERO_LENGTH_ACCESS definition. This turns on the CHKZLN macro
>> >>     <
>> https://github.com/r-devel/r-svn/blob/4ef83b9dc3c6874e774195d329cbb6c11a71c414/src/main/memory.c#L4090-L4104
>> >> <
>> https://github.com/r-devel/r-svn/blob/4ef83b9dc3c6874e774195d329cbb6c11a71c414/src/main/memory.c#L4090-L4104
>> >>,
>> >>     which returns a trivial pointer (rather than the data pointer that
>> >>     would
>> >>     be returned in the normal control flow) if an object has length 0:
>> >>
>> >>     /* Attempts to read or write elements of a zero length vector will
>> >>          result in a segfault, rather than read and write random
>> memory.
>> >>          Returning NULL would be more natural, but Matrix seems to
>> assume
>> >>          that even zero-length vectors have non-NULL data pointers, so
>> >>          return (void *) 1 instead. Zero-length CHARSXP objects still
>> have
>> >> a
>> >>          trailing zero byte so they are not handled. */
>> >>
>> >>         In the Rcpp context this leads to an inconsistency, where
>> `REAL(x)`
>> >>     is a 'real' external pointer and `DATAPTR(x)` is 0x1, which in turn
>> >>     leads to ASAN warnings like
>> >>
>> >>     runtime error: reference binding to misaligned address
>> 0x000000000001
>> >>     for type 'const double', which requires 8 byte alignment
>> >>     0x000000000001: note: pointer points here
>> >>
>> >>          I'm in over my head and hoping for insight into whether this
>> >>     problem
>> >>     should be resolved by changing R, Rcpp, or downstream Rcpp
>> packages ...
>> >>
>> >>         cheers
>> >>          Ben Bolker
>> >>
>> >>     ______________________________________________
>> >>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>> >>     https://stat.ethz.ch/mailman/listinfo/r-devel
>> >>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>> >>
>> >
>> >
>>
>> --
>> Luke Tierney
>> Ralph E. Wareham Professor of Mathematical Sciences
>> University of Iowa                  Phone:             319-335-3386
>> Department of Statistics and        Fax:               319-335-3017
>>     Actuarial Science
>> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
>> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu/
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>

	[[alternative HTML version deleted]]


From ||u|@@rev|||@ @end|ng |rom gm@||@com  Sun Jun  9 12:58:30 2024
From: ||u|@@rev|||@ @end|ng |rom gm@||@com (=?UTF-8?Q?Llu=C3=ADs_Revilla?=)
Date: Sun, 9 Jun 2024 12:58:30 +0200
Subject: [Rd] Fields used by available.packages
Message-ID: <CAN+W6_vcvA4Gr9BUenydQOmt4HQSrTzNuNUyirFkbYN30vM-zA@mail.gmail.com>

Hi all,

I have recently been researching how available.packages and
install.packages filter packages from repositories with additional fields
in their PACKAGES file.

Currently there are some default filters, but users (and R admins) can set
up their own filters by passing a list to the fields argument or adding
them to the "available_packages_filters" option.
But if the fields used by the filters are not read by default, then users
must manually add the required fields to each call to available.packages.

This makes it difficult to use new fields and to control what is installed
in highly regulated systems which want to use more fields to select what is
installed.

Current workarounds considered are:
 1) The filtering function requiring new fields intercepts the call to
available.packages and adds the desired fields via eval in
parent.environment and then adds the filters again.
 2) Import new data (remote or local) when filtering packages, merge them
and filter accordingly.
 3) Suggestions?

The first solution is complicated, while the second doesn't use the R
machinery of tools::write_PACKAGES to set up the repository with all the
fields (although how to add more fields to the repository file is a
different issue).

Would it be possible to add a new option to add fields to be read by
available.packages, similar to filters?
The same approach for fields as for filters would avoid the two workarounds
mentioned. To match it, the new option could be named
"available_packages_fields".

I look forward to hearing from you,

Llu?s

	[[alternative HTML version deleted]]


From @pencer@gr@ve@ @end|ng |rom prod@y@e@com  Sun Jun  9 18:03:52 2024
From: @pencer@gr@ve@ @end|ng |rom prod@y@e@com (Spencer Graves)
Date: Sun, 9 Jun 2024 11:03:52 -0500
Subject: [Rd] head.ts, tail.ts loses time
Message-ID: <016d5bb8-b0ee-47f0-91b2-7a2b8c51557d@prodsyse.com>

Hello, All:


	  The 'head' and 'tail' functions strip the time from a 'ts' object. 
Example:


 > head(presidents)
[1] NA 87 82 75 63 50


 > window(presidents, 1945, 1946.25)
      Qtr1 Qtr2 Qtr3 Qtr4
1945   NA   87   82   75
1946   63   50


	  Below please find code for 'head.ts' and 'tail.ts' that matches 
'window'.


	  Comments?
	  Spencer Graves

head.ts <- function(x, n=6L, ...){
   tmx <- as.numeric(time(x))
#
   utils:::checkHT(n, d <- dim(x))
   if(is.na(n[1]) || n[1]==0)ts(NULL)
#
   firstn <- head(tmx, n[1])
   if(is.null(d)){
     return(window(x, firstn[1], tail(firstn, 1)))
   } else{
     if(length(n)<2){
       return(window(x, firstn[1], tail(firstn, 1)))
     } else {
       Cols <- head(1:d[2], n[2])
       xn2 <- x[, Cols[1]:tail(Cols, 1)]
       return(window(xn2, firstn[1], tail(firstn, 1)))
     }
   }
}


tail.ts <- function (x, n = 6L, ...)
{
   utils:::checkHT(n, d <- dim(x))
   tmx <- as.numeric(time(x))
#
   if(is.na(n[1]) || n[1]==0)ts(NULL)
#
   lastn <- tail(tmx, n[1])
   if(is.null(d)){
     return(window(x, lastn[1], tail(lastn, 1)))
   } else{
     if(length(n)<2){
       return(window(x, lastn[1], tail(lastn, 1)))
     } else {
       Cols <- head(1:d[2], n[2])
       xn2 <- x[, Cols[1]:tail(Cols, 1)]
       return(window(xn2, lastn[1], tail(lastn, 1)))
     }
   }
}


# examples
head(presidents)

head(presidents, 2)

npresObs <- length(presidents)
head(presidents, 6-npresObs)

try(head(presidents, 1:2)) # 'try-error'

try(head(presidents, 0)) # 'try-error'

# matrix time series
str(pres <- cbind(n=1:length(presidents), presidents))
head(pres, 2)

head(pres, 2-npresObs)

head(pres, 1:2)
head(pres, 2:1)
head(pres, 1:3)

# examples
tail(presidents)

tail(presidents, 2)

npresObs <- length(presidents)
tail(presidents, 6-npresObs)

try(tail(presidents, 1:2)) # 'try-error'

try(tail(presidents, 0)) # 'try-error'

# matrix time series
str(pres <- cbind(n=1:length(presidents), presidents))
tail(pres, 2)

tail(pres, 2-npresObs)

tail(pres, 1:2)
tail(pres, 2:1)
tail(pres, 1:3)

# for unit testing:
headPres <- head(presidents)
pres6 <- ts(presidents[1:6], time(presidents)[1],
             frequency=frequency(presidents))
stopifnot(all.equal(headPres, pres6))

headPres2 <- head(presidents, 2)
pres2 <- ts(presidents[1:2], time(presidents)[1],
             frequency=frequency(presidents))
stopifnot(all.equal(headPres2, pres2))

npresObs <- length(presidents)
headPres. <- head(presidents, 6-npresObs)
stopifnot(all.equal(headPres., pres6))

headPresOops <- try(head(presidents, 1:2))
stopifnot(class(headPresOops) == 'try-error')

headPres0 <- try(head(presidents, 0))
stopifnot(class(headPres0) == 'try-error')

str(pres <- cbind(n=1:length(presidents), presidents))
headP2 <- head(pres, 2)

p2 <- ts(pres[1:2, ], time(presidents)[1],
          frequency=frequency(presidents))
stopifnot(all.equal(headP2, p2))

headP2. <- head(pres, 2-npresObs)
stopifnot(all.equal(headP2., p2))


#############


sessionInfo()
R version 4.4.0 (2024-04-24)
Platform: aarch64-apple-darwin20
Running under: macOS Sonoma 14.5

Matrix products: default
BLAS: 
/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib 

LAPACK: 
/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib; 
  LAPACK version 3.12.0

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

time zone: America/Chicago
tzcode source: internal

attached base packages:
[1] stats     graphics  grDevices utils     datasets
[6] methods   base

loaded via a namespace (and not attached):
[1] compiler_4.4.0 tools_4.4.0


From jo@|@h@p@rry @end|ng |rom gm@||@com  Sun Jun  9 18:20:10 2024
From: jo@|@h@p@rry @end|ng |rom gm@||@com (Josiah Parry)
Date: Sun, 9 Jun 2024 12:20:10 -0400
Subject: [Rd] head.ts, tail.ts loses time
In-Reply-To: <016d5bb8-b0ee-47f0-91b2-7a2b8c51557d@prodsyse.com>
References: <016d5bb8-b0ee-47f0-91b2-7a2b8c51557d@prodsyse.com>
Message-ID: <CAL3ufUJ-hJ=frFdTWFc61xqzj-acEDVLwxx42R3px+ghBGFvQw@mail.gmail.com>

It looks like to me the class is being removed explicitly due to the use of
as.numeric()

On Sun, Jun 9, 2024 at 12:04?PM Spencer Graves <spencer.graves at prodsyse.com>
wrote:

> Hello, All:
>
>
>           The 'head' and 'tail' functions strip the time from a 'ts'
> object.
> Example:
>
>
>  > head(presidents)
> [1] NA 87 82 75 63 50
>
>
>  > window(presidents, 1945, 1946.25)
>       Qtr1 Qtr2 Qtr3 Qtr4
> 1945   NA   87   82   75
> 1946   63   50
>
>
>           Below please find code for 'head.ts' and 'tail.ts' that matches
> 'window'.
>
>
>           Comments?
>           Spencer Graves
>
> head.ts <- function(x, n=6L, ...){
>    tmx <- as.numeric(time(x))
> #
>    utils:::checkHT(n, d <- dim(x))
>    if(is.na(n[1]) || n[1]==0)ts(NULL)
> #
>    firstn <- head(tmx, n[1])
>    if(is.null(d)){
>      return(window(x, firstn[1], tail(firstn, 1)))
>    } else{
>      if(length(n)<2){
>        return(window(x, firstn[1], tail(firstn, 1)))
>      } else {
>        Cols <- head(1:d[2], n[2])
>        xn2 <- x[, Cols[1]:tail(Cols, 1)]
>        return(window(xn2, firstn[1], tail(firstn, 1)))
>      }
>    }
> }
>
>
> tail.ts <- function (x, n = 6L, ...)
> {
>    utils:::checkHT(n, d <- dim(x))
>    tmx <- as.numeric(time(x))
> #
>    if(is.na(n[1]) || n[1]==0)ts(NULL)
> #
>    lastn <- tail(tmx, n[1])
>    if(is.null(d)){
>      return(window(x, lastn[1], tail(lastn, 1)))
>    } else{
>      if(length(n)<2){
>        return(window(x, lastn[1], tail(lastn, 1)))
>      } else {
>        Cols <- head(1:d[2], n[2])
>        xn2 <- x[, Cols[1]:tail(Cols, 1)]
>        return(window(xn2, lastn[1], tail(lastn, 1)))
>      }
>    }
> }
>
>
> # examples
> head(presidents)
>
> head(presidents, 2)
>
> npresObs <- length(presidents)
> head(presidents, 6-npresObs)
>
> try(head(presidents, 1:2)) # 'try-error'
>
> try(head(presidents, 0)) # 'try-error'
>
> # matrix time series
> str(pres <- cbind(n=1:length(presidents), presidents))
> head(pres, 2)
>
> head(pres, 2-npresObs)
>
> head(pres, 1:2)
> head(pres, 2:1)
> head(pres, 1:3)
>
> # examples
> tail(presidents)
>
> tail(presidents, 2)
>
> npresObs <- length(presidents)
> tail(presidents, 6-npresObs)
>
> try(tail(presidents, 1:2)) # 'try-error'
>
> try(tail(presidents, 0)) # 'try-error'
>
> # matrix time series
> str(pres <- cbind(n=1:length(presidents), presidents))
> tail(pres, 2)
>
> tail(pres, 2-npresObs)
>
> tail(pres, 1:2)
> tail(pres, 2:1)
> tail(pres, 1:3)
>
> # for unit testing:
> headPres <- head(presidents)
> pres6 <- ts(presidents[1:6], time(presidents)[1],
>              frequency=frequency(presidents))
> stopifnot(all.equal(headPres, pres6))
>
> headPres2 <- head(presidents, 2)
> pres2 <- ts(presidents[1:2], time(presidents)[1],
>              frequency=frequency(presidents))
> stopifnot(all.equal(headPres2, pres2))
>
> npresObs <- length(presidents)
> headPres. <- head(presidents, 6-npresObs)
> stopifnot(all.equal(headPres., pres6))
>
> headPresOops <- try(head(presidents, 1:2))
> stopifnot(class(headPresOops) == 'try-error')
>
> headPres0 <- try(head(presidents, 0))
> stopifnot(class(headPres0) == 'try-error')
>
> str(pres <- cbind(n=1:length(presidents), presidents))
> headP2 <- head(pres, 2)
>
> p2 <- ts(pres[1:2, ], time(presidents)[1],
>           frequency=frequency(presidents))
> stopifnot(all.equal(headP2, p2))
>
> headP2. <- head(pres, 2-npresObs)
> stopifnot(all.equal(headP2., p2))
>
>
> #############
>
>
> sessionInfo()
> R version 4.4.0 (2024-04-24)
> Platform: aarch64-apple-darwin20
> Running under: macOS Sonoma 14.5
>
> Matrix products: default
> BLAS:
> /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
>
>
> LAPACK:
> /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;
>
>   LAPACK version 3.12.0
>
> locale:
> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
>
> time zone: America/Chicago
> tzcode source: internal
>
> attached base packages:
> [1] stats     graphics  grDevices utils     datasets
> [6] methods   base
>
> loaded via a namespace (and not attached):
> [1] compiler_4.4.0 tools_4.4.0
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From tr@ver@c @end|ng |rom gm@||@com  Sun Jun  9 21:25:46 2024
From: tr@ver@c @end|ng |rom gm@||@com (Travers Ching)
Date: Sun, 9 Jun 2024 12:25:46 -0700
Subject: [Rd] clarifying and adjusting the C API for R
In-Reply-To: <CALyqOb-4YHJ3HOMw9aDz0A9QUfRGSfCtbFFQ50EKZHs7CJ_CFA@mail.gmail.com>
References: <5a1ccb59-3e90-31eb-132a-35c3a1839bbf@uiowa.edu>
 <CALyqOb-4YHJ3HOMw9aDz0A9QUfRGSfCtbFFQ50EKZHs7CJ_CFA@mail.gmail.com>
Message-ID: <CAPLMX9HdF8R+UO5WvdzCeoXpcqFM87KgDAigLuByhboqXX2qJQ@mail.gmail.com>

Hi Luke, thanks for all your work on R!

I'd like to ask specifically about R_serialize / R_unserialize (and
associated helper functions). These are used by at least a handful of
packages and I don't see them in the list from Yutani.

Are these API functions considered "stable"?

Best,
Travers

On Sat, Jun 8, 2024 at 9:29?PM Hiroaki Yutani <yutani.ini at gmail.com> wrote:
>
> Thanks so much for your wonderful work, Luke!
> I didn't expect such a clarification to happen this soon. This is really
> great.
>
> For convenience, I created a quick web page to search the result of
> tools:::funAPI().
>
> https://yutannihilation.github.io/R-fun-API/
>
> Hope this helps those who are too lazy to install R-devel to check.
>
> Best,
> Yutani
>
> 2024?6?6?(?) 23:47 luke-tierney--- via R-devel <r-devel at r-project.org>:
>
> > This is an update on some current work on the C API for use in R
> > extensions.
> >
> > The internal R implementation makes use of tens of thousands of C
> > entry points. On Linux and Windows, which support visibility
> > restrictions, most of these are visible only within the R executble or
> > shared library. About 1500 are not hidden and are visible to
> > dynamically loaded shared libraries, such as ones in packages, and to
> > embedding applications.
> >
> > There are two main reasons for limiting access to entry points in a
> > software framework:
> >
> > - Some entry points are very easy to use in ways that corrupt internal
> >    data, leading to segfaults or, worse, incorrect computations without
> >    segfaults.
> >
> > - Some entry point expose internal structure and other implementation
> >    details, which makes it hard to make improvements without breaking
> >    client code that has come to depend on these details.
> >
> > The API of C entry points that can be used in R extensions, both for
> > packages and embedding, has evolved organically over many years. The
> > definition for the current release expressed in the Writing R
> > Extensions manual (WRE) is roughly:
> >
> >      An entry point can be used if (1) it is declared in a header file
> >      in R.home("include"), and (2) if it is documented for use in WRE.
> >
> > Ideally, (1) would be necessary and sufficient, but for a variety of
> > reasons that isn't achievable, at least not in the near term. (2) can
> > be challenging to determine; in particular, it is not amenable to a
> > computational answer.
> >
> > An experimental effort is underway to add annotations to the WRE
> > Texinfo source to allow (2) to be answered unambiguously. The
> > annotations so far mostly reflect my reading or WRE and may be revised
> > as they are reviewed by others. The annotated document can be used for
> > programmatically identifying what is currently considered part of the C
> > API. The result so far is an experimental function tools:::funAPI():
> >
> >      > head(tools:::funAPI())
> >                      name                    loc apitype
> >      1 Rf_AdobeSymbol2utf8 R_ext/GraphicsDevice.h    eapi
> >      2        alloc3DArray                    WRE     api
> >      3          allocArray                    WRE     api
> >      4           allocLang                    WRE     api
> >      5           allocList                    WRE     api
> >      6         allocMatrix                    WRE     api
> >
> > The 'apitype' field has three possible levels
> >
> >      | api  | stable (ideally) API |
> >      | eapi | experimental API     |
> >      | emb  | embedding API        |
> >
> > Entry points in the embedded API would typically only be used in
> > applications embedding R or providing new front ends, but might be
> > reasonable to use in packages that support embedding.
> >
> > The 'loc' field indicates how the entry point is identified as part of
> > an API: explicit mention in WRE, or declaration in a header file
> > identified as fully part of an API.
> >
> > [tools:::funAPI() may not be completely accurate as it relies on
> > regular expressions for examining header files considered part of the
> > API rather than proper parsing. But it seems to be pretty close to
> > what can be achieved with proper parsing.  Proper parsing would add
> > dependencies on additional tools, which I would like to avoid for
> > now. One dependency already present is that a C compiler has to be on
> > the search path and cc -E has to run the C pre-processor.]
> >
> > Two additional experimental functions are available for analyzing
> > package compliance: tools:::checkPkgAPI and tools:::checkAllPkgsAPI.
> > These examine installed packages.
> >
> > [These may produce some false positives on macOS; they may or may not
> > work on Windows at this point.]
> >
> > Using these tools initially showed around 200 non-API entry points
> > used across packages on CRAN and BIOC. Ideally this number should be
> > reduced to zero. This will require a combination of additions to the
> > API and changes in packages.
> >
> > Some entry points can safely be added to the API. Around 40 have
> > already been added to WRE with API annotations; another 40 or so can
> > probably be added after review.
> >
> > The remainder mostly fall into two groups:
> >
> > - Entry points that should never be used in packages, such as
> >    SET_OBJECT or SETLENGTH (or any non-API SETXYZ functions for that
> >    matter) that can create inconsistent or corrupt internal state.
> >
> > - Entry points that depend on the existence of internal structure that
> >    might be subject to change, such as the existence of promise objects
> >    or internal structure of environments.
> >
> > Many, if not most, of these seem to be used in idioms that can either
> > be accomplished with existing higher-level functions already in the
> > API, or by new higher level functions that can be created and
> > added. Working through these will take some time and coordination
> > between R-core and maintainers of affected packages.
> >
> > Once things have gelled a bit more I hope to turn this into a blog
> > post that will include some examples of moving non-API entry point
> > uses into compliance.
> >
> > Best,
> >
> > luke
> >
> > --
> > Luke Tierney
> > Ralph E. Wareham Professor of Mathematical Sciences
> > University of Iowa                  Phone:             319-335-3386
> > Department of Statistics and        Fax:               319-335-3017
> >     Actuarial Science
> > 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> > Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From ggrothend|eck @end|ng |rom gm@||@com  Mon Jun 10 03:40:12 2024
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Sun, 9 Jun 2024 21:40:12 -0400
Subject: [Rd] head.ts, tail.ts loses time
In-Reply-To: <016d5bb8-b0ee-47f0-91b2-7a2b8c51557d@prodsyse.com>
References: <016d5bb8-b0ee-47f0-91b2-7a2b8c51557d@prodsyse.com>
Message-ID: <CAP01uRmdPR_3M5qUnD8+4REw8Fz8sSf1UrrxzJFwQN+f1dx1xQ@mail.gmail.com>

zoo overcomes many of the limitations of ts:

  library(zoo)
  as.ts(head(as.zoo(presidents)))
  ##      Qtr1 Qtr2 Qtr3 Qtr4
  ## 1945   NA   87   82   75
  ## 1946   63   50

xts also works here.

On Sun, Jun 9, 2024 at 12:04?PM Spencer Graves
<spencer.graves at prodsyse.com> wrote:
>
> Hello, All:
>
>
>           The 'head' and 'tail' functions strip the time from a 'ts' object.
> Example:
>
>
>  > head(presidents)
> [1] NA 87 82 75 63 50
>
>
>  > window(presidents, 1945, 1946.25)
>       Qtr1 Qtr2 Qtr3 Qtr4
> 1945   NA   87   82   75
> 1946   63   50
>
>
>           Below please find code for 'head.ts' and 'tail.ts' that matches
> 'window'.
>
>
>           Comments?
>           Spencer Graves
>
> head.ts <- function(x, n=6L, ...){
>    tmx <- as.numeric(time(x))
> #
>    utils:::checkHT(n, d <- dim(x))
>    if(is.na(n[1]) || n[1]==0)ts(NULL)
> #
>    firstn <- head(tmx, n[1])
>    if(is.null(d)){
>      return(window(x, firstn[1], tail(firstn, 1)))
>    } else{
>      if(length(n)<2){
>        return(window(x, firstn[1], tail(firstn, 1)))
>      } else {
>        Cols <- head(1:d[2], n[2])
>        xn2 <- x[, Cols[1]:tail(Cols, 1)]
>        return(window(xn2, firstn[1], tail(firstn, 1)))
>      }
>    }
> }
>
>
> tail.ts <- function (x, n = 6L, ...)
> {
>    utils:::checkHT(n, d <- dim(x))
>    tmx <- as.numeric(time(x))
> #
>    if(is.na(n[1]) || n[1]==0)ts(NULL)
> #
>    lastn <- tail(tmx, n[1])
>    if(is.null(d)){
>      return(window(x, lastn[1], tail(lastn, 1)))
>    } else{
>      if(length(n)<2){
>        return(window(x, lastn[1], tail(lastn, 1)))
>      } else {
>        Cols <- head(1:d[2], n[2])
>        xn2 <- x[, Cols[1]:tail(Cols, 1)]
>        return(window(xn2, lastn[1], tail(lastn, 1)))
>      }
>    }
> }
>
>
> # examples
> head(presidents)
>
> head(presidents, 2)
>
> npresObs <- length(presidents)
> head(presidents, 6-npresObs)
>
> try(head(presidents, 1:2)) # 'try-error'
>
> try(head(presidents, 0)) # 'try-error'
>
> # matrix time series
> str(pres <- cbind(n=1:length(presidents), presidents))
> head(pres, 2)
>
> head(pres, 2-npresObs)
>
> head(pres, 1:2)
> head(pres, 2:1)
> head(pres, 1:3)
>
> # examples
> tail(presidents)
>
> tail(presidents, 2)
>
> npresObs <- length(presidents)
> tail(presidents, 6-npresObs)
>
> try(tail(presidents, 1:2)) # 'try-error'
>
> try(tail(presidents, 0)) # 'try-error'
>
> # matrix time series
> str(pres <- cbind(n=1:length(presidents), presidents))
> tail(pres, 2)
>
> tail(pres, 2-npresObs)
>
> tail(pres, 1:2)
> tail(pres, 2:1)
> tail(pres, 1:3)
>
> # for unit testing:
> headPres <- head(presidents)
> pres6 <- ts(presidents[1:6], time(presidents)[1],
>              frequency=frequency(presidents))
> stopifnot(all.equal(headPres, pres6))
>
> headPres2 <- head(presidents, 2)
> pres2 <- ts(presidents[1:2], time(presidents)[1],
>              frequency=frequency(presidents))
> stopifnot(all.equal(headPres2, pres2))
>
> npresObs <- length(presidents)
> headPres. <- head(presidents, 6-npresObs)
> stopifnot(all.equal(headPres., pres6))
>
> headPresOops <- try(head(presidents, 1:2))
> stopifnot(class(headPresOops) == 'try-error')
>
> headPres0 <- try(head(presidents, 0))
> stopifnot(class(headPres0) == 'try-error')
>
> str(pres <- cbind(n=1:length(presidents), presidents))
> headP2 <- head(pres, 2)
>
> p2 <- ts(pres[1:2, ], time(presidents)[1],
>           frequency=frequency(presidents))
> stopifnot(all.equal(headP2, p2))
>
> headP2. <- head(pres, 2-npresObs)
> stopifnot(all.equal(headP2., p2))
>
>
> #############
>
>
> sessionInfo()
> R version 4.4.0 (2024-04-24)
> Platform: aarch64-apple-darwin20
> Running under: macOS Sonoma 14.5
>
> Matrix products: default
> BLAS:
> /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
>
> LAPACK:
> /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;
>   LAPACK version 3.12.0
>
> locale:
> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
>
> time zone: America/Chicago
> tzcode source: internal
>
> attached base packages:
> [1] stats     graphics  grDevices utils     datasets
> [6] methods   base
>
> loaded via a namespace (and not attached):
> [1] compiler_4.4.0 tools_4.4.0
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From they||@n||u @end|ng |rom gm@||@com  Mon Jun 10 11:13:23 2024
From: they||@n||u @end|ng |rom gm@||@com (Yifan Liu)
Date: Mon, 10 Jun 2024 04:13:23 -0500
Subject: [Rd] summary() does not count missing characters
Message-ID: <CADdpgayq--ABABGMc17C3px3BDu3K9mPdbz526pkS_csw76feg@mail.gmail.com>

as.character(NA) |> rep(times = 10) |> summary()
vs.
as.numeric(NA) |> rep(times = 10) |> summary()
This feels inconsistent, doesn't it?

I constantly need to count missing characters in some data.frame columns.
It would be helpful if summary() can do that. Thanks.

Sincerely,

Yifan Liu

	[[alternative HTML version deleted]]


From @pencer@gr@ve@ @end|ng |rom prod@y@e@com  Mon Jun 10 14:50:13 2024
From: @pencer@gr@ve@ @end|ng |rom prod@y@e@com (Spencer Graves)
Date: Mon, 10 Jun 2024 07:50:13 -0500
Subject: [Rd] head.ts, tail.ts loses time
In-Reply-To: <CAP01uRmdPR_3M5qUnD8+4REw8Fz8sSf1UrrxzJFwQN+f1dx1xQ@mail.gmail.com>
References: <016d5bb8-b0ee-47f0-91b2-7a2b8c51557d@prodsyse.com>
 <CAP01uRmdPR_3M5qUnD8+4REw8Fz8sSf1UrrxzJFwQN+f1dx1xQ@mail.gmail.com>
Message-ID: <da0e13c2-d7d6-4f9e-b22e-c2b7392066e1@prodsyse.com>

Hi, Gabor et al.:


	  Thanks for this. I should change my current application to use either 
zoo or xts, as Gabor suggests.


	  However, I was surprised to learn that "[.ts" does NOT return an 
object of class "ts". I see that "head.default" and "head.matrix" both 
call "[", so "head" cannot return a ts object, because "[" doesn't.


	  Best Wishes,
	  Spencer Graves


On 6/9/24 8:40 PM, Gabor Grothendieck wrote:
> zoo overcomes many of the limitations of ts:
> 
>    library(zoo)
>    as.ts(head(as.zoo(presidents)))
>    ##      Qtr1 Qtr2 Qtr3 Qtr4
>    ## 1945   NA   87   82   75
>    ## 1946   63   50
> 
> xts also works here.
> 
> On Sun, Jun 9, 2024 at 12:04?PM Spencer Graves
> <spencer.graves at prodsyse.com> wrote:
>>
>> Hello, All:
>>
>>
>>            The 'head' and 'tail' functions strip the time from a 'ts' object.
>> Example:
>>
>>
>>   > head(presidents)
>> [1] NA 87 82 75 63 50
>>
>>
>>   > window(presidents, 1945, 1946.25)
>>        Qtr1 Qtr2 Qtr3 Qtr4
>> 1945   NA   87   82   75
>> 1946   63   50
>>
>>
>>            Below please find code for 'head.ts' and 'tail.ts' that matches
>> 'window'.
>>
>>
>>            Comments?
>>            Spencer Graves
>>
>> head.ts <- function(x, n=6L, ...){
>>     tmx <- as.numeric(time(x))
>> #
>>     utils:::checkHT(n, d <- dim(x))
>>     if(is.na(n[1]) || n[1]==0)ts(NULL)
>> #
>>     firstn <- head(tmx, n[1])
>>     if(is.null(d)){
>>       return(window(x, firstn[1], tail(firstn, 1)))
>>     } else{
>>       if(length(n)<2){
>>         return(window(x, firstn[1], tail(firstn, 1)))
>>       } else {
>>         Cols <- head(1:d[2], n[2])
>>         xn2 <- x[, Cols[1]:tail(Cols, 1)]
>>         return(window(xn2, firstn[1], tail(firstn, 1)))
>>       }
>>     }
>> }
>>
>>
>> tail.ts <- function (x, n = 6L, ...)
>> {
>>     utils:::checkHT(n, d <- dim(x))
>>     tmx <- as.numeric(time(x))
>> #
>>     if(is.na(n[1]) || n[1]==0)ts(NULL)
>> #
>>     lastn <- tail(tmx, n[1])
>>     if(is.null(d)){
>>       return(window(x, lastn[1], tail(lastn, 1)))
>>     } else{
>>       if(length(n)<2){
>>         return(window(x, lastn[1], tail(lastn, 1)))
>>       } else {
>>         Cols <- head(1:d[2], n[2])
>>         xn2 <- x[, Cols[1]:tail(Cols, 1)]
>>         return(window(xn2, lastn[1], tail(lastn, 1)))
>>       }
>>     }
>> }
>>
>>
>> # examples
>> head(presidents)
>>
>> head(presidents, 2)
>>
>> npresObs <- length(presidents)
>> head(presidents, 6-npresObs)
>>
>> try(head(presidents, 1:2)) # 'try-error'
>>
>> try(head(presidents, 0)) # 'try-error'
>>
>> # matrix time series
>> str(pres <- cbind(n=1:length(presidents), presidents))
>> head(pres, 2)
>>
>> head(pres, 2-npresObs)
>>
>> head(pres, 1:2)
>> head(pres, 2:1)
>> head(pres, 1:3)
>>
>> # examples
>> tail(presidents)
>>
>> tail(presidents, 2)
>>
>> npresObs <- length(presidents)
>> tail(presidents, 6-npresObs)
>>
>> try(tail(presidents, 1:2)) # 'try-error'
>>
>> try(tail(presidents, 0)) # 'try-error'
>>
>> # matrix time series
>> str(pres <- cbind(n=1:length(presidents), presidents))
>> tail(pres, 2)
>>
>> tail(pres, 2-npresObs)
>>
>> tail(pres, 1:2)
>> tail(pres, 2:1)
>> tail(pres, 1:3)
>>
>> # for unit testing:
>> headPres <- head(presidents)
>> pres6 <- ts(presidents[1:6], time(presidents)[1],
>>               frequency=frequency(presidents))
>> stopifnot(all.equal(headPres, pres6))
>>
>> headPres2 <- head(presidents, 2)
>> pres2 <- ts(presidents[1:2], time(presidents)[1],
>>               frequency=frequency(presidents))
>> stopifnot(all.equal(headPres2, pres2))
>>
>> npresObs <- length(presidents)
>> headPres. <- head(presidents, 6-npresObs)
>> stopifnot(all.equal(headPres., pres6))
>>
>> headPresOops <- try(head(presidents, 1:2))
>> stopifnot(class(headPresOops) == 'try-error')
>>
>> headPres0 <- try(head(presidents, 0))
>> stopifnot(class(headPres0) == 'try-error')
>>
>> str(pres <- cbind(n=1:length(presidents), presidents))
>> headP2 <- head(pres, 2)
>>
>> p2 <- ts(pres[1:2, ], time(presidents)[1],
>>            frequency=frequency(presidents))
>> stopifnot(all.equal(headP2, p2))
>>
>> headP2. <- head(pres, 2-npresObs)
>> stopifnot(all.equal(headP2., p2))
>>
>>
>> #############
>>
>>
>> sessionInfo()
>> R version 4.4.0 (2024-04-24)
>> Platform: aarch64-apple-darwin20
>> Running under: macOS Sonoma 14.5
>>
>> Matrix products: default
>> BLAS:
>> /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
>>
>> LAPACK:
>> /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;
>>    LAPACK version 3.12.0
>>
>> locale:
>> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
>>
>> time zone: America/Chicago
>> tzcode source: internal
>>
>> attached base packages:
>> [1] stats     graphics  grDevices utils     datasets
>> [6] methods   base
>>
>> loaded via a namespace (and not attached):
>> [1] compiler_4.4.0 tools_4.4.0
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> 
>


From j@g@nmn2 @end|ng |rom gm@||@com  Mon Jun 10 16:12:52 2024
From: j@g@nmn2 @end|ng |rom gm@||@com (Mikael Jagan)
Date: Mon, 10 Jun 2024 10:12:52 -0400
Subject: [Rd] changes in R-devel and zero-extent objects in Rcpp
In-Reply-To: <mailman.54329.3.1717927202.15503.r-devel@r-project.org>
References: <mailman.54329.3.1717927202.15503.r-devel@r-project.org>
Message-ID: <9694a015-e5be-4aa9-a5fe-bb0e6bb530cf@gmail.com>

     > Date: Sat, 8 Jun 2024 19:16:22 -0400
     > From: Ben Bolker <bbolker at gmail.com>
     >
     >     The ASAN errors occur *even if the zero-length object is not actually
     > accessed*/is used in a perfectly correct manner, i.e. it's perfectly
     > legal in base R to define `m <- numeric(0)` or `m <- matrix(nrow = 0,
     > ncol = 0)`, whereas doing the equivalent in Rcpp will (now) lead to an
     > ASAN error.
     >
     >     i.e., these are *not* previously cryptic out-of-bounds accesses that
     > are now being revealed, but instead sensible and previously legal
     > definitions of zero-length objects that are now causing problems.
     >

The ASan output is:

     > reference binding to misaligned address 0x000000000001 for type 'const 
double', which requires 8 byte alignment

That there is a "reference" to 0x1 means that there really _is_ an attempt to
access memory there.  The stack trace provided by ASan tells you exactly where
it happens: line 100 of
RcppEigen/inst/include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h:

     for(Index k2=0; k2<depth; k2+=kc)
     {
       const Index actual_kc = (std::min)(k2+kc,depth)-k2;


       // note that the actual rhs is the transpose/adjoint of mat
       pack_rhs(blockB, rhs.getSubMapper(k2,0), actual_kc, size);
                        ^^^^^^^^^^^^^^^^^^^^^^

where 'rhs' is an object wrapping the pointer with a method getSubMapper(i, j)
for accessing the data like a matrix.  In the first loop iteration, you access
rhs[0]; there is no defensive test for 'rhs' of positive length.

So ASan _is_ revealing an illegal access, complaining only now (since r86629)
because _now_ the address that you access illegally is misaligned.

This really should be avoided in lme4 and ideally reported to Eigen maintainers
if not already fixed there.

Mikael

     >      I'm pretty sure I'm right about this, but it's absolutely possible
     > that I'm just confused at this point; I don't have a super-simple
     > example to show you at the moment. The closest is this example by Mikael
     > Jagan: https://github.com/lme4/lme4/issues/794#issuecomment-2155093049
     >
     >     which shows that if x is a pointer to a zero-length vector (in plain
     > C++ for R, no Rcpp is involved), DATAPTR(x) and REAL(x) evaluate to
     > different values.
     >
     >     Mikael further points out that "Rcpp seems to cast a (void *)
     > returned by DATAPTR to (double *) when constructing a Vector<REALSXP>
     > from a SEXP, rather than using the (double *) returned by REAL." So
     > perhaps R-core doesn't want to guarantee that these operations give
     > identical answers, in which case Rcpp will have to change the way it
     > does things ...
     >
     >     cheers
     >      Ben
     >
     >
     >
     > On 2024-06-08 6:39 p.m., Kevin Ushey wrote:
     >    > IMHO, this should be changed in both Rcpp and downstream packages:
     >    >
     >    > 1. Rcpp could check for out-of-bounds accesses in cases like these, and
     >    > emit an R warning / error when such an access is detected;
     >    >
     >    > 2. The downstream packages unintentionally making these out-of-bounds
     >    > accesses should be fixed to avoid doing that.
     >    >
     >    > That is, I think this is ultimately a bug in the affected packages, but
     >    > Rcpp could do better in detecting and handling this for client packages
     >    > (avoiding a segfault).
     >    >
     >    > Best,
     >    > Kevin
     >    >
     >    >
     >    > On Sat, Jun 8, 2024, 3:06?PM Ben Bolker <bbolker at gmail.com
     >    > <mailto:bbolker at gmail.com>> wrote:
     >    >
     >    >
     >    >       ? ? A change to R-devel (SVN r86629 or
     >    > 
https://github.com/r-devel/r-svn/commit/92c1d5de23c93576f55062e26d446feface07250 
<https://github.com/r-devel/r-svn/commit/92c1d5de23c93576f55062e26d446feface07250>
     >    >      has changed the handling of pointers to zero-length objects, 
leading to
     >    >      ASAN issues with a number of Rcpp-based packages (the commit 
message
     >    >      reads, in part, "Also define STRICT_TYPECHECK when compiling
     >    >      inlined.c.")
     >    >
     >    >       ? ?I'm interested in discussion from the community.
     >    >
     >    >       ? ?Details/diagnosis for the issues in the lme4 package are here:
     >    >      https://github.com/lme4/lme4/issues/794
     >    >      <https://github.com/lme4/lme4/issues/794>, with a bit more 
discussion
     >    >      about how zero-length objects should be handled.
     >    >
     >    >       ? ?The short(ish) version is that r86629 enables the
     >    >      CATCH_ZERO_LENGTH_ACCESS definition. This turns on the CHKZLN macro
     >    > 
<https://github.com/r-devel/r-svn/blob/4ef83b9dc3c6874e774195d329cbb6c11a71c414/src/main/memory.c#L4090-L4104 
<https://github.com/r-devel/r-svn/blob/4ef83b9dc3c6874e774195d329cbb6c11a71c414/src/main/memory.c#L4090-L4104>>,
     >    >      which returns a trivial pointer (rather than the data pointer that
     >    >      would
     >    >      be returned in the normal control flow) if an object has length 0:
     >    >
     >    >      /* Attempts to read or write elements of a zero length vector will
     >    >       ? ? result in a segfault, rather than read and write random 
memory.
     >    >       ? ? Returning NULL would be more natural, but Matrix seems to 
assume
     >    >       ? ? that even zero-length vectors have non-NULL data pointers, so
     >    >       ? ? return (void *) 1 instead. Zero-length CHARSXP objects 
still have a
     >    >       ? ? trailing zero byte so they are not handled. */
     >    >
     >    >       ? ?In the Rcpp context this leads to an inconsistency, where 
`REAL(x)`
     >    >      is a 'real' external pointer and `DATAPTR(x)` is 0x1, which in turn
     >    >      leads to ASAN warnings like
     >    >
     >    >      runtime error: reference binding to misaligned address 
0x000000000001
     >    >      for type 'const double', which requires 8 byte alignment
     >    >      0x000000000001: note: pointer points here
     >    >
     >    >       ? ? I'm in over my head and hoping for insight into whether this
     >    >      problem
     >    >      should be resolved by changing R, Rcpp, or downstream Rcpp 
packages ...
     >    >
     >    >       ? ?cheers
     >    >       ? ? Ben Bolker


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Mon Jun 10 16:32:17 2024
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Mon, 10 Jun 2024 16:32:17 +0200
Subject: [Rd] head.ts, tail.ts loses time
In-Reply-To: <da0e13c2-d7d6-4f9e-b22e-c2b7392066e1@prodsyse.com>
References: <016d5bb8-b0ee-47f0-91b2-7a2b8c51557d@prodsyse.com>
 <CAP01uRmdPR_3M5qUnD8+4REw8Fz8sSf1UrrxzJFwQN+f1dx1xQ@mail.gmail.com>
 <da0e13c2-d7d6-4f9e-b22e-c2b7392066e1@prodsyse.com>
Message-ID: <26215.3697.815212.54251@stat.math.ethz.ch>

>>>>> Spencer Graves 
>>>>>     on Mon, 10 Jun 2024 07:50:13 -0500 writes:

    > Hi, Gabor et al.: Thanks for this. I should change my
    > current application to use either zoo or xts, as Gabor
    > suggests.


    > 	  However, I was surprised to learn that "[.ts" does NOT
    > return an object of class "ts". I see that "head.default"
    > and "head.matrix" both call "[", so "head" cannot return a
    > ts object, because "[" doesn't.

Yes, the default head() and tail() are built on  `[` very much
on purpose.
Note that   `[`  should *not* keep the "ts"  property  in
general, e.g.,  
	 lynx[c(1:3, 7)]
cannot be a regular time series 

I think I'd consider using  windows() for a head.ts() and tail.ts(),
but in any case, I am sympathetic adding such methods to "base R"'s
utils package.


Martin

    > 	  Best Wishes, Spencer Graves


    > On 6/9/24 8:40 PM, Gabor Grothendieck wrote:
    >> zoo overcomes many of the limitations of ts:
    >> 
    >> library(zoo) as.ts(head(as.zoo(presidents))) ## Qtr1 Qtr2
    >> Qtr3 Qtr4 ## 1945 NA 87 82 75 ## 1946 63 50
    >> 
    >> xts also works here.
    >> 
    >> On Sun, Jun 9, 2024 at 12:04?PM Spencer Graves
    >> <spencer.graves at prodsyse.com> wrote:
    >>> 
    >>> Hello, All:
    >>> 
    >>> 
    >>> The 'head' and 'tail' functions strip the time from a
    >>> 'ts' object.  Example:
    >>> 
    >>> 
    >>> > head(presidents) [1] NA 87 82 75 63 50
    >>> 
    >>> 
    >>> > window(presidents, 1945, 1946.25) Qtr1 Qtr2 Qtr3 Qtr4
    >>> 1945 NA 87 82 75 1946 63 50
    >>> 
    >>> 
    >>> Below please find code for 'head.ts' and 'tail.ts' that
    >>> matches 'window'.
    >>> 
    >>> 
    >>> Comments?  Spencer Graves
    >>> 
    >>> head.ts <- function(x, n=6L, ...){ tmx <-
    >>> as.numeric(time(x))
    >>> #
    >>> utils:::checkHT(n, d <- dim(x)) if(is.na(n[1]) ||
    >>> n[1]==0)ts(NULL)
    >>> #
    >>> firstn <- head(tmx, n[1]) if(is.null(d)){
    >>> return(window(x, firstn[1], tail(firstn, 1))) } else{
    >>> if(length(n)<2){ return(window(x, firstn[1],
    >>> tail(firstn, 1))) } else { Cols <- head(1:d[2], n[2])
    >>> xn2 <- x[, Cols[1]:tail(Cols, 1)] return(window(xn2,
    >>> firstn[1], tail(firstn, 1))) } } }
    >>> 
    >>> 
    >>> tail.ts <- function (x, n = 6L, ...)  {
    >>> utils:::checkHT(n, d <- dim(x)) tmx <-
    >>> as.numeric(time(x))
    >>> #
    >>> if(is.na(n[1]) || n[1]==0)ts(NULL)
    >>> #
    >>> lastn <- tail(tmx, n[1]) if(is.null(d)){
    >>> return(window(x, lastn[1], tail(lastn, 1))) } else{
    >>> if(length(n)<2){ return(window(x, lastn[1], tail(lastn,
    >>> 1))) } else { Cols <- head(1:d[2], n[2]) xn2 <- x[,
    >>> Cols[1]:tail(Cols, 1)] return(window(xn2, lastn[1],
    >>> tail(lastn, 1))) } } }
    >>> 
    >>> 
    >>> # examples head(presidents)
    >>> 
    >>> head(presidents, 2)
    >>> 
    >>> npresObs <- length(presidents) head(presidents,
    >>> 6-npresObs)
    >>> 
    >>> try(head(presidents, 1:2)) # 'try-error'
    >>> 
    >>> try(head(presidents, 0)) # 'try-error'
    >>> 
    >>> # matrix time series str(pres <-
    >>> cbind(n=1:length(presidents), presidents)) head(pres, 2)
    >>> 
    >>> head(pres, 2-npresObs)
    >>> 
    >>> head(pres, 1:2) head(pres, 2:1) head(pres, 1:3)
    >>> 
    >>> # examples tail(presidents)
    >>> 
    >>> tail(presidents, 2)
    >>> 
    >>> npresObs <- length(presidents) tail(presidents,
    >>> 6-npresObs)
    >>> 
    >>> try(tail(presidents, 1:2)) # 'try-error'
    >>> 
    >>> try(tail(presidents, 0)) # 'try-error'
    >>> 
    >>> # matrix time series str(pres <-
    >>> cbind(n=1:length(presidents), presidents)) tail(pres, 2)
    >>> 
    >>> tail(pres, 2-npresObs)
    >>> 
    >>> tail(pres, 1:2) tail(pres, 2:1) tail(pres, 1:3)
    >>> 
    >>> # for unit testing: headPres <- head(presidents) pres6
    >>> <- ts(presidents[1:6], time(presidents)[1],
    >>> frequency=frequency(presidents))
    >>> stopifnot(all.equal(headPres, pres6))
    >>> 
    >>> headPres2 <- head(presidents, 2) pres2 <-
    >>> ts(presidents[1:2], time(presidents)[1],
    >>> frequency=frequency(presidents))
    >>> stopifnot(all.equal(headPres2, pres2))
    >>> 
    >>> npresObs <- length(presidents) headPres. <-
    >>> head(presidents, 6-npresObs)
    >>> stopifnot(all.equal(headPres., pres6))
    >>> 
    >>> headPresOops <- try(head(presidents, 1:2))
    >>> stopifnot(class(headPresOops) == 'try-error')
    >>> 
    >>> headPres0 <- try(head(presidents, 0))
    >>> stopifnot(class(headPres0) == 'try-error')
    >>> 
    >>> str(pres <- cbind(n=1:length(presidents), presidents))
    >>> headP2 <- head(pres, 2)
    >>> 
    >>> p2 <- ts(pres[1:2, ], time(presidents)[1],
    >>> frequency=frequency(presidents))
    >>> stopifnot(all.equal(headP2, p2))
    >>> 
    >>> headP2. <- head(pres, 2-npresObs)
    >>> stopifnot(all.equal(headP2., p2))
    >>> 
    >>> 
    >>> #############
    >>> 
    >>> 
    >>> sessionInfo() R version 4.4.0 (2024-04-24) Platform:
    >>> aarch64-apple-darwin20 Running under: macOS Sonoma 14.5
    >>> 
    >>> Matrix products: default BLAS:
    >>> /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
    >>> 
    >>> LAPACK:
    >>> /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;
    >>> LAPACK version 3.12.0
    >>> 
    >>> locale: [1]
    >>> en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
    >>> 
    >>> time zone: America/Chicago tzcode source: internal
    >>> 
    >>> attached base packages: [1] stats graphics grDevices
    >>> utils datasets [6] methods base
    >>> 
    >>> loaded via a namespace (and not attached): [1]
    >>> compiler_4.4.0 tools_4.4.0
    >>> 
    >>> ______________________________________________
    >>> R-devel at r-project.org mailing list
    >>> https://stat.ethz.ch/mailman/listinfo/r-devel
    >> 
    >> 
    >> 

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From @pencer@gr@ve@ @end|ng |rom prod@y@e@com  Mon Jun 10 16:45:46 2024
From: @pencer@gr@ve@ @end|ng |rom prod@y@e@com (Spencer Graves)
Date: Mon, 10 Jun 2024 09:45:46 -0500
Subject: [Rd] head.ts, tail.ts loses time
In-Reply-To: <26215.3697.815212.54251@stat.math.ethz.ch>
References: <016d5bb8-b0ee-47f0-91b2-7a2b8c51557d@prodsyse.com>
 <CAP01uRmdPR_3M5qUnD8+4REw8Fz8sSf1UrrxzJFwQN+f1dx1xQ@mail.gmail.com>
 <da0e13c2-d7d6-4f9e-b22e-c2b7392066e1@prodsyse.com>
 <26215.3697.815212.54251@stat.math.ethz.ch>
Message-ID: <295e6967-6ea6-4334-a43d-58c18ef7fcfd@prodsyse.com>

Hi, Martin et al.:


On 6/10/24 9:32 AM, Martin Maechler wrote:
>>>>>> Spencer Graves
>>>>>>      on Mon, 10 Jun 2024 07:50:13 -0500 writes:
> 
>      > Hi, Gabor et al.: Thanks for this. I should change my
>      > current application to use either zoo or xts, as Gabor
>      > suggests.
> 
> 
>      > 	  However, I was surprised to learn that "[.ts" does NOT
>      > return an object of class "ts". I see that "head.default"
>      > and "head.matrix" both call "[", so "head" cannot return a
>      > ts object, because "[" doesn't.
> 
> Yes, the default head() and tail() are built on  `[` very much
> on purpose.
> Note that   `[`  should *not* keep the "ts"  property  in
> general, e.g.,
> 	 lynx[c(1:3, 7)]
> cannot be a regular time series


	  Agreed.

> 
> I think I'd consider using  windows() for a head.ts() and tail.ts(),
> but in any case, I am sympathetic adding such methods to "base R"'s
> utils package.


	  The code I provided below for head.ts() and tail.ts() does that: I 
took the code for head.default and head.matrix, etc., computed tmx <- 
as.numeric(time(x)), and then used head(tmx) [and tail(tmx)] in "window()".


	  Thanks for your reply.
	  sg
> 
> 
> Martin
> 
>      > 	  Best Wishes, Spencer Graves
> 
> 
>      > On 6/9/24 8:40 PM, Gabor Grothendieck wrote:
>      >> zoo overcomes many of the limitations of ts:
>      >>
>      >> library(zoo) as.ts(head(as.zoo(presidents))) ## Qtr1 Qtr2
>      >> Qtr3 Qtr4 ## 1945 NA 87 82 75 ## 1946 63 50
>      >>
>      >> xts also works here.
>      >>
>      >> On Sun, Jun 9, 2024 at 12:04?PM Spencer Graves
>      >> <spencer.graves at prodsyse.com> wrote:
>      >>>
>      >>> Hello, All:
>      >>>
>      >>>
>      >>> The 'head' and 'tail' functions strip the time from a
>      >>> 'ts' object.  Example:
>      >>>
>      >>>
>      >>> > head(presidents) [1] NA 87 82 75 63 50
>      >>>
>      >>>
>      >>> > window(presidents, 1945, 1946.25) Qtr1 Qtr2 Qtr3 Qtr4
>      >>> 1945 NA 87 82 75 1946 63 50
>      >>>
>      >>>
>      >>> Below please find code for 'head.ts' and 'tail.ts' that
>      >>> matches 'window'.
>      >>>
>      >>>
>      >>> Comments?  Spencer Graves
>      >>>
>      >>> head.ts <- function(x, n=6L, ...){ tmx <-
>      >>> as.numeric(time(x))
>      >>> #
>      >>> utils:::checkHT(n, d <- dim(x)) if(is.na(n[1]) ||
>      >>> n[1]==0)ts(NULL)
>      >>> #
>      >>> firstn <- head(tmx, n[1]) if(is.null(d)){
>      >>> return(window(x, firstn[1], tail(firstn, 1))) } else{
>      >>> if(length(n)<2){ return(window(x, firstn[1],
>      >>> tail(firstn, 1))) } else { Cols <- head(1:d[2], n[2])
>      >>> xn2 <- x[, Cols[1]:tail(Cols, 1)] return(window(xn2,
>      >>> firstn[1], tail(firstn, 1))) } } }
>      >>>
>      >>>
>      >>> tail.ts <- function (x, n = 6L, ...)  {
>      >>> utils:::checkHT(n, d <- dim(x)) tmx <-
>      >>> as.numeric(time(x))
>      >>> #
>      >>> if(is.na(n[1]) || n[1]==0)ts(NULL)
>      >>> #
>      >>> lastn <- tail(tmx, n[1]) if(is.null(d)){
>      >>> return(window(x, lastn[1], tail(lastn, 1))) } else{
>      >>> if(length(n)<2){ return(window(x, lastn[1], tail(lastn,
>      >>> 1))) } else { Cols <- head(1:d[2], n[2]) xn2 <- x[,
>      >>> Cols[1]:tail(Cols, 1)] return(window(xn2, lastn[1],
>      >>> tail(lastn, 1))) } } }
>      >>>
>      >>>
>      >>> # examples head(presidents)
>      >>>
>      >>> head(presidents, 2)
>      >>>
>      >>> npresObs <- length(presidents) head(presidents,
>      >>> 6-npresObs)
>      >>>
>      >>> try(head(presidents, 1:2)) # 'try-error'
>      >>>
>      >>> try(head(presidents, 0)) # 'try-error'
>      >>>
>      >>> # matrix time series str(pres <-
>      >>> cbind(n=1:length(presidents), presidents)) head(pres, 2)
>      >>>
>      >>> head(pres, 2-npresObs)
>      >>>
>      >>> head(pres, 1:2) head(pres, 2:1) head(pres, 1:3)
>      >>>
>      >>> # examples tail(presidents)
>      >>>
>      >>> tail(presidents, 2)
>      >>>
>      >>> npresObs <- length(presidents) tail(presidents,
>      >>> 6-npresObs)
>      >>>
>      >>> try(tail(presidents, 1:2)) # 'try-error'
>      >>>
>      >>> try(tail(presidents, 0)) # 'try-error'
>      >>>
>      >>> # matrix time series str(pres <-
>      >>> cbind(n=1:length(presidents), presidents)) tail(pres, 2)
>      >>>
>      >>> tail(pres, 2-npresObs)
>      >>>
>      >>> tail(pres, 1:2) tail(pres, 2:1) tail(pres, 1:3)
>      >>>
>      >>> # for unit testing: headPres <- head(presidents) pres6
>      >>> <- ts(presidents[1:6], time(presidents)[1],
>      >>> frequency=frequency(presidents))
>      >>> stopifnot(all.equal(headPres, pres6))
>      >>>
>      >>> headPres2 <- head(presidents, 2) pres2 <-
>      >>> ts(presidents[1:2], time(presidents)[1],
>      >>> frequency=frequency(presidents))
>      >>> stopifnot(all.equal(headPres2, pres2))
>      >>>
>      >>> npresObs <- length(presidents) headPres. <-
>      >>> head(presidents, 6-npresObs)
>      >>> stopifnot(all.equal(headPres., pres6))
>      >>>
>      >>> headPresOops <- try(head(presidents, 1:2))
>      >>> stopifnot(class(headPresOops) == 'try-error')
>      >>>
>      >>> headPres0 <- try(head(presidents, 0))
>      >>> stopifnot(class(headPres0) == 'try-error')
>      >>>
>      >>> str(pres <- cbind(n=1:length(presidents), presidents))
>      >>> headP2 <- head(pres, 2)
>      >>>
>      >>> p2 <- ts(pres[1:2, ], time(presidents)[1],
>      >>> frequency=frequency(presidents))
>      >>> stopifnot(all.equal(headP2, p2))
>      >>>
>      >>> headP2. <- head(pres, 2-npresObs)
>      >>> stopifnot(all.equal(headP2., p2))
>      >>>
>      >>>
>      >>> #############
>      >>>
>      >>>
>      >>> sessionInfo() R version 4.4.0 (2024-04-24) Platform:
>      >>> aarch64-apple-darwin20 Running under: macOS Sonoma 14.5
>      >>>
>      >>> Matrix products: default BLAS:
>      >>> /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
>      >>>
>      >>> LAPACK:
>      >>> /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;
>      >>> LAPACK version 3.12.0
>      >>>
>      >>> locale: [1]
>      >>> en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
>      >>>
>      >>> time zone: America/Chicago tzcode source: internal
>      >>>
>      >>> attached base packages: [1] stats graphics grDevices
>      >>> utils datasets [6] methods base
>      >>>
>      >>> loaded via a namespace (and not attached): [1]
>      >>> compiler_4.4.0 tools_4.4.0
>      >>>
>      >>> ______________________________________________
>      >>> R-devel at r-project.org mailing list
>      >>> https://stat.ethz.ch/mailman/listinfo/r-devel
>      >>
>      >>
>      >>
> 
>      > ______________________________________________
>      > R-devel at r-project.org mailing list
>      > https://stat.ethz.ch/mailman/listinfo/r-devel


From bbo|ker @end|ng |rom gm@||@com  Mon Jun 10 17:02:38 2024
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Mon, 10 Jun 2024 11:02:38 -0400
Subject: [Rd] changes in R-devel and zero-extent objects in Rcpp
In-Reply-To: <9694a015-e5be-4aa9-a5fe-bb0e6bb530cf@gmail.com>
References: <mailman.54329.3.1717927202.15503.r-devel@r-project.org>
 <9694a015-e5be-4aa9-a5fe-bb0e6bb530cf@gmail.com>
Message-ID: <09e1f687-3973-4673-a393-ad6d0060a46c@gmail.com>

   Thanks, that's very useful.

   AFAICT, in the problematic case we are doing some linear algebra with 
zero-column matrices that are mathematically well-defined (and whose 
base-R equivalents work correctly). It's maybe not surprising that 
Eigen/RcppEigen would do some weird stuff in this edge case.  I'll see 
if I can come up with some pure RcppEigen/Eigen examples to illustrate 
the problem ...

   cheers
    Ben



On 2024-06-10 10:12 a.m., Mikael Jagan wrote:
> 
> The ASan output is:
> 
>  ??? > reference binding to misaligned address 0x000000000001 for type 
> 'const double', which requires 8 byte alignment
> 
> That there is a "reference" to 0x1 means that there really _is_ an 
> attempt to
> access memory there.? The stack trace provided by ASan tells you exactly 
> where
> it happens: line 100 of
> RcppEigen/inst/include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h:
> 
>  ??? for(Index k2=0; k2<depth; k2+=kc)
>  ??? {
>  ????? const Index actual_kc = (std::min)(k2+kc,depth)-k2;
> 
> 
>  ????? // note that the actual rhs is the transpose/adjoint of mat
>  ????? pack_rhs(blockB, rhs.getSubMapper(k2,0), actual_kc, size);
>  ?????????????????????? ^^^^^^^^^^^^^^^^^^^^^^
> 
> where 'rhs' is an object wrapping the pointer with a method 
> getSubMapper(i, j)
> for accessing the data like a matrix.? In the first loop iteration, you 
> access
> rhs[0]; there is no defensive test for 'rhs' of positive length.
> 
> So ASan _is_ revealing an illegal access, complaining only now (since 
> r86629)
> because _now_ the address that you access illegally is misaligned.

-- 
Dr. Benjamin Bolker
Professor, Mathematics & Statistics and Biology, McMaster University
Director, School of Computational Science and Engineering
(Acting) Graduate chair, Mathematics & Statistics
 > E-mail is sent at my convenience; I don't expect replies outside of 
working hours.


From ggrothend|eck @end|ng |rom gm@||@com  Tue Jun 11 15:13:49 2024
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Tue, 11 Jun 2024 09:13:49 -0400
Subject: [Rd] head.ts, tail.ts loses time
In-Reply-To: <26215.3697.815212.54251@stat.math.ethz.ch>
References: <016d5bb8-b0ee-47f0-91b2-7a2b8c51557d@prodsyse.com>
 <CAP01uRmdPR_3M5qUnD8+4REw8Fz8sSf1UrrxzJFwQN+f1dx1xQ@mail.gmail.com>
 <da0e13c2-d7d6-4f9e-b22e-c2b7392066e1@prodsyse.com>
 <26215.3697.815212.54251@stat.math.ethz.ch>
Message-ID: <CAP01uRkHWsQrELjRDU7MR9XtXgghT5VM0vnQmrE=pOa-mqSBhQ@mail.gmail.com>

It isn't really clear that it can't work.  This does work by inserting NA's.

  library(zoo)
  as.ts(as.zoo(lynx)[ c(1:3, 7) ] )
  ## Time Series:
  ## Start = 1821
  ## End = 1827
  ## Frequency = 1
  ## [1]  269  321  585   NA   NA   NA 3928


On Mon, Jun 10, 2024 at 10:32?AM Martin Maechler
<maechler at stat.math.ethz.ch> wrote:
>
> >>>>> Spencer Graves
> >>>>>     on Mon, 10 Jun 2024 07:50:13 -0500 writes:
>
>     > Hi, Gabor et al.: Thanks for this. I should change my
>     > current application to use either zoo or xts, as Gabor
>     > suggests.
>
>
>     >     However, I was surprised to learn that "[.ts" does NOT
>     > return an object of class "ts". I see that "head.default"
>     > and "head.matrix" both call "[", so "head" cannot return a
>     > ts object, because "[" doesn't.
>
> Yes, the default head() and tail() are built on  `[` very much
> on purpose.
> Note that   `[`  should *not* keep the "ts"  property  in
> general, e.g.,
>          lynx[c(1:3, 7)]
> cannot be a regular time series
>
> I think I'd consider using  windows() for a head.ts() and tail.ts(),
> but in any case, I am sympathetic adding such methods to "base R"'s
> utils package.
>
>
> Martin
>
>     >     Best Wishes, Spencer Graves
>
>
>     > On 6/9/24 8:40 PM, Gabor Grothendieck wrote:
>     >> zoo overcomes many of the limitations of ts:
>     >>
>     >> library(zoo) as.ts(head(as.zoo(presidents))) ## Qtr1 Qtr2
>     >> Qtr3 Qtr4 ## 1945 NA 87 82 75 ## 1946 63 50
>     >>
>     >> xts also works here.
>     >>
>     >> On Sun, Jun 9, 2024 at 12:04?PM Spencer Graves
>     >> <spencer.graves at prodsyse.com> wrote:
>     >>>
>     >>> Hello, All:
>     >>>
>     >>>
>     >>> The 'head' and 'tail' functions strip the time from a
>     >>> 'ts' object.  Example:
>     >>>
>     >>>
>     >>> > head(presidents) [1] NA 87 82 75 63 50
>     >>>
>     >>>
>     >>> > window(presidents, 1945, 1946.25) Qtr1 Qtr2 Qtr3 Qtr4
>     >>> 1945 NA 87 82 75 1946 63 50
>     >>>
>     >>>
>     >>> Below please find code for 'head.ts' and 'tail.ts' that
>     >>> matches 'window'.
>     >>>
>     >>>
>     >>> Comments?  Spencer Graves
>     >>>
>     >>> head.ts <- function(x, n=6L, ...){ tmx <-
>     >>> as.numeric(time(x))
>     >>> #
>     >>> utils:::checkHT(n, d <- dim(x)) if(is.na(n[1]) ||
>     >>> n[1]==0)ts(NULL)
>     >>> #
>     >>> firstn <- head(tmx, n[1]) if(is.null(d)){
>     >>> return(window(x, firstn[1], tail(firstn, 1))) } else{
>     >>> if(length(n)<2){ return(window(x, firstn[1],
>     >>> tail(firstn, 1))) } else { Cols <- head(1:d[2], n[2])
>     >>> xn2 <- x[, Cols[1]:tail(Cols, 1)] return(window(xn2,
>     >>> firstn[1], tail(firstn, 1))) } } }
>     >>>
>     >>>
>     >>> tail.ts <- function (x, n = 6L, ...)  {
>     >>> utils:::checkHT(n, d <- dim(x)) tmx <-
>     >>> as.numeric(time(x))
>     >>> #
>     >>> if(is.na(n[1]) || n[1]==0)ts(NULL)
>     >>> #
>     >>> lastn <- tail(tmx, n[1]) if(is.null(d)){
>     >>> return(window(x, lastn[1], tail(lastn, 1))) } else{
>     >>> if(length(n)<2){ return(window(x, lastn[1], tail(lastn,
>     >>> 1))) } else { Cols <- head(1:d[2], n[2]) xn2 <- x[,
>     >>> Cols[1]:tail(Cols, 1)] return(window(xn2, lastn[1],
>     >>> tail(lastn, 1))) } } }
>     >>>
>     >>>
>     >>> # examples head(presidents)
>     >>>
>     >>> head(presidents, 2)
>     >>>
>     >>> npresObs <- length(presidents) head(presidents,
>     >>> 6-npresObs)
>     >>>
>     >>> try(head(presidents, 1:2)) # 'try-error'
>     >>>
>     >>> try(head(presidents, 0)) # 'try-error'
>     >>>
>     >>> # matrix time series str(pres <-
>     >>> cbind(n=1:length(presidents), presidents)) head(pres, 2)
>     >>>
>     >>> head(pres, 2-npresObs)
>     >>>
>     >>> head(pres, 1:2) head(pres, 2:1) head(pres, 1:3)
>     >>>
>     >>> # examples tail(presidents)
>     >>>
>     >>> tail(presidents, 2)
>     >>>
>     >>> npresObs <- length(presidents) tail(presidents,
>     >>> 6-npresObs)
>     >>>
>     >>> try(tail(presidents, 1:2)) # 'try-error'
>     >>>
>     >>> try(tail(presidents, 0)) # 'try-error'
>     >>>
>     >>> # matrix time series str(pres <-
>     >>> cbind(n=1:length(presidents), presidents)) tail(pres, 2)
>     >>>
>     >>> tail(pres, 2-npresObs)
>     >>>
>     >>> tail(pres, 1:2) tail(pres, 2:1) tail(pres, 1:3)
>     >>>
>     >>> # for unit testing: headPres <- head(presidents) pres6
>     >>> <- ts(presidents[1:6], time(presidents)[1],
>     >>> frequency=frequency(presidents))
>     >>> stopifnot(all.equal(headPres, pres6))
>     >>>
>     >>> headPres2 <- head(presidents, 2) pres2 <-
>     >>> ts(presidents[1:2], time(presidents)[1],
>     >>> frequency=frequency(presidents))
>     >>> stopifnot(all.equal(headPres2, pres2))
>     >>>
>     >>> npresObs <- length(presidents) headPres. <-
>     >>> head(presidents, 6-npresObs)
>     >>> stopifnot(all.equal(headPres., pres6))
>     >>>
>     >>> headPresOops <- try(head(presidents, 1:2))
>     >>> stopifnot(class(headPresOops) == 'try-error')
>     >>>
>     >>> headPres0 <- try(head(presidents, 0))
>     >>> stopifnot(class(headPres0) == 'try-error')
>     >>>
>     >>> str(pres <- cbind(n=1:length(presidents), presidents))
>     >>> headP2 <- head(pres, 2)
>     >>>
>     >>> p2 <- ts(pres[1:2, ], time(presidents)[1],
>     >>> frequency=frequency(presidents))
>     >>> stopifnot(all.equal(headP2, p2))
>     >>>
>     >>> headP2. <- head(pres, 2-npresObs)
>     >>> stopifnot(all.equal(headP2., p2))
>     >>>
>     >>>
>     >>> #############
>     >>>
>     >>>
>     >>> sessionInfo() R version 4.4.0 (2024-04-24) Platform:
>     >>> aarch64-apple-darwin20 Running under: macOS Sonoma 14.5
>     >>>
>     >>> Matrix products: default BLAS:
>     >>> /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
>     >>>
>     >>> LAPACK:
>     >>> /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;
>     >>> LAPACK version 3.12.0
>     >>>
>     >>> locale: [1]
>     >>> en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
>     >>>
>     >>> time zone: America/Chicago tzcode source: internal
>     >>>
>     >>> attached base packages: [1] stats graphics grDevices
>     >>> utils datasets [6] methods base
>     >>>
>     >>> loaded via a namespace (and not attached): [1]
>     >>> compiler_4.4.0 tools_4.4.0
>     >>>
>     >>> ______________________________________________
>     >>> R-devel at r-project.org mailing list
>     >>> https://stat.ethz.ch/mailman/listinfo/r-devel
>     >>
>     >>
>     >>
>
>     > ______________________________________________
>     > R-devel at r-project.org mailing list
>     > https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From Kurt@Horn|k @end|ng |rom wu@@c@@t  Wed Jun 12 16:35:31 2024
From: Kurt@Horn|k @end|ng |rom wu@@c@@t (Kurt Hornik)
Date: Wed, 12 Jun 2024 16:35:31 +0200
Subject: [Rd] Fields used by available.packages
In-Reply-To: <CAN+W6_vcvA4Gr9BUenydQOmt4HQSrTzNuNUyirFkbYN30vM-zA@mail.gmail.com>
References: <CAN+W6_vcvA4Gr9BUenydQOmt4HQSrTzNuNUyirFkbYN30vM-zA@mail.gmail.com>
Message-ID: <26217.45619.441769.623342@hornik.net>

>>>>> Llu?s Revilla writes:

Lluis,

So in available.packages() I could replace

    if (is.null(fields))
	fields <- requiredFields
    else {
	stopifnot(is.character(fields))
	fields <- unique(c(requiredFields, fields))
    }

by someting like

    if(is.null(fields))
        fields <- getOption("available_packages_fields")
    if(is.null(fields))
        fields <- requiredFields
    else {
	stopifnot(is.character(fields))
	fields <- unique(c(requiredFields, fields))
    }

?

Best
-k



> Hi all,
> I have recently been researching how available.packages and
> install.packages filter packages from repositories with additional fields
> in their PACKAGES file.

> Currently there are some default filters, but users (and R admins) can set
> up their own filters by passing a list to the fields argument or adding
> them to the "available_packages_filters" option.
> But if the fields used by the filters are not read by default, then users
> must manually add the required fields to each call to available.packages.

> This makes it difficult to use new fields and to control what is installed
> in highly regulated systems which want to use more fields to select what is
> installed.

> Current workarounds considered are:
>  1) The filtering function requiring new fields intercepts the call to
> available.packages and adds the desired fields via eval in
> parent.environment and then adds the filters again.
>  2) Import new data (remote or local) when filtering packages, merge them
> and filter accordingly.
>  3) Suggestions?

> The first solution is complicated, while the second doesn't use the R
> machinery of tools::write_PACKAGES to set up the repository with all the
> fields (although how to add more fields to the repository file is a
> different issue).

> Would it be possible to add a new option to add fields to be read by
> available.packages, similar to filters?
> The same approach for fields as for filters would avoid the two workarounds
> mentioned. To match it, the new option could be named
> "available_packages_fields".

> I look forward to hearing from you,

> Llu?s

> 	[[alternative HTML version deleted]]

> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From ||u|@@rev|||@ @end|ng |rom gm@||@com  Wed Jun 12 16:47:31 2024
From: ||u|@@rev|||@ @end|ng |rom gm@||@com (=?UTF-8?Q?Llu=C3=ADs_Revilla?=)
Date: Wed, 12 Jun 2024 16:47:31 +0200
Subject: [Rd] Fields used by available.packages
In-Reply-To: <26217.45619.441769.623342@hornik.net>
References: <CAN+W6_vcvA4Gr9BUenydQOmt4HQSrTzNuNUyirFkbYN30vM-zA@mail.gmail.com>
 <26217.45619.441769.623342@hornik.net>
Message-ID: <CAN+W6_um=SYDgRkTrJsVj80=K-4EXf-ckJ=xa2=v24gDrx37qw@mail.gmail.com>

Yes, I think that would be enough.
Thank you, Kurt!

Llu?s

On Wed, 12 Jun 2024 at 16:35, Kurt Hornik <Kurt.Hornik at wu.ac.at> wrote:

> >>>>> Llu?s Revilla writes:
>
> Lluis,
>
> So in available.packages() I could replace
>
>     if (is.null(fields))
>         fields <- requiredFields
>     else {
>         stopifnot(is.character(fields))
>         fields <- unique(c(requiredFields, fields))
>     }
>
> by someting like
>
>     if(is.null(fields))
>         fields <- getOption("available_packages_fields")
>     if(is.null(fields))
>         fields <- requiredFields
>     else {
>         stopifnot(is.character(fields))
>         fields <- unique(c(requiredFields, fields))
>     }
>
> ?
>
> Best
> -k
>
>
>
> > Hi all,
> > I have recently been researching how available.packages and
> > install.packages filter packages from repositories with additional fields
> > in their PACKAGES file.
>
> > Currently there are some default filters, but users (and R admins) can
> set
> > up their own filters by passing a list to the fields argument or adding
> > them to the "available_packages_filters" option.
> > But if the fields used by the filters are not read by default, then users
> > must manually add the required fields to each call to available.packages.
>
> > This makes it difficult to use new fields and to control what is
> installed
> > in highly regulated systems which want to use more fields to select what
> is
> > installed.
>
> > Current workarounds considered are:
> >  1) The filtering function requiring new fields intercepts the call to
> > available.packages and adds the desired fields via eval in
> > parent.environment and then adds the filters again.
> >  2) Import new data (remote or local) when filtering packages, merge them
> > and filter accordingly.
> >  3) Suggestions?
>
> > The first solution is complicated, while the second doesn't use the R
> > machinery of tools::write_PACKAGES to set up the repository with all the
> > fields (although how to add more fields to the repository file is a
> > different issue).
>
> > Would it be possible to add a new option to add fields to be read by
> > available.packages, similar to filters?
> > The same approach for fields as for filters would avoid the two
> workarounds
> > mentioned. To match it, the new option could be named
> > "available_packages_fields".
>
> > I look forward to hearing from you,
>
> > Llu?s
>
> >       [[alternative HTML version deleted]]
>
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From Kurt@Horn|k @end|ng |rom wu@@c@@t  Wed Jun 12 16:49:33 2024
From: Kurt@Horn|k @end|ng |rom wu@@c@@t (Kurt Hornik)
Date: Wed, 12 Jun 2024 16:49:33 +0200
Subject: [Rd] Fields used by available.packages
In-Reply-To: <CAN+W6_um=SYDgRkTrJsVj80=K-4EXf-ckJ=xa2=v24gDrx37qw@mail.gmail.com>
References: <CAN+W6_vcvA4Gr9BUenydQOmt4HQSrTzNuNUyirFkbYN30vM-zA@mail.gmail.com>
 <26217.45619.441769.623342@hornik.net>
 <CAN+W6_um=SYDgRkTrJsVj80=K-4EXf-ckJ=xa2=v24gDrx37qw@mail.gmail.com>
Message-ID: <26217.46461.646968.454827@hornik.net>

>>>>> Llu?s Revilla writes:

> Yes, I think that would be enough.?

Thanks.  And of course add documentation ...

Will try to get this in in the next few days.

Best
-k

> Thank you, Kurt!


> Llu?s

> On Wed, 12 Jun 2024 at 16:35, Kurt Hornik <Kurt.Hornik at wu.ac.at> wrote:

>>>>>> Llu?s Revilla writes:
   
>     Lluis,
   
>     So in available.packages() I could replace
   
>     ? ? if (is.null(fields))
>     ? ? ? ? fields <- requiredFields
>     ? ? else {
>     ? ? ? ? stopifnot(is.character(fields))
>     ? ? ? ? fields <- unique(c(requiredFields, fields))
>     ? ? }
   
>     by someting like
   
>     ? ? if(is.null(fields))
>     ? ? ? ? fields <- getOption("available_packages_fields")
>     ? ? if(is.null(fields))
>     ? ? ? ? fields <- requiredFields
>     ? ? else {
>     ? ? ? ? stopifnot(is.character(fields))
>     ? ? ? ? fields <- unique(c(requiredFields, fields))
>     ? ? }
   
>     ?
   
>     Best
>     -k

>> Hi all,
>> I have recently been researching how available.packages and
>> install.packages filter packages from repositories with additional
>     fields
>> in their PACKAGES file.
   
>> Currently there are some default filters, but users (and R admins) can
>     set
>> up their own filters by passing a list to the fields argument or adding
>> them to the "available_packages_filters" option.
>> But if the fields used by the filters are not read by default, then
>     users
>> must manually add the required fields to each call to
>     available.packages.
   
>> This makes it difficult to use new fields and to control what is
>     installed
>> in highly regulated systems which want to use more fields to select
>     what is
>> installed.
   
>> Current workarounds considered are:
>> ? 1) The filtering function requiring new fields intercepts the call to
>> available.packages and adds the desired fields via eval in
>> parent.environment and then adds the filters again.
>> ? 2) Import new data (remote or local) when filtering packages, merge
>     them
>> and filter accordingly.
>> ? 3) Suggestions?
   
>> The first solution is complicated, while the second doesn't use the R
>> machinery of tools::write_PACKAGES to set up the repository with all
>     the
>> fields (although how to add more fields to the repository file is a
>> different issue).
   
>> Would it be possible to add a new option to add fields to be read by
>> available.packages, similar to filters?
>> The same approach for fields as for filters would avoid the two
>     workarounds
>> mentioned. To match it, the new option could be named
>> "available_packages_fields".
   
>> I look forward to hearing from you,
   
>> Llu?s
   
>> ? ? ? ?[[alternative HTML version deleted]]
   
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Thu Jun 13 10:40:49 2024
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Thu, 13 Jun 2024 10:40:49 +0200
Subject: [Rd] head.ts, tail.ts loses time
In-Reply-To: <295e6967-6ea6-4334-a43d-58c18ef7fcfd@prodsyse.com>
References: <016d5bb8-b0ee-47f0-91b2-7a2b8c51557d@prodsyse.com>
 <CAP01uRmdPR_3M5qUnD8+4REw8Fz8sSf1UrrxzJFwQN+f1dx1xQ@mail.gmail.com>
 <da0e13c2-d7d6-4f9e-b22e-c2b7392066e1@prodsyse.com>
 <26215.3697.815212.54251@stat.math.ethz.ch>
 <295e6967-6ea6-4334-a43d-58c18ef7fcfd@prodsyse.com>
Message-ID: <26218.45201.138876.12305@stat.math.ethz.ch>

>>>>> Spencer Graves 
>>>>>     on Mon, 10 Jun 2024 09:45:46 -0500 writes:

    > Hi, Martin et al.:
    > On 6/10/24 9:32 AM, Martin Maechler wrote:
    >>>>>>> Spencer Graves
    >>>>>>> on Mon, 10 Jun 2024 07:50:13 -0500 writes:
    >> 
    >> > Hi, Gabor et al.: Thanks for this. I should change my
    >> > current application to use either zoo or xts, as Gabor
    >> > suggests.
    >> 
    >> 
    >> > 	  However, I was surprised to learn that "[.ts" does NOT
    >> > return an object of class "ts". I see that "head.default"
    >> > and "head.matrix" both call "[", so "head" cannot return a
    >> > ts object, because "[" doesn't.
    >> 
    >> Yes, the default head() and tail() are built on  `[` very much
    >> on purpose.
    >> Note that   `[`  should *not* keep the "ts"  property  in
    >> general, e.g.,
    >> lynx[c(1:3, 7)]
    >> cannot be a regular time series


    > Agreed.

    >> 
    >> I think I'd consider using  windows() for a head.ts() and tail.ts(),
    >> but in any case, I am sympathetic adding such methods to "base R"'s
    >> utils package.


    > The code I provided below for head.ts() and tail.ts() does that: I 
    > took the code for head.default and head.matrix, etc., computed tmx <- 
    > as.numeric(time(x)), and then used head(tmx) [and tail(tmx)] in "window()".

Indeed.  I've found that the new methods really belong to pkg
'stats' (where "ts" are), and hence renamed and exported  the internal
.checkHT(), and shence the change became somewhat more extensive:

------------------------------------------------------------------------
r86728 | maechler | 2024-06-13 10:36:51 +0200 (Thu, 13 Jun 2024) | 1 line
Changed paths:
   M doc/NEWS.Rd
   M src/library/stats/NAMESPACE
   M src/library/stats/R/ts.R
   M src/library/stats/man/ts.Rd
   M src/library/utils/NAMESPACE
   M src/library/utils/R/head.R
   M src/library/utils/man/head.Rd
   M tests/Examples/stats-Ex.Rout.save

add head() & tail() methods for "ts"(time series) ==> export .checkHT() utility
------------------------------------------------------------------------

With thanks to Spencer Graves,

Martin


    > Thanks for your reply.
    > sg
    >> 
    >> 
    >> Martin
    >> 
    >> > 	  Best Wishes, Spencer Graves
    >> 
    >> 
    >> > On 6/9/24 8:40 PM, Gabor Grothendieck wrote:
    >> >> zoo overcomes many of the limitations of ts:
    >> >>
    >> >> library(zoo) as.ts(head(as.zoo(presidents))) ## Qtr1 Qtr2
    >> >> Qtr3 Qtr4 ## 1945 NA 87 82 75 ## 1946 63 50
    >> >>
    >> >> xts also works here.
    >> >>
    >> >> On Sun, Jun 9, 2024 at 12:04?PM Spencer Graves
    >> >> <spencer.graves at prodsyse.com> wrote:
    >> >>>
    >> >>> Hello, All:
    >> >>>
    >> >>>
    >> >>> The 'head' and 'tail' functions strip the time from a
    >> >>> 'ts' object.  Example:
    >> >>>
    >> >>>
    >> >>> > head(presidents) [1] NA 87 82 75 63 50
    >> >>>
    >> >>>
    >> >>> > window(presidents, 1945, 1946.25) Qtr1 Qtr2 Qtr3 Qtr4
    >> >>> 1945 NA 87 82 75 1946 63 50
    >> >>>
    >> >>>
    >> >>> Below please find code for 'head.ts' and 'tail.ts' that
    >> >>> matches 'window'.
    >> >>>
    >> >>>
    >> >>> Comments?  Spencer Graves
    >> >>>
    >> >>> head.ts <- function(x, n=6L, ...){ tmx <-
    >> >>> as.numeric(time(x))
    >> >>> #
    >> >>> utils:::checkHT(n, d <- dim(x)) if(is.na(n[1]) ||
    >> >>> n[1]==0)ts(NULL)
    >> >>> #
    >> >>> firstn <- head(tmx, n[1]) if(is.null(d)){
    >> >>> return(window(x, firstn[1], tail(firstn, 1))) } else{
    >> >>> if(length(n)<2){ return(window(x, firstn[1],
    >> >>> tail(firstn, 1))) } else { Cols <- head(1:d[2], n[2])
    >> >>> xn2 <- x[, Cols[1]:tail(Cols, 1)] return(window(xn2,
    >> >>> firstn[1], tail(firstn, 1))) } } }
    >> >>>
    >> >>>
    >> >>> tail.ts <- function (x, n = 6L, ...)  {
    >> >>> utils:::checkHT(n, d <- dim(x)) tmx <-
    >> >>> as.numeric(time(x))
    >> >>> #
    >> >>> if(is.na(n[1]) || n[1]==0)ts(NULL)
    >> >>> #
    >> >>> lastn <- tail(tmx, n[1]) if(is.null(d)){
    >> >>> return(window(x, lastn[1], tail(lastn, 1))) } else{
    >> >>> if(length(n)<2){ return(window(x, lastn[1], tail(lastn,
    >> >>> 1))) } else { Cols <- head(1:d[2], n[2]) xn2 <- x[,
    >> >>> Cols[1]:tail(Cols, 1)] return(window(xn2, lastn[1],
    >> >>> tail(lastn, 1))) } } }
    >> >>>
    >> >>>
    >> >>> # examples head(presidents)
    >> >>>
    >> >>> head(presidents, 2)
    >> >>>
    >> >>> npresObs <- length(presidents) head(presidents,
    >> >>> 6-npresObs)
    >> >>>
    >> >>> try(head(presidents, 1:2)) # 'try-error'
    >> >>>
    >> >>> try(head(presidents, 0)) # 'try-error'
    >> >>>
    >> >>> # matrix time series str(pres <-
    >> >>> cbind(n=1:length(presidents), presidents)) head(pres, 2)
    >> >>>
    >> >>> head(pres, 2-npresObs)
    >> >>>
    >> >>> head(pres, 1:2) head(pres, 2:1) head(pres, 1:3)
    >> >>>
    >> >>> # examples tail(presidents)
    >> >>>
    >> >>> tail(presidents, 2)
    >> >>>
    >> >>> npresObs <- length(presidents) tail(presidents,
    >> >>> 6-npresObs)
    >> >>>
    >> >>> try(tail(presidents, 1:2)) # 'try-error'
    >> >>>
    >> >>> try(tail(presidents, 0)) # 'try-error'
    >> >>>
    >> >>> # matrix time series str(pres <-
    >> >>> cbind(n=1:length(presidents), presidents)) tail(pres, 2)
    >> >>>
    >> >>> tail(pres, 2-npresObs)
    >> >>>
    >> >>> tail(pres, 1:2) tail(pres, 2:1) tail(pres, 1:3)
    >> >>>
    >> >>> # for unit testing: headPres <- head(presidents) pres6
    >> >>> <- ts(presidents[1:6], time(presidents)[1],
    >> >>> frequency=frequency(presidents))
    >> >>> stopifnot(all.equal(headPres, pres6))
    >> >>>
    >> >>> headPres2 <- head(presidents, 2) pres2 <-
    >> >>> ts(presidents[1:2], time(presidents)[1],
    >> >>> frequency=frequency(presidents))
    >> >>> stopifnot(all.equal(headPres2, pres2))
    >> >>>
    >> >>> npresObs <- length(presidents) headPres. <-
    >> >>> head(presidents, 6-npresObs)
    >> >>> stopifnot(all.equal(headPres., pres6))
    >> >>>
    >> >>> headPresOops <- try(head(presidents, 1:2))
    >> >>> stopifnot(class(headPresOops) == 'try-error')
    >> >>>
    >> >>> headPres0 <- try(head(presidents, 0))
    >> >>> stopifnot(class(headPres0) == 'try-error')
    >> >>>
    >> >>> str(pres <- cbind(n=1:length(presidents), presidents))
    >> >>> headP2 <- head(pres, 2)
    >> >>>
    >> >>> p2 <- ts(pres[1:2, ], time(presidents)[1],
    >> >>> frequency=frequency(presidents))
    >> >>> stopifnot(all.equal(headP2, p2))
    >> >>>
    >> >>> headP2. <- head(pres, 2-npresObs)
    >> >>> stopifnot(all.equal(headP2., p2))
    >> >>>
    >> >>>
    >> >>> #############
    >> >>>
    >> >>>
    >> >>> sessionInfo() R version 4.4.0 (2024-04-24) Platform:
    >> >>> aarch64-apple-darwin20 Running under: macOS Sonoma 14.5
    >> >>>
    >> >>> Matrix products: default BLAS:
    >> >>> /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
    >> >>>
    >> >>> LAPACK:
    >> >>> /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;
    >> >>> LAPACK version 3.12.0
    >> >>>
    >> >>> locale: [1]
    >> >>> en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
    >> >>>
    >> >>> time zone: America/Chicago tzcode source: internal
    >> >>>
    >> >>> attached base packages: [1] stats graphics grDevices
    >> >>> utils datasets [6] methods base
    >> >>>
    >> >>> loaded via a namespace (and not attached): [1]
    >> >>> compiler_4.4.0 tools_4.4.0
    >> >>>
    >> >>> ______________________________________________
    >> >>> R-devel at r-project.org mailing list
    >> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
    >> >>
    >> >>
    >> >>
    >> 
    >> > ______________________________________________
    >> > R-devel at r-project.org mailing list
    >> > https://stat.ethz.ch/mailman/listinfo/r-devel


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Thu Jun 13 10:47:27 2024
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Thu, 13 Jun 2024 10:47:27 +0200
Subject: [Rd] head.ts, tail.ts loses time
In-Reply-To: <CAP01uRkHWsQrELjRDU7MR9XtXgghT5VM0vnQmrE=pOa-mqSBhQ@mail.gmail.com>
References: <016d5bb8-b0ee-47f0-91b2-7a2b8c51557d@prodsyse.com>
 <CAP01uRmdPR_3M5qUnD8+4REw8Fz8sSf1UrrxzJFwQN+f1dx1xQ@mail.gmail.com>
 <da0e13c2-d7d6-4f9e-b22e-c2b7392066e1@prodsyse.com>
 <26215.3697.815212.54251@stat.math.ethz.ch>
 <CAP01uRkHWsQrELjRDU7MR9XtXgghT5VM0vnQmrE=pOa-mqSBhQ@mail.gmail.com>
Message-ID: <26218.45599.975713.139484@stat.math.ethz.ch>

>>>>> Gabor Grothendieck 
>>>>>     on Tue, 11 Jun 2024 09:13:49 -0400 writes:

    > It isn't really clear that it can't work.  This does work by inserting NA's.
    > library(zoo)
    > as.ts(as.zoo(lynx)[ c(1:3, 7) ] )
    > ## Time Series:
    > ## Start = 1821
    > ## End = 1827
    > ## Frequency = 1
    > ## [1]  269  321  585   NA   NA   NA 3928

You are right,  Gabor, such an implementation of  `[.ts`
*would* make sense, too.

But given that head.ts() and tail.ts() -- slightly compactified
from Spencer's proposal,  are now simple and "robust",

I did not want to make such a "strong" change to such a basic class and its `[` operator.
(I'm not *against* it either currently, but I'm not convinced
 it's worth the effort with possible subsequent changes needed
 in code which has relied on the old behavior for > 30 years
 if you count the pre-R  S version, too.)

Best, Martin


    > On Mon, Jun 10, 2024 at 10:32?AM Martin Maechler
    > <maechler at stat.math.ethz.ch> wrote:
    >> 
    >> >>>>> Spencer Graves
    >> >>>>>     on Mon, 10 Jun 2024 07:50:13 -0500 writes:
    >> 
    >> > Hi, Gabor et al.: Thanks for this. I should change my
    >> > current application to use either zoo or xts, as Gabor
    >> > suggests.
    >> 
    >> 
    >> >     However, I was surprised to learn that "[.ts" does NOT
    >> > return an object of class "ts". I see that "head.default"
    >> > and "head.matrix" both call "[", so "head" cannot return a
    >> > ts object, because "[" doesn't.
    >> 
    >> Yes, the default head() and tail() are built on  `[` very much
    >> on purpose.
    >> Note that   `[`  should *not* keep the "ts"  property  in
    >> general, e.g.,
    >> lynx[c(1:3, 7)]
    >> cannot be a regular time series
    >> 
    >> I think I'd consider using  windows() for a head.ts() and tail.ts(),
    >> but in any case, I am sympathetic adding such methods to "base R"'s
    >> utils package.
    >> 
    >> 
    >> Martin
    >> 
    >> >     Best Wishes, Spencer Graves
    >> 
    >> 
    >> > On 6/9/24 8:40 PM, Gabor Grothendieck wrote:
    >> >> zoo overcomes many of the limitations of ts:
    >> >>
    >> >> library(zoo) as.ts(head(as.zoo(presidents))) ## Qtr1 Qtr2
    >> >> Qtr3 Qtr4 ## 1945 NA 87 82 75 ## 1946 63 50
    >> >>
    >> >> xts also works here.
    >> >>
    >> >> On Sun, Jun 9, 2024 at 12:04?PM Spencer Graves
    >> >> <spencer.graves at prodsyse.com> wrote:
    >> >>>
    >> >>> Hello, All:
    >> >>>
    >> >>>
    >> >>> The 'head' and 'tail' functions strip the time from a
    >> >>> 'ts' object.  Example:
    >> >>>
    >> >>>
    >> >>> > head(presidents) [1] NA 87 82 75 63 50
    >> >>>
    >> >>>
    >> >>> > window(presidents, 1945, 1946.25) Qtr1 Qtr2 Qtr3 Qtr4
    >> >>> 1945 NA 87 82 75 1946 63 50
    >> >>>
    >> >>>
    >> >>> Below please find code for 'head.ts' and 'tail.ts' that
    >> >>> matches 'window'.
    >> >>>
    >> >>>
    >> >>> Comments?  Spencer Graves
    >> >>>
    >> >>> head.ts <- function(x, n=6L, ...){ tmx <-
    >> >>> as.numeric(time(x))
    >> >>> #
    >> >>> utils:::checkHT(n, d <- dim(x)) if(is.na(n[1]) ||
    >> >>> n[1]==0)ts(NULL)
    >> >>> #
    >> >>> firstn <- head(tmx, n[1]) if(is.null(d)){
    >> >>> return(window(x, firstn[1], tail(firstn, 1))) } else{
    >> >>> if(length(n)<2){ return(window(x, firstn[1],
    >> >>> tail(firstn, 1))) } else { Cols <- head(1:d[2], n[2])
    >> >>> xn2 <- x[, Cols[1]:tail(Cols, 1)] return(window(xn2,
    >> >>> firstn[1], tail(firstn, 1))) } } }
    >> >>>
    >> >>>
    >> >>> tail.ts <- function (x, n = 6L, ...)  {
    >> >>> utils:::checkHT(n, d <- dim(x)) tmx <-
    >> >>> as.numeric(time(x))
    >> >>> #
    >> >>> if(is.na(n[1]) || n[1]==0)ts(NULL)
    >> >>> #
    >> >>> lastn <- tail(tmx, n[1]) if(is.null(d)){
    >> >>> return(window(x, lastn[1], tail(lastn, 1))) } else{
    >> >>> if(length(n)<2){ return(window(x, lastn[1], tail(lastn,
    >> >>> 1))) } else { Cols <- head(1:d[2], n[2]) xn2 <- x[,
    >> >>> Cols[1]:tail(Cols, 1)] return(window(xn2, lastn[1],
    >> >>> tail(lastn, 1))) } } }
    >> >>>
    >> >>>
    >> >>> # examples head(presidents)
    >> >>>
    >> >>> head(presidents, 2)
    >> >>>
    >> >>> npresObs <- length(presidents) head(presidents,
    >> >>> 6-npresObs)
    >> >>>
    >> >>> try(head(presidents, 1:2)) # 'try-error'
    >> >>>
    >> >>> try(head(presidents, 0)) # 'try-error'
    >> >>>
    >> >>> # matrix time series str(pres <-
    >> >>> cbind(n=1:length(presidents), presidents)) head(pres, 2)
    >> >>>
    >> >>> head(pres, 2-npresObs)
    >> >>>
    >> >>> head(pres, 1:2) head(pres, 2:1) head(pres, 1:3)
    >> >>>
    >> >>> # examples tail(presidents)
    >> >>>
    >> >>> tail(presidents, 2)
    >> >>>
    >> >>> npresObs <- length(presidents) tail(presidents,
    >> >>> 6-npresObs)
    >> >>>
    >> >>> try(tail(presidents, 1:2)) # 'try-error'
    >> >>>
    >> >>> try(tail(presidents, 0)) # 'try-error'
    >> >>>
    >> >>> # matrix time series str(pres <-
    >> >>> cbind(n=1:length(presidents), presidents)) tail(pres, 2)
    >> >>>
    >> >>> tail(pres, 2-npresObs)
    >> >>>
    >> >>> tail(pres, 1:2) tail(pres, 2:1) tail(pres, 1:3)
    >> >>>
    >> >>> # for unit testing: headPres <- head(presidents) pres6
    >> >>> <- ts(presidents[1:6], time(presidents)[1],
    >> >>> frequency=frequency(presidents))
    >> >>> stopifnot(all.equal(headPres, pres6))
    >> >>>
    >> >>> headPres2 <- head(presidents, 2) pres2 <-
    >> >>> ts(presidents[1:2], time(presidents)[1],
    >> >>> frequency=frequency(presidents))
    >> >>> stopifnot(all.equal(headPres2, pres2))
    >> >>>
    >> >>> npresObs <- length(presidents) headPres. <-
    >> >>> head(presidents, 6-npresObs)
    >> >>> stopifnot(all.equal(headPres., pres6))
    >> >>>
    >> >>> headPresOops <- try(head(presidents, 1:2))
    >> >>> stopifnot(class(headPresOops) == 'try-error')
    >> >>>
    >> >>> headPres0 <- try(head(presidents, 0))
    >> >>> stopifnot(class(headPres0) == 'try-error')
    >> >>>
    >> >>> str(pres <- cbind(n=1:length(presidents), presidents))
    >> >>> headP2 <- head(pres, 2)
    >> >>>
    >> >>> p2 <- ts(pres[1:2, ], time(presidents)[1],
    >> >>> frequency=frequency(presidents))
    >> >>> stopifnot(all.equal(headP2, p2))
    >> >>>
    >> >>> headP2. <- head(pres, 2-npresObs)
    >> >>> stopifnot(all.equal(headP2., p2))
    >> >>>
    >> >>>
    >> >>> #############
    >> >>>
    >> >>>
    >> >>> sessionInfo() R version 4.4.0 (2024-04-24) Platform:
    >> >>> aarch64-apple-darwin20 Running under: macOS Sonoma 14.5
    >> >>>
    >> >>> Matrix products: default BLAS:
    >> >>> /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
    >> >>>
    >> >>> LAPACK:
    >> >>> /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;
    >> >>> LAPACK version 3.12.0
    >> >>>
    >> >>> locale: [1]
    >> >>> en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
    >> >>>
    >> >>> time zone: America/Chicago tzcode source: internal
    >> >>>
    >> >>> attached base packages: [1] stats graphics grDevices
    >> >>> utils datasets [6] methods base
    >> >>>
    >> >>> loaded via a namespace (and not attached): [1]
    >> >>> compiler_4.4.0 tools_4.4.0
    >> >>>
    >> >>> ______________________________________________
    >> >>> R-devel at r-project.org mailing list
    >> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
    >> >>
    >> >>
    >> >>
    >> 
    >> > ______________________________________________
    >> > R-devel at r-project.org mailing list
    >> > https://stat.ethz.ch/mailman/listinfo/r-devel



    > -- 
    > Statistics & Software Consulting
    > GKX Group, GKX Associates Inc.
    > tel: 1-877-GKX-GROUP
    > email: ggrothendieck at gmail.com


From georg|@bo@hn@kov @end|ng |rom m@nche@ter@@c@uk  Thu Jun 13 11:38:21 2024
From: georg|@bo@hn@kov @end|ng |rom m@nche@ter@@c@uk (Georgi Boshnakov)
Date: Thu, 13 Jun 2024 09:38:21 +0000
Subject: [Rd] head.ts, tail.ts loses time
In-Reply-To: <mailman.54342.3.1718186401.9590.r-devel@r-project.org>
References: <mailman.54342.3.1718186401.9590.r-devel@r-project.org>
Message-ID: <LO0P265MB6325A77C563D088D0DE7C44BAEC12@LO0P265MB6325.GBRP265.PROD.OUTLOOK.COM>

> It isn't really clear that it can't work.  This does work by inserting NA's...
>
>  library(zoo)
> as.ts(as.zoo(lynx)[ c(1:3, 7) ] )

If by 'this' you mean indexing, it would be very confusing and error prone for expressions like lynx[c(1:3, 7)] (lynx is from class 'ts') to return a ts object with NA's inserted and, even more  so, since this has been unambiguously documented for ages in '?ts'. For 'zoo' objects, the situation is different since they have a time index by definition, so the above index doesn't introduce artificial NA's:

> as.zoo(lynx)[ c(1:3, 7) ]
1821 1822 1823 1827 
 269  321  585 3928 
> coredata(as.zoo(lynx)[ c(1:3, 7) ])
[1]  269  321  585 3928

On the other hand,  'ts' methods for 'head' and 'tail' would be suitable, since the indexing is contiguous by definition there. Also, compatibility problems may not be a big concern for these functions.

Georgi Boshnakov



Date: Tue, 11 Jun 2024 09:13:49 -0400
From: Gabor Grothendieck <ggrothendieck at gmail.com>
To: Martin Maechler <maechler at stat.math.ethz.ch>
Cc: Spencer Graves <spencer.graves at prodsyse.com>, r-devel
        <r-devel at r-project.org>
Subject: Re: [Rd] head.ts, tail.ts loses time
Message-ID:
        <CAP01uRkHWsQrELjRDU7MR9XtXgghT5VM0vnQmrE=pOa-mqSBhQ at mail.gmail.com>
Content-Type: text/plain; charset="utf-8"

It isn't really clear that it can't work.  This does work by inserting NA's...

  library(zoo)
  as.ts(as.zoo(lynx)[ c(1:3, 7) ] )
  ## Time Series:
  ## Start = 1821
  ## End = 1827
  ## Frequency = 1
  ## [1]  269  321  585   NA   NA   NA 3928


On Mon, Jun 10, 2024 at 10:32?AM Martin Maechler
<maechler at stat.math.ethz.ch> wrote:
>
> >>>>> Spencer Graves
> >>>>>     on Mon, 10 Jun 2024 07:50:13 -0500 writes:
>
>     > Hi, Gabor et al.: Thanks for this. I should change my
>     > current application to use either zoo or xts, as Gabor
>     > suggests.
>
>
>     >     However, I was surprised to learn that "[.ts" does NOT
>     > return an object of class "ts". I see that "head.default"
>     > and "head.matrix" both call "[", so "head" cannot return a
>     > ts object, because "[" doesn't.
>
> Yes, the default head() and tail() are built on  `[` very much
> on purpose.
> Note that   `[`  should *not* keep the "ts"  property  in
> general, e.g.,
>          lynx[c(1:3, 7)]
> cannot be a regular time series
>
> I think I'd consider using  windows() for a head.ts() and tail.ts(),
> but in any case, I am sympathetic adding such methods to "base R"'s
> utils package.
>
>
> Martin
>
>     >     Best Wishes, Spencer Graves
>
>
>     > On 6/9/24 8:40 PM, Gabor Grothendieck wrote:
>     >> zoo overcomes many of the limitations of ts:
>     >>
>     >> library(zoo) as.ts(head(as.zoo(presidents))) ## Qtr1 Qtr2
>     >> Qtr3 Qtr4 ## 1945 NA 87 82 75 ## 1946 63 50
>     >>
>     >> xts also works here.
>     >>
>     >> On Sun, Jun 9, 2024 at 12:04?PM Spencer Graves
>     >> <spencer.graves at prodsyse.com> wrote:
>     >>>
>     >>> Hello, All:
>     >>>
>     >>>
>     >>> The 'head' and 'tail' functions strip the time from a
>     >>> 'ts' object.  Example:
>     >>>
>     >>>
>     >>> > head(presidents) [1] NA 87 82 75 63 50
>     >>>
>     >>>
>     >>> > window(presidents, 1945, 1946.25) Qtr1 Qtr2 Qtr3 Qtr4
>     >>> 1945 NA 87 82 75 1946 63 50
>     >>>
>     >>>
>     >>> Below please find code for 'head.ts' and 'tail.ts' that
>     >>> matches 'window'.
>     >>>
>     >>>
>     >>> Comments?  Spencer Graves
>     >>>
>     >>> head.ts <- function(x, n=6L, ...){ tmx <-
>     >>> as.numeric(time(x))
>     >>> #
>     >>> utils:::checkHT(n, d <- dim(x)) if(is.na(n[1]) ||
>     >>> n[1]==0)ts(NULL)
>     >>> #
>     >>> firstn <- head(tmx, n[1]) if(is.null(d)){
>     >>> return(window(x, firstn[1], tail(firstn, 1))) } else{
>     >>> if(length(n)<2){ return(window(x, firstn[1],
>     >>> tail(firstn, 1))) } else { Cols <- head(1:d[2], n[2])
>     >>> xn2 <- x[, Cols[1]:tail(Cols, 1)] return(window(xn2,
>     >>> firstn[1], tail(firstn, 1))) } } }
>     >>>
>     >>>
>     >>> tail.ts <- function (x, n = 6L, ...)  {
>     >>> utils:::checkHT(n, d <- dim(x)) tmx <-
>     >>> as.numeric(time(x))
>     >>> #
>     >>> if(is.na(n[1]) || n[1]==0)ts(NULL)
>     >>> #
>     >>> lastn <- tail(tmx, n[1]) if(is.null(d)){
>     >>> return(window(x, lastn[1], tail(lastn, 1))) } else{
>     >>> if(length(n)<2){ return(window(x, lastn[1], tail(lastn,
>     >>> 1))) } else { Cols <- head(1:d[2], n[2]) xn2 <- x[,
>     >>> Cols[1]:tail(Cols, 1)] return(window(xn2, lastn[1],
>     >>> tail(lastn, 1))) } } }
>     >>>
>     >>>
>     >>> # examples head(presidents)
>     >>>
>     >>> head(presidents, 2)
>     >>>
>     >>> npresObs <- length(presidents) head(presidents,
>     >>> 6-npresObs)
>     >>>
>     >>> try(head(presidents, 1:2)) # 'try-error'
>     >>>
>     >>> try(head(presidents, 0)) # 'try-error'
>     >>>
>     >>> # matrix time series str(pres <-
>     >>> cbind(n=1:length(presidents), presidents)) head(pres, 2)
>     >>>
>     >>> head(pres, 2-npresObs)
>     >>>
>     >>> head(pres, 1:2) head(pres, 2:1) head(pres, 1:3)
>     >>>
>     >>> # examples tail(presidents)
>     >>>
>     >>> tail(presidents, 2)
>     >>>
>     >>> npresObs <- length(presidents) tail(presidents,
>     >>> 6-npresObs)
>     >>>
>     >>> try(tail(presidents, 1:2)) # 'try-error'
>     >>>
>     >>> try(tail(presidents, 0)) # 'try-error'
>     >>>
>     >>> # matrix time series str(pres <-
>     >>> cbind(n=1:length(presidents), presidents)) tail(pres, 2)
>     >>>
>     >>> tail(pres, 2-npresObs)
>     >>>
>     >>> tail(pres, 1:2) tail(pres, 2:1) tail(pres, 1:3)
>     >>>
>     >>> # for unit testing: headPres <- head(presidents) pres6
>     >>> <- ts(presidents[1:6], time(presidents)[1],
>     >>> frequency=frequency(presidents))
>     >>> stopifnot(all.equal(headPres, pres6))
>     >>>
>     >>> headPres2 <- head(presidents, 2) pres2 <-
>     >>> ts(presidents[1:2], time(presidents)[1],
>     >>> frequency=frequency(presidents))
>     >>> stopifnot(all.equal(headPres2, pres2))
>     >>>
>     >>> npresObs <- length(presidents) headPres. <-
>     >>> head(presidents, 6-npresObs)
>     >>> stopifnot(all.equal(headPres., pres6))
>     >>>
>     >>> headPresOops <- try(head(presidents, 1:2))
>     >>> stopifnot(class(headPresOops) == 'try-error')
>     >>>
>     >>> headPres0 <- try(head(presidents, 0))
>     >>> stopifnot(class(headPres0) == 'try-error')
>     >>>
>     >>> str(pres <- cbind(n=1:length(presidents), presidents))
>     >>> headP2 <- head(pres, 2)
>     >>>
>     >>> p2 <- ts(pres[1:2, ], time(presidents)[1],
>     >>> frequency=frequency(presidents))
>     >>> stopifnot(all.equal(headP2, p2))
>     >>>
>     >>> headP2. <- head(pres, 2-npresObs)
>     >>> stopifnot(all.equal(headP2., p2))
>     >>>
>     >>>
>     >>> #############
>     >>>
>     >>>
>     >>> sessionInfo() R version 4.4.0 (2024-04-24) Platform:
>     >>> aarch64-apple-darwin20 Running under: macOS Sonoma 14.5
>     >>>
>     >>> Matrix products: default BLAS:
>     >>> /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
>     >>>
>     >>> LAPACK:
>     >>> /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;
>     >>> LAPACK version 3.12.0
>     >>>
>     >>> locale: [1]
>     >>> en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
>     >>>
>     >>> time zone: America/Chicago tzcode source: internal
>     >>>
>     >>> attached base packages: [1] stats graphics grDevices
>     >>> utils datasets [6] methods base
>     >>>
>     >>> loaded via a namespace (and not attached): [1]
>     >>> compiler_4.4.0 tools_4.4.0
>     >>>
>     >>> ______________________________________________
>     >>> R-devel at r-project.org mailing list
>     >>> https://urldefense.com/v3/__https://stat.ethz.ch/mailman/listinfo/r-devel__;!!PDiH4ENfjr2_Jw!BrlX0n74cttdH54fH7zImanZ4AEoUysullXuaB2TLwZnk4MElP8_Wzb1Jb-Qa6hu4N2xsqMoRZOivoiAzEMCMrHpuPa3LvL2StE0whuxSwE$ [stat[.]ethz[.]ch]
>     >>
>     >>
>     >>
>
>     > ______________________________________________
>     > R-devel at r-project.org mailing list
>     > https://urldefense.com/v3/__https://stat.ethz.ch/mailman/listinfo/r-devel__;!!PDiH4ENfjr2_Jw!BrlX0n74cttdH54fH7zImanZ4AEoUysullXuaB2TLwZnk4MElP8_Wzb1Jb-Qa6hu4N2xsqMoRZOivoiAzEMCMrHpuPa3LvL2StE0whuxSwE$ [stat[.]ethz[.]ch]



--
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com

From edd @end|ng |rom deb|@n@org  Thu Jun 13 14:20:00 2024
From: edd @end|ng |rom deb|@n@org (Dirk Eddelbuettel)
Date: Thu, 13 Jun 2024 07:20:00 -0500
Subject: [Rd] R-devel on Windows temporarily broken?
Message-ID: <26218.58352.92640.574440@rob.eddelbuettel.com>


I had a very routine CI job fail twice this morning on r-devel on Windows;
the package (in fine standard form) doesn't even install under win-builder
r-devel. Whereas on Linux with r86731 everything is peachy.

Dirk

-- 
dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org


From edd @end|ng |rom deb|@n@org  Thu Jun 13 15:35:24 2024
From: edd @end|ng |rom deb|@n@org (Dirk Eddelbuettel)
Date: Thu, 13 Jun 2024 08:35:24 -0500
Subject: [Rd] R-devel on Windows temporarily broken?
In-Reply-To: <26218.62344.708682.22736@stat.math.ethz.ch>
References: <26218.58352.92640.574440@rob.eddelbuettel.com>
 <26218.62344.708682.22736@stat.math.ethz.ch>
Message-ID: <26218.62876.585076.819818@rob.eddelbuettel.com>


On 13 June 2024 at 15:26, Martin Maechler wrote:
| >>>>> Dirk Eddelbuettel 
| >>>>>     on Thu, 13 Jun 2024 07:20:00 -0500 writes:
| 
|     > I had a very routine CI job fail twice this morning on r-devel on Windows;
|     > the package (in fine standard form) doesn't even install under win-builder
|     > r-devel. Whereas on Linux with r86731 everything is peachy.
| 
|     > Dirk
| 
| There was a texinfo typo for a while which Prof Brian Ripley
| fixed in r86729.
| 
| Hence r86731 is fine on Windows, too, at least when I look at
| the R contributor svn dashboard  (provided thanks to Jeroen Ooms):
|     https://contributor.r-project.org/svn-dashboard/

This ran twice, and blew up both times in a spot where it is 'impossible to
blow up where it did' (line 183) 
  https://github.com/TileDB-Inc/TileDB-R/actions/runs/9498253355/job/26179179289
Note that r-release ran fine on the same commit.

Ditto with this win-builder r-devel build _not even installing_
  https://win-builder.r-project.org/SNSy1J8W8H8b

The package now also errors on r-devel-linux-x86_64-debian-gcc and was fine
days ago (as we just uploaded that release last week). 

Neither one of these errors has, as best as I can tell, anything to do with
texinfo, as you brought that up.

Anyway, I just disabled r-devel in the CI matrix for now and will revisit in
a few days.  As I wrote, it works here (as I wrote) under '2024-06-13 r86731'.

Dirk

-- 
dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Thu Jun 13 15:26:32 2024
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Thu, 13 Jun 2024 15:26:32 +0200
Subject: [Rd] R-devel on Windows temporarily broken?
In-Reply-To: <26218.58352.92640.574440@rob.eddelbuettel.com>
References: <26218.58352.92640.574440@rob.eddelbuettel.com>
Message-ID: <26218.62344.708682.22736@stat.math.ethz.ch>

>>>>> Dirk Eddelbuettel 
>>>>>     on Thu, 13 Jun 2024 07:20:00 -0500 writes:

    > I had a very routine CI job fail twice this morning on r-devel on Windows;
    > the package (in fine standard form) doesn't even install under win-builder
    > r-devel. Whereas on Linux with r86731 everything is peachy.

    > Dirk

There was a texinfo typo for a while which Prof Brian Ripley
fixed in r86729.

Hence r86731 is fine on Windows, too, at least when I look at
the R contributor svn dashboard  (provided thanks to Jeroen Ooms):
    https://contributor.r-project.org/svn-dashboard/


