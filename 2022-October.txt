From wo||g@ng@v|echtb@uer @end|ng |rom m@@@tr|chtun|ver@|ty@n|  Sat Oct  1 18:00:07 2022
From: wo||g@ng@v|echtb@uer @end|ng |rom m@@@tr|chtun|ver@|ty@n| (Viechtbauer, Wolfgang (NP))
Date: Sat, 1 Oct 2022 16:00:07 +0000
Subject: [Rd] Linking to Intel's MKL on Windows
In-Reply-To: <CAP1vfdtozPWjKkvL9tqKZPKA1y+B44d2tc+yO6n4tYCUpJQOug@mail.gmail.com>
References: <CAP1vfdtozPWjKkvL9tqKZPKA1y+B44d2tc+yO6n4tYCUpJQOug@mail.gmail.com>
Message-ID: <acfeb141204c48ebb18d8c6737f1d1a9@UM-MAIL3214.unimaas.nl>

Hi Christine,

MKL is a closed-source commercial product (yes, one can get it for free, but it is not libre/open-source software).

Best,
Wolfgang

>-----Original Message-----
>From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of Christine
>Stawitz - NOAA Federal via R-devel
>Sent: Friday, 30 September, 2022 18:46
>To: r-devel at r-project.org
>Subject: [Rd] Linking to Intel's MKL on Windows
>
>Hi,
>
>Recently I became aware that Microsoft R Open provides accelerated matrix
>algebra computations through Intel's Math Kernel Libraries. However, the
>version of R shipped with the Microsoft R Open is too out of date to be
>able to use concurrently with other dependencies while developing our
>package. This thread suggests a way to get the updated matrix libraries
>with a more recent version of R, however it is unlikely to be approved by
>our IT admin since those of us in government agencies aren't typically
>given admin privileges: Linking Intel's Math Kernel Library (MKL) to R on
>Windows - Stack Overflow
><https://stackoverflow.com/questions/38090206/linking-intels-math-kernel-library-
>mkl-to-r-on-windows>
>
>Is there a reason why CRAN doesn't provide a version of R with the updated
>libraries such that developers don't have to recompile R or copy .dlls
>around as described above? It would help those of us running software with
>slow-running matrix calculations in R.
>
>Thanks,
>Christine
>
>--
>Christine C. Stawitz, PhD. (pronouns: she/her)
>
>National Stock Assessment Program Modeling Team
>
>NOAA Fisheries Office of Science and Technology |  U.S. Department of
>Commerce
>
>Mobile: 206-617-2060
>
>www.fisheries.noaa.gov


From bbo|ker @end|ng |rom gm@||@com  Sat Oct  1 18:48:39 2022
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Sat, 1 Oct 2022 12:48:39 -0400
Subject: [Rd] Linking to Intel's MKL on Windows
In-Reply-To: <acfeb141204c48ebb18d8c6737f1d1a9@UM-MAIL3214.unimaas.nl>
References: <CAP1vfdtozPWjKkvL9tqKZPKA1y+B44d2tc+yO6n4tYCUpJQOug@mail.gmail.com>
 <acfeb141204c48ebb18d8c6737f1d1a9@UM-MAIL3214.unimaas.nl>
Message-ID: <13d28348-762f-c15a-4ece-980498e7e990@gmail.com>

    Maybe you can find out more about Microsoft's development/release 
process for MRO and why they're still on 4.0.2 (from June 2020)?  I 
followed the "user forum" link on their web page, but it appears to be a 
generic Windows forum ...

https://social.msdn.microsoft.com/Forums/en-US/home?forum%20=ropen

    I might tweet at @revodavid (David Smith) to see if there's any more 
information available about the MRO release schedule ...

   good luck,
    Ben Bolker




On 2022-10-01 12:00 p.m., Viechtbauer, Wolfgang (NP) wrote:
> Hi Christine,
> 
> MKL is a closed-source commercial product (yes, one can get it for free, but it is not libre/open-source software).
> 
> Best,
> Wolfgang
> 
>> -----Original Message-----
>> From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of Christine
>> Stawitz - NOAA Federal via R-devel
>> Sent: Friday, 30 September, 2022 18:46
>> To: r-devel at r-project.org
>> Subject: [Rd] Linking to Intel's MKL on Windows
>>
>> Hi,
>>
>> Recently I became aware that Microsoft R Open provides accelerated matrix
>> algebra computations through Intel's Math Kernel Libraries. However, the
>> version of R shipped with the Microsoft R Open is too out of date to be
>> able to use concurrently with other dependencies while developing our
>> package. This thread suggests a way to get the updated matrix libraries
>> with a more recent version of R, however it is unlikely to be approved by
>> our IT admin since those of us in government agencies aren't typically
>> given admin privileges: Linking Intel's Math Kernel Library (MKL) to R on
>> Windows - Stack Overflow
>> <https://stackoverflow.com/questions/38090206/linking-intels-math-kernel-library-
>> mkl-to-r-on-windows>
>>
>> Is there a reason why CRAN doesn't provide a version of R with the updated
>> libraries such that developers don't have to recompile R or copy .dlls
>> around as described above? It would help those of us running software with
>> slow-running matrix calculations in R.
>>
>> Thanks,
>> Christine
>>
>> --
>> Christine C. Stawitz, PhD. (pronouns: she/her)
>>
>> National Stock Assessment Program Modeling Team
>>
>> NOAA Fisheries Office of Science and Technology |  U.S. Department of
>> Commerce
>>
>> Mobile: 206-617-2060
>>
>> www.fisheries.noaa.gov
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Dr. Benjamin Bolker
Professor, Mathematics & Statistics and Biology, McMaster University
Director, School of Computational Science and Engineering
(Acting) Graduate chair, Mathematics & Statistics
 > E-mail is sent at my convenience; I don't expect replies outside of 
working hours.


From @vr@h@m@@d|er @end|ng |rom gm@||@com  Sun Oct  2 01:52:39 2022
From: @vr@h@m@@d|er @end|ng |rom gm@||@com (Avraham Adler)
Date: Sat, 1 Oct 2022 19:52:39 -0400
Subject: [Rd] Linking to Intel's MKL on Windows
In-Reply-To: <13d28348-762f-c15a-4ece-980498e7e990@gmail.com>
References: <13d28348-762f-c15a-4ece-980498e7e990@gmail.com>
Message-ID: <DE8330EC-333A-4F4A-8333-035E1B9ECCA3@gmail.com>

Also, you can build Rblas against OpenBLAS even on Windows which will go far in speeding up matrix calculations. 

Thanks,

Avi

Sent from my iPhone

> On Oct 1, 2022, at 12:49 PM, Ben Bolker <bbolker at gmail.com> wrote:
> 
> ?   Maybe you can find out more about Microsoft's development/release process for MRO and why they're still on 4.0.2 (from June 2020)?  I followed the "user forum" link on their web page, but it appears to be a generic Windows forum ...
> 
> https://social.msdn.microsoft.com/Forums/en-US/home?forum%20=ropen
> 
>   I might tweet at @revodavid (David Smith) to see if there's any more information available about the MRO release schedule ...
> 
>  good luck,
>   Ben Bolker
> 
> 
> 
> 
>> On 2022-10-01 12:00 p.m., Viechtbauer, Wolfgang (NP) wrote:
>> Hi Christine,
>> MKL is a closed-source commercial product (yes, one can get it for free, but it is not libre/open-source software).
>> Best,
>> Wolfgang
>>> -----Original Message-----
>>> From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of Christine
>>> Stawitz - NOAA Federal via R-devel
>>> Sent: Friday, 30 September, 2022 18:46
>>> To: r-devel at r-project.org
>>> Subject: [Rd] Linking to Intel's MKL on Windows
>>> 
>>> Hi,
>>> 
>>> Recently I became aware that Microsoft R Open provides accelerated matrix
>>> algebra computations through Intel's Math Kernel Libraries. However, the
>>> version of R shipped with the Microsoft R Open is too out of date to be
>>> able to use concurrently with other dependencies while developing our
>>> package. This thread suggests a way to get the updated matrix libraries
>>> with a more recent version of R, however it is unlikely to be approved by
>>> our IT admin since those of us in government agencies aren't typically
>>> given admin privileges: Linking Intel's Math Kernel Library (MKL) to R on
>>> Windows - Stack Overflow
>>> <https://stackoverflow.com/questions/38090206/linking-intels-math-kernel-library-
>>> mkl-to-r-on-windows>
>>> 
>>> Is there a reason why CRAN doesn't provide a version of R with the updated
>>> libraries such that developers don't have to recompile R or copy .dlls
>>> around as described above? It would help those of us running software with
>>> slow-running matrix calculations in R.
>>> 
>>> Thanks,
>>> Christine
>>> 
>>> --
>>> Christine C. Stawitz, PhD. (pronouns: she/her)
>>> 
>>> National Stock Assessment Program Modeling Team
>>> 
>>> NOAA Fisheries Office of Science and Technology |  U.S. Department of
>>> Commerce
>>> 
>>> Mobile: 206-617-2060
>>> 
>>> www.fisheries.noaa.gov
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> -- 
> Dr. Benjamin Bolker
> Professor, Mathematics & Statistics and Biology, McMaster University
> Director, School of Computational Science and Engineering
> (Acting) Graduate chair, Mathematics & Statistics
> > E-mail is sent at my convenience; I don't expect replies outside of working hours.
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @uh@rto_@nggono @end|ng |rom y@hoo@com  Sun Oct  2 10:42:50 2022
From: @uh@rto_@nggono @end|ng |rom y@hoo@com (Suharto Anggono Suharto Anggono)
Date: Sun, 2 Oct 2022 08:42:50 +0000 (UTC)
Subject: [Rd] as.character.POSIXt in R devel
References: <1454067819.3486826.1664700170912.ref@mail.yahoo.com>
Message-ID: <1454067819.3486826.1664700170912@mail.yahoo.com>

With?r82904,?'as.character.POSIXt'?in?R?devel?is?changed.?The?NEWS?item:
as.character(<POSIXt>)?now?behaves?more?in?line?with?the
???methods?for?atomic?vectors?such?as?numbers,?and?is?no?longer
???influenced?by?options().

Part?of?the?code:

???????s?<-?trunc(x$sec)
????????fs?<-?x$sec?-?s
????????r1?<-?sprintf("%d-%02d-%02d",?1900?+?x$year,?x$mon+1L,?x$mday)
??????if(any(n0?<-?time?!=?0))?#?add?time?if?not?0
????????????r1[n0]?<-?paste(r1[n0],
????????????????????????sprintf("%02d:%02d:%02d%s",?x$hour[n0],?x$min[n0],?s[n0],
????????????????????????????????substr(as.character(fs[n0]),?2L,?32L)))


*?Wrong:
The?result?is?wrong?when?as.character(fs[n0])?has?scientific?notation.
Example?(modified?from?https://bugs.r-project.org/show_bug.cgi?id=9819):
op?<-?options(scipen?=?0,?OutDec?=?".")?#?(default?setting)
x?<-?as.POSIXlt("2007-07-27?16:11:03.000002")
as.character(x)
#?"2007-07-27?16:11:03.99999999983547e-06"
as.character(x$sec?-?trunc(x$sec))
#?"1.99999999983547e-06"
options(op)

'as.character.POSIXt'?could?temporarily?set?option?'scipen'?large?enough?to?prevent?scientific?notation?in?as.character(fs[n0])?.


*?Too?much?precision:
In?some?cases?with?fractional?seconds?with?seconds?close?to?60,?the?result?has?many?decimal?places?while?there?is?an?accurate?representation?with?less?decimal?places.?It?is?actually?OK,?just?unpleasant.
Example?(modified?from?https://bugs.r-project.org/show_bug.cgi?id=14693):
op?<-?options(scipen?=?0,?OutDec?=?".")?#?(default?setting)
x?<-?as.POSIXlt("2011-10-01?12:34:56.3")
x$sec?==?56.3?#?TRUE
print(x$sec,?17)
#?[1]?56.299999999999997
as.character(x)
#?"2011-10-01?12:34:56.299999999999997"
format(x,?"%Y-%m-%d?%H:%M:%OS1")?#?short?and?accurate
#?"2011-10-01?12:34:56.3"
ct?<-?as.POSIXct(x,?tz?=?"UTC")
identical(ct,
as.POSIXct("2011-10-01?12:34:56.3",?tz?=?"UTC"))
#?TRUE
print(as.numeric(ct),?17)
#?[1]?1317472496.3
lct?<-?as.POSIXlt(ct)
lct$sec?==?56.3?#?FALSE
print(lct$sec,?17)
#?[1]?56.299999952316284
as.character(ct)
#?"2011-10-01?12:34:56.299999952316284"
options(op)

The?"POSIXct"?case?is?a?little?different?because?some?precision?is?already?lost?after?converted?to?"POSIXct".

In?'as.character.POSIXt',?using?'as.character'?on?the?seconds?(not?separating?the?fractional?part)?might?be?good?enough,?but?a?leading?zero?must?be?added?as?necessary.


*?Different?from?'format':

-?With?fractional?seconds,?the?result?is?influenced?by?option?'OutDec'.

-?From?"Printing?years"?in??strptime:?"For?years?0?to?999?most?OSes?pad?with?zeros?or?spaces?to?4?characters,?and?Linux?outputs?just?the?number."
Because?(1900?+?x$year)?is?formatted?with?%d?in?'as.character.POSIXt',?years?0?to?999?is?output?without?padding.?It?is?different?from?'format'?in?OSes?other?than?Linux.


*?Behavior?with?"improper"?"POSIXlt"?object:

-?"POSIXlt"?object?with?out-of-bounds?components?is?not?normalized.
Example?(modified?from?regr.tests-1d.R):
op?<-?options(scipen?=?0)?#?(default?setting)
x?<-?structure(
list(sec?=?10000,?min?=?59L,?hour?=?18L,
mday?=?6L,?mon?=?11L,?year?=?116L,
wday?=?2L,?yday?=?340L,
isdst?=?0L,?zone?=?"CET",?gmtoff?=?3600L),
class?=?c("POSIXlt",?"POSIXt"),?tzone?=?"CET")
as.character(x)
#?"2016-12-06?18:59:10000"
format(x)
#?"2016-12-06?21:45:40"
options(op)

-?With?"POSIXlt"?object?where?sec,?min,?hour,?mday,?mon,?and?year?components?are?not?all?of?the?same?length,?recycling?is?not?handled.
Example?(modified?from?regr.tests-1d.R):
op?<-?options(scipen?=?0)?#?(default?setting)
x?<-?structure(
list(sec?=?c(1,??2),?min?=?59L,?hour?=?18L,
mday?=?6L,?mon?=?11L,?year?=?116L,
wday?=?2L,?yday?=?340L,
isdst?=?0L,?zone?=?"CET",?gmtoff?=?3600L),
class?=?c("POSIXlt",?"POSIXt"),?tzone?=?"CET")
as.character(x)
#?c("2016-12-06?18:59:01",?"NA?NA:NA:02")
format(x)
#?c("2016-12-06?18:59:01",?"2016-12-06?18:59:02")
options(op)


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Mon Oct  3 13:17:58 2022
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Mon, 3 Oct 2022 13:17:58 +0200
Subject: [Rd] as.character.POSIXt in R devel
In-Reply-To: <1454067819.3486826.1664700170912@mail.yahoo.com>
References: <1454067819.3486826.1664700170912.ref@mail.yahoo.com>
 <1454067819.3486826.1664700170912@mail.yahoo.com>
Message-ID: <25402.50406.857046.262247@stat.math.ethz.ch>

>>>>> Suharto Anggono Suharto Anggono via R-devel 
>>>>>     on Sun, 2 Oct 2022 08:42:50 +0000 (UTC) writes:

    > With r82904, 'as.character.POSIXt' in R devel is changed. The NEWS item:
    > as.character(<POSIXt>) now behaves more in line with the
    >    methods for atomic vectors such as numbers, and is no longer
    >    influenced by options().

    > Part of the code:

    >        s <- trunc(x$sec)         fs <- x$sec - s
    >         r1 <- sprintf("%d-%02d-%02d", 1900 + x$year, x$mon+1L, x$mday)
    >       if(any(n0 <- time != 0)) # add time if not 0
    >             r1[n0] <- paste(r1[n0],
    >                         sprintf("%02d:%02d:%02d%s", x$hour[n0], x$min[n0], s[n0],
    >                                 substr(as.character(fs[n0]), 2L, 32L)))


    > * Wrong:
    > The result is wrong when as.character(fs[n0]) has scientific notation.
    > Example (modified from https://bugs.r-project.org/show_bug.cgi?id=9819):
    > op <- options(scipen = 0, OutDec = ".") # (default setting)
    > x <- as.POSIXlt("2007-07-27 16:11:03.000002")
    > as.character(x) # "2007-07-27 16:11:03.99999999983547e-06"
    > as.character(x$sec - trunc(x$sec))
    > # "1.99999999983547e-06" options(op)

    > 'as.character.POSIXt' could temporarily set option 'scipen' large enough to prevent scientific notation in as.character(fs[n0]) .


    > * Too much precision:
    > In some cases with fractional seconds with seconds close to 60, the result has many decimal places while there is an accurate representation with less decimal places. It is actually OK, just unpleasant.
    > Example (modified from https://bugs.r-project.org/show_bug.cgi?id=14693):
    > op <- options(scipen = 0, OutDec = ".") # (default setting)
    > x <- as.POSIXlt("2011-10-01 12:34:56.3")
    > x$sec == 56.3 # TRUE print(x$sec, 17)
    > # [1] 56.299999999999997 as.character(x)
    > # "2011-10-01 12:34:56.299999999999997"
    > format(x, "%Y-%m-%d %H:%M:%OS1") # short and accurate
    > # "2011-10-01 12:34:56.3" ct <- as.POSIXct(x, tz = "UTC")
    > identical(ct,
    > as.POSIXct("2011-10-01 12:34:56.3", tz = "UTC")) # TRUE
    > print(as.numeric(ct), 17) # [1] 1317472496.3
    > lct <- as.POSIXlt(ct) lct$sec == 56.3 # FALSE
    > print(lct$sec, 17) # [1] 56.299999952316284
    > as.character(ct) # "2011-10-01 12:34:56.299999952316284"
    > options(op)

    > The "POSIXct" case is a little different because some precision is already lost after converted to "POSIXct".

    > In 'as.character.POSIXt', using 'as.character' on the seconds (not separating the fractional part) might be good enough, but a leading zero must be added as necessary.


    > * Different from 'format':

    > - With fractional seconds, the result is influenced by option 'OutDec'.

    > - From "Printing years" in ?strptime: "For years 0 to 999 most OSes pad with zeros or spaces to 4 characters, and Linux outputs just the number."
    > Because (1900 + x$year) is formatted with %d in 'as.character.POSIXt', years 0 to 999 is output without padding. It is different from 'format' in OSes other than Linux.


    > * Behavior with "improper" "POSIXlt" object:

    > - "POSIXlt" object with out-of-bounds components is not normalized.
    > Example (modified from regr.tests-1d.R):
    > op <- options(scipen = 0) # (default setting)
    > x <- structure( list(sec = 10000, min = 59L, hour = 18L,
    > mday = 6L, mon = 11L, year = 116L, wday = 2L, yday = 340L,
    > isdst = 0L, zone = "CET", gmtoff = 3600L),
    > class = c("POSIXlt", "POSIXt"), tzone = "CET")
    > as.character(x) # "2016-12-06 18:59:10000" format(x)
    > # "2016-12-06 21:45:40" options(op)

    > - With "POSIXlt" object where sec, min, hour, mday, mon, and year components are not all of the same length, recycling is not handled.
    > Example (modified from regr.tests-1d.R):
    > op <- options(scipen = 0) # (default setting)
    > x <- structure(
    > list(sec = c(1,  2), min = 59L, hour = 18L,
    > mday = 6L, mon = 11L, year = 116L, wday = 2L, yday = 340L,
    > isdst = 0L, zone = "CET", gmtoff = 3600L),
    > class = c("POSIXlt", "POSIXt"), tzone = "CET")
    > as.character(x) # c("2016-12-06 18:59:01", "NA NA:NA:02")
    > format(x)
    > # c("2016-12-06 18:59:01", "2016-12-06 18:59:02")
    > options(op)

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Mon Oct  3 14:46:08 2022
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Mon, 3 Oct 2022 14:46:08 +0200
Subject: [Rd] as.character.POSIXt in R devel
In-Reply-To: <1454067819.3486826.1664700170912@mail.yahoo.com>
References: <1454067819.3486826.1664700170912.ref@mail.yahoo.com>
 <1454067819.3486826.1664700170912@mail.yahoo.com>
Message-ID: <25402.55696.329918.913605@stat.math.ethz.ch>


>>>>> Suharto Anggono Suharto Anggono via R-devel 
>>>>>     on Sun, 2 Oct 2022 08:42:50 +0000 (UTC) writes:

    > With r82904, 'as.character.POSIXt' in R devel is changed. The NEWS item:

    >   as.character(<POSIXt>) now behaves more in line with the
    >   methods for atomic vectors such as numbers, and is no longer
    >   influenced by options().

    > Part of the code:
    > 
    >   s <- trunc(x$sec)
    >   fs <- x$sec - s
    >   r1 <- sprintf("%d-%02d-%02d", 1900 + x$year, x$mon+1L, x$mday)
    >   if(any(n0 <- time != 0)) # add time if not 0
    >     r1[n0] <- paste(r1[n0],
    >                  sprintf("%02d:%02d:%02d%s", x$hour[n0], x$min[n0], s[n0],
    >                         substr(as.character(fs[n0]), 2L, 32L)))


    > * Wrong:

    > The result is wrong when as.character(fs[n0]) has scientific notation.

yes, you are right.  This is a lapsus I will fix.

    > Example (modified from https://bugs.r-project.org/show_bug.cgi?id=9819):
    > op <- options(scipen = 0, OutDec = ".") # (default setting)
    > x <- as.POSIXlt("2007-07-27 16:11:03.000002")
    > as.character(x)
    > # "2007-07-27 16:11:03.99999999983547e-06"
    > as.character(x$sec - trunc(x$sec))
    > # "1.99999999983547e-06"
    > options(op)

    > 'as.character.POSIXt' could temporarily set option 'scipen' large enough to prevent scientific notation in as.character(fs[n0]) .

Yes, something like that.


    > * Too much precision:

    > In some cases with fractional seconds with seconds close to 60, the result has many decimal places while there is an accurate representation with less decimal places. It is actually OK, just unpleasant.

I agree that is unpleasant.
To someone else I had written that we also may need to improve
the number of decimals shown here.
The design has been that it should be "full precision"
as it is for  as.character(<numbers>)

Now, we know that POSIXct cannot be very precise (in its
fractional seconds) but that is very different for POSIXlt where
fractional seconds may have 14 digits after the decimal point.

Ideally we could *store* with the POSIXlt object if it was
produced from a POSIXct one, and hence have only around 6 valid digits
(after the dec.) or not.  As we cannot currently store/save that
info, we kept using "full" precision which may be much more than
is sensible.

    > Example (modified from https://bugs.r-project.org/show_bug.cgi?id=14693):
    > op <- options(scipen = 0, OutDec = ".") # (default setting)
    > x <- as.POSIXlt("2011-10-01 12:34:56.3")
    > x$sec == 56.3 # TRUE

[which may be typical, but may also be platform dependent]

    > print(x$sec, 17)
    > # [1] 56.299999999999997
    > as.character(x)
    > # "2011-10-01 12:34:56.299999999999997"
    > format(x, "%Y-%m-%d %H:%M:%OS1") # short and accurate
    > # "2011-10-01 12:34:56.3"
    > ct <- as.POSIXct(x, tz = "UTC")
    > identical(ct,
    > as.POSIXct("2011-10-01 12:34:56.3", tz = "UTC"))
    > # TRUE
    > print(as.numeric(ct), 17)
    > # [1] 1317472496.3
    > lct <- as.POSIXlt(ct)
    > lct$sec == 56.3 # FALSE
    > print(lct$sec, 17)
    > # [1] 56.299999952316284
    > as.character(ct)
    > # "2011-10-01 12:34:56.299999952316284"
    > options(op)

    > The "POSIXct" case is a little different because some precision is already lost after converted to "POSIXct".

yes, indeed.

    > In 'as.character.POSIXt', using 'as.character' on the seconds (not separating the fractional part) might be good enough, but a leading zero must be added as necessary.

I think you are right: that may definitely better...

    > * Different from 'format':

    > - With fractional seconds, the result is influenced by option 'OutDec'.

Thank you.  I was not aware of that.
The reason "of course" being that  as.character(<numeric>)  is
*also* depending on option  OutDec.

I would say that is clearly wrong...  and I think we should
strongl consider to change that:

'OutDec' should influence print()ing and format()ing  but should
*not* influence  as.character()  at least not for basic R types/objects.


    > - From "Printing years" in ?strptime: "For years 0 to 999 most OSes pad with zeros or spaces to 4 characters, and Linux outputs just the number."
    > Because (1900 + x$year) is formatted with %d in 'as.character.POSIXt', years 0 to 999 is output without padding. It is different from 'format' in OSes other than Linux.

Good point.  This should be  amended.



    > * Behavior with "improper" "POSIXlt" object:

    > - "POSIXlt" object with out-of-bounds components is not normalized.

    > Example (modified from regr.tests-1d.R):
    > op <- options(scipen = 0) # (default setting)
    > x <- structure(
    > list(sec = 10000, min = 59L, hour = 18L,
    > mday = 6L, mon = 11L, year = 116L,
    > wday = 2L, yday = 340L,
    > isdst = 0L, zone = "CET", gmtoff = 3600L),
    > class = c("POSIXlt", "POSIXt"), tzone = "CET")
    > as.character(x)
    > # "2016-12-06 18:59:10000"
    > format(x)
    > # "2016-12-06 21:45:40"
    > options(op)


Yes, we knew that  and were not too happy about it, but also not
too unhappy:
After all,		    help(DateTimeClasses)
clearly explains how
POSIXlt objects should look like :

-------------------------------------------------------------------
  Class ?"POSIXlt"? is a named list of vectors representing

     ?sec? 0-61: seconds.
     ?min? 0-59: minutes.
     ?hour? 0-23: hours.
     ?mday? 1-31: day of the month
     ?mon? 0-11: months after the first of the year.
     ?year? years since 1900.
     ?wday? 0-6 day of the week, starting on Sunday.
     ?yday? 0-365: day of the year (365 only in leap years).

     ?isdst? Daylight Saving Time ... ... ...
     ................................
     ................................

-------------------------------------------------------------------

We have been aware that as.character() assumes the above specification,
even though other R functions, notably format() which uses
internal (C level; either system (OS) or R's own) strptime() do
arithmetic (modulo 60, then modulo 24, then modulo month length)
to compute the date "used".

Allowing such  "un-normalized" / out-of-bound  POSIXlt objects
in R has not been documented AFAICS, and has the consequence
that two different POSIXlt objects may correspond to the exact
same time. 

This may be something worth discussing.
In some sense we are discussing how the "POSIXlt" class is defined
(even though an S3 class is never formally defined).



    > - With "POSIXlt" object where sec, min, hour, mday, mon,
    > and year components are not all of the same length, recycling is not handled.

Good point.  I tend to agree that this should be improved *and* also
documented: AFAIK, it is also not at all documented  (or is it ??)
that the POSIXlt components should be thought to be recycling.

If we decide we want that, 
once this is documented (and all methods/functions tested with
such POSIXlt) it could also be used to use considerably smaller size
POSIXlt objects, e.g, when all parts are in the same year, or
when all seconds are 0, or ...

    > Example (modified from regr.tests-1d.R):
    > op <- options(scipen = 0) # (default setting)
    > x <- structure(
    > list(sec = c(1,  2), min = 59L, hour = 18L,
    > mday = 6L, mon = 11L, year = 116L,
    > wday = 2L, yday = 340L,
    > isdst = 0L, zone = "CET", gmtoff = 3600L),
    > class = c("POSIXlt", "POSIXt"), tzone = "CET")
    > as.character(x)
    > # c("2016-12-06 18:59:01", "NA NA:NA:02")
    > format(x)
    > # c("2016-12-06 18:59:01", "2016-12-06 18:59:02")
    > options(op)


Thank you for your careful analysis and feedback
on this future R behavior !

Best regards,
Martin


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Mon Oct  3 18:58:48 2022
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Mon, 3 Oct 2022 18:58:48 +0200
Subject: [Rd] as.character.POSIXt in R devel
In-Reply-To: <25402.55696.329918.913605@stat.math.ethz.ch>
References: <1454067819.3486826.1664700170912.ref@mail.yahoo.com>
 <1454067819.3486826.1664700170912@mail.yahoo.com>
 <25402.55696.329918.913605@stat.math.ethz.ch>
Message-ID: <25403.5320.335656.447541@stat.math.ethz.ch>

>>>>> Martin Maechler 
>>>>>     on Mon, 3 Oct 2022 14:46:08 +0200 writes:

>>>>> Suharto Anggono Suharto Anggono via R-devel 
>>>>>     on Sun, 2 Oct 2022 08:42:50 +0000 (UTC) writes:

    >> With r82904, 'as.character.POSIXt' in R devel is changed. The NEWS item:

    >> as.character(<POSIXt>) now behaves more in line with the
    >> methods for atomic vectors such as numbers, and is no longer
    >> influenced by options().

 [..............]

    >> * Wrong:

    >> The result is wrong when as.character(fs[n0]) has scientific notation.

    > yes, you are right.  This is a lapsus I will fix.

    >> Example (modified from https://bugs.r-project.org/show_bug.cgi?id=9819):
    >> op <- options(scipen = 0, OutDec = ".") # (default setting)
    >> x <- as.POSIXlt("2007-07-27 16:11:03.000002")
    >> as.character(x)
    >> # "2007-07-27 16:11:03.99999999983547e-06"
    >> as.character(x$sec - trunc(x$sec))
    >> # "1.99999999983547e-06"
    >> options(op)

    >> 'as.character.POSIXt' could temporarily set option 'scipen' large enough to prevent scientific notation in as.character(fs[n0]) .

    > Yes, something like that.

I have committed a version now of datetime.R,  svn rev 83010 ,
which does no longer depend on  'OutDec' (but gets such argument)
and which has a new 'digits' argument which defaults
to 14 for POSIXlt and
to  6 for POSIXct  .. but the user can choose a different value.

Also, it now uses the equivalent of  as.character(round(x$sec, digits))
(in case the seconds need to be shown)  which also solves the
following  "too much precision"  problem.

    >> * Too much precision:

    >> In some cases with fractional seconds with seconds close to 60, the result has many decimal places while there is an accurate representation with less decimal places. It is actually OK, just unpleasant.

    > I agree that is unpleasant.
    > To someone else I had written that we also may need to improve
    > the number of decimals shown here.
    > The design has been that it should be "full precision"
    > as it is for  as.character(<numbers>)

    > Now, we know that POSIXct cannot be very precise (in its
    > fractional seconds) but that is very different for POSIXlt where
    > fractional seconds may have 14 digits after the decimal point.

    > Ideally we could *store* with the POSIXlt object if it was
    > produced from a POSIXct one, and hence have only around 6 valid digits
    > (after the dec.) or not.  As we cannot currently store/save that
    > info, we kept using "full" precision which may be much more than
    > is sensible.

    >> Example (modified from https://bugs.r-project.org/show_bug.cgi?id=14693):
    >> op <- options(scipen = 0, OutDec = ".") # (default setting)
    >> x <- as.POSIXlt("2011-10-01 12:34:56.3")
    >> x$sec == 56.3 # TRUE

    > [which may be typical, but may also be platform dependent]

    >> print(x$sec, 17)
    >> # [1] 56.299999999999997
    >> as.character(x)
    >> # "2011-10-01 12:34:56.299999999999997"
    >> format(x, "%Y-%m-%d %H:%M:%OS1") # short and accurate
    >> # "2011-10-01 12:34:56.3"
    >> ct <- as.POSIXct(x, tz = "UTC")
    >> identical(ct,
    >> as.POSIXct("2011-10-01 12:34:56.3", tz = "UTC"))
    >> # TRUE
    >> print(as.numeric(ct), 17)
    >> # [1] 1317472496.3
    >> lct <- as.POSIXlt(ct)
    >> lct$sec == 56.3 # FALSE
    >> print(lct$sec, 17)
    >> # [1] 56.299999952316284
    >> as.character(ct)
    >> # "2011-10-01 12:34:56.299999952316284"
    >> options(op)

    >> The "POSIXct" case is a little different because some precision is already lost after converted to "POSIXct".

    > yes, indeed.

    >> In 'as.character.POSIXt', using 'as.character' on the seconds (not separating the fractional part) might be good enough, but a leading zero must be added as necessary.

    > I think you are right: that may definitely better...

indeed; part of my commit.

    >> * Different from 'format':

    >> - With fractional seconds, the result is influenced by option 'OutDec'.

this has been solved, too.
For the "freaks" allowing an explicit  'OutDec = *' argument
but *not* with default depending on options()!


    > Thank you.  I was not aware of that.
    > The reason "of course" being that  as.character(<numeric>)  is
    > *also* depending on option  OutDec.

    > I would say that is clearly wrong...  and I think we should
    > strongl consider to change that:

    > 'OutDec' should influence print()ing and format()ing  but should
    > *not* influence  as.character()  at least not for basic R types/objects.


    >> - From "Printing years" in ?strptime: "For years 0 to 999 most OSes pad with zeros or spaces to 4 characters, and Linux outputs just the number."
    >> Because (1900 + x$year) is formatted with %d in 'as.character.POSIXt', years 0 to 999 is output without padding. It is different from 'format' in OSes other than Linux.

    > Good point.  This should be  amended.

Not yet.  Actually, I'm no longer sure this needs any action.
I find it somewhat natural that

> (CharleMagne.crowned <- as.POSIXlt(ISOdate(774,7,10)))
[1] "774-07-10 12:00:00 GMT"
> as.character(CharleMagne.crowned)
[1] "774-07-10 12:00:00"



    >> * Behavior with "improper" "POSIXlt" object:

    >> - "POSIXlt" object with out-of-bounds components is not normalized.

    >> Example (modified from regr.tests-1d.R):
    >> op <- options(scipen = 0) # (default setting)
    >> x <- structure(
    >> list(sec = 10000, min = 59L, hour = 18L,
    >> mday = 6L, mon = 11L, year = 116L,
    >> wday = 2L, yday = 340L,
    >> isdst = 0L, zone = "CET", gmtoff = 3600L),
    >> class = c("POSIXlt", "POSIXt"), tzone = "CET")
    >> as.character(x)
    >> # "2016-12-06 18:59:10000"
    >> format(x)
    >> # "2016-12-06 21:45:40"
    >> options(op)


    > Yes, we knew that  and were not too happy about it, but also not
    > too unhappy:
    > After all,		    help(DateTimeClasses)
    > clearly explains how
    > POSIXlt objects should look like :

    > -------------------------------------------------------------------
    > Class ?"POSIXlt"? is a named list of vectors representing

    > ?sec? 0-61: seconds.
    > ?min? 0-59: minutes.
    > ?hour? 0-23: hours.
    > ?mday? 1-31: day of the month
    > ?mon? 0-11: months after the first of the year.
    > ?year? years since 1900.
    > ?wday? 0-6 day of the week, starting on Sunday.
    > ?yday? 0-365: day of the year (365 only in leap years).

    > ?isdst? Daylight Saving Time ... ... ...
    > ................................
    > ................................

    > -------------------------------------------------------------------

    > We have been aware that as.character() assumes the above specification,
    > even though other R functions, notably format() which uses
    > internal (C level; either system (OS) or R's own) strptime() do
    > arithmetic (modulo 60, then modulo 24, then modulo month length)
    > to compute the date "used".

    > Allowing such  "un-normalized" / out-of-bound  POSIXlt objects
    > in R has not been documented AFAICS, and has the consequence
    > that two different POSIXlt objects may correspond to the exact
    > same time. 

    > This may be something worth discussing.
    > In some sense we are discussing how the "POSIXlt" class is defined
    > (even though an S3 class is never formally defined).

(nothing changed here)


    >> - With "POSIXlt" object where sec, min, hour, mday, mon,
    >> and year components are not all of the same length, recycling is not handled.

This is still the case... (see below).

    > Good point.  I tend to agree that this should be improved *and* also
    > documented: AFAIK, it is also not at all documented  (or is it ??)
    > that the POSIXlt components should be thought to be recycling.

    > If we decide we want that, 
    > once this is documented (and all methods/functions tested with
    > such POSIXlt) it could also be used to use considerably smaller size
    > POSIXlt objects, e.g, when all parts are in the same year, or
    > when all seconds are 0, or ...

    >> Example (modified from regr.tests-1d.R):
    >> op <- options(scipen = 0) # (default setting)
    >> x <- structure(
    >> list(sec = c(1,  2), min = 59L, hour = 18L,
    >> mday = 6L, mon = 11L, year = 116L,
    >> wday = 2L, yday = 340L,
    >> isdst = 0L, zone = "CET", gmtoff = 3600L),
    >> class = c("POSIXlt", "POSIXt"), tzone = "CET")
    >> as.character(x)
    >> # c("2016-12-06 18:59:01", "NA NA:NA:02")
    >> format(x)
    >> # c("2016-12-06 18:59:01", "2016-12-06 18:59:02")
    >> options(op)

Note that currently such {needing recycling} - cases are
*also* not handled by the simple  (and important!)  length.POSIXlt()
method, either:  It currently only looks at the '.$sec'
component !

So this case does need discussion two.
I think it's unfortunate that *some* *.POSIXt methods do such
recycling, e.g. format.POSIXt,
but others do not {and the documentation does not even mention recycling}.

As mentioned, I am *pro* going in that direction;
so I would change

  length.POSIXlt <- function(x) length(unclass(x)[[1L]])

       (which only uses x$sec !)

to

  length.POSIXlt <- function(x) max(lengths(unclass(x), use.names=FALSE))

not allowing 0-length recycling; 0-lengths components
should really be illegal in an otherwise non-0-length POSIXlt x


Martin


From p@u| @end|ng |rom @t@t@@uck|@nd@@c@nz  Mon Oct  3 22:20:50 2022
From: p@u| @end|ng |rom @t@t@@uck|@nd@@c@nz (Paul Murrell)
Date: Tue, 4 Oct 2022 09:20:50 +1300
Subject: [Rd] Question about grid.group compositing operators in cairo
In-Reply-To: <197c7a88-fb1c-49e1-7fc9-c1605abfef95@stat.auckland.ac.nz>
References: <0eaac5fb-b749-1470-c2a7-9f2f8215ace9@posteo.net>
 <c3debb04-04b8-90e8-2315-392105cd9db6@stat.auckland.ac.nz>
 <f581c979-44f0-3dc3-2c6f-015c2651b19c@stat.auckland.ac.nz>
 <6d240042-2017-a760-28d7-bf96d773fd90@posteo.net>
 <3e245b89-9c4f-dcbc-b310-5d3a25687af2@stat.auckland.ac.nz>
 <159821f0-0fc6-9054-c6bc-185102114e68@posteo.net>
 <c92574d5-f064-39c1-5fb4-05242607f19a@stat.auckland.ac.nz>
 <197c7a88-fb1c-49e1-7fc9-c1605abfef95@stat.auckland.ac.nz>
Message-ID: <543be111-1ed2-24ad-51ca-4849a67a49eb@stat.auckland.ac.nz>


Interim update:  I have spoken with Thomas Lin Pedersen (cc'ed), the 
author/maintainer of 'ragg' and 'svglite', who is working on adding 
group support for those graphics devices and he has voted in support of 
the current Cairo implementation, so the needle has shifted towards 
Cairo at this stage.

I still want to do more tests on other devices to gather more evidence.

Paul

p.s.  Attached (if it makes it through the filters) is a manual 
modification of your original dsvg() example that has been changed so 
that it produces the Cairo result.  This is probably not exactly how you 
would want to implement the dsvg() solution, but it is at least a proof 
of concept that the Cairo result can be produced in SVG.

On 30/09/22 10:49, Paul Murrell wrote:
> Hi
> 
> Some more thoughts ...
> 
> <1>
> I said before that currently, dev->group() does this ...
> 
> [OVER] shape shape shape OP shape shape shape
> 
> ... and one option would be an implicit group on 'src' and 'dst' like 
> this ...
> 
> ([OVER] shape shape shape) OP ([OVER] shape shape shape)
> 
> ... but another approach could be just an implicit group on each shape, 
> like this ...
> 
> [OVER] ([OVER] shape) ([OVER] shape) OP ([OVER] shape) ([OVER] shape)
> 
> That may be a better representation of what you are already doing with 
> dsvg() ?? It may also better reflect what naturally occurs in some 
> graphics systems.
> 
> <2>
> Changing the Cairo implementation to work like that would I think 
> produce the same result as your dsvg() for ...
> 
> grid.group(src, "in", dst)
> 
> ... and it would make what constitutes more than one shape much less 
> surprising ...
> 
> gList(rectGrob(), rectGrob())? ## multiple shapes (obviously)
> rectGrob(width=1:2/2)????????? ## multiple shapes (less obvious)
> rectGrob(gp=gpar(col=, fill=)) ## NOT multiple shapes (no surprise)
> 
> ... and it should not break any pre-existing non-group behaviour.
> 
> <3>
> One casualty from this third option would be that the following would no 
> longer solve the overlapping fill and stroke problem ...
> 
> grid.group(overlapRect, "source")
> 
> ... although the fact that that currently works is really a bit 
> surprising AND that result could still be achieved by explicitly drawing 
> separate shapes ...
> 
> grid.group(rectGrob(gp=gpar(col=rgb(1,0,0,.5), lwd=20, fill=NA)),
>  ?????????? "source",
>  ?????????? rectGrob(gp=gpar(col=NA, fill="green")))
> 
> <4>
> I need to try some of this out and also check in with some other people 
> who I think are working on implementing groups on different graphics 
> devices.
> 
> <5>
> In summary, don't go changing dsvg() too much just yet!
> 
> Paul
> 
> On 29/09/2022 1:30 pm, Paul Murrell wrote:
>> Hi
>>
>> Would it work to explicitly record a filled-and-stroked shape as two 
>> separate elements (one only filled and one only stroked) ?
>>
>> Then it should only be as hard to apply the active operator on both of 
>> those elements as it is to apply the active operator to more than one 
>> shape (?)
>>
>> Paul
>>
>> On 29/09/22 10:17, Panagiotis Skintzos wrote:
>>> Thank you for the very thorough explanation Paul.
>>>
>>> To answer your question on 11: The dsvg device, simply defines svg
>>> elements with their attributes (rect with fill & stroke in my examples).
>>> It does not do any internal image processing like cairo.
>>>
>>> My concern is how to proceed with the implementation in dsvg.
>>>
>>> If I leave it as it is now, they're will be cases where it will give
>>> different results from cairo (and perhaps other devices that will
>>> implement group compositing in similar way).
>>>
>>> On the other hand It would be quite challenging in practice to simulate
>>> the cairo implementation and apply first the fill and then the stroke
>>> with the active operator, on the element itself.
>>>
>>> Any suggestions? :-)
>>>
>>> Panagiotis
>>>
>>>
>>> On 28/9/22 02:56, Paul Murrell wrote:
>>> ?> Hi
>>> ?>
>>> ?> Thanks for the code (and for the previous attachments).
>>> ?>
>>> ?> Some thoughts so far (HTML version with images attached) ...
>>> ?>
>>> ?> <1>
>>> ?> As you have pointed out, the Cairo device draws a stroked-and-filled
>>> ?> shape with two separate drawing operations: the path is filled and
>>> ?> then the path is stroked.? I do not believe that there is any
>>> ?> alternative in Cairo graphics (apart from filling and stroking as an
>>> ?> isolated group and then drawing the group, which we will come back 
>>> to).
>>> ?>
>>> ?> <2>
>>> ?> This fill-then-stroke approach is easy to demonstrate just with a 
>>> thick
>>> ?> semitransparent border ...
>>> ?>
>>> ?> library(grid)
>>> ?> overlapRect <- rectGrob(width=.5, height=.5,
>>> ?> ??????????????????????? gp=gpar(fill="green", lwd=20,
>>> ?> ??????????????????????????????? col=rgb(1,0,0,.5)))
>>> ?> grid.newpage()
>>> ?> grid.draw(overlapRect)
>>> ?>
>>> ?> <3>
>>> ?> This fill-then-stroke approach is what happens on many (most?)
>>> ?> graphics devices, including, for example, the core windows() device,
>>> ?> the core quartz() device, the 'ragg' devices, and 'ggiraph'.? The
>>> ?> latter is true because this is actually the defined behaviour for 
>>> SVG ...
>>> ?>
>>> ?> https://www.w3.org/TR/SVG2/render.html#Elements 
>>> <https://www.w3.org/TR/SVG2/render.html#Elements>
>>> ?> https://www.w3.org/TR/SVG2/render.html#PaintingShapesAndText 
>>> <https://www.w3.org/TR/SVG2/render.html#PaintingShapesAndText>
>>> ?>
>>> ?> <4>
>>> ?> There are exceptions to the fill-then-stroke approach, including the
>>> ?> core pdf() device, but I think they are in the minority.? The PDF
>>> ?> language supports a "B" operator that only fills within the border 
>>> (no
>>> ?> overlap between fill and border).? Demonstrating this is complicated
>>> ?> by the fact that not all PDF viewers support this correctly (e.g.,
>>> ?> evince and Firefox do not;? ghostscript and chrome do)!
>>> ?>
>>> ?> <5>
>>> ?> Forcing all R graphics devices to change the rendering of
>>> ?> filled-and-stroked shapes to match the PDF definition instead of
>>> ?> fill-then-stroke is unlikely to happen because it would impact a lot
>>> ?> of graphics devices, it would break existing behaviour, it may be
>>> ?> difficult/impossible for some devices, and it is not clear that it is
>>> ?> the best approach anyway.
>>> ?>
>>> ?> <6>
>>> ?> Finally getting back to your example, the fill-then-stroke approach
>>> ?> produces some interesting results when applying compositing operators
>>> ?> because the fill is drawn using the compositing operator to 
>>> combine it
>>> ?> with previous drawing and then the stroke is drawn using the
>>> ?> compositing operator to combine it with *the result of combining the
>>> ?> fill with previous drawing*. The result makes sense in terms of how
>>> ?> the rendering works, but it probably fails the "principle of least
>>> ?> surprise".
>>> ?>
>>> ?> srcRect <- rectGrob(2/3, 1/3, width=.6, height=.6,
>>> ?> ??????????????????? gp=gpar(lwd = 5, fill=rgb(0, 0, 0.9, 0.4)))
>>> ?> dstRect <- rectGrob(1/3, 2/3, width=.6, height=.6,
>>> ?> ??????????????????? gp=gpar(lwd = 5, fill=rgb(0.7, 0, 0, 0.8)))
>>> ?> grid.newpage()
>>> ?> grid.group(srcRect, "in", dstRect)
>>> ?>
>>> ?> <7>
>>> ?> This issue is not entirely unanticipated because it can arise
>>> ?> slightly-less-unintentionally if we combine a 'src' and/or 'dst' that
>>> ?> draw more than one shape, like this ...
>>> ?>
>>> ?> src <- circleGrob(3:4/5, r=.2, gp=gpar(col=NA, fill=2))
>>> ?> dst <- circleGrob(1:2/5, r=.2, gp=gpar(col=NA, fill=3))
>>> ?> grid.newpage()
>>> ?> grid.group(src, "xor", dst)
>>> ?>
>>> ?> This was discussed in the Section "Compositing and blend modes" in 
>>> the
>>> ?> original technical report about groups and compositing ...
>>> ?>
>>> ?> 
>>> https://www.stat.auckland.ac.nz/~paul/Reports/GraphicsEngine/groups/groups.html#userdetails 
>>> <https://www.stat.auckland.ac.nz/~paul/Reports/GraphicsEngine/groups/groups.html#userdetails> 
>>>
>>> ?>
>>> ?>
>>> ?> <8>
>>> ?> A solution to the problem of drawing more than one shape (above) 
>>> is to
>>> ?> take explicit control of how shapes are combined, *using explicit
>>> ?> groups* ...
>>> ?>
>>> ?> grid.newpage()
>>> ?> grid.group(groupGrob(src), "xor", dst)
>>> ?>
>>> ?> <9>
>>> ?> Explicit groups can be used to solve the problem of overlapping fill
>>> ?> and stroke (here we specify that the rectangle border should be
>>> ?> combined with the rectangle fill using the "source" operator) ...
>>> ?>
>>> ?> grid.newpage()
>>> ?> grid.group(overlapRect, "source")
>>> ?>
>>> ?> <10>
>>> ?> Explicit groups can also be used to get the result that we might have
>>> ?> originally expected for the "in" operator example (here we isolate 
>>> the
>>> ?> 'src' rectangle so that the border and the fill are combined together
>>> ?> [using the default "over" operator] and then combined with the other
>>> ?> rectangle using the "in" operator) ...
>>> ?>
>>> ?> grid.newpage()
>>> ?> grid.group(groupGrob(srcRect), "in", dstRect)
>>> ?>
>>> ?> <11>
>>> ?> A possible change would be to force an implicit group (with op=OVER)
>>> ?> on the 'src' and 'dst' in dev->group().? I believe this is 
>>> effectively
>>> ?> what you are doing with your dsvg() device (?).
>>> ?>
>>> ?> Currently, dev->group() does this ...
>>> ?>
>>> ?> [OVER] shape shape shape OP shape shape shape
>>> ?>
>>> ?> ... and an implicit group on 'src' and 'dst' would do this ...
>>> ?>
>>> ?> ([OVER] shape shape shape) OP ([OVER] shape shape shape)
>>> ?>
>>> ?> An implicit (OVER) group would make it easier to combine multiple
>>> ?> shapes with OVER (though only slightly) ...
>>> ?>
>>> ?> grid.group(src, OP, dst)
>>> ?>
>>> ?> ... instead of ...
>>> ?>
>>> ?> grid.group(groupGrob(src), OP, dst)
>>> ?>
>>> ?> On the other hand, an implicit (OVER) group would make it harder to
>>> ?> combine multiple shapes with an operator other than OVER (by quite a
>>> ?> lot?) ...
>>> ?>
>>> ?> grid.group(groupGrob(shape, OP, groupGrob(shape, OP, shape)), OP, 
>>> dst)
>>> ?>
>>> ?> ... instead of ...
>>> ?>
>>> ?> grid.group(src, OP, dst)
>>> ?>
>>> ?> The complicating factor is that what constitutes more than one shape
>>> ?> (or drawing operation) can be unexpected ...
>>> ?>
>>> ?> gList(rectGrob(), rectGrob())? ## obvious
>>> ?> rectGrob(width=1:2/2)????????? ## less obvious
>>> ?> rectGrob(gp=gpar(col=, fill=)) ## a bit of a surprise
>>> ?>
>>> ?> <12>
>>> ?> In summary, while there is some temptation to add an implicit group
>>> ?> around 'src' and 'dst' in a group, there are also reasons not to.
>>> ?>
>>> ?> Happy to hear further arguments on this.
>>> ?>
>>> ?> Paul
>>> ?>
>>> ?> On 28/09/2022 8:04 am, Panagiotis Skintzos wrote:
>>> ?>> Here is the code again in text:
>>> ?>>
>>> ?>>
>>> ?>> src <- rectGrob(2/3, 1/3, width=.6, height=.6, gp=gpar(lwd = 5,
>>> ?>> fill=rgb(0, 0, 0.9, 0.4)))
>>> ?>> dst <- rectGrob(1/3, 2/3, width=.6, height=.6, gp=gpar(lwd = 5,
>>> ?>> fill=rgb(0.7, 0, 0, 0.8)))
>>> ?>>
>>> ?>> svg("cairo.in.svg", width = 5, height = 5)
>>> ?>> grid.group(src, "in", dst)
>>> ?>> dev.off()
>>> ?>>
>>> ?>>
>>> ?>>
>>> ?>> On 27/9/22 04:44, Paul Murrell wrote:
>>> ?>> ?>
>>> ?>> ?> Could you also please send me the SVG code that your device is
>>> ?>> ?> generating for your example.? Thanks!
>>> ?>> ?>
>>> ?>> ?> Paul
>>> ?>> ?>
>>> ?>> ?> On 27/09/22 08:50, Paul Murrell wrote:
>>> ?>> ?>> Hi
>>> ?>> ?>>
>>> ?>> ?>> Thanks for the report.? It certainly sounds like I have done
>>> ?>> ?>> something stupid :)? For my debugging and testing could you 
>>> please
>>> ?>> ?>> share the R code from your tests ?? Thanks!
>>> ?>> ?>>
>>> ?>> ?>> Paul
>>> ?>> ?>>
>>> ?>> ?>> On 26/09/22 10:27, Panagiotis Skintzos wrote:
>>> ?>> ?>>> Hello,
>>> ?>> ?>>>
>>> ?>> ?>>> I'm trying to update ggiraph package in graphic engine v15
>>> ?>> ?>>> (currently we support up to v14).
>>> ?>> ?>>>
>>> ?>> ?>>> I've implemented the group operators and when I compare the 
>>> outputs
>>> ?>> ?>>> of ggiraph::dsvg with the outputs of svg/png, I noticed some 
>>> weird
>>> ?>> ?>>> results.
>>> ?>> ?>>>
>>> ?>> ?>>> Specifically, some operators in cairo (in, out, dest.in, 
>>> dest.atop)
>>> ?>> ?>>> give strange output, when any source element in the group has a
>>> ?>> ?>>> stroke color defined.
>>> ?>> ?>>>
>>> ?>> ?>>> I attach three example images, where two stroked rectangles are
>>> ?>> used
>>> ?>> ?>>> as source (right) and destination (left).
>>> ?>> ?>>>
>>> ?>> ?>>> cairo.over.png shows the result of the over operator in cairo
>>> ?>> ?>>>
>>> ?>> ?>>> cairo.in.png shows the result of the in operator in cairo
>>> ?>> ?>>>
>>> ?>> ?>>> dsvg.in.png shows the result of the in operator in dsvg
>>> ?>> ?>>>
>>> ?>> ?>>>
>>> ?>> ?>>> You can see the difference between cairo.in.png and 
>>> dsvg.in.png. I
>>> ?>> ?>>> found out why I get different results:
>>> ?>> ?>>>
>>> ?>> ?>>> In dsvg implementation there is one drawing operation: Draw the
>>> ?>> ?>>> source element, as whole (fill and stroke) over the destination
>>> ?>> ?>>> element (using feComposite filter)
>>> ?>> ?>>>
>>> ?>> ?>>> In cairo implementation though there are two operations: 
>>> Apply the
>>> ?>> ?>>> fill on source and draw over the destination and then apply the
>>> ?>> ?>>> stroke and draw over the result of the previous operation.
>>> ?>> ?>>>
>>> ?>> ?>>> I'm not sure if this is intentional or not. Shouldn't the 
>>> source
>>> ?>> ?>>> element being drawn first as whole (fill and stroke with over
>>> ?>> ?>>> operator) and then apply the group operator and draw it over 
>>> the
>>> ?>> ?>>> destination? It would seem more logical that way.
>>> ?>> ?>>>
>>> ?>> ?>>>
>>> ?>> ?>>> Thanks,
>>> ?>> ?>>>
>>> ?>> ?>>> Panagiotis
>>> ?>> ?>>>
>>> ?>> ?>>>
>>> ?>> ?>>> ______________________________________________
>>> ?>> ?>>> R-devel at r-project.org mailing list
>>> ?>> ?>>> https://stat.ethz.ch/mailman/listinfo/r-devel 
>>> <https://stat.ethz.ch/mailman/listinfo/r-devel> 
>>>
>>> ?>> <https://stat.ethz.ch/mailman/listinfo/r-devel 
>>> <https://stat.ethz.ch/mailman/listinfo/r-devel>> 
>>>
>>> ?>> ?>>
>>> ?>> ?>
>>> ?>
>>
> 

-- 
Dr Paul Murrell
Te Kura Tatauranga | Department of Statistics
Waipapa Taumata Rau | The University of Auckland
Private Bag 92019, Auckland 1142, New Zealand
64 9 3737599 x85392
paul at stat.auckland.ac.nz
www.stat.auckland.ac.nz/~paul/

-------------- next part --------------
A non-text attachment was scrubbed...
Name: dsvg.in-mod-4.svg
Type: image/svg+xml
Size: 2034 bytes
Desc: not available
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20221004/f2475af8/attachment.svg>

