From ch|r|com @end|ng |rom goog|e@com  Wed Mar  1 10:36:02 2023
From: ch|r|com @end|ng |rom goog|e@com (Michael Chirico)
Date: Wed, 1 Mar 2023 01:36:02 -0800
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
Message-ID: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>

Consider:

x <- list(`a b` = 1)
x$a<tab>

(i.e., press the 'tab' key after typing 'x$a')

The auto-complete mechanism will fill the buffer like so:
x$a b

This is not particularly helpful because this is now a syntax error.

It seems to me there's a simple fix -- in
utils:::specialCompletions(), we can wrap the result of
utils:::specialOpCompletionsHelper() with backticks for non-syntactic
names ([1]):

comps <- specialOpCompletionsHelper(op, suffix, prefix)
if (length(comps) == 0L) comps <- ""
+non_syntactic <- make.names(comps) != comps
+comps[non_syntactic] <- paste0("`", comps[non_syntactic], "`")
sprintf("%s%s%s", prefix, op, comps)

I'm somewhat surprised this hasn't come up before (I searched for
'completeToken', 'specialCompletions', and
'specialOpCompletionsHelper' here and on Bugzilla), so I'm checking
with the list first if I'm missing anything before filing a patch.

Mike C

[1] https://github.com/r-devel/r-svn/blob/4657f65a377cb5ef318c6548bc264e3b0f9517a0/src/library/utils/R/completion.R#L536-L538


From kry|ov@r00t @end|ng |rom gm@||@com  Wed Mar  1 10:56:47 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Wed, 1 Mar 2023 12:56:47 +0300
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
Message-ID: <20230301125647.765cda59@arachnoid>

? Wed, 1 Mar 2023 01:36:02 -0800
Michael Chirico via R-devel <r-devel at r-project.org> ?????:

> +comps[non_syntactic] <- paste0("`", comps[non_syntactic], "`")

There are a few more corner cases. For example, comps could contain
backticks (which should be escaped with backslashes) and backslashes
(which should also be escaped). Thankfully, \uXXXX-style Unicode escape
sequences are not currently supported inside backticks, and "escape the
backslash" rule already takes care of them.

The deparse() function already knows these rules:

name <- 'hello world ` \\uFF'
cat(deparse1(as.name(name), backtick=TRUE), '\n')
# `hello world \` \\uFF`
`hello world \` \\uFF` <- 'hello'
`hello world \` \\uFF`
# [1] "hello"

-- 
Best regards,
Ivan


From @|@ergbox @end|ng |rom gm@||@com  Wed Mar  1 01:19:00 2023
From: @|@ergbox @end|ng |rom gm@||@com (Alexey Sergushichev)
Date: Tue, 28 Feb 2023 18:19:00 -0600
Subject: [Rd] Incorrect behavior of ks.test and psmirnov functions with
 exact=TRUE
Message-ID: <CAMGHQ95wXZ=LMVkUjDRsCJ_0P2VAbWnQrj-4_NvdXRGMuvVDvA@mail.gmail.com>

HI,

I've noticed what I think is an incorrect behavior of stats::psmirnov
function and consequently of ks.test when run in an exact mode.

For example:
psmirnov(1, sizes=c(50, 50), z=1:100, two.sided = FALSE, lower.tail = F,
exact=TRUE)

produces 2.775558e-15

However, the exact value should be 1/combination(100, 50), which is
9.9e-30. While the absolute error is small, the relative error is huge, and
it is not fixed by setting option log.p=T

To compare, SciPy has a correct implementation in scipy.stats.ks_2samp:
scipy.stats.ks_2samp(list(range(1,51)), list(range(51, 101)),
alternative="greater", method="exact")
returns 9.911653021418333e-30.

I've tried to dig in a bit and the problem comes down to how the final
value is calculated in psmirnov function:

    if (log.p & !lower.tail)
        return(log1p(-ret/exp(logdenom)))
    if (!log.p & !lower.tail)
        return(1 - ret/exp(logdenom))

There exp(logdenom) is a relatively good (but not perfect) approximation of
combination(100, 50) = 1.008913e+29, ret is also a good approximation of
combination(100, 50)-1 = 1.008913e+29 but there is not enough double
precision for 1 - ret/exp(logdenom) to capture 1/combination(100, 50).

I don't have time to provide a fix, at least not now, but I think this
behavior (good absolute error, but poor relative error for small values)
should at least be mentioned in the manual of the methods psmirnov and/or
ks.test

Best,
Alexey Sergushichev

	[[alternative HTML version deleted]]


From pd@me@ @end|ng |rom cb@@dk  Wed Mar  1 13:04:56 2023
From: pd@me@ @end|ng |rom cb@@dk (Peter Dalgaard)
Date: Wed, 1 Mar 2023 12:04:56 +0000
Subject: [Rd] R 4.2.3 scheduled for March 15
Message-ID: <0698828C-0FC0-421C-92DC-045717E4F7A2@cbs.dk>

Full schedule available on developer.r-project.org in a short while.

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From @nto|ne@|@br| @end|ng |rom gm@||@com  Wed Mar  1 13:53:21 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Wed, 1 Mar 2023 13:53:21 +0100
Subject: [Rd] confusing all.equal output
Message-ID: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>

dear r-devel,

This has probably been forever like this but is this satisfying ?

all.equal(c(1,NA,NA), c(1,NA,3))
#> [1] "'is.NA' value mismatch: 1 in current 2 in target"

is.NA() doesn't exist (is.na() does), and is.na() is never 1 or 2.

In this example it's obvious that we're counting missing values, in a
general situation I believe it isn't (we might understand it as the
position of the first NA for instance).

I would expect something like "'amount of missing values mismatch: 1 in
current 2 in target"

Thanks,

Antoine

	[[alternative HTML version deleted]]


From ch|r|com @end|ng |rom goog|e@com  Wed Mar  1 17:48:08 2023
From: ch|r|com @end|ng |rom goog|e@com (Michael Chirico)
Date: Wed, 1 Mar 2023 08:48:08 -0800
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <20230301125647.765cda59@arachnoid>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
Message-ID: <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>

Great suggestion! I've started a patch:
https://bugs.r-project.org/show_bug.cgi?id=18479

On Wed, Mar 1, 2023 at 1:56 AM Ivan Krylov <krylov.r00t at gmail.com> wrote:
>
> ? Wed, 1 Mar 2023 01:36:02 -0800
> Michael Chirico via R-devel <r-devel at r-project.org> ?????:
>
> > +comps[non_syntactic] <- paste0("`", comps[non_syntactic], "`")
>
> There are a few more corner cases. For example, comps could contain
> backticks (which should be escaped with backslashes) and backslashes
> (which should also be escaped). Thankfully, \uXXXX-style Unicode escape
> sequences are not currently supported inside backticks, and "escape the
> backslash" rule already takes care of them.
>
> The deparse() function already knows these rules:
>
> name <- 'hello world ` \\uFF'
> cat(deparse1(as.name(name), backtick=TRUE), '\n')
> # `hello world \` \\uFF`
> `hello world \` \\uFF` <- 'hello'
> `hello world \` \\uFF`
> # [1] "hello"
>
> --
> Best regards,
> Ivan


From AHL27 @end|ng |rom p|tt@edu  Wed Mar  1 17:52:20 2023
From: AHL27 @end|ng |rom p|tt@edu (Lakshman, Aidan H)
Date: Wed, 1 Mar 2023 16:52:20 +0000
Subject: [Rd] `dendrapply` Enhancements
In-Reply-To: <BL0PR04MB4706A66884728B9419CEAE00D9A89@BL0PR04MB4706.namprd04.prod.outlook.com>
References: <BL0PR04MB47068D544F5A49315EF1D042D9AB9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <CALK03d1PWiA4tfbRkxMBU6tckhfB2JRGUmnuqh5ygLcCLHDXNw@mail.gmail.com>
 <BL0PR04MB4706A66884728B9419CEAE00D9A89@BL0PR04MB4706.namprd04.prod.outlook.com>
Message-ID: <BL0PR04MB4706B185A345A98AB4AB829AD9AC9@BL0PR04MB4706.namprd04.prod.outlook.com>

Just wanted to give an update on the status of this, since it?s been a couple days and I?ve had a chance to work on it a little more.

Improvements:
- Fixed a few bugs, added some more robust checking to ensure correct checking for leaf nodes
- Corrected references to ?in-order? traversals, I actually meant ?pre-order?
- Added new documentation, including some new examples to the ?Usage? section
- Cleaned up some names/variables/identifiers
- Added some additional code to have function accurately replicate a weird bug of `stats::dendrapply` that is used in CRAN packages. Full details are in my PR (linked below).


I?ve integrated this into the svn mirror at r-devel/r-svn, and put out a PR at https://github.com/r-devel/r-svn/pull/111. Current PR is passing all build checks aside from Windows, which is throwing the error `Sorry, but: Error response from server: 500` while installing Miktex. I?m not sure what?s causing this, but it seems to be something aside from my code because it?s also crashing builds for other PRs.

A link to the diff file is here: https://patch-diff.githubusercontent.com/raw/r-devel/r-svn/pull/111.diff

Happy to open a Bugzilla report as well; this is enough code that a discussion is probably warranted, and Bugzilla may be an easier place to discuss compared to here. Also happy to discuss on the PR itself.

Thank you to everyone that has taken a look at my code, I appreciate people taking the time to read through it.

Sincerely,
Aidan Lakshman

-----------------------
Aidan Lakshman (he/him)<https://www.ahl27.com/>
Doctoral Candidate, Wright Lab<https://www.wrightlabscience.com/>
University of Pittsburgh School of Medicine
Department of Biomedical Informatics
ahl27 at pitt.edu
(724) 612-9940


From: Lakshman, Aidan H <AHL27 at pitt.edu>
Date: Friday, February 24, 2023 at 07:42
To: Toby Hocking <tdhock5 at gmail.com>
Cc: R-devel at r-project.org <R-devel at r-project.org>
Subject: Re: [Rd] `dendrapply` Enhancements
Hi Toby,

Thanks for your reply! I haven?t heard about the R project sprint, but I?ll definitely check it out. UK is going to be a little hard for me to get to funding-wise, but I?ll try to apply for funding.

I appreciate your other comments. As far as coding style, I did do everything I could think of to make sure it?s a drop-in replacement for the current version with the default settings, so all the user-exposed arguments/variables should be identical. I used the conventions in https://github.com/wch/r-source/wiki/Contributing for commenting and whitespace, so hopefully that all looks okay. I?m realizing there may be some differences in tab widths, but I can fix that later today.

-Aidan

-----------------------
Aidan Lakshman (he/him)<https://www.ahl27.com/>
Doctoral Candidate, Wright Lab<https://www.wrightlabscience.com/>
University of Pittsburgh School of Medicine
Department of Biomedical Informatics
ahl27 at pitt.edu
(724) 612-9940


From: Toby Hocking <tdhock5 at gmail.com>
Date: Friday, February 24, 2023 at 06:57
To: Lakshman, Aidan H <AHL27 at pitt.edu>
Cc: R-devel at r-project.org <R-devel at r-project.org>
Subject: Re: [Rd] `dendrapply` Enhancements
Hi Aidan, I think you are on the right email list.
I'm not R-core, but this looks like an interesting/meaningful/significant contribution to base R.
I'm not sure what the original dendrapply looks like in terms of code style (variable names/white space formatting/etc) but in my experience it is important that your code contribution makes minimal changes in that area.
Did you hear about the R project sprint 2023? https://contributor.r-project.org/r-project-sprint-2023/<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fcontributor.r-project.org%2Fr-project-sprint-2023%2F&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=oB%2BBivUsBjIgBtZNU8mh%2Fz2rujD3bv9MbWdxqNtyUFk%3D&reserved=0> Your work falls into the "new developments" category so I think you could apply for that funding to participate.
Toby

On Fri, Feb 24, 2023 at 3:47 AM Lakshman, Aidan H <AHL27 at pitt.edu<mailto:AHL27 at pitt.edu>> wrote:
Hi everyone,

My apologies if this isn?t the right place to submit this?I?m new to the R-devel community and still figuring out what is where.

If people want to skip my writeup and just look at the code, I?ve made a repository for it here: https://github.com/ahl27/new_dendrapply/tree/master<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fahl27%2Fnew_dendrapply%2Ftree%2Fmaster&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=QI%2B5t1C%2BJB15D8o8noZra4W87fgyITm12nluGN%2BFNoE%3D&reserved=0>. I?m not quite sure how to integrate it into a fork of R-devel; the package structure is different from what I?m used to.

I had written a slightly improved version of dendrapply for one of my research projects, and my advisor encouraged me to submit it to the R project. It took me longer than I expected, but I?ve finally gotten my implementation to be a drop-in replacement for `stats::dendrapply`. The man page for `stats::dendrapply` says ?The implementation is somewhat experimental and suggestions for enhancements (or nice examples of usage) are very welcome,? so I figured this had the potential to be a worthwhile contribution. I wanted to send it out to R-devel to see if this was something worth pursuing as an enhancement to R.

The implementation I have is based in C, which I understand implies an increased burden of maintenance over pure R code. However, it does come with the following benefits:

- Completely eliminates recursion, so no memory overhead from function calls or possibility of stack overflows (this was a major issue reported on some of the functions in one of our Bioconductor packages that previously used `dendrapply`).
- Modest runtime improvement, around 2x on my computer (2021 MBP, 32GB RAM). I?m relatively confident this could be optimized more.
- Seemingly significant reduction in memory reduction, still working on a robust benchmark. Suggestions for the best way to do that are welcome.
- Support for applying functions with an inorder traversal (as in `stats::dendrapply`) as well as using a postorder traversal.

This implementation was tested manually as well as running all the unit tests in `dendextend`, which comprises a lot of applications of `dendrapply`.

The postorder traversal would be a significant new functionality to dendrapply, as it would allow for functions that use the child nodes to correctly execute. A toy example of this is something like:
```
exFunc <- function(x){
  attr(x, 'newA') <- 'a'
  if(is.null(attr(x, 'leaf'))){
    cat(attr(x[[1]], 'newA'), attr(x[[2]], 'newA'))
    cat('\n')
  }
  x
})

dendrapply(dend, exFunc)
```

With the current version of dendrapply, this prints nothing, but the postorder traversal version will print ?a? twice for each internal branch. If this would be a worthwhile addition, I can refactor the code for brevity and add a `how=c("in.order", "post.order")`, with the default value ?in.order? to maintain backwards compatibility. A preorder traversal version should also be possible, I just haven?t gotten to it yet.

I think the runtime could be optimized more as well.

Thank you in advance for looking at my code and offering feedback; I?m excited at the possibility of helping contribute to the R project! I?m happy to discuss more either here, on GitHub, or on the R Contributors Slack.

Sincerely,
Aidan Lakshman

-----------------------
Aidan Lakshman (he/him)<https://www.ahl27.com/<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.ahl27.com%2F&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=7KUpJpdulSIzSXbpDJlyUV8pMJm%2BSVFvDOJTlVs9lhc%3D&reserved=0>>
Doctoral Candidate, Wright Lab<https://www.wrightlabscience.com/<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.wrightlabscience.com%2F&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=JMgw%2BMiQ6xdp3OokToJ2nyyco%2BryiFH%2B9ap5iU3yJH8%3D&reserved=0>>
University of Pittsburgh School of Medicine
Department of Biomedical Informatics
ahl27 at pitt.edu<mailto:ahl27 at pitt.edu>
(724) 612-9940


        [[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=I88%2FQhGHXDRS2yHqvh53k3MSWHSd5z2KBgORUHIxfG0%3D&reserved=0>

	[[alternative HTML version deleted]]


From kry|ov@r00t @end|ng |rom gm@||@com  Thu Mar  2 09:39:38 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Thu, 2 Mar 2023 11:39:38 +0300
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
 <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
Message-ID: <20230302113938.26be9522@Tarkus>

There turn out to be a few more things to fix.

One problem is easy to solve: vapply() needs a third argument
specifying the type of the return value. (Can we have unit tests for
tab completion?)

The other problem is harder: `comps` defaults to an empty string, and
you can't have a symbol consisting of an empty string, because this
value is internally reserved for missing function arguments. I think
you can return(paste0(prefix, op)) if length(comps) == 0L, but this is
still somewhat worrying. R tries to prevent empty names, so I wouldn't
expect specialOpCompletionsHelper() to return an empty string, but I
can't prove it right now.

On the other hand, x$'a string' is the same as x$`a string`. Could we
just drop as.name() and keep the return value being a string literal?
I'm not sure about this, either.

-- 
Best regards,
Ivan


From deep@y@n@@@rk@r @end|ng |rom gm@||@com  Thu Mar  2 10:03:03 2023
From: deep@y@n@@@rk@r @end|ng |rom gm@||@com (Deepayan Sarkar)
Date: Thu, 2 Mar 2023 14:33:03 +0530
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <20230302113938.26be9522@Tarkus>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
 <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
 <20230302113938.26be9522@Tarkus>
Message-ID: <CADfFDC6CQRJ6fP2vSc+WKibccFN_j1jeKvgptF-Da15MWpomZQ@mail.gmail.com>

On Thu, Mar 2, 2023 at 2:09?PM Ivan Krylov <krylov.r00t at gmail.com> wrote:
>
> There turn out to be a few more things to fix.
>
> One problem is easy to solve: vapply() needs a third argument
> specifying the type of the return value. (Can we have unit tests for
> tab completion?)

There are tests in

src/library/utils/tests/completion.R

which should get run by make check-devel (which runs R CMD check on
all base packages).

> The other problem is harder: `comps` defaults to an empty string, and
> you can't have a symbol consisting of an empty string, because this
> value is internally reserved for missing function arguments. I think
> you can return(paste0(prefix, op)) if length(comps) == 0L, but this is
> still somewhat worrying. R tries to prevent empty names, so I wouldn't
> expect specialOpCompletionsHelper() to return an empty string, but I
> can't prove it right now.
>
> On the other hand, x$'a string' is the same as x$`a string`. Could we
> just drop as.name() and keep the return value being a string literal?
> I'm not sure about this, either.

See my just-posted response on bugzilla for other issues to look out for.

Best,
-Deepayan

> --
> Best regards,
> Ivan
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From ch|r|com @end|ng |rom goog|e@com  Thu Mar  2 10:37:09 2023
From: ch|r|com @end|ng |rom goog|e@com (Michael Chirico)
Date: Thu, 2 Mar 2023 01:37:09 -0800
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <20230302113938.26be9522@Tarkus>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
 <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
 <20230302113938.26be9522@Tarkus>
Message-ID: <CAD7Bkx8YZgYo8bBoYegXQG+vcJmxbTSE+9uMOf8nZ2iOig0q7g@mail.gmail.com>

I personally wouldn't like using a string, and this comment makes me
think it's against the r-core preference as well:

https://bugs.r-project.org/show_bug.cgi?id=18429#c1

Thanks both for catching the sloppy mistake in vapply() :)

Let's continue discussion on the bug/PR.

On Thu, Mar 2, 2023 at 12:39 AM Ivan Krylov <krylov.r00t at gmail.com> wrote:
>
> There turn out to be a few more things to fix.
>
> One problem is easy to solve: vapply() needs a third argument
> specifying the type of the return value. (Can we have unit tests for
> tab completion?)
>
> The other problem is harder: `comps` defaults to an empty string, and
> you can't have a symbol consisting of an empty string, because this
> value is internally reserved for missing function arguments. I think
> you can return(paste0(prefix, op)) if length(comps) == 0L, but this is
> still somewhat worrying. R tries to prevent empty names, so I wouldn't
> expect specialOpCompletionsHelper() to return an empty string, but I
> can't prove it right now.
>
> On the other hand, x$'a string' is the same as x$`a string`. Could we
> just drop as.name() and keep the return value being a string literal?
> I'm not sure about this, either.
>
> --
> Best regards,
> Ivan


From pd@|gd @end|ng |rom gm@||@com  Thu Mar  2 14:18:34 2023
From: pd@|gd @end|ng |rom gm@||@com (peter dalgaard)
Date: Thu, 2 Mar 2023 14:18:34 +0100
Subject: [Rd] confusing all.equal output
In-Reply-To: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
Message-ID: <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>

Yes... Also, of course, the sentence after colon does not the describe the cause of the mismatch, e.g.

> all.equal(c(1,NA,NA), c(NA,NA,3))
[1] "'is.NA' value mismatch: 2 in current 2 in target"

could be confusing. 

Perhaps "is.na() mismatch (2 positions)", with the count calculated as sum(is.na(current) != is.na(target)) instead? 

Or you could give both off-diagonal elements of the confusion matrix:

"target-only: 1, current-only: 1"

but actually, the whole current/target terminology is somewhat unclear.

-pd

> On 1 Mar 2023, at 13:53 , Antoine Fabri <antoine.fabri at gmail.com> wrote:
> 
> dear r-devel,
> 
> This has probably been forever like this but is this satisfying ?
> 
> all.equal(c(1,NA,NA), c(1,NA,3))
> #> [1] "'is.NA' value mismatch: 1 in current 2 in target"
> 
> is.NA() doesn't exist (is.na() does), and is.na() is never 1 or 2.
> 
> In this example it's obvious that we're counting missing values, in a
> general situation I believe it isn't (we might understand it as the
> position of the first NA for instance).
> 
> I would expect something like "'amount of missing values mismatch: 1 in
> current 2 in target"
> 
> Thanks,
> 
> Antoine
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From kry|ov@r00t @end|ng |rom gm@||@com  Thu Mar  2 15:47:50 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Thu, 2 Mar 2023 17:47:50 +0300
Subject: [Rd] `dendrapply` Enhancements
In-Reply-To: <BL0PR04MB4706B185A345A98AB4AB829AD9AC9@BL0PR04MB4706.namprd04.prod.outlook.com>
References: <BL0PR04MB47068D544F5A49315EF1D042D9AB9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <CALK03d1PWiA4tfbRkxMBU6tckhfB2JRGUmnuqh5ygLcCLHDXNw@mail.gmail.com>
 <BL0PR04MB4706A66884728B9419CEAE00D9A89@BL0PR04MB4706.namprd04.prod.outlook.com>
 <BL0PR04MB4706B185A345A98AB4AB829AD9AC9@BL0PR04MB4706.namprd04.prod.outlook.com>
Message-ID: <20230302174750.19c3b247@arachnoid>

Dear Aidan Lakshman,

To answer your implicit question, VECTOR_ELT() unclasses the nodes
because it doesn't go through the stats:::`[[.dendrogram` method,
instead dereferencing the data pointer directly.

Other *apply functions in base R create a call to the `[[` operator,
letting the language dispatch the generic call, allowing the method to
assign a class to the return value. The following example is taken from
src/main/apply.c:do_lapply():

// prepare a call to FUN(X[[i]], ...)

    SEXP isym = install("i");
    SEXP tmp = PROTECT(lang3(R_Bracket2Symbol, X, isym));
    SEXP R_fcall = PROTECT(lang3(FUN, tmp, R_DotsSymbol));
    MARK_NOT_MUTABLE(R_fcall);

// inside the loop: evaluate the call

        tmp = R_forceAndCall(R_fcall, 1, rho);

Not sure which way is faster, but it may make sense to try, and it's
probably more correct in (contrived) cases where unclass(node)[[i]] is
invalid because it relies on a hypothetical `[[.subclass-of-dendrogram`
to restore some invariants.

Would you mind telling me more about the following case?

> if(!(inherits(res,c('dendrogram', 'list')))){
>  res1 <- lapply(unclass(node), \(x) x)
> }

If you're looking to improve the performance, there might be a way to
avoid the wrapper and this lapply(unclass(node), identity) call in it.

-- 
Best regards,
Ivan


From AHL27 @end|ng |rom p|tt@edu  Thu Mar  2 16:38:20 2023
From: AHL27 @end|ng |rom p|tt@edu (Lakshman, Aidan H)
Date: Thu, 2 Mar 2023 15:38:20 +0000
Subject: [Rd] `dendrapply` Enhancements
In-Reply-To: <20230302174750.19c3b247@arachnoid>
References: <BL0PR04MB47068D544F5A49315EF1D042D9AB9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <CALK03d1PWiA4tfbRkxMBU6tckhfB2JRGUmnuqh5ygLcCLHDXNw@mail.gmail.com>
 <BL0PR04MB4706A66884728B9419CEAE00D9A89@BL0PR04MB4706.namprd04.prod.outlook.com>
 <BL0PR04MB4706B185A345A98AB4AB829AD9AC9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <20230302174750.19c3b247@arachnoid>
Message-ID: <BL0PR04MB47069CCBD8C6EB57BB22533ED9B29@BL0PR04MB4706.namprd04.prod.outlook.com>

Thanks for your reply!

> To answer your implicit question, VECTOR_ELT() unclasses the nodes
> because it doesn't go through the stats:::`[[.dendrogram` method,
> instead dereferencing the data pointer directly.

That?s roughly what I had suspected?I appreciate the clarification.

To your point on other *apply functions, I wasn?t actually aware of that implementation, but it?s definitely a smarter way to do it. I?ll try later today/tomorrow to incorporate that method; it seems much better and more future-proof than my approach. Definitely agree with you with respect to cases where unclass(node)[[i]] is invalid. It may be slightly slower due to having to rely on R method dispatch, but I think the benefits outweigh the drawbacks in this case.

> Would you mind telling me more about the following case?

> > if(!(inherits(res,c('dendrogram', 'list')))){
> >   res1 <- lapply(unclass(node), \(x) x)
> > }

> If you're looking to improve the performance, there might be a way to
> avoid the wrapper and this lapply(unclass(node), identity) call in it.

This was a product of trying to get performance to be the same as in the current method?I agree that it?s probably not the best way to do this. The use-case is when you apply a function to the dendrogram that doesn?t return a dendrogram object. One example is the one from reg-tests-1c.R:

```
D <- as.dendrogram(hclust(dist(cbind(setNames(c(0,1,4), LETTERS[1:3])))))

dendrapply(D, labels))



# Expected result:

#
# [[1]]

# ?C?
#
# [[2]]
# [[2]][[1]]
# ?A?

#

# [[2]][[2]]

# ?B?

#

# [[3]]

# ?C?
```

Applying labels to the root node returns c(?C?, ?A?, ?B?), and if we convert that to a list, we get a length 3 list of length 1 character vectors. However, when traversing the dendrogram pre-order, this would break things, since then the first entry of the node is no longer a dendrogram object, it?s been replaced by a character vector. I had written it this way with the unclass so that I could replace entries that needed to be evaluated at child nodes with child nodes. For example, in this instance, after evaluating the function at the root, the tree would look like:

```
[[1]]
<unclassed D[[1]]>

[[2]]
<unclassed D[[2]]>

[[3]]
?B?
```

To answer the question on why there?s an lapply(?, identity) call, I think I ended up doing it this way because I was having some issues with not getting the elements to populate correctly from the dendrogram. Looking back on it now, there?s definitely an easier way to do this that isn?t so hard to understand code-wise?.
```
if(!is.leaf(node)){
      if(!is.list(res)){
        res <- as.list(res)
      }
      res[seq_along(node)] <- node
    }
```
That should perform almost identically and make more sense, with the added benefit that it doesn?t unclass the child nodes, so (when I also incorporate the other fix you suggested) we shouldn?t have any unexpected performance from functions relying on a hypothetical `subclass-of-dendrogram`. This implementation is also slightly faster due to no lapply call and is.list() over inherits(?).

Result after applying to root node with this approach:
```
[[1]]
D[[1]]

[[2]]
D[[2]]

[[3]]
?B?
```
Classes of D[[1]] and D[[2]] are preserved for future evaluations.

Thanks for pointing this out, I?ll incorporate this into the code when I check the `[[` case later. If you have any other questions/comments/suggestions I would love to hear them! Happy to clarify further as well if I didn?t answer your questions fully.

Sincerely,
Aidan

-----------------------
Aidan Lakshman (he/him)<https://www.ahl27.com/>
Doctoral Candidate, Wright Lab<https://www.wrightlabscience.com/>
University of Pittsburgh School of Medicine
Department of Biomedical Informatics
ahl27 at pitt.edu
(724) 612-9940


From: Ivan Krylov <krylov.r00t at gmail.com>
Date: Thursday, March 2, 2023 at 09:47
To: Lakshman, Aidan H <AHL27 at pitt.edu>
Cc: R-devel at r-project.org <R-devel at r-project.org>
Subject: Re: [Rd] `dendrapply` Enhancements
Dear Aidan Lakshman,

To answer your implicit question, VECTOR_ELT() unclasses the nodes
because it doesn't go through the stats:::`[[.dendrogram` method,
instead dereferencing the data pointer directly.

Other *apply functions in base R create a call to the `[[` operator,
letting the language dispatch the generic call, allowing the method to
assign a class to the return value. The following example is taken from
src/main/apply.c:do_lapply():

// prepare a call to FUN(X[[i]], ...)

    SEXP isym = install("i");
    SEXP tmp = PROTECT(lang3(R_Bracket2Symbol, X, isym));
    SEXP R_fcall = PROTECT(lang3(FUN, tmp, R_DotsSymbol));
    MARK_NOT_MUTABLE(R_fcall);

// inside the loop: evaluate the call

        tmp = R_forceAndCall(R_fcall, 1, rho);

Not sure which way is faster, but it may make sense to try, and it's
probably more correct in (contrived) cases where unclass(node)[[i]] is
invalid because it relies on a hypothetical `[[.subclass-of-dendrogram`
to restore some invariants.

Would you mind telling me more about the following case?

> if(!(inherits(res,c('dendrogram', 'list')))){
>  res1 <- lapply(unclass(node), \(x) x)
> }

If you're looking to improve the performance, there might be a way to
avoid the wrapper and this lapply(unclass(node), identity) call in it.

--
Best regards,
Ivan

	[[alternative HTML version deleted]]


From @nto|ne@|@br| @end|ng |rom gm@||@com  Thu Mar  2 18:23:12 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Thu, 2 Mar 2023 18:23:12 +0100
Subject: [Rd] confusing all.equal output
In-Reply-To: <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
 <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
Message-ID: <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>

Good points. I don't mind the terminology since target and current are the
names of the arguments. As the function is already designed to stop at the
first failing check we might not need to enumerate or count the mismatches,
instead we could have "`NA` found in `target` but not in `current` at
position <FIRST_MISMATCH>"

	[[alternative HTML version deleted]]


From w||||@mwdun|@p @end|ng |rom gm@||@com  Thu Mar  2 18:39:24 2023
From: w||||@mwdun|@p @end|ng |rom gm@||@com (Bill Dunlap)
Date: Thu, 2 Mar 2023 09:39:24 -0800
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <20230302113938.26be9522@Tarkus>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
 <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
 <20230302113938.26be9522@Tarkus>
Message-ID: <CAHqSRuRaASWG-Dka76Vb4J9JXWJJKssN8ZfHjt=gQf6RmTaduQ@mail.gmail.com>

x$`string` is not the same as x$'string'.  They may act similarly now, but
they do not parse the same.

> vapply(as.list(quote(list$`component`)), typeof, "")
[1] "symbol" "symbol" "symbol"
> vapply(as.list(quote(list$"component")), typeof, "")
[1] "symbol"    "symbol"    "character"
> vapply(as.list(quote(list$'component')), typeof, "")
[1] "symbol"    "symbol"    "character"

Single and double quoted character sequences do parse to the same thing
(character) but backquoted ones parse to symbols (aka names).

-Bill

On Thu, Mar 2, 2023 at 12:39?AM Ivan Krylov <krylov.r00t at gmail.com> wrote:

> There turn out to be a few more things to fix.
>
> One problem is easy to solve: vapply() needs a third argument
> specifying the type of the return value. (Can we have unit tests for
> tab completion?)
>
> The other problem is harder: `comps` defaults to an empty string, and
> you can't have a symbol consisting of an empty string, because this
> value is internally reserved for missing function arguments. I think
> you can return(paste0(prefix, op)) if length(comps) == 0L, but this is
> still somewhat worrying. R tries to prevent empty names, so I wouldn't
> expect specialOpCompletionsHelper() to return an empty string, but I
> can't prove it right now.
>
> On the other hand, x$'a string' is the same as x$`a string`. Could we
> just drop as.name() and keep the return value being a string literal?
> I'm not sure about this, either.
>
> --
> Best regards,
> Ivan
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From @nto|ne@|@br| @end|ng |rom gm@||@com  Thu Mar  2 18:49:52 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Thu, 2 Mar 2023 18:49:52 +0100
Subject: [Rd] transform.data.frame() ignores unnamed arguments when no named
 argument is provided
Message-ID: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>

Dear r-devel,

See below:


transform(data.frame(a = 1), 2, 3)

#>   a

#> 1 1


transform(data.frame(a = 1), b=2, 3)

#>   a b X3

#> 1 1 2  3


We need a small modification to make it work consistently, see below:


transform.data.frame <- function (`_data`, ...) {

  e <- eval(substitute(list(...)), `_data`, parent.frame())

  tags <- names(e)

  ## NEW LINE -----------------------------------------------

  if (is.null(tags)) tags <- character(length(e))

  inx <- match(tags, names(`_data`))

  matched <- !is.na(inx)

  if (any(matched)) {

    `_data`[inx[matched]] <- e[matched]

    `_data` <- data.frame(`_data`)

  }

  if (!all(matched))

    do.call("data.frame", c(list(`_data`), e[!matched]))

  else `_data`

}


transform(data.frame(a = 1), 2, 3)

#>   a X2 X3

#> 1 1  2  3

transform(data.frame(a = 1), b=2, 3)

#>   a b X3

#> 1 1 2  3


Thanks,


Antoine

	[[alternative HTML version deleted]]


From @vi@e@gross m@iii@g oii gm@ii@com  Thu Mar  2 19:30:42 2023
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Thu, 2 Mar 2023 13:30:42 -0500
Subject: [Rd] confusing all.equal output
In-Reply-To: <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
 <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
 <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>
Message-ID: <001d01d94d35$187fbb90$497f32b0$@gmail.com>

I think if you step back, you can ask what the purpose of an error message
is and who designs it.

Is the message for the developer or others on their team or something an
end-user knowing nothing about R will see.

This reminds me a bit of legal mumbo jumbo that turns many reading it off as
it keeps talking about the party of the first part or the plaintiff as
compared to somewhat straighter talk.

The scenario is that you are comparing two things. Their names are not
things like "target" or "current" so even other programmers not involved in
your code will pause and wonder.

One view is to use phrases like first and second arguments/lists/whatever.
You might talk about the one on the left (but using LHS is a bit opaque)
versus the one on the right. 

But sometimes it can be too verbose. Sometimes the error message is being
generated not where everything is clear.

So ideally you could say:

WARNING Danger Will Robinson.
Comparing two things for equality.
Result finds mismatches.
There were NA found on the (left or right) that were not matched on the
other side.
Number of such found: 2

If you had a Systems Engineer write detailed requirements that included
something a bit better than the example and the programmer was able to
supply the data using the words and guidelines, it might fit some needs but
maybe not satisfy other programmers. But there are human factors people
whose job it is to help choose among alternatives and although they may not
choose well, letting a programmer come up with whatever they feel like is
generally worse. 

Yes, in their microcosm centered on a dozen lines of code, "current" and
"target" may have meaning. But are they the intended user of the product?

-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Antoine Fabri
Sent: Thursday, March 2, 2023 12:23 PM
To: peter dalgaard <pdalgd at gmail.com>
Cc: R-devel <r-devel at r-project.org>
Subject: Re: [Rd] confusing all.equal output

Good points. I don't mind the terminology since target and current are the
names of the arguments. As the function is already designed to stop at the
first failing check we might not need to enumerate or count the mismatches,
instead we could have "`NA` found in `target` but not in `current` at
position <FIRST_MISMATCH>"

	[[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From pd@|gd @end|ng |rom gm@||@com  Thu Mar  2 19:47:59 2023
From: pd@|gd @end|ng |rom gm@||@com (peter dalgaard)
Date: Thu, 2 Mar 2023 19:47:59 +0100
Subject: [Rd] confusing all.equal output
In-Reply-To: <001d01d94d35$187fbb90$497f32b0$@gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
 <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
 <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>
 <001d01d94d35$187fbb90$497f32b0$@gmail.com>
Message-ID: <B97B1379-B884-4DBF-A926-82789F81B93B@gmail.com>

I believe the wording goes back to Martin Maechler many moons ago (AFAICT towards the end of the last millennium.)

We might leave it to him to change it?

- Peter D.

> On 2 Mar 2023, at 19:30 , avi.e.gross at gmail.com wrote:
> 
> I think if you step back, you can ask what the purpose of an error message
> is and who designs it.
> 
> Is the message for the developer or others on their team or something an
> end-user knowing nothing about R will see.
> 
> This reminds me a bit of legal mumbo jumbo that turns many reading it off as
> it keeps talking about the party of the first part or the plaintiff as
> compared to somewhat straighter talk.
> 
> The scenario is that you are comparing two things. Their names are not
> things like "target" or "current" so even other programmers not involved in
> your code will pause and wonder.
> 
> One view is to use phrases like first and second arguments/lists/whatever.
> You might talk about the one on the left (but using LHS is a bit opaque)
> versus the one on the right. 
> 
> But sometimes it can be too verbose. Sometimes the error message is being
> generated not where everything is clear.
> 
> So ideally you could say:
> 
> WARNING Danger Will Robinson.
> Comparing two things for equality.
> Result finds mismatches.
> There were NA found on the (left or right) that were not matched on the
> other side.
> Number of such found: 2
> 
> If you had a Systems Engineer write detailed requirements that included
> something a bit better than the example and the programmer was able to
> supply the data using the words and guidelines, it might fit some needs but
> maybe not satisfy other programmers. But there are human factors people
> whose job it is to help choose among alternatives and although they may not
> choose well, letting a programmer come up with whatever they feel like is
> generally worse. 
> 
> Yes, in their microcosm centered on a dozen lines of code, "current" and
> "target" may have meaning. But are they the intended user of the product?
> 
> -----Original Message-----
> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Antoine Fabri
> Sent: Thursday, March 2, 2023 12:23 PM
> To: peter dalgaard <pdalgd at gmail.com>
> Cc: R-devel <r-devel at r-project.org>
> Subject: Re: [Rd] confusing all.equal output
> 
> Good points. I don't mind the terminology since target and current are the
> names of the arguments. As the function is already designed to stop at the
> first failing check we might not need to enumerate or count the mismatches,
> instead we could have "`NA` found in `target` but not in `current` at
> position <FIRST_MISMATCH>"
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From @eb@meyer @end|ng |rom |@u@de  Thu Mar  2 22:34:33 2023
From: @eb@meyer @end|ng |rom |@u@de (Sebastian Meyer)
Date: Thu, 2 Mar 2023 22:34:33 +0100
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
Message-ID: <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>

Note that ?transform.data.frame says arguments need to be named, so you 
are testing unspecified behaviour. I guess this falls in a similar 
category as the note

      If some of the values are not vectors of the appropriate length,
      you deserve whatever you get!

Experiments for a related Problem Report 
(<https://bugs.r-project.org/show_bug.cgi?id=17890>) showed that 
packages bravely ignore the caveats mentioned on the help page, 
including to assume recycling the rows of the input data frame. I didn't 
yet see any uses of unnamed arguments, though.

That said, I agree that transform.data.frame() should be improved. Maybe 
unnamed arguments should always be ignored with a warning. My feeling is 
that these would more often be usage errors than intentional, e.g.:

 > data.frame(a = 1) |> transform(b = 2, a + 2)  # "forgetting" a=
   a b X3
1 1 2  3

I also think the implicit check.names=TRUE behaviour should be disabled. In

 > list2DF(list(`A-1` = 1)) |> transform(B = 2)
   A.1 B
1   1 2

transforming B should not touch the other columns.

I'm less sure about some other forms of undocumented behaviour as 
described in Comment 6 of the linked PR.

	Sebastian Meyer


Am 02.03.23 um 18:49 schrieb Antoine Fabri:
> Dear r-devel,
> 
> See below:
> 
> 
> transform(data.frame(a = 1), 2, 3)
> 
> #>   a
> 
> #> 1 1
> 
> 
> transform(data.frame(a = 1), b=2, 3)
> 
> #>   a b X3
> 
> #> 1 1 2  3
> 
> 
> We need a small modification to make it work consistently, see below:
> 
> 
> transform.data.frame <- function (`_data`, ...) {
> 
>    e <- eval(substitute(list(...)), `_data`, parent.frame())
> 
>    tags <- names(e)
> 
>    ## NEW LINE -----------------------------------------------
> 
>    if (is.null(tags)) tags <- character(length(e))
> 
>    inx <- match(tags, names(`_data`))
> 
>    matched <- !is.na(inx)
> 
>    if (any(matched)) {
> 
>      `_data`[inx[matched]] <- e[matched]
> 
>      `_data` <- data.frame(`_data`)
> 
>    }
> 
>    if (!all(matched))
> 
>      do.call("data.frame", c(list(`_data`), e[!matched]))
> 
>    else `_data`
> 
> }
> 
> 
> transform(data.frame(a = 1), 2, 3)
> 
> #>   a X2 X3
> 
> #> 1 1  2  3
> 
> transform(data.frame(a = 1), b=2, 3)
> 
> #>   a b X3
> 
> #> 1 1 2  3
> 
> 
> Thanks,
> 
> 
> Antoine
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @nto|ne@|@br| @end|ng |rom gm@||@com  Thu Mar  2 23:01:41 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Thu, 2 Mar 2023 23:01:41 +0100
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
Message-ID: <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>

Thanks and good point about unspecified behavior. The way it behaves now
(when it doesn't ignore) is more consistent with data.frame() though so I
prefer that to a "warn and ignore" behaviour:

data.frame(a = 1, b = 2, 3)

#>   a b X3

#> 1 1 2  3


data.frame(a = 1, 2, 3)

#>   a X2 X3

#> 1 1  2  3


(and in general warnings make for unpleasant debugging so I prefer when we
don't add new ones if avoidable)


playing a bit more with it, it would make sense to me that the following
have the same output:


coefficient <- 3


data.frame(value1 = 5) |> transform(coefficient, value2 = coefficient *
value1)

#>   value1 X3 value2

#> 1      5  3     15


data.frame(value1 = 5, coefficient) |> transform(value2 = coefficient *
value1)

#>   value1 coefficient value2

#> 1      5           3     15

	[[alternative HTML version deleted]]


From g@bembecker @end|ng |rom gm@||@com  Thu Mar  2 23:37:18 2023
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Thu, 2 Mar 2023 14:37:18 -0800
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
Message-ID: <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>

On Thu, Mar 2, 2023 at 2:02?PM Antoine Fabri <antoine.fabri at gmail.com>
wrote:

> Thanks and good point about unspecified behavior. The way it behaves now
> (when it doesn't ignore) is more consistent with data.frame() though so I
> prefer that to a "warn and ignore" behaviour:
>
> data.frame(a = 1, b = 2, 3)
>
> #>   a b X3
>
> #> 1 1 2  3
>
>
> data.frame(a = 1, 2, 3)
>
> #>   a X2 X3
>
> #> 1 1  2  3
>
>
> (and in general warnings make for unpleasant debugging so I prefer when we
> don't add new ones if avoidable)
>

I find silence to be much more unpleasant in practice when debugging,
myself, but that may be a personal preference.


>
>
> playing a bit more with it, it would make sense to me that the following
> have the same output:
>
>
> coefficient <- 3
>
>
> data.frame(value1 = 5) |> transform(coefficient, value2 = coefficient *
> value1)
>
> #>   value1 X3 value2
>
> #> 1      5  3     15
>
>
> data.frame(value1 = 5, coefficient) |> transform(value2 = coefficient *
> value1)
>
> #>   value1 coefficient value2
>
> #> 1      5           3     15
>
>
I'm not so sure. data.frame() is doing some substitute magic to get the
column name coefficient there.

> coefficient = 3

> data.frame(value1 = 5, coefficient)

  value1 coefficient

1      5           3

Beyond that these two pieces of code are doing subtly but crucially
different things; in the latter, coefficient is a variable in the
data.frame, and when transform resolves that symbol during calculation of
value2, it *gets the column in the incoming data.frame*.

In the former case, coefficient does not exist in the data.frame, so the
symbol is being resolved somewhere else in the scope chain (in this case,
the global environment).

These happen to be the same, except for the column name , but we can see
the difference if we change the code to

> coefficient <- 3

> data.frame(value1 = 5, coefficient = 4)  |> transform(value2 = value1 *
coefficient)

  value1 coefficient value2

1      5           4     20

> data.frame(value1 = 5) |> transform(coefficient = 4, value2 = value1 *
coefficient)

  value1 coefficient *value2*

1      5           4     *15*

Please note that another way this difference could rear its head is if
these arent' directly one after eachother in a pipe:

> coefficient <- 3

> df1 <- data.frame(value1 = 5, coefficient)

> coefficient <- 4

> df2 <- data.frame(value1 = 5)

> df1 |> transform(value2 = value1 * coefficient)

  value1 coefficient value2

1      5           3     15

> df2 |> transform(coefficient, value2 = value1 * coefficient)

  value1 X4 value2

1      5  4     20


Cause you know someday the place where you do that transform and the place
where coefficient is initially set are gonna be far away from eachother, so
whether you put coefficient into the incoming data, or don't will matter.


Best,
~G

        [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Fri Mar  3 16:25:30 2023
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Fri, 3 Mar 2023 16:25:30 +0100
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
Message-ID: <25602.4458.303335.397238@stat.math.ethz.ch>

>>>>> Gabriel Becker 
>>>>>     on Thu, 2 Mar 2023 14:37:18 -0800 writes:

    > On Thu, Mar 2, 2023 at 2:02?PM Antoine Fabri
    > <antoine.fabri at gmail.com> wrote:

    >> Thanks and good point about unspecified behavior. The way
    >> it behaves now (when it doesn't ignore) is more
    >> consistent with data.frame() though so I prefer that to a
    >> "warn and ignore" behaviour:
    >> 
    >> data.frame(a = 1, b = 2, 3)
    >> 
    >> #> a b X3
    >> 
    >> #> 1 1 2 3
    >> 
    >> 
    >> data.frame(a = 1, 2, 3)
    >> 
    >> #> a X2 X3
    >> 
    >> #> 1 1 2 3
    >> 
    >> 
    >> (and in general warnings make for unpleasant debugging so
    >> I prefer when we don't add new ones if avoidable)
    >> 

    > I find silence to be much more unpleasant in practice when
    > debugging, myself, but that may be a personal preference.

+1

I also *strongly* disagree with the claim

   " in general warnings make for unpleasant debugging "

That may be true for beginners (for whom debugging is often not really
feasible anyway ..), but somewhat experienced useRs should know

about
    options(warn = 1) # or
    options(warn = 2) # plus  options(error = recover) #
or
    tryCatch( ...,  warning = ..)

or  {even more}

Martin

--
Martin Maechler
ETH Zurich  and  R Core team


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Fri Mar  3 18:01:06 2023
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Fri, 3 Mar 2023 18:01:06 +0100
Subject: [Rd] confusing all.equal output
In-Reply-To: <B97B1379-B884-4DBF-A926-82789F81B93B@gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
 <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
 <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>
 <001d01d94d35$187fbb90$497f32b0$@gmail.com>
 <B97B1379-B884-4DBF-A926-82789F81B93B@gmail.com>
Message-ID: <25602.10194.172872.572433@stat.math.ethz.ch>

>>>>> peter dalgaard 
>>>>>     on Thu, 2 Mar 2023 19:47:59 +0100 writes:

    > I believe the wording goes back to Martin Maechler many
    > moons ago (AFAICT towards the end of the last millennium.)
    > We might leave it to him to change it?
    > - Peter D.

Thank you, Peter.

Yes, this is *very* old.  I could claim that R users seem to get
more and more confused over time, because nobody had ever
complained for a quarter of a century .. (;-) ;-)

I know I had been inspired by the all.equal() implementation of
S-PLUS version 3.x (x = 4, IIRC) at the time, but then I also think
that I have to take the "full blame" on this :

Trying to think like myself "yesterday, when I was young ..",
I guess the argumentation for using  is.NA  was what I
considered helpful to the non experienced S / R user at the time:
Everybody has seen 'NA' before (and they see it in their objects
in this case) but only somewhat more experienced useRs would
know about is.na(). .. and it may be that at the time I found it
"slick" to combine the "NA" and "is.na" into  "is.NA" ...

About the other wording and how the mismatches should be counted, I
have no recollection.

But indeed, already in 1999, i.e., before R 1.0.0 existed,
that part of the code was

    out <- is.na(target)
    if(any(out != is.na(current)))
	return(paste("`is.NA' value mismatches:", sum(is.na(current)),
		     "in current,", sum(out), " in target"))

- - - 

Ok, now I need to work to commit a (completely orthogonal) change to
all.equal.numeric()  which had been lying around with me for
about a year at least... so I can start looking at your proposed
changes ...

Martin


    >> On 2 Mar 2023, at 19:30 , avi.e.gross at gmail.com wrote:
    >> 
    >> I think if you step back, you can ask what the purpose of
    >> an error message is and who designs it.
    >> 
    >> Is the message for the developer or others on their team
    >> or something an end-user knowing nothing about R will
    >> see.
    >> 
    >> This reminds me a bit of legal mumbo jumbo that turns
    >> many reading it off as it keeps talking about the party
    >> of the first part or the plaintiff as compared to
    >> somewhat straighter talk.
    >> 
    >> The scenario is that you are comparing two things. Their
    >> names are not things like "target" or "current" so even
    >> other programmers not involved in your code will pause
    >> and wonder.
    >> 
    >> One view is to use phrases like first and second
    >> arguments/lists/whatever.  You might talk about the one
    >> on the left (but using LHS is a bit opaque) versus the
    >> one on the right.
    >> 
    >> But sometimes it can be too verbose. Sometimes the error
    >> message is being generated not where everything is clear.
    >> 
    >> So ideally you could say:
    >> 
    >> WARNING Danger Will Robinson.  Comparing two things for
    >> equality.  Result finds mismatches.  There were NA found
    >> on the (left or right) that were not matched on the other
    >> side.  Number of such found: 2
    >> 
    >> If you had a Systems Engineer write detailed requirements
    >> that included something a bit better than the example and
    >> the programmer was able to supply the data using the
    >> words and guidelines, it might fit some needs but maybe
    >> not satisfy other programmers. But there are human
    >> factors people whose job it is to help choose among
    >> alternatives and although they may not choose well,
    >> letting a programmer come up with whatever they feel like
    >> is generally worse.
    >> 
    >> Yes, in their microcosm centered on a dozen lines of
    >> code, "current" and "target" may have meaning. But are
    >> they the intended user of the product?
    >> 
    >> -----Original Message----- From: R-devel
    >> <r-devel-bounces at r-project.org> On Behalf Of Antoine
    >> Fabri Sent: Thursday, March 2, 2023 12:23 PM To: peter
    >> dalgaard <pdalgd at gmail.com> Cc: R-devel
    >> <r-devel at r-project.org> Subject: Re: [Rd] confusing
    >> all.equal output
    >> 
    >> Good points. I don't mind the terminology since target
    >> and current are the names of the arguments. As the
    >> function is already designed to stop at the first failing
    >> check we might not need to enumerate or count the
    >> mismatches, instead we could have "`NA` found in `target`
    >> but not in `current` at position <FIRST_MISMATCH>"
    >> 
    >> [[alternative HTML version deleted]]
    >> 
    >> ______________________________________________
    >> R-devel at r-project.org mailing list
    >> https://stat.ethz.ch/mailman/listinfo/r-devel
    >> 
    >> ______________________________________________
    >> R-devel at r-project.org mailing list
    >> https://stat.ethz.ch/mailman/listinfo/r-devel

    > -- 
    > Peter Dalgaard, Professor, Center for Statistics,
    > Copenhagen Business School Solbjerg Plads 3, 2000
    > Frederiksberg, Denmark Phone: (+45)38153501 Office: A 4.23
    > Email: pd.mes at cbs.dk Priv: PDalgd at gmail.com


From @nto|ne@|@br| @end|ng |rom gm@||@com  Fri Mar  3 18:17:18 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Fri, 3 Mar 2023 18:17:18 +0100
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <25602.4458.303335.397238@stat.math.ethz.ch>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
 <25602.4458.303335.397238@stat.math.ethz.ch>
Message-ID: <CAEKh8uh2pY5N98eufV2DX01wfCp++rMDSEPwXA-AUCogHBkDGA@mail.gmail.com>

Let me expand a bit, I might have expressed myself poorly.

 If there is a good reason for a warning I want a warning, and because I
take them seriously I don't want my console cluttered with those that can
be avoided. I strongly believe we should strive to make our code silent,
and I like my console to tell me only what I need to know. In my opinion
many warnings would be better designed as errors, sometimes with an
argument to opt in the behaviour, or a documented way to work around. Some
other warnings should just be documented behavior, because the behavior is
not all that surprising.

Some reasons why I find warnings hard to debug:
- options(warn = 1) is not always enough to spot the source of the warning
- options(warn = 2) fails at every warning, including the ones that are not
interesting to the user and that they may not do anything about, in these
cases you'll have to find a way to shut off the first to get to the second,
and if it's packaged code that's not fun.
- Unlike with errors, traceback() won't help.
- tryCatch() will help you only if you call it at the right place, assuming
you've found it.
- We might also have many harmless warnings triggered through loops and
hiding important ones.
- When you are sure that you are OK with your code despite the warning, say
`as.numeric(c("1", "2", "foo"))`, a workaround might be expensive (here we
could use regex first to ditch the non numeric strings but who does that)
so you're tempted to use `suppressWarnings()`, but then you might be
suppressing other important warnings so you just made your code less safe
because the developper wanted to make it safer (you might say it's on the
user but still, we get suboptimal code that was avoidable).

Of course I might miss some approaches that would make my experience of
debugging warnings more pleasant.

In our precise case I don't find the behavior surprising enough to warrant
more precious red ink since it's close to what we get with data.frame(),
and close to what we get with dplyr::mutate() FWIW, so I'd be personally
happier to have this documented and work silently.

Either way I appreciate you considering the problem.

Thanks,

Antoine

	[[alternative HTML version deleted]]


From bbo|ker @end|ng |rom gm@||@com  Fri Mar  3 21:58:30 2023
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Fri, 3 Mar 2023 15:58:30 -0500
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <CAEKh8uh2pY5N98eufV2DX01wfCp++rMDSEPwXA-AUCogHBkDGA@mail.gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
 <25602.4458.303335.397238@stat.math.ethz.ch>
 <CAEKh8uh2pY5N98eufV2DX01wfCp++rMDSEPwXA-AUCogHBkDGA@mail.gmail.com>
Message-ID: <CABghstT+5CX8f15X8zTFp_DgKGwe6g2F6=g9bJvworFhyLXHTQ@mail.gmail.com>

   For what it's worth I think the increased emphasis on classed
errors should help with this (i.e., it will be easier to filter out
errors you know are false positives/irrelevant for your use case).

On Fri, Mar 3, 2023 at 12:17?PM Antoine Fabri <antoine.fabri at gmail.com> wrote:
>
> Let me expand a bit, I might have expressed myself poorly.
>
>  If there is a good reason for a warning I want a warning, and because I
> take them seriously I don't want my console cluttered with those that can
> be avoided. I strongly believe we should strive to make our code silent,
> and I like my console to tell me only what I need to know. In my opinion
> many warnings would be better designed as errors, sometimes with an
> argument to opt in the behaviour, or a documented way to work around. Some
> other warnings should just be documented behavior, because the behavior is
> not all that surprising.
>
> Some reasons why I find warnings hard to debug:
> - options(warn = 1) is not always enough to spot the source of the warning
> - options(warn = 2) fails at every warning, including the ones that are not
> interesting to the user and that they may not do anything about, in these
> cases you'll have to find a way to shut off the first to get to the second,
> and if it's packaged code that's not fun.
> - Unlike with errors, traceback() won't help.
> - tryCatch() will help you only if you call it at the right place, assuming
> you've found it.
> - We might also have many harmless warnings triggered through loops and
> hiding important ones.
> - When you are sure that you are OK with your code despite the warning, say
> `as.numeric(c("1", "2", "foo"))`, a workaround might be expensive (here we
> could use regex first to ditch the non numeric strings but who does that)
> so you're tempted to use `suppressWarnings()`, but then you might be
> suppressing other important warnings so you just made your code less safe
> because the developper wanted to make it safer (you might say it's on the
> user but still, we get suboptimal code that was avoidable).
>
> Of course I might miss some approaches that would make my experience of
> debugging warnings more pleasant.
>
> In our precise case I don't find the behavior surprising enough to warrant
> more precious red ink since it's close to what we get with data.frame(),
> and close to what we get with dplyr::mutate() FWIW, so I'd be personally
> happier to have this documented and work silently.
>
> Either way I appreciate you considering the problem.
>
> Thanks,
>
> Antoine
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From p@kr|v|t@ky @end|ng |rom un@w@edu@@u  Sat Mar  4 01:21:48 2023
From: p@kr|v|t@ky @end|ng |rom un@w@edu@@u (Pavel Krivitsky)
Date: Sat, 4 Mar 2023 00:21:48 +0000
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
Message-ID: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>

Dear All,

Currently, list= in base::replace(x, list, value) has to be an index
vector. For me, at least, the most common use case is for list= to be
some simple property of elements of x, e.g.,

x <- c(1,2,NA,3)
replace(x, is.na(x), 0)

Particularly when using R pipes, which don't allow multiple
substitutions, it would simplify many of such cases if list= could be a
function that returns an index, e.g.,

replace <- function (x, list, values, ...) {
  # Here, list() refers to the argument, not the built-in.
  if(is.function(list)) list <- list(x, ...)
  x[list] <- values
  x
}

Then, the following is possible:

c(1,2,NA,3) |> replace(is.na, 0)

			Any thoughts?
			Pavel

From @vi@e@gross m@iii@g oii gm@ii@com  Sat Mar  4 06:06:40 2023
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Sat, 4 Mar 2023 00:06:40 -0500
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <25602.4458.303335.397238@stat.math.ethz.ch>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
 <25602.4458.303335.397238@stat.math.ethz.ch>
Message-ID: <012001d94e57$1b4c0b30$51e42190$@gmail.com>

I am probably mistaken but it looks to me like the design of much of the data.frame infrastructure not only does not insist you give columns names, but even has all kinds of options such as check.names and fix.empty.names

https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/data.frame

During the lifetime of a column, it can get removed, renamed, transfomed in many ways and so on. A data.frame read in from a file such as a .CSV often begins with temporary created names. 

It is so common, that sometimes not giving a name is a choice and not in any way an error. I have seen some rather odd names in backticks that include spaces and seen duplicate names. The reality is you can index by column number two and maybe no actual name was needed by the one creating or modifying the data.

Some placed warnings are welcome as they tend to reflect a possibly serious error.  But that error may not easily be at this point versus later in the game.  If later the program tries to access the misnamed column, then an error makes sense. Warnings, if overused, get old quickly and you regularly see code written to suppress startup messages or warnings because the same message shown every day becomes something you ignore mentally even if not suppressed. How many times has loading the tidyverse reminded me it is shadowing a few base R functions? How many times have I really cared?

What makes some sense to me is to add an argument to some functions BEGGING to be shown the errors of your ways and turn that on as you wish, often after something has gone wrong.

-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Martin Maechler
Sent: Friday, March 3, 2023 10:26 AM
To: Gabriel Becker <gabembecker at gmail.com>
Cc: Antoine Fabri <antoine.fabri at gmail.com>; R-devel <r-devel at r-project.org>
Subject: Re: [Rd] transform.data.frame() ignores unnamed arguments when no named argument is provided

>>>>> Gabriel Becker 
>>>>>     on Thu, 2 Mar 2023 14:37:18 -0800 writes:

    > On Thu, Mar 2, 2023 at 2:02?PM Antoine Fabri
    > <antoine.fabri at gmail.com> wrote:

    >> Thanks and good point about unspecified behavior. The way
    >> it behaves now (when it doesn't ignore) is more
    >> consistent with data.frame() though so I prefer that to a
    >> "warn and ignore" behaviour:
    >> 
    >> data.frame(a = 1, b = 2, 3)
    >> 
    >> #> a b X3
    >> 
    >> #> 1 1 2 3
    >> 
    >> 
    >> data.frame(a = 1, 2, 3)
    >> 
    >> #> a X2 X3
    >> 
    >> #> 1 1 2 3
    >> 
    >> 
    >> (and in general warnings make for unpleasant debugging so
    >> I prefer when we don't add new ones if avoidable)
    >> 

    > I find silence to be much more unpleasant in practice when
    > debugging, myself, but that may be a personal preference.

+1

I also *strongly* disagree with the claim

   " in general warnings make for unpleasant debugging "

That may be true for beginners (for whom debugging is often not really
feasible anyway ..), but somewhat experienced useRs should know

about
    options(warn = 1) # or
    options(warn = 2) # plus  options(error = recover) #
or
    tryCatch( ...,  warning = ..)

or  {even more}

Martin

--
Martin Maechler
ETH Zurich  and  R Core team

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From g@bembecker @end|ng |rom gm@||@com  Sat Mar  4 22:44:03 2023
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Sat, 4 Mar 2023 13:44:03 -0800
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <012001d94e57$1b4c0b30$51e42190$@gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
 <25602.4458.303335.397238@stat.math.ethz.ch>
 <012001d94e57$1b4c0b30$51e42190$@gmail.com>
Message-ID: <CAD4oTHEgE9+PdpOtvgRV1823OrNW3K-ufqZf=j9D0MPBNiyStA@mail.gmail.com>

Hi Avi,

On Fri, Mar 3, 2023 at 9:07?PM <avi.e.gross at gmail.com> wrote:

> I am probably mistaken but it looks to me like the design of much of the
> data.frame infrastructure not only does not insist you give columns names,
> but even has all kinds of options such as check.names and fix.empty.names
>
>
> https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/data.frame
>
>
I think this is true, but thats for the *construction* of a data.frame,
where as, in my opinion from what I can tell, transform is for operating on
a data.frame that has already been constructed. I'm not personally
convinced the same allowances should be made at this conceptually later
stage in data processing.


> During the lifetime of a column, it can get removed, renamed, transfomed
> in many ways and so on. A data.frame read in from a file such as a .CSV
> often begins with temporary created names.
>
> It is so common, that sometimes not giving a name is a choice and not in
> any way an error. I have seen some rather odd names in backticks that
> include spaces and seen duplicate names. The reality is you can index by
> column number two and maybe no actual name was needed by the one creating
> or modifying the data.
>

You can but this creates brittle, difficult to maintain code to the extent
that I consider this an anti-pattern, and I don't believe I'm alone in that.


>
> Some placed warnings are welcome as they tend to reflect a possibly
> serious error.  But that error may not easily be at this point versus later
> in the game.  If later the program tries to access the misnamed column,
> then an error makes sense. Warnings, if overused, get old quickly and you
> regularly see code written to suppress startup messages or warnings because
> the same message shown every day becomes something you ignore mentally even
> if not suppressed. How many times has loading the tidyverse reminded me it
> is shadowing a few base R functions? How many times have I really cared?
>

I think this is a bad example to make your case on, because symbol masking
is actually *really* important. In bioinformatics, Bioconductor is the
flagship (which sails upon the sea that R provides), but guess what; dplyr
and Bioconductor both define filter, and they do so meaning completely
different incompatible things.

I have seen code that wanted one version and got the other in both
directions, and in neither case is it fun, but without that warning it
would be a dystopian nightmarescape that scarcely bears thinking about.


> What makes some sense to me is to add an argument to some functions
> BEGGING to be shown the errors of your ways and turn that on as you wish,
> often after something has gone wrong.
>


Flipping this on its head, I wonder, alternatively, if there might be a
"strict" mode for transform which errors out on unnamed arguments, instead
of providing the current undefined behavior.

Best,
~G


>
> -----Original Message-----
> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Martin Maechler
> Sent: Friday, March 3, 2023 10:26 AM
> To: Gabriel Becker <gabembecker at gmail.com>
> Cc: Antoine Fabri <antoine.fabri at gmail.com>; R-devel <
> r-devel at r-project.org>
> Subject: Re: [Rd] transform.data.frame() ignores unnamed arguments when no
> named argument is provided
>
> >>>>> Gabriel Becker
> >>>>>     on Thu, 2 Mar 2023 14:37:18 -0800 writes:
>
>     > On Thu, Mar 2, 2023 at 2:02?PM Antoine Fabri
>     > <antoine.fabri at gmail.com> wrote:
>
>     >> Thanks and good point about unspecified behavior. The way
>     >> it behaves now (when it doesn't ignore) is more
>     >> consistent with data.frame() though so I prefer that to a
>     >> "warn and ignore" behaviour:
>     >>
>     >> data.frame(a = 1, b = 2, 3)
>     >>
>     >> #> a b X3
>     >>
>     >> #> 1 1 2 3
>     >>
>     >>
>     >> data.frame(a = 1, 2, 3)
>     >>
>     >> #> a X2 X3
>     >>
>     >> #> 1 1 2 3
>     >>
>     >>
>     >> (and in general warnings make for unpleasant debugging so
>     >> I prefer when we don't add new ones if avoidable)
>     >>
>
>     > I find silence to be much more unpleasant in practice when
>     > debugging, myself, but that may be a personal preference.
>
> +1
>
> I also *strongly* disagree with the claim
>
>    " in general warnings make for unpleasant debugging "
>
> That may be true for beginners (for whom debugging is often not really
> feasible anyway ..), but somewhat experienced useRs should know
>
> about
>     options(warn = 1) # or
>     options(warn = 2) # plus  options(error = recover) #
> or
>     tryCatch( ...,  warning = ..)
>
> or  {even more}
>
> Martin
>
> --
> Martin Maechler
> ETH Zurich  and  R Core team
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From @oko| @end|ng |rom |n@@-tou|ou@e@|r  Mon Mar  6 09:45:21 2023
From: @oko| @end|ng |rom |n@@-tou|ou@e@|r (Serguei Sokol)
Date: Mon, 6 Mar 2023 09:45:21 +0100
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
In-Reply-To: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
References: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
Message-ID: <60f31223-033a-21ee-67fd-b1a6566a0278@insa-toulouse.fr>

Le 04/03/2023 ? 01:21, Pavel Krivitsky a ?crit?:
> Dear All,
>
> Currently, list= in base::replace(x, list, value) has to be an index
> vector. For me, at least, the most common use case is for list= to be
> some simple property of elements of x, e.g.,
>
> x <- c(1,2,NA,3)
> replace(x, is.na(x), 0)
>
> Particularly when using R pipes, which don't allow multiple
> substitutions,
Right, but anonymous function syntax can palliate to this:

x |> (\(x) replace(x, is.na(x), 0))()


>   it would simplify many of such cases if list= could be a
> function that returns an index, e.g.,
>
> replace <- function (x, list, values, ...) {
>    # Here, list() refers to the argument, not the built-in.
>    if(is.function(list)) list <- list(x, ...)
>    x[list] <- values
>    x
> }
Before modifying the base of R, we should examine existing possibilities 
to achieve the same goal.
In this particular case and if the previous solution (anonymous 
function) is not satisfactory a thin one-line wrapper can make the job:

freplace <- function (x, list, values, ...) replace(x, 
if(is.function(list)) list <- list(x, ...) else list, values)

>
> Then, the following is possible:
>
> c(1,2,NA,3) |> replace(is.na, 0)
this becomes

c(1,2,NA,3) |> freplace(is.na, 0)

and looks quite acceptable for me.

Best,
Serguei.

>
> 			Any thoughts?
> 			Pavel
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


-- 
Serguei Sokol
Ingenieur de recherche INRAE

Cellule Math?matiques
TBI, INSA/INRAE UMR 792, INSA/CNRS UMR 5504
135 Avenue de Rangueil
31077 Toulouse Cedex 04

tel: +33 5 61 55 98 49
email: sokol at insa-toulouse.fr
http://www.toulouse-biotechnology-institute.fr/en/technology_platforms/mathematics-cell.html


From p@kr|v|t@ky @end|ng |rom un@w@edu@@u  Tue Mar  7 11:49:41 2023
From: p@kr|v|t@ky @end|ng |rom un@w@edu@@u (Pavel Krivitsky)
Date: Tue, 7 Mar 2023 10:49:41 +0000
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
In-Reply-To: <60f31223-033a-21ee-67fd-b1a6566a0278@insa-toulouse.fr>
References: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
 <60f31223-033a-21ee-67fd-b1a6566a0278@insa-toulouse.fr>
Message-ID: <d9dc22049a09fdbf55b43b21a947f61dda3d0720.camel@unsw.edu.au>

Dear Serguei,

On Mon, 2023-03-06 at 09:45 +0100, Serguei Sokol wrote:
> Right, but anonymous function syntax can palliate to this:
> 
> x |> (\(x) replace(x, is.na(x), 0))()

This approach hardly makes for concise or readable code.

> 
> Before modifying the base of R, we should examine existing
> possibilities to achieve the same goal.

Backwards-compatible enhancements to existing functions in base R
appear in every major release. In this case, the proposed behaviour of
replace() would be consistent with that of the *apply() family of
functions.

> In this particular case and if the previous solution (anonymous 
> function) is not satisfactory a thin one-line wrapper can make the
> job:
> 
> freplace <- function (x, list, values, ...) replace(x, 
> if(is.function(list)) list <- list(x, ...) else list, values)
> 
> this becomes
> 
> c(1,2,NA,3) |> freplace(is.na, 0)
> 
> and looks quite acceptable for me.

One could always implement a function that has this functionality, of
course. In fact, one could write,

replace <- function (x, list, values, ...) base::replace(x, 
  if(is.function(list)) list <- list(x, ...) else list, values)

and not even have to change the name. However, having to write it every
time defeats the purpose of having it in base in the first place.

				Best Regards,
				Pavel

> 
> Best,
> Serguei.
> 
> > 
> > ????????????????????????Any thoughts?
> > ????????????????????????Pavel
> > ______________________________________________
> > R-devel at r-project.org?mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> 


From ggrothend|eck @end|ng |rom gm@||@com  Tue Mar  7 13:33:56 2023
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Tue, 7 Mar 2023 07:33:56 -0500
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
In-Reply-To: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
References: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
Message-ID: <CAP01uRk2-FWoH9cceJP61ckxte1hGF3VVcwFjF12ouASvoBZ9g@mail.gmail.com>

This could be extended to sub and gsub as well which gsubfn in the
gusbfn package already does:

  library(gsubfn)
  gsubfn("^..", toupper, c("abc", "xyz"))
  ## [1] "ABc" "XYz"

On Fri, Mar 3, 2023 at 7:22?PM Pavel Krivitsky <p.krivitsky at unsw.edu.au> wrote:
>
> Dear All,
>
> Currently, list= in base::replace(x, list, value) has to be an index
> vector. For me, at least, the most common use case is for list= to be
> some simple property of elements of x, e.g.,
>
> x <- c(1,2,NA,3)
> replace(x, is.na(x), 0)
>
> Particularly when using R pipes, which don't allow multiple
> substitutions, it would simplify many of such cases if list= could be a
> function that returns an index, e.g.,
>
> replace <- function (x, list, values, ...) {
>   # Here, list() refers to the argument, not the built-in.
>   if(is.function(list)) list <- list(x, ...)
>   x[list] <- values
>   x
> }
>
> Then, the following is possible:
>
> c(1,2,NA,3) |> replace(is.na, 0)
>
>                         Any thoughts?
>                         Pavel
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From x|e @end|ng |rom y|hu|@n@me  Tue Mar  7 18:35:41 2023
From: x|e @end|ng |rom y|hu|@n@me (Yihui Xie)
Date: Tue, 7 Mar 2023 11:35:41 -0600
Subject: [Rd] 
 Undocumented change of dirname("C:/") on R-devel on Windows
In-Reply-To: <a182c76a-02f1-2ede-5ded-0752e7a618bd@gmail.com>
References: <CALyqOb8-eihVs9FW2AcH42mOCwZj2gLsq=j1sNUSthnf0k7Zow@mail.gmail.com>
 <1db6ce6b-04f0-b890-c320-3e0cbc20a99f@gmail.com>
 <CALyqOb8fuhNtO3QZVO75Zvb91EbV0ZgLvUPRyC6KkVYBWocUQw@mail.gmail.com>
 <CALyqOb8xCA182niry8_OudVw+xVpg=WiPCMsEQZTP=R7Wc2wzw@mail.gmail.com>
 <CANROs4cp5K5ZC3F8UcZa8Togd4EyuRmBiMxQrq4Du2=Asc5pUQ@mail.gmail.com>
 <a182c76a-02f1-2ede-5ded-0752e7a618bd@gmail.com>
Message-ID: <CANROs4df-Y6T-qp+LEqo3_LK67Hz7Xgm=Bgn7w81FEtbfDOuqQ@mail.gmail.com>

Thanks a lot! I can confirm that it has been fixed indeed.

Regards,
Yihui



On Mon, Feb 27, 2023 at 1:14?PM Tomas Kalibera <tomas.kalibera at gmail.com>
wrote:

>
> On 2/27/23 17:02, Yihui Xie wrote:
>
> Hi Tomas,
>
> There has been an R CMD check error with xfun and r-devel on Windows for a
> while:
> https://www.r-project.org/nosvn/R.check/r-devel-windows-x86_64/xfun-00check.html
> Basically it means that the following would return TRUE before:
>
>   normalizePath('a/b', mustWork = FALSE) == normalizePath('./a/b',
> mustWork = FALSE)
>
> but it became FALSE at some point in r-devel. I think 'a/b' and './a/b`
> should be treated as the same path. Does that make sense? Thanks!
>
> Thanks a lot for spotting and reporting this, fixed in R-devel.
> Normalization of non-existent paths was broken.
>
> Best
> Tomas
>
>
> Regards,
> Yihui
> --
> https://yihui.org
>
>
> On Thu, Feb 23, 2023 at 11:44 PM Hiroaki Yutani <yutani.ini at gmail.com>
> wrote:
>
>> I confirmed the revert fixed my failing test. Thanks!
>>
>> 2023?2?23?(?) 20:12 Hiroaki Yutani <yutani.ini at gmail.com>:
>>
>> > Thanks for the prompt response, I'll confirm it after the new R-devel
>> > binary is available.
>> > Also, thanks for the detailed explanation. I agree with you in general.
>> >
>> > > "/" in "C:/" is a path separator or not, and whether it is trailing or
>> > not
>> >
>> > It seems a Windows' path basically consists of two components; a drive
>> > specification (e.g., C:) and the directory structure within the drive.
>> What
>> > I learned today is that both "C:/" and "C:" are valid path
>> specifications,
>> > but refer to different locations; "C:" is not the root directory of the
>> > drive, but just a relative path [1]. So, I agree with you that the
>> basename
>> > of "C:/" should be "C:/". However, at the same time, I don't feel this
>> is
>> > worth a breaking change, so I think we can preserve the current (R
>> 4.2.2)
>> > behavior.
>> >
>> > [1]:
>> >
>> https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats#apply-the-current-directory
>> >
>> > Best,
>> > Yutani
>> >
>> > 2023?2?23?(?) 17:15 Tomas Kalibera <tomas.kalibera at gmail.com>:
>> >
>> >>
>> >> On 2/23/23 03:27, Hiroaki Yutani wrote:
>> >> > Hi,
>> >> >
>> >> > I found dirname() behaves differently on R-devel on Windows. Since
>> I'm
>> >> not
>> >> > sure which behavior is right, let me ask here before filing this to
>> R's
>> >> > Bigzilla.
>> >> >
>> >> > On R 4.2.2., we get
>> >> >
>> >> >      > dirname("C:/")
>> >> >      [1] "C:/"
>> >> >
>> >> > However, on R-devel (r83888), we get
>> >> >
>> >> >      > dirname("C:/")
>> >> >      [1] "."
>> >> >
>> >> > ?dirname says 'dirname returns the part of the path up to but
>> excluding
>> >> the
>> >> > last path separator, or "." if there is no path separator,' but I
>> don't
>> >> see
>> >> > how the root path is supposed to be treated based on this rule (,
>> >> whether
>> >> > it's WIndows or UNIX-alike).
>> >> Thanks for spotting the difference, I've reverted to the previous
>> >> behavior, the change was unintentional. If you spot any other
>> suspicious
>> >> changes in behavior in file-system operations, please report.
>> >> > What should we expect as the return value of dirname("C:/")? I feel
>> the
>> >> > current behavior on R 4.2.2 is right, but I'd like to confirm.
>> >>
>> >> I also think the old behavior is better, even though it could be argued
>> >> whether the "/" in "C:/" is a path separator or not, and whether it is
>> >> trailing or not. But the behavior is in line with Unix where dirname of
>> >> "/" is also "/". Msys2 would return "C:".
>> >>
>> >> If  "/" in "C:/" is a path separator but not a trailing path separator,
>> >> then basename("C:/") should probably be "" and not "C:", and this would
>> >> be in line with what R does on Unix. However, to be in line with Unix,
>> I
>> >> think the basename of "C:/" should be "C:/". Yet, Msys2 returns "C:"
>> >> which is what R does now.
>> >>
>> >> So what these functions should do on Windows is definitely tricky. In
>> >> either case the behavior is now again as in R 4.2.2.
>> >>
>> >> Best
>> >> Tomas
>> >>
>> >> >
>> >> > Best,
>> >> > Yutani
>> >> >
>> >> >       [[alternative HTML version deleted]]
>> >> >
>> >> > ______________________________________________
>> >> > R-devel at r-project.org mailing list
>> >> > https://stat.ethz.ch/mailman/listinfo/r-devel
>> >>
>> >
>>
>>         [[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>

	[[alternative HTML version deleted]]


