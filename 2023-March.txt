From ch|r|com @end|ng |rom goog|e@com  Wed Mar  1 10:36:02 2023
From: ch|r|com @end|ng |rom goog|e@com (Michael Chirico)
Date: Wed, 1 Mar 2023 01:36:02 -0800
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
Message-ID: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>

Consider:

x <- list(`a b` = 1)
x$a<tab>

(i.e., press the 'tab' key after typing 'x$a')

The auto-complete mechanism will fill the buffer like so:
x$a b

This is not particularly helpful because this is now a syntax error.

It seems to me there's a simple fix -- in
utils:::specialCompletions(), we can wrap the result of
utils:::specialOpCompletionsHelper() with backticks for non-syntactic
names ([1]):

comps <- specialOpCompletionsHelper(op, suffix, prefix)
if (length(comps) == 0L) comps <- ""
+non_syntactic <- make.names(comps) != comps
+comps[non_syntactic] <- paste0("`", comps[non_syntactic], "`")
sprintf("%s%s%s", prefix, op, comps)

I'm somewhat surprised this hasn't come up before (I searched for
'completeToken', 'specialCompletions', and
'specialOpCompletionsHelper' here and on Bugzilla), so I'm checking
with the list first if I'm missing anything before filing a patch.

Mike C

[1] https://github.com/r-devel/r-svn/blob/4657f65a377cb5ef318c6548bc264e3b0f9517a0/src/library/utils/R/completion.R#L536-L538


From kry|ov@r00t @end|ng |rom gm@||@com  Wed Mar  1 10:56:47 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Wed, 1 Mar 2023 12:56:47 +0300
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
Message-ID: <20230301125647.765cda59@arachnoid>

? Wed, 1 Mar 2023 01:36:02 -0800
Michael Chirico via R-devel <r-devel at r-project.org> ?????:

> +comps[non_syntactic] <- paste0("`", comps[non_syntactic], "`")

There are a few more corner cases. For example, comps could contain
backticks (which should be escaped with backslashes) and backslashes
(which should also be escaped). Thankfully, \uXXXX-style Unicode escape
sequences are not currently supported inside backticks, and "escape the
backslash" rule already takes care of them.

The deparse() function already knows these rules:

name <- 'hello world ` \\uFF'
cat(deparse1(as.name(name), backtick=TRUE), '\n')
# `hello world \` \\uFF`
`hello world \` \\uFF` <- 'hello'
`hello world \` \\uFF`
# [1] "hello"

-- 
Best regards,
Ivan


From @|@ergbox @end|ng |rom gm@||@com  Wed Mar  1 01:19:00 2023
From: @|@ergbox @end|ng |rom gm@||@com (Alexey Sergushichev)
Date: Tue, 28 Feb 2023 18:19:00 -0600
Subject: [Rd] Incorrect behavior of ks.test and psmirnov functions with
 exact=TRUE
Message-ID: <CAMGHQ95wXZ=LMVkUjDRsCJ_0P2VAbWnQrj-4_NvdXRGMuvVDvA@mail.gmail.com>

HI,

I've noticed what I think is an incorrect behavior of stats::psmirnov
function and consequently of ks.test when run in an exact mode.

For example:
psmirnov(1, sizes=c(50, 50), z=1:100, two.sided = FALSE, lower.tail = F,
exact=TRUE)

produces 2.775558e-15

However, the exact value should be 1/combination(100, 50), which is
9.9e-30. While the absolute error is small, the relative error is huge, and
it is not fixed by setting option log.p=T

To compare, SciPy has a correct implementation in scipy.stats.ks_2samp:
scipy.stats.ks_2samp(list(range(1,51)), list(range(51, 101)),
alternative="greater", method="exact")
returns 9.911653021418333e-30.

I've tried to dig in a bit and the problem comes down to how the final
value is calculated in psmirnov function:

    if (log.p & !lower.tail)
        return(log1p(-ret/exp(logdenom)))
    if (!log.p & !lower.tail)
        return(1 - ret/exp(logdenom))

There exp(logdenom) is a relatively good (but not perfect) approximation of
combination(100, 50) = 1.008913e+29, ret is also a good approximation of
combination(100, 50)-1 = 1.008913e+29 but there is not enough double
precision for 1 - ret/exp(logdenom) to capture 1/combination(100, 50).

I don't have time to provide a fix, at least not now, but I think this
behavior (good absolute error, but poor relative error for small values)
should at least be mentioned in the manual of the methods psmirnov and/or
ks.test

Best,
Alexey Sergushichev

	[[alternative HTML version deleted]]


From pd@me@ @end|ng |rom cb@@dk  Wed Mar  1 13:04:56 2023
From: pd@me@ @end|ng |rom cb@@dk (Peter Dalgaard)
Date: Wed, 1 Mar 2023 12:04:56 +0000
Subject: [Rd] R 4.2.3 scheduled for March 15
Message-ID: <0698828C-0FC0-421C-92DC-045717E4F7A2@cbs.dk>

Full schedule available on developer.r-project.org in a short while.

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From @nto|ne@|@br| @end|ng |rom gm@||@com  Wed Mar  1 13:53:21 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Wed, 1 Mar 2023 13:53:21 +0100
Subject: [Rd] confusing all.equal output
Message-ID: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>

dear r-devel,

This has probably been forever like this but is this satisfying ?

all.equal(c(1,NA,NA), c(1,NA,3))
#> [1] "'is.NA' value mismatch: 1 in current 2 in target"

is.NA() doesn't exist (is.na() does), and is.na() is never 1 or 2.

In this example it's obvious that we're counting missing values, in a
general situation I believe it isn't (we might understand it as the
position of the first NA for instance).

I would expect something like "'amount of missing values mismatch: 1 in
current 2 in target"

Thanks,

Antoine

	[[alternative HTML version deleted]]


From ch|r|com @end|ng |rom goog|e@com  Wed Mar  1 17:48:08 2023
From: ch|r|com @end|ng |rom goog|e@com (Michael Chirico)
Date: Wed, 1 Mar 2023 08:48:08 -0800
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <20230301125647.765cda59@arachnoid>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
Message-ID: <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>

Great suggestion! I've started a patch:
https://bugs.r-project.org/show_bug.cgi?id=18479

On Wed, Mar 1, 2023 at 1:56 AM Ivan Krylov <krylov.r00t at gmail.com> wrote:
>
> ? Wed, 1 Mar 2023 01:36:02 -0800
> Michael Chirico via R-devel <r-devel at r-project.org> ?????:
>
> > +comps[non_syntactic] <- paste0("`", comps[non_syntactic], "`")
>
> There are a few more corner cases. For example, comps could contain
> backticks (which should be escaped with backslashes) and backslashes
> (which should also be escaped). Thankfully, \uXXXX-style Unicode escape
> sequences are not currently supported inside backticks, and "escape the
> backslash" rule already takes care of them.
>
> The deparse() function already knows these rules:
>
> name <- 'hello world ` \\uFF'
> cat(deparse1(as.name(name), backtick=TRUE), '\n')
> # `hello world \` \\uFF`
> `hello world \` \\uFF` <- 'hello'
> `hello world \` \\uFF`
> # [1] "hello"
>
> --
> Best regards,
> Ivan


From AHL27 @end|ng |rom p|tt@edu  Wed Mar  1 17:52:20 2023
From: AHL27 @end|ng |rom p|tt@edu (Lakshman, Aidan H)
Date: Wed, 1 Mar 2023 16:52:20 +0000
Subject: [Rd] `dendrapply` Enhancements
In-Reply-To: <BL0PR04MB4706A66884728B9419CEAE00D9A89@BL0PR04MB4706.namprd04.prod.outlook.com>
References: <BL0PR04MB47068D544F5A49315EF1D042D9AB9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <CALK03d1PWiA4tfbRkxMBU6tckhfB2JRGUmnuqh5ygLcCLHDXNw@mail.gmail.com>
 <BL0PR04MB4706A66884728B9419CEAE00D9A89@BL0PR04MB4706.namprd04.prod.outlook.com>
Message-ID: <BL0PR04MB4706B185A345A98AB4AB829AD9AC9@BL0PR04MB4706.namprd04.prod.outlook.com>

Just wanted to give an update on the status of this, since it?s been a couple days and I?ve had a chance to work on it a little more.

Improvements:
- Fixed a few bugs, added some more robust checking to ensure correct checking for leaf nodes
- Corrected references to ?in-order? traversals, I actually meant ?pre-order?
- Added new documentation, including some new examples to the ?Usage? section
- Cleaned up some names/variables/identifiers
- Added some additional code to have function accurately replicate a weird bug of `stats::dendrapply` that is used in CRAN packages. Full details are in my PR (linked below).


I?ve integrated this into the svn mirror at r-devel/r-svn, and put out a PR at https://github.com/r-devel/r-svn/pull/111. Current PR is passing all build checks aside from Windows, which is throwing the error `Sorry, but: Error response from server: 500` while installing Miktex. I?m not sure what?s causing this, but it seems to be something aside from my code because it?s also crashing builds for other PRs.

A link to the diff file is here: https://patch-diff.githubusercontent.com/raw/r-devel/r-svn/pull/111.diff

Happy to open a Bugzilla report as well; this is enough code that a discussion is probably warranted, and Bugzilla may be an easier place to discuss compared to here. Also happy to discuss on the PR itself.

Thank you to everyone that has taken a look at my code, I appreciate people taking the time to read through it.

Sincerely,
Aidan Lakshman

-----------------------
Aidan Lakshman (he/him)<https://www.ahl27.com/>
Doctoral Candidate, Wright Lab<https://www.wrightlabscience.com/>
University of Pittsburgh School of Medicine
Department of Biomedical Informatics
ahl27 at pitt.edu
(724) 612-9940


From: Lakshman, Aidan H <AHL27 at pitt.edu>
Date: Friday, February 24, 2023 at 07:42
To: Toby Hocking <tdhock5 at gmail.com>
Cc: R-devel at r-project.org <R-devel at r-project.org>
Subject: Re: [Rd] `dendrapply` Enhancements
Hi Toby,

Thanks for your reply! I haven?t heard about the R project sprint, but I?ll definitely check it out. UK is going to be a little hard for me to get to funding-wise, but I?ll try to apply for funding.

I appreciate your other comments. As far as coding style, I did do everything I could think of to make sure it?s a drop-in replacement for the current version with the default settings, so all the user-exposed arguments/variables should be identical. I used the conventions in https://github.com/wch/r-source/wiki/Contributing for commenting and whitespace, so hopefully that all looks okay. I?m realizing there may be some differences in tab widths, but I can fix that later today.

-Aidan

-----------------------
Aidan Lakshman (he/him)<https://www.ahl27.com/>
Doctoral Candidate, Wright Lab<https://www.wrightlabscience.com/>
University of Pittsburgh School of Medicine
Department of Biomedical Informatics
ahl27 at pitt.edu
(724) 612-9940


From: Toby Hocking <tdhock5 at gmail.com>
Date: Friday, February 24, 2023 at 06:57
To: Lakshman, Aidan H <AHL27 at pitt.edu>
Cc: R-devel at r-project.org <R-devel at r-project.org>
Subject: Re: [Rd] `dendrapply` Enhancements
Hi Aidan, I think you are on the right email list.
I'm not R-core, but this looks like an interesting/meaningful/significant contribution to base R.
I'm not sure what the original dendrapply looks like in terms of code style (variable names/white space formatting/etc) but in my experience it is important that your code contribution makes minimal changes in that area.
Did you hear about the R project sprint 2023? https://contributor.r-project.org/r-project-sprint-2023/<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fcontributor.r-project.org%2Fr-project-sprint-2023%2F&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=oB%2BBivUsBjIgBtZNU8mh%2Fz2rujD3bv9MbWdxqNtyUFk%3D&reserved=0> Your work falls into the "new developments" category so I think you could apply for that funding to participate.
Toby

On Fri, Feb 24, 2023 at 3:47 AM Lakshman, Aidan H <AHL27 at pitt.edu<mailto:AHL27 at pitt.edu>> wrote:
Hi everyone,

My apologies if this isn?t the right place to submit this?I?m new to the R-devel community and still figuring out what is where.

If people want to skip my writeup and just look at the code, I?ve made a repository for it here: https://github.com/ahl27/new_dendrapply/tree/master<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fahl27%2Fnew_dendrapply%2Ftree%2Fmaster&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=QI%2B5t1C%2BJB15D8o8noZra4W87fgyITm12nluGN%2BFNoE%3D&reserved=0>. I?m not quite sure how to integrate it into a fork of R-devel; the package structure is different from what I?m used to.

I had written a slightly improved version of dendrapply for one of my research projects, and my advisor encouraged me to submit it to the R project. It took me longer than I expected, but I?ve finally gotten my implementation to be a drop-in replacement for `stats::dendrapply`. The man page for `stats::dendrapply` says ?The implementation is somewhat experimental and suggestions for enhancements (or nice examples of usage) are very welcome,? so I figured this had the potential to be a worthwhile contribution. I wanted to send it out to R-devel to see if this was something worth pursuing as an enhancement to R.

The implementation I have is based in C, which I understand implies an increased burden of maintenance over pure R code. However, it does come with the following benefits:

- Completely eliminates recursion, so no memory overhead from function calls or possibility of stack overflows (this was a major issue reported on some of the functions in one of our Bioconductor packages that previously used `dendrapply`).
- Modest runtime improvement, around 2x on my computer (2021 MBP, 32GB RAM). I?m relatively confident this could be optimized more.
- Seemingly significant reduction in memory reduction, still working on a robust benchmark. Suggestions for the best way to do that are welcome.
- Support for applying functions with an inorder traversal (as in `stats::dendrapply`) as well as using a postorder traversal.

This implementation was tested manually as well as running all the unit tests in `dendextend`, which comprises a lot of applications of `dendrapply`.

The postorder traversal would be a significant new functionality to dendrapply, as it would allow for functions that use the child nodes to correctly execute. A toy example of this is something like:
```
exFunc <- function(x){
  attr(x, 'newA') <- 'a'
  if(is.null(attr(x, 'leaf'))){
    cat(attr(x[[1]], 'newA'), attr(x[[2]], 'newA'))
    cat('\n')
  }
  x
})

dendrapply(dend, exFunc)
```

With the current version of dendrapply, this prints nothing, but the postorder traversal version will print ?a? twice for each internal branch. If this would be a worthwhile addition, I can refactor the code for brevity and add a `how=c("in.order", "post.order")`, with the default value ?in.order? to maintain backwards compatibility. A preorder traversal version should also be possible, I just haven?t gotten to it yet.

I think the runtime could be optimized more as well.

Thank you in advance for looking at my code and offering feedback; I?m excited at the possibility of helping contribute to the R project! I?m happy to discuss more either here, on GitHub, or on the R Contributors Slack.

Sincerely,
Aidan Lakshman

-----------------------
Aidan Lakshman (he/him)<https://www.ahl27.com/<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.ahl27.com%2F&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=7KUpJpdulSIzSXbpDJlyUV8pMJm%2BSVFvDOJTlVs9lhc%3D&reserved=0>>
Doctoral Candidate, Wright Lab<https://www.wrightlabscience.com/<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.wrightlabscience.com%2F&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=JMgw%2BMiQ6xdp3OokToJ2nyyco%2BryiFH%2B9ap5iU3yJH8%3D&reserved=0>>
University of Pittsburgh School of Medicine
Department of Biomedical Informatics
ahl27 at pitt.edu<mailto:ahl27 at pitt.edu>
(724) 612-9940


        [[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=I88%2FQhGHXDRS2yHqvh53k3MSWHSd5z2KBgORUHIxfG0%3D&reserved=0>

	[[alternative HTML version deleted]]


From kry|ov@r00t @end|ng |rom gm@||@com  Thu Mar  2 09:39:38 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Thu, 2 Mar 2023 11:39:38 +0300
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
 <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
Message-ID: <20230302113938.26be9522@Tarkus>

There turn out to be a few more things to fix.

One problem is easy to solve: vapply() needs a third argument
specifying the type of the return value. (Can we have unit tests for
tab completion?)

The other problem is harder: `comps` defaults to an empty string, and
you can't have a symbol consisting of an empty string, because this
value is internally reserved for missing function arguments. I think
you can return(paste0(prefix, op)) if length(comps) == 0L, but this is
still somewhat worrying. R tries to prevent empty names, so I wouldn't
expect specialOpCompletionsHelper() to return an empty string, but I
can't prove it right now.

On the other hand, x$'a string' is the same as x$`a string`. Could we
just drop as.name() and keep the return value being a string literal?
I'm not sure about this, either.

-- 
Best regards,
Ivan


From deep@y@n@@@rk@r @end|ng |rom gm@||@com  Thu Mar  2 10:03:03 2023
From: deep@y@n@@@rk@r @end|ng |rom gm@||@com (Deepayan Sarkar)
Date: Thu, 2 Mar 2023 14:33:03 +0530
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <20230302113938.26be9522@Tarkus>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
 <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
 <20230302113938.26be9522@Tarkus>
Message-ID: <CADfFDC6CQRJ6fP2vSc+WKibccFN_j1jeKvgptF-Da15MWpomZQ@mail.gmail.com>

On Thu, Mar 2, 2023 at 2:09?PM Ivan Krylov <krylov.r00t at gmail.com> wrote:
>
> There turn out to be a few more things to fix.
>
> One problem is easy to solve: vapply() needs a third argument
> specifying the type of the return value. (Can we have unit tests for
> tab completion?)

There are tests in

src/library/utils/tests/completion.R

which should get run by make check-devel (which runs R CMD check on
all base packages).

> The other problem is harder: `comps` defaults to an empty string, and
> you can't have a symbol consisting of an empty string, because this
> value is internally reserved for missing function arguments. I think
> you can return(paste0(prefix, op)) if length(comps) == 0L, but this is
> still somewhat worrying. R tries to prevent empty names, so I wouldn't
> expect specialOpCompletionsHelper() to return an empty string, but I
> can't prove it right now.
>
> On the other hand, x$'a string' is the same as x$`a string`. Could we
> just drop as.name() and keep the return value being a string literal?
> I'm not sure about this, either.

See my just-posted response on bugzilla for other issues to look out for.

Best,
-Deepayan

> --
> Best regards,
> Ivan
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From ch|r|com @end|ng |rom goog|e@com  Thu Mar  2 10:37:09 2023
From: ch|r|com @end|ng |rom goog|e@com (Michael Chirico)
Date: Thu, 2 Mar 2023 01:37:09 -0800
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <20230302113938.26be9522@Tarkus>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
 <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
 <20230302113938.26be9522@Tarkus>
Message-ID: <CAD7Bkx8YZgYo8bBoYegXQG+vcJmxbTSE+9uMOf8nZ2iOig0q7g@mail.gmail.com>

I personally wouldn't like using a string, and this comment makes me
think it's against the r-core preference as well:

https://bugs.r-project.org/show_bug.cgi?id=18429#c1

Thanks both for catching the sloppy mistake in vapply() :)

Let's continue discussion on the bug/PR.

On Thu, Mar 2, 2023 at 12:39 AM Ivan Krylov <krylov.r00t at gmail.com> wrote:
>
> There turn out to be a few more things to fix.
>
> One problem is easy to solve: vapply() needs a third argument
> specifying the type of the return value. (Can we have unit tests for
> tab completion?)
>
> The other problem is harder: `comps` defaults to an empty string, and
> you can't have a symbol consisting of an empty string, because this
> value is internally reserved for missing function arguments. I think
> you can return(paste0(prefix, op)) if length(comps) == 0L, but this is
> still somewhat worrying. R tries to prevent empty names, so I wouldn't
> expect specialOpCompletionsHelper() to return an empty string, but I
> can't prove it right now.
>
> On the other hand, x$'a string' is the same as x$`a string`. Could we
> just drop as.name() and keep the return value being a string literal?
> I'm not sure about this, either.
>
> --
> Best regards,
> Ivan


From pd@|gd @end|ng |rom gm@||@com  Thu Mar  2 14:18:34 2023
From: pd@|gd @end|ng |rom gm@||@com (peter dalgaard)
Date: Thu, 2 Mar 2023 14:18:34 +0100
Subject: [Rd] confusing all.equal output
In-Reply-To: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
Message-ID: <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>

Yes... Also, of course, the sentence after colon does not the describe the cause of the mismatch, e.g.

> all.equal(c(1,NA,NA), c(NA,NA,3))
[1] "'is.NA' value mismatch: 2 in current 2 in target"

could be confusing. 

Perhaps "is.na() mismatch (2 positions)", with the count calculated as sum(is.na(current) != is.na(target)) instead? 

Or you could give both off-diagonal elements of the confusion matrix:

"target-only: 1, current-only: 1"

but actually, the whole current/target terminology is somewhat unclear.

-pd

> On 1 Mar 2023, at 13:53 , Antoine Fabri <antoine.fabri at gmail.com> wrote:
> 
> dear r-devel,
> 
> This has probably been forever like this but is this satisfying ?
> 
> all.equal(c(1,NA,NA), c(1,NA,3))
> #> [1] "'is.NA' value mismatch: 1 in current 2 in target"
> 
> is.NA() doesn't exist (is.na() does), and is.na() is never 1 or 2.
> 
> In this example it's obvious that we're counting missing values, in a
> general situation I believe it isn't (we might understand it as the
> position of the first NA for instance).
> 
> I would expect something like "'amount of missing values mismatch: 1 in
> current 2 in target"
> 
> Thanks,
> 
> Antoine
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From kry|ov@r00t @end|ng |rom gm@||@com  Thu Mar  2 15:47:50 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Thu, 2 Mar 2023 17:47:50 +0300
Subject: [Rd] `dendrapply` Enhancements
In-Reply-To: <BL0PR04MB4706B185A345A98AB4AB829AD9AC9@BL0PR04MB4706.namprd04.prod.outlook.com>
References: <BL0PR04MB47068D544F5A49315EF1D042D9AB9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <CALK03d1PWiA4tfbRkxMBU6tckhfB2JRGUmnuqh5ygLcCLHDXNw@mail.gmail.com>
 <BL0PR04MB4706A66884728B9419CEAE00D9A89@BL0PR04MB4706.namprd04.prod.outlook.com>
 <BL0PR04MB4706B185A345A98AB4AB829AD9AC9@BL0PR04MB4706.namprd04.prod.outlook.com>
Message-ID: <20230302174750.19c3b247@arachnoid>

Dear Aidan Lakshman,

To answer your implicit question, VECTOR_ELT() unclasses the nodes
because it doesn't go through the stats:::`[[.dendrogram` method,
instead dereferencing the data pointer directly.

Other *apply functions in base R create a call to the `[[` operator,
letting the language dispatch the generic call, allowing the method to
assign a class to the return value. The following example is taken from
src/main/apply.c:do_lapply():

// prepare a call to FUN(X[[i]], ...)

    SEXP isym = install("i");
    SEXP tmp = PROTECT(lang3(R_Bracket2Symbol, X, isym));
    SEXP R_fcall = PROTECT(lang3(FUN, tmp, R_DotsSymbol));
    MARK_NOT_MUTABLE(R_fcall);

// inside the loop: evaluate the call

        tmp = R_forceAndCall(R_fcall, 1, rho);

Not sure which way is faster, but it may make sense to try, and it's
probably more correct in (contrived) cases where unclass(node)[[i]] is
invalid because it relies on a hypothetical `[[.subclass-of-dendrogram`
to restore some invariants.

Would you mind telling me more about the following case?

> if(!(inherits(res,c('dendrogram', 'list')))){
>  res1 <- lapply(unclass(node), \(x) x)
> }

If you're looking to improve the performance, there might be a way to
avoid the wrapper and this lapply(unclass(node), identity) call in it.

-- 
Best regards,
Ivan


From AHL27 @end|ng |rom p|tt@edu  Thu Mar  2 16:38:20 2023
From: AHL27 @end|ng |rom p|tt@edu (Lakshman, Aidan H)
Date: Thu, 2 Mar 2023 15:38:20 +0000
Subject: [Rd] `dendrapply` Enhancements
In-Reply-To: <20230302174750.19c3b247@arachnoid>
References: <BL0PR04MB47068D544F5A49315EF1D042D9AB9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <CALK03d1PWiA4tfbRkxMBU6tckhfB2JRGUmnuqh5ygLcCLHDXNw@mail.gmail.com>
 <BL0PR04MB4706A66884728B9419CEAE00D9A89@BL0PR04MB4706.namprd04.prod.outlook.com>
 <BL0PR04MB4706B185A345A98AB4AB829AD9AC9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <20230302174750.19c3b247@arachnoid>
Message-ID: <BL0PR04MB47069CCBD8C6EB57BB22533ED9B29@BL0PR04MB4706.namprd04.prod.outlook.com>

Thanks for your reply!

> To answer your implicit question, VECTOR_ELT() unclasses the nodes
> because it doesn't go through the stats:::`[[.dendrogram` method,
> instead dereferencing the data pointer directly.

That?s roughly what I had suspected?I appreciate the clarification.

To your point on other *apply functions, I wasn?t actually aware of that implementation, but it?s definitely a smarter way to do it. I?ll try later today/tomorrow to incorporate that method; it seems much better and more future-proof than my approach. Definitely agree with you with respect to cases where unclass(node)[[i]] is invalid. It may be slightly slower due to having to rely on R method dispatch, but I think the benefits outweigh the drawbacks in this case.

> Would you mind telling me more about the following case?

> > if(!(inherits(res,c('dendrogram', 'list')))){
> >   res1 <- lapply(unclass(node), \(x) x)
> > }

> If you're looking to improve the performance, there might be a way to
> avoid the wrapper and this lapply(unclass(node), identity) call in it.

This was a product of trying to get performance to be the same as in the current method?I agree that it?s probably not the best way to do this. The use-case is when you apply a function to the dendrogram that doesn?t return a dendrogram object. One example is the one from reg-tests-1c.R:

```
D <- as.dendrogram(hclust(dist(cbind(setNames(c(0,1,4), LETTERS[1:3])))))

dendrapply(D, labels))



# Expected result:

#
# [[1]]

# ?C?
#
# [[2]]
# [[2]][[1]]
# ?A?

#

# [[2]][[2]]

# ?B?

#

# [[3]]

# ?C?
```

Applying labels to the root node returns c(?C?, ?A?, ?B?), and if we convert that to a list, we get a length 3 list of length 1 character vectors. However, when traversing the dendrogram pre-order, this would break things, since then the first entry of the node is no longer a dendrogram object, it?s been replaced by a character vector. I had written it this way with the unclass so that I could replace entries that needed to be evaluated at child nodes with child nodes. For example, in this instance, after evaluating the function at the root, the tree would look like:

```
[[1]]
<unclassed D[[1]]>

[[2]]
<unclassed D[[2]]>

[[3]]
?B?
```

To answer the question on why there?s an lapply(?, identity) call, I think I ended up doing it this way because I was having some issues with not getting the elements to populate correctly from the dendrogram. Looking back on it now, there?s definitely an easier way to do this that isn?t so hard to understand code-wise?.
```
if(!is.leaf(node)){
      if(!is.list(res)){
        res <- as.list(res)
      }
      res[seq_along(node)] <- node
    }
```
That should perform almost identically and make more sense, with the added benefit that it doesn?t unclass the child nodes, so (when I also incorporate the other fix you suggested) we shouldn?t have any unexpected performance from functions relying on a hypothetical `subclass-of-dendrogram`. This implementation is also slightly faster due to no lapply call and is.list() over inherits(?).

Result after applying to root node with this approach:
```
[[1]]
D[[1]]

[[2]]
D[[2]]

[[3]]
?B?
```
Classes of D[[1]] and D[[2]] are preserved for future evaluations.

Thanks for pointing this out, I?ll incorporate this into the code when I check the `[[` case later. If you have any other questions/comments/suggestions I would love to hear them! Happy to clarify further as well if I didn?t answer your questions fully.

Sincerely,
Aidan

-----------------------
Aidan Lakshman (he/him)<https://www.ahl27.com/>
Doctoral Candidate, Wright Lab<https://www.wrightlabscience.com/>
University of Pittsburgh School of Medicine
Department of Biomedical Informatics
ahl27 at pitt.edu
(724) 612-9940


From: Ivan Krylov <krylov.r00t at gmail.com>
Date: Thursday, March 2, 2023 at 09:47
To: Lakshman, Aidan H <AHL27 at pitt.edu>
Cc: R-devel at r-project.org <R-devel at r-project.org>
Subject: Re: [Rd] `dendrapply` Enhancements
Dear Aidan Lakshman,

To answer your implicit question, VECTOR_ELT() unclasses the nodes
because it doesn't go through the stats:::`[[.dendrogram` method,
instead dereferencing the data pointer directly.

Other *apply functions in base R create a call to the `[[` operator,
letting the language dispatch the generic call, allowing the method to
assign a class to the return value. The following example is taken from
src/main/apply.c:do_lapply():

// prepare a call to FUN(X[[i]], ...)

    SEXP isym = install("i");
    SEXP tmp = PROTECT(lang3(R_Bracket2Symbol, X, isym));
    SEXP R_fcall = PROTECT(lang3(FUN, tmp, R_DotsSymbol));
    MARK_NOT_MUTABLE(R_fcall);

// inside the loop: evaluate the call

        tmp = R_forceAndCall(R_fcall, 1, rho);

Not sure which way is faster, but it may make sense to try, and it's
probably more correct in (contrived) cases where unclass(node)[[i]] is
invalid because it relies on a hypothetical `[[.subclass-of-dendrogram`
to restore some invariants.

Would you mind telling me more about the following case?

> if(!(inherits(res,c('dendrogram', 'list')))){
>  res1 <- lapply(unclass(node), \(x) x)
> }

If you're looking to improve the performance, there might be a way to
avoid the wrapper and this lapply(unclass(node), identity) call in it.

--
Best regards,
Ivan

	[[alternative HTML version deleted]]


From @nto|ne@|@br| @end|ng |rom gm@||@com  Thu Mar  2 18:23:12 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Thu, 2 Mar 2023 18:23:12 +0100
Subject: [Rd] confusing all.equal output
In-Reply-To: <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
 <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
Message-ID: <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>

Good points. I don't mind the terminology since target and current are the
names of the arguments. As the function is already designed to stop at the
first failing check we might not need to enumerate or count the mismatches,
instead we could have "`NA` found in `target` but not in `current` at
position <FIRST_MISMATCH>"

	[[alternative HTML version deleted]]


From w||||@mwdun|@p @end|ng |rom gm@||@com  Thu Mar  2 18:39:24 2023
From: w||||@mwdun|@p @end|ng |rom gm@||@com (Bill Dunlap)
Date: Thu, 2 Mar 2023 09:39:24 -0800
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <20230302113938.26be9522@Tarkus>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
 <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
 <20230302113938.26be9522@Tarkus>
Message-ID: <CAHqSRuRaASWG-Dka76Vb4J9JXWJJKssN8ZfHjt=gQf6RmTaduQ@mail.gmail.com>

x$`string` is not the same as x$'string'.  They may act similarly now, but
they do not parse the same.

> vapply(as.list(quote(list$`component`)), typeof, "")
[1] "symbol" "symbol" "symbol"
> vapply(as.list(quote(list$"component")), typeof, "")
[1] "symbol"    "symbol"    "character"
> vapply(as.list(quote(list$'component')), typeof, "")
[1] "symbol"    "symbol"    "character"

Single and double quoted character sequences do parse to the same thing
(character) but backquoted ones parse to symbols (aka names).

-Bill

On Thu, Mar 2, 2023 at 12:39?AM Ivan Krylov <krylov.r00t at gmail.com> wrote:

> There turn out to be a few more things to fix.
>
> One problem is easy to solve: vapply() needs a third argument
> specifying the type of the return value. (Can we have unit tests for
> tab completion?)
>
> The other problem is harder: `comps` defaults to an empty string, and
> you can't have a symbol consisting of an empty string, because this
> value is internally reserved for missing function arguments. I think
> you can return(paste0(prefix, op)) if length(comps) == 0L, but this is
> still somewhat worrying. R tries to prevent empty names, so I wouldn't
> expect specialOpCompletionsHelper() to return an empty string, but I
> can't prove it right now.
>
> On the other hand, x$'a string' is the same as x$`a string`. Could we
> just drop as.name() and keep the return value being a string literal?
> I'm not sure about this, either.
>
> --
> Best regards,
> Ivan
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From @nto|ne@|@br| @end|ng |rom gm@||@com  Thu Mar  2 18:49:52 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Thu, 2 Mar 2023 18:49:52 +0100
Subject: [Rd] transform.data.frame() ignores unnamed arguments when no named
 argument is provided
Message-ID: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>

Dear r-devel,

See below:


transform(data.frame(a = 1), 2, 3)

#>   a

#> 1 1


transform(data.frame(a = 1), b=2, 3)

#>   a b X3

#> 1 1 2  3


We need a small modification to make it work consistently, see below:


transform.data.frame <- function (`_data`, ...) {

  e <- eval(substitute(list(...)), `_data`, parent.frame())

  tags <- names(e)

  ## NEW LINE -----------------------------------------------

  if (is.null(tags)) tags <- character(length(e))

  inx <- match(tags, names(`_data`))

  matched <- !is.na(inx)

  if (any(matched)) {

    `_data`[inx[matched]] <- e[matched]

    `_data` <- data.frame(`_data`)

  }

  if (!all(matched))

    do.call("data.frame", c(list(`_data`), e[!matched]))

  else `_data`

}


transform(data.frame(a = 1), 2, 3)

#>   a X2 X3

#> 1 1  2  3

transform(data.frame(a = 1), b=2, 3)

#>   a b X3

#> 1 1 2  3


Thanks,


Antoine

	[[alternative HTML version deleted]]


From @vi@e@gross m@iii@g oii gm@ii@com  Thu Mar  2 19:30:42 2023
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Thu, 2 Mar 2023 13:30:42 -0500
Subject: [Rd] confusing all.equal output
In-Reply-To: <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
 <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
 <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>
Message-ID: <001d01d94d35$187fbb90$497f32b0$@gmail.com>

I think if you step back, you can ask what the purpose of an error message
is and who designs it.

Is the message for the developer or others on their team or something an
end-user knowing nothing about R will see.

This reminds me a bit of legal mumbo jumbo that turns many reading it off as
it keeps talking about the party of the first part or the plaintiff as
compared to somewhat straighter talk.

The scenario is that you are comparing two things. Their names are not
things like "target" or "current" so even other programmers not involved in
your code will pause and wonder.

One view is to use phrases like first and second arguments/lists/whatever.
You might talk about the one on the left (but using LHS is a bit opaque)
versus the one on the right. 

But sometimes it can be too verbose. Sometimes the error message is being
generated not where everything is clear.

So ideally you could say:

WARNING Danger Will Robinson.
Comparing two things for equality.
Result finds mismatches.
There were NA found on the (left or right) that were not matched on the
other side.
Number of such found: 2

If you had a Systems Engineer write detailed requirements that included
something a bit better than the example and the programmer was able to
supply the data using the words and guidelines, it might fit some needs but
maybe not satisfy other programmers. But there are human factors people
whose job it is to help choose among alternatives and although they may not
choose well, letting a programmer come up with whatever they feel like is
generally worse. 

Yes, in their microcosm centered on a dozen lines of code, "current" and
"target" may have meaning. But are they the intended user of the product?

-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Antoine Fabri
Sent: Thursday, March 2, 2023 12:23 PM
To: peter dalgaard <pdalgd at gmail.com>
Cc: R-devel <r-devel at r-project.org>
Subject: Re: [Rd] confusing all.equal output

Good points. I don't mind the terminology since target and current are the
names of the arguments. As the function is already designed to stop at the
first failing check we might not need to enumerate or count the mismatches,
instead we could have "`NA` found in `target` but not in `current` at
position <FIRST_MISMATCH>"

	[[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From pd@|gd @end|ng |rom gm@||@com  Thu Mar  2 19:47:59 2023
From: pd@|gd @end|ng |rom gm@||@com (peter dalgaard)
Date: Thu, 2 Mar 2023 19:47:59 +0100
Subject: [Rd] confusing all.equal output
In-Reply-To: <001d01d94d35$187fbb90$497f32b0$@gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
 <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
 <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>
 <001d01d94d35$187fbb90$497f32b0$@gmail.com>
Message-ID: <B97B1379-B884-4DBF-A926-82789F81B93B@gmail.com>

I believe the wording goes back to Martin Maechler many moons ago (AFAICT towards the end of the last millennium.)

We might leave it to him to change it?

- Peter D.

> On 2 Mar 2023, at 19:30 , avi.e.gross at gmail.com wrote:
> 
> I think if you step back, you can ask what the purpose of an error message
> is and who designs it.
> 
> Is the message for the developer or others on their team or something an
> end-user knowing nothing about R will see.
> 
> This reminds me a bit of legal mumbo jumbo that turns many reading it off as
> it keeps talking about the party of the first part or the plaintiff as
> compared to somewhat straighter talk.
> 
> The scenario is that you are comparing two things. Their names are not
> things like "target" or "current" so even other programmers not involved in
> your code will pause and wonder.
> 
> One view is to use phrases like first and second arguments/lists/whatever.
> You might talk about the one on the left (but using LHS is a bit opaque)
> versus the one on the right. 
> 
> But sometimes it can be too verbose. Sometimes the error message is being
> generated not where everything is clear.
> 
> So ideally you could say:
> 
> WARNING Danger Will Robinson.
> Comparing two things for equality.
> Result finds mismatches.
> There were NA found on the (left or right) that were not matched on the
> other side.
> Number of such found: 2
> 
> If you had a Systems Engineer write detailed requirements that included
> something a bit better than the example and the programmer was able to
> supply the data using the words and guidelines, it might fit some needs but
> maybe not satisfy other programmers. But there are human factors people
> whose job it is to help choose among alternatives and although they may not
> choose well, letting a programmer come up with whatever they feel like is
> generally worse. 
> 
> Yes, in their microcosm centered on a dozen lines of code, "current" and
> "target" may have meaning. But are they the intended user of the product?
> 
> -----Original Message-----
> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Antoine Fabri
> Sent: Thursday, March 2, 2023 12:23 PM
> To: peter dalgaard <pdalgd at gmail.com>
> Cc: R-devel <r-devel at r-project.org>
> Subject: Re: [Rd] confusing all.equal output
> 
> Good points. I don't mind the terminology since target and current are the
> names of the arguments. As the function is already designed to stop at the
> first failing check we might not need to enumerate or count the mismatches,
> instead we could have "`NA` found in `target` but not in `current` at
> position <FIRST_MISMATCH>"
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From @eb@meyer @end|ng |rom |@u@de  Thu Mar  2 22:34:33 2023
From: @eb@meyer @end|ng |rom |@u@de (Sebastian Meyer)
Date: Thu, 2 Mar 2023 22:34:33 +0100
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
Message-ID: <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>

Note that ?transform.data.frame says arguments need to be named, so you 
are testing unspecified behaviour. I guess this falls in a similar 
category as the note

      If some of the values are not vectors of the appropriate length,
      you deserve whatever you get!

Experiments for a related Problem Report 
(<https://bugs.r-project.org/show_bug.cgi?id=17890>) showed that 
packages bravely ignore the caveats mentioned on the help page, 
including to assume recycling the rows of the input data frame. I didn't 
yet see any uses of unnamed arguments, though.

That said, I agree that transform.data.frame() should be improved. Maybe 
unnamed arguments should always be ignored with a warning. My feeling is 
that these would more often be usage errors than intentional, e.g.:

 > data.frame(a = 1) |> transform(b = 2, a + 2)  # "forgetting" a=
   a b X3
1 1 2  3

I also think the implicit check.names=TRUE behaviour should be disabled. In

 > list2DF(list(`A-1` = 1)) |> transform(B = 2)
   A.1 B
1   1 2

transforming B should not touch the other columns.

I'm less sure about some other forms of undocumented behaviour as 
described in Comment 6 of the linked PR.

	Sebastian Meyer


Am 02.03.23 um 18:49 schrieb Antoine Fabri:
> Dear r-devel,
> 
> See below:
> 
> 
> transform(data.frame(a = 1), 2, 3)
> 
> #>   a
> 
> #> 1 1
> 
> 
> transform(data.frame(a = 1), b=2, 3)
> 
> #>   a b X3
> 
> #> 1 1 2  3
> 
> 
> We need a small modification to make it work consistently, see below:
> 
> 
> transform.data.frame <- function (`_data`, ...) {
> 
>    e <- eval(substitute(list(...)), `_data`, parent.frame())
> 
>    tags <- names(e)
> 
>    ## NEW LINE -----------------------------------------------
> 
>    if (is.null(tags)) tags <- character(length(e))
> 
>    inx <- match(tags, names(`_data`))
> 
>    matched <- !is.na(inx)
> 
>    if (any(matched)) {
> 
>      `_data`[inx[matched]] <- e[matched]
> 
>      `_data` <- data.frame(`_data`)
> 
>    }
> 
>    if (!all(matched))
> 
>      do.call("data.frame", c(list(`_data`), e[!matched]))
> 
>    else `_data`
> 
> }
> 
> 
> transform(data.frame(a = 1), 2, 3)
> 
> #>   a X2 X3
> 
> #> 1 1  2  3
> 
> transform(data.frame(a = 1), b=2, 3)
> 
> #>   a b X3
> 
> #> 1 1 2  3
> 
> 
> Thanks,
> 
> 
> Antoine
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @nto|ne@|@br| @end|ng |rom gm@||@com  Thu Mar  2 23:01:41 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Thu, 2 Mar 2023 23:01:41 +0100
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
Message-ID: <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>

Thanks and good point about unspecified behavior. The way it behaves now
(when it doesn't ignore) is more consistent with data.frame() though so I
prefer that to a "warn and ignore" behaviour:

data.frame(a = 1, b = 2, 3)

#>   a b X3

#> 1 1 2  3


data.frame(a = 1, 2, 3)

#>   a X2 X3

#> 1 1  2  3


(and in general warnings make for unpleasant debugging so I prefer when we
don't add new ones if avoidable)


playing a bit more with it, it would make sense to me that the following
have the same output:


coefficient <- 3


data.frame(value1 = 5) |> transform(coefficient, value2 = coefficient *
value1)

#>   value1 X3 value2

#> 1      5  3     15


data.frame(value1 = 5, coefficient) |> transform(value2 = coefficient *
value1)

#>   value1 coefficient value2

#> 1      5           3     15

	[[alternative HTML version deleted]]


From g@bembecker @end|ng |rom gm@||@com  Thu Mar  2 23:37:18 2023
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Thu, 2 Mar 2023 14:37:18 -0800
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
Message-ID: <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>

On Thu, Mar 2, 2023 at 2:02?PM Antoine Fabri <antoine.fabri at gmail.com>
wrote:

> Thanks and good point about unspecified behavior. The way it behaves now
> (when it doesn't ignore) is more consistent with data.frame() though so I
> prefer that to a "warn and ignore" behaviour:
>
> data.frame(a = 1, b = 2, 3)
>
> #>   a b X3
>
> #> 1 1 2  3
>
>
> data.frame(a = 1, 2, 3)
>
> #>   a X2 X3
>
> #> 1 1  2  3
>
>
> (and in general warnings make for unpleasant debugging so I prefer when we
> don't add new ones if avoidable)
>

I find silence to be much more unpleasant in practice when debugging,
myself, but that may be a personal preference.


>
>
> playing a bit more with it, it would make sense to me that the following
> have the same output:
>
>
> coefficient <- 3
>
>
> data.frame(value1 = 5) |> transform(coefficient, value2 = coefficient *
> value1)
>
> #>   value1 X3 value2
>
> #> 1      5  3     15
>
>
> data.frame(value1 = 5, coefficient) |> transform(value2 = coefficient *
> value1)
>
> #>   value1 coefficient value2
>
> #> 1      5           3     15
>
>
I'm not so sure. data.frame() is doing some substitute magic to get the
column name coefficient there.

> coefficient = 3

> data.frame(value1 = 5, coefficient)

  value1 coefficient

1      5           3

Beyond that these two pieces of code are doing subtly but crucially
different things; in the latter, coefficient is a variable in the
data.frame, and when transform resolves that symbol during calculation of
value2, it *gets the column in the incoming data.frame*.

In the former case, coefficient does not exist in the data.frame, so the
symbol is being resolved somewhere else in the scope chain (in this case,
the global environment).

These happen to be the same, except for the column name , but we can see
the difference if we change the code to

> coefficient <- 3

> data.frame(value1 = 5, coefficient = 4)  |> transform(value2 = value1 *
coefficient)

  value1 coefficient value2

1      5           4     20

> data.frame(value1 = 5) |> transform(coefficient = 4, value2 = value1 *
coefficient)

  value1 coefficient *value2*

1      5           4     *15*

Please note that another way this difference could rear its head is if
these arent' directly one after eachother in a pipe:

> coefficient <- 3

> df1 <- data.frame(value1 = 5, coefficient)

> coefficient <- 4

> df2 <- data.frame(value1 = 5)

> df1 |> transform(value2 = value1 * coefficient)

  value1 coefficient value2

1      5           3     15

> df2 |> transform(coefficient, value2 = value1 * coefficient)

  value1 X4 value2

1      5  4     20


Cause you know someday the place where you do that transform and the place
where coefficient is initially set are gonna be far away from eachother, so
whether you put coefficient into the incoming data, or don't will matter.


Best,
~G

        [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Fri Mar  3 16:25:30 2023
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Fri, 3 Mar 2023 16:25:30 +0100
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
Message-ID: <25602.4458.303335.397238@stat.math.ethz.ch>

>>>>> Gabriel Becker 
>>>>>     on Thu, 2 Mar 2023 14:37:18 -0800 writes:

    > On Thu, Mar 2, 2023 at 2:02?PM Antoine Fabri
    > <antoine.fabri at gmail.com> wrote:

    >> Thanks and good point about unspecified behavior. The way
    >> it behaves now (when it doesn't ignore) is more
    >> consistent with data.frame() though so I prefer that to a
    >> "warn and ignore" behaviour:
    >> 
    >> data.frame(a = 1, b = 2, 3)
    >> 
    >> #> a b X3
    >> 
    >> #> 1 1 2 3
    >> 
    >> 
    >> data.frame(a = 1, 2, 3)
    >> 
    >> #> a X2 X3
    >> 
    >> #> 1 1 2 3
    >> 
    >> 
    >> (and in general warnings make for unpleasant debugging so
    >> I prefer when we don't add new ones if avoidable)
    >> 

    > I find silence to be much more unpleasant in practice when
    > debugging, myself, but that may be a personal preference.

+1

I also *strongly* disagree with the claim

   " in general warnings make for unpleasant debugging "

That may be true for beginners (for whom debugging is often not really
feasible anyway ..), but somewhat experienced useRs should know

about
    options(warn = 1) # or
    options(warn = 2) # plus  options(error = recover) #
or
    tryCatch( ...,  warning = ..)

or  {even more}

Martin

--
Martin Maechler
ETH Zurich  and  R Core team


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Fri Mar  3 18:01:06 2023
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Fri, 3 Mar 2023 18:01:06 +0100
Subject: [Rd] confusing all.equal output
In-Reply-To: <B97B1379-B884-4DBF-A926-82789F81B93B@gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
 <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
 <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>
 <001d01d94d35$187fbb90$497f32b0$@gmail.com>
 <B97B1379-B884-4DBF-A926-82789F81B93B@gmail.com>
Message-ID: <25602.10194.172872.572433@stat.math.ethz.ch>

>>>>> peter dalgaard 
>>>>>     on Thu, 2 Mar 2023 19:47:59 +0100 writes:

    > I believe the wording goes back to Martin Maechler many
    > moons ago (AFAICT towards the end of the last millennium.)
    > We might leave it to him to change it?
    > - Peter D.

Thank you, Peter.

Yes, this is *very* old.  I could claim that R users seem to get
more and more confused over time, because nobody had ever
complained for a quarter of a century .. (;-) ;-)

I know I had been inspired by the all.equal() implementation of
S-PLUS version 3.x (x = 4, IIRC) at the time, but then I also think
that I have to take the "full blame" on this :

Trying to think like myself "yesterday, when I was young ..",
I guess the argumentation for using  is.NA  was what I
considered helpful to the non experienced S / R user at the time:
Everybody has seen 'NA' before (and they see it in their objects
in this case) but only somewhat more experienced useRs would
know about is.na(). .. and it may be that at the time I found it
"slick" to combine the "NA" and "is.na" into  "is.NA" ...

About the other wording and how the mismatches should be counted, I
have no recollection.

But indeed, already in 1999, i.e., before R 1.0.0 existed,
that part of the code was

    out <- is.na(target)
    if(any(out != is.na(current)))
	return(paste("`is.NA' value mismatches:", sum(is.na(current)),
		     "in current,", sum(out), " in target"))

- - - 

Ok, now I need to work to commit a (completely orthogonal) change to
all.equal.numeric()  which had been lying around with me for
about a year at least... so I can start looking at your proposed
changes ...

Martin


    >> On 2 Mar 2023, at 19:30 , avi.e.gross at gmail.com wrote:
    >> 
    >> I think if you step back, you can ask what the purpose of
    >> an error message is and who designs it.
    >> 
    >> Is the message for the developer or others on their team
    >> or something an end-user knowing nothing about R will
    >> see.
    >> 
    >> This reminds me a bit of legal mumbo jumbo that turns
    >> many reading it off as it keeps talking about the party
    >> of the first part or the plaintiff as compared to
    >> somewhat straighter talk.
    >> 
    >> The scenario is that you are comparing two things. Their
    >> names are not things like "target" or "current" so even
    >> other programmers not involved in your code will pause
    >> and wonder.
    >> 
    >> One view is to use phrases like first and second
    >> arguments/lists/whatever.  You might talk about the one
    >> on the left (but using LHS is a bit opaque) versus the
    >> one on the right.
    >> 
    >> But sometimes it can be too verbose. Sometimes the error
    >> message is being generated not where everything is clear.
    >> 
    >> So ideally you could say:
    >> 
    >> WARNING Danger Will Robinson.  Comparing two things for
    >> equality.  Result finds mismatches.  There were NA found
    >> on the (left or right) that were not matched on the other
    >> side.  Number of such found: 2
    >> 
    >> If you had a Systems Engineer write detailed requirements
    >> that included something a bit better than the example and
    >> the programmer was able to supply the data using the
    >> words and guidelines, it might fit some needs but maybe
    >> not satisfy other programmers. But there are human
    >> factors people whose job it is to help choose among
    >> alternatives and although they may not choose well,
    >> letting a programmer come up with whatever they feel like
    >> is generally worse.
    >> 
    >> Yes, in their microcosm centered on a dozen lines of
    >> code, "current" and "target" may have meaning. But are
    >> they the intended user of the product?
    >> 
    >> -----Original Message----- From: R-devel
    >> <r-devel-bounces at r-project.org> On Behalf Of Antoine
    >> Fabri Sent: Thursday, March 2, 2023 12:23 PM To: peter
    >> dalgaard <pdalgd at gmail.com> Cc: R-devel
    >> <r-devel at r-project.org> Subject: Re: [Rd] confusing
    >> all.equal output
    >> 
    >> Good points. I don't mind the terminology since target
    >> and current are the names of the arguments. As the
    >> function is already designed to stop at the first failing
    >> check we might not need to enumerate or count the
    >> mismatches, instead we could have "`NA` found in `target`
    >> but not in `current` at position <FIRST_MISMATCH>"
    >> 
    >> [[alternative HTML version deleted]]
    >> 
    >> ______________________________________________
    >> R-devel at r-project.org mailing list
    >> https://stat.ethz.ch/mailman/listinfo/r-devel
    >> 
    >> ______________________________________________
    >> R-devel at r-project.org mailing list
    >> https://stat.ethz.ch/mailman/listinfo/r-devel

    > -- 
    > Peter Dalgaard, Professor, Center for Statistics,
    > Copenhagen Business School Solbjerg Plads 3, 2000
    > Frederiksberg, Denmark Phone: (+45)38153501 Office: A 4.23
    > Email: pd.mes at cbs.dk Priv: PDalgd at gmail.com


From @nto|ne@|@br| @end|ng |rom gm@||@com  Fri Mar  3 18:17:18 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Fri, 3 Mar 2023 18:17:18 +0100
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <25602.4458.303335.397238@stat.math.ethz.ch>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
 <25602.4458.303335.397238@stat.math.ethz.ch>
Message-ID: <CAEKh8uh2pY5N98eufV2DX01wfCp++rMDSEPwXA-AUCogHBkDGA@mail.gmail.com>

Let me expand a bit, I might have expressed myself poorly.

 If there is a good reason for a warning I want a warning, and because I
take them seriously I don't want my console cluttered with those that can
be avoided. I strongly believe we should strive to make our code silent,
and I like my console to tell me only what I need to know. In my opinion
many warnings would be better designed as errors, sometimes with an
argument to opt in the behaviour, or a documented way to work around. Some
other warnings should just be documented behavior, because the behavior is
not all that surprising.

Some reasons why I find warnings hard to debug:
- options(warn = 1) is not always enough to spot the source of the warning
- options(warn = 2) fails at every warning, including the ones that are not
interesting to the user and that they may not do anything about, in these
cases you'll have to find a way to shut off the first to get to the second,
and if it's packaged code that's not fun.
- Unlike with errors, traceback() won't help.
- tryCatch() will help you only if you call it at the right place, assuming
you've found it.
- We might also have many harmless warnings triggered through loops and
hiding important ones.
- When you are sure that you are OK with your code despite the warning, say
`as.numeric(c("1", "2", "foo"))`, a workaround might be expensive (here we
could use regex first to ditch the non numeric strings but who does that)
so you're tempted to use `suppressWarnings()`, but then you might be
suppressing other important warnings so you just made your code less safe
because the developper wanted to make it safer (you might say it's on the
user but still, we get suboptimal code that was avoidable).

Of course I might miss some approaches that would make my experience of
debugging warnings more pleasant.

In our precise case I don't find the behavior surprising enough to warrant
more precious red ink since it's close to what we get with data.frame(),
and close to what we get with dplyr::mutate() FWIW, so I'd be personally
happier to have this documented and work silently.

Either way I appreciate you considering the problem.

Thanks,

Antoine

	[[alternative HTML version deleted]]


From bbo|ker @end|ng |rom gm@||@com  Fri Mar  3 21:58:30 2023
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Fri, 3 Mar 2023 15:58:30 -0500
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <CAEKh8uh2pY5N98eufV2DX01wfCp++rMDSEPwXA-AUCogHBkDGA@mail.gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
 <25602.4458.303335.397238@stat.math.ethz.ch>
 <CAEKh8uh2pY5N98eufV2DX01wfCp++rMDSEPwXA-AUCogHBkDGA@mail.gmail.com>
Message-ID: <CABghstT+5CX8f15X8zTFp_DgKGwe6g2F6=g9bJvworFhyLXHTQ@mail.gmail.com>

   For what it's worth I think the increased emphasis on classed
errors should help with this (i.e., it will be easier to filter out
errors you know are false positives/irrelevant for your use case).

On Fri, Mar 3, 2023 at 12:17?PM Antoine Fabri <antoine.fabri at gmail.com> wrote:
>
> Let me expand a bit, I might have expressed myself poorly.
>
>  If there is a good reason for a warning I want a warning, and because I
> take them seriously I don't want my console cluttered with those that can
> be avoided. I strongly believe we should strive to make our code silent,
> and I like my console to tell me only what I need to know. In my opinion
> many warnings would be better designed as errors, sometimes with an
> argument to opt in the behaviour, or a documented way to work around. Some
> other warnings should just be documented behavior, because the behavior is
> not all that surprising.
>
> Some reasons why I find warnings hard to debug:
> - options(warn = 1) is not always enough to spot the source of the warning
> - options(warn = 2) fails at every warning, including the ones that are not
> interesting to the user and that they may not do anything about, in these
> cases you'll have to find a way to shut off the first to get to the second,
> and if it's packaged code that's not fun.
> - Unlike with errors, traceback() won't help.
> - tryCatch() will help you only if you call it at the right place, assuming
> you've found it.
> - We might also have many harmless warnings triggered through loops and
> hiding important ones.
> - When you are sure that you are OK with your code despite the warning, say
> `as.numeric(c("1", "2", "foo"))`, a workaround might be expensive (here we
> could use regex first to ditch the non numeric strings but who does that)
> so you're tempted to use `suppressWarnings()`, but then you might be
> suppressing other important warnings so you just made your code less safe
> because the developper wanted to make it safer (you might say it's on the
> user but still, we get suboptimal code that was avoidable).
>
> Of course I might miss some approaches that would make my experience of
> debugging warnings more pleasant.
>
> In our precise case I don't find the behavior surprising enough to warrant
> more precious red ink since it's close to what we get with data.frame(),
> and close to what we get with dplyr::mutate() FWIW, so I'd be personally
> happier to have this documented and work silently.
>
> Either way I appreciate you considering the problem.
>
> Thanks,
>
> Antoine
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From p@kr|v|t@ky @end|ng |rom un@w@edu@@u  Sat Mar  4 01:21:48 2023
From: p@kr|v|t@ky @end|ng |rom un@w@edu@@u (Pavel Krivitsky)
Date: Sat, 4 Mar 2023 00:21:48 +0000
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
Message-ID: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>

Dear All,

Currently, list= in base::replace(x, list, value) has to be an index
vector. For me, at least, the most common use case is for list= to be
some simple property of elements of x, e.g.,

x <- c(1,2,NA,3)
replace(x, is.na(x), 0)

Particularly when using R pipes, which don't allow multiple
substitutions, it would simplify many of such cases if list= could be a
function that returns an index, e.g.,

replace <- function (x, list, values, ...) {
  # Here, list() refers to the argument, not the built-in.
  if(is.function(list)) list <- list(x, ...)
  x[list] <- values
  x
}

Then, the following is possible:

c(1,2,NA,3) |> replace(is.na, 0)

			Any thoughts?
			Pavel

From @vi@e@gross m@iii@g oii gm@ii@com  Sat Mar  4 06:06:40 2023
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Sat, 4 Mar 2023 00:06:40 -0500
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <25602.4458.303335.397238@stat.math.ethz.ch>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
 <25602.4458.303335.397238@stat.math.ethz.ch>
Message-ID: <012001d94e57$1b4c0b30$51e42190$@gmail.com>

I am probably mistaken but it looks to me like the design of much of the data.frame infrastructure not only does not insist you give columns names, but even has all kinds of options such as check.names and fix.empty.names

https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/data.frame

During the lifetime of a column, it can get removed, renamed, transfomed in many ways and so on. A data.frame read in from a file such as a .CSV often begins with temporary created names. 

It is so common, that sometimes not giving a name is a choice and not in any way an error. I have seen some rather odd names in backticks that include spaces and seen duplicate names. The reality is you can index by column number two and maybe no actual name was needed by the one creating or modifying the data.

Some placed warnings are welcome as they tend to reflect a possibly serious error.  But that error may not easily be at this point versus later in the game.  If later the program tries to access the misnamed column, then an error makes sense. Warnings, if overused, get old quickly and you regularly see code written to suppress startup messages or warnings because the same message shown every day becomes something you ignore mentally even if not suppressed. How many times has loading the tidyverse reminded me it is shadowing a few base R functions? How many times have I really cared?

What makes some sense to me is to add an argument to some functions BEGGING to be shown the errors of your ways and turn that on as you wish, often after something has gone wrong.

-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Martin Maechler
Sent: Friday, March 3, 2023 10:26 AM
To: Gabriel Becker <gabembecker at gmail.com>
Cc: Antoine Fabri <antoine.fabri at gmail.com>; R-devel <r-devel at r-project.org>
Subject: Re: [Rd] transform.data.frame() ignores unnamed arguments when no named argument is provided

>>>>> Gabriel Becker 
>>>>>     on Thu, 2 Mar 2023 14:37:18 -0800 writes:

    > On Thu, Mar 2, 2023 at 2:02?PM Antoine Fabri
    > <antoine.fabri at gmail.com> wrote:

    >> Thanks and good point about unspecified behavior. The way
    >> it behaves now (when it doesn't ignore) is more
    >> consistent with data.frame() though so I prefer that to a
    >> "warn and ignore" behaviour:
    >> 
    >> data.frame(a = 1, b = 2, 3)
    >> 
    >> #> a b X3
    >> 
    >> #> 1 1 2 3
    >> 
    >> 
    >> data.frame(a = 1, 2, 3)
    >> 
    >> #> a X2 X3
    >> 
    >> #> 1 1 2 3
    >> 
    >> 
    >> (and in general warnings make for unpleasant debugging so
    >> I prefer when we don't add new ones if avoidable)
    >> 

    > I find silence to be much more unpleasant in practice when
    > debugging, myself, but that may be a personal preference.

+1

I also *strongly* disagree with the claim

   " in general warnings make for unpleasant debugging "

That may be true for beginners (for whom debugging is often not really
feasible anyway ..), but somewhat experienced useRs should know

about
    options(warn = 1) # or
    options(warn = 2) # plus  options(error = recover) #
or
    tryCatch( ...,  warning = ..)

or  {even more}

Martin

--
Martin Maechler
ETH Zurich  and  R Core team

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From g@bembecker @end|ng |rom gm@||@com  Sat Mar  4 22:44:03 2023
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Sat, 4 Mar 2023 13:44:03 -0800
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <012001d94e57$1b4c0b30$51e42190$@gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
 <25602.4458.303335.397238@stat.math.ethz.ch>
 <012001d94e57$1b4c0b30$51e42190$@gmail.com>
Message-ID: <CAD4oTHEgE9+PdpOtvgRV1823OrNW3K-ufqZf=j9D0MPBNiyStA@mail.gmail.com>

Hi Avi,

On Fri, Mar 3, 2023 at 9:07?PM <avi.e.gross at gmail.com> wrote:

> I am probably mistaken but it looks to me like the design of much of the
> data.frame infrastructure not only does not insist you give columns names,
> but even has all kinds of options such as check.names and fix.empty.names
>
>
> https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/data.frame
>
>
I think this is true, but thats for the *construction* of a data.frame,
where as, in my opinion from what I can tell, transform is for operating on
a data.frame that has already been constructed. I'm not personally
convinced the same allowances should be made at this conceptually later
stage in data processing.


> During the lifetime of a column, it can get removed, renamed, transfomed
> in many ways and so on. A data.frame read in from a file such as a .CSV
> often begins with temporary created names.
>
> It is so common, that sometimes not giving a name is a choice and not in
> any way an error. I have seen some rather odd names in backticks that
> include spaces and seen duplicate names. The reality is you can index by
> column number two and maybe no actual name was needed by the one creating
> or modifying the data.
>

You can but this creates brittle, difficult to maintain code to the extent
that I consider this an anti-pattern, and I don't believe I'm alone in that.


>
> Some placed warnings are welcome as they tend to reflect a possibly
> serious error.  But that error may not easily be at this point versus later
> in the game.  If later the program tries to access the misnamed column,
> then an error makes sense. Warnings, if overused, get old quickly and you
> regularly see code written to suppress startup messages or warnings because
> the same message shown every day becomes something you ignore mentally even
> if not suppressed. How many times has loading the tidyverse reminded me it
> is shadowing a few base R functions? How many times have I really cared?
>

I think this is a bad example to make your case on, because symbol masking
is actually *really* important. In bioinformatics, Bioconductor is the
flagship (which sails upon the sea that R provides), but guess what; dplyr
and Bioconductor both define filter, and they do so meaning completely
different incompatible things.

I have seen code that wanted one version and got the other in both
directions, and in neither case is it fun, but without that warning it
would be a dystopian nightmarescape that scarcely bears thinking about.


> What makes some sense to me is to add an argument to some functions
> BEGGING to be shown the errors of your ways and turn that on as you wish,
> often after something has gone wrong.
>


Flipping this on its head, I wonder, alternatively, if there might be a
"strict" mode for transform which errors out on unnamed arguments, instead
of providing the current undefined behavior.

Best,
~G


>
> -----Original Message-----
> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Martin Maechler
> Sent: Friday, March 3, 2023 10:26 AM
> To: Gabriel Becker <gabembecker at gmail.com>
> Cc: Antoine Fabri <antoine.fabri at gmail.com>; R-devel <
> r-devel at r-project.org>
> Subject: Re: [Rd] transform.data.frame() ignores unnamed arguments when no
> named argument is provided
>
> >>>>> Gabriel Becker
> >>>>>     on Thu, 2 Mar 2023 14:37:18 -0800 writes:
>
>     > On Thu, Mar 2, 2023 at 2:02?PM Antoine Fabri
>     > <antoine.fabri at gmail.com> wrote:
>
>     >> Thanks and good point about unspecified behavior. The way
>     >> it behaves now (when it doesn't ignore) is more
>     >> consistent with data.frame() though so I prefer that to a
>     >> "warn and ignore" behaviour:
>     >>
>     >> data.frame(a = 1, b = 2, 3)
>     >>
>     >> #> a b X3
>     >>
>     >> #> 1 1 2 3
>     >>
>     >>
>     >> data.frame(a = 1, 2, 3)
>     >>
>     >> #> a X2 X3
>     >>
>     >> #> 1 1 2 3
>     >>
>     >>
>     >> (and in general warnings make for unpleasant debugging so
>     >> I prefer when we don't add new ones if avoidable)
>     >>
>
>     > I find silence to be much more unpleasant in practice when
>     > debugging, myself, but that may be a personal preference.
>
> +1
>
> I also *strongly* disagree with the claim
>
>    " in general warnings make for unpleasant debugging "
>
> That may be true for beginners (for whom debugging is often not really
> feasible anyway ..), but somewhat experienced useRs should know
>
> about
>     options(warn = 1) # or
>     options(warn = 2) # plus  options(error = recover) #
> or
>     tryCatch( ...,  warning = ..)
>
> or  {even more}
>
> Martin
>
> --
> Martin Maechler
> ETH Zurich  and  R Core team
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From @oko| @end|ng |rom |n@@-tou|ou@e@|r  Mon Mar  6 09:45:21 2023
From: @oko| @end|ng |rom |n@@-tou|ou@e@|r (Serguei Sokol)
Date: Mon, 6 Mar 2023 09:45:21 +0100
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
In-Reply-To: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
References: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
Message-ID: <60f31223-033a-21ee-67fd-b1a6566a0278@insa-toulouse.fr>

Le 04/03/2023 ? 01:21, Pavel Krivitsky a ?crit?:
> Dear All,
>
> Currently, list= in base::replace(x, list, value) has to be an index
> vector. For me, at least, the most common use case is for list= to be
> some simple property of elements of x, e.g.,
>
> x <- c(1,2,NA,3)
> replace(x, is.na(x), 0)
>
> Particularly when using R pipes, which don't allow multiple
> substitutions,
Right, but anonymous function syntax can palliate to this:

x |> (\(x) replace(x, is.na(x), 0))()


>   it would simplify many of such cases if list= could be a
> function that returns an index, e.g.,
>
> replace <- function (x, list, values, ...) {
>    # Here, list() refers to the argument, not the built-in.
>    if(is.function(list)) list <- list(x, ...)
>    x[list] <- values
>    x
> }
Before modifying the base of R, we should examine existing possibilities 
to achieve the same goal.
In this particular case and if the previous solution (anonymous 
function) is not satisfactory a thin one-line wrapper can make the job:

freplace <- function (x, list, values, ...) replace(x, 
if(is.function(list)) list <- list(x, ...) else list, values)

>
> Then, the following is possible:
>
> c(1,2,NA,3) |> replace(is.na, 0)
this becomes

c(1,2,NA,3) |> freplace(is.na, 0)

and looks quite acceptable for me.

Best,
Serguei.

>
> 			Any thoughts?
> 			Pavel
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


-- 
Serguei Sokol
Ingenieur de recherche INRAE

Cellule Math?matiques
TBI, INSA/INRAE UMR 792, INSA/CNRS UMR 5504
135 Avenue de Rangueil
31077 Toulouse Cedex 04

tel: +33 5 61 55 98 49
email: sokol at insa-toulouse.fr
http://www.toulouse-biotechnology-institute.fr/en/technology_platforms/mathematics-cell.html


From p@kr|v|t@ky @end|ng |rom un@w@edu@@u  Tue Mar  7 11:49:41 2023
From: p@kr|v|t@ky @end|ng |rom un@w@edu@@u (Pavel Krivitsky)
Date: Tue, 7 Mar 2023 10:49:41 +0000
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
In-Reply-To: <60f31223-033a-21ee-67fd-b1a6566a0278@insa-toulouse.fr>
References: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
 <60f31223-033a-21ee-67fd-b1a6566a0278@insa-toulouse.fr>
Message-ID: <d9dc22049a09fdbf55b43b21a947f61dda3d0720.camel@unsw.edu.au>

Dear Serguei,

On Mon, 2023-03-06 at 09:45 +0100, Serguei Sokol wrote:
> Right, but anonymous function syntax can palliate to this:
> 
> x |> (\(x) replace(x, is.na(x), 0))()

This approach hardly makes for concise or readable code.

> 
> Before modifying the base of R, we should examine existing
> possibilities to achieve the same goal.

Backwards-compatible enhancements to existing functions in base R
appear in every major release. In this case, the proposed behaviour of
replace() would be consistent with that of the *apply() family of
functions.

> In this particular case and if the previous solution (anonymous 
> function) is not satisfactory a thin one-line wrapper can make the
> job:
> 
> freplace <- function (x, list, values, ...) replace(x, 
> if(is.function(list)) list <- list(x, ...) else list, values)
> 
> this becomes
> 
> c(1,2,NA,3) |> freplace(is.na, 0)
> 
> and looks quite acceptable for me.

One could always implement a function that has this functionality, of
course. In fact, one could write,

replace <- function (x, list, values, ...) base::replace(x, 
  if(is.function(list)) list <- list(x, ...) else list, values)

and not even have to change the name. However, having to write it every
time defeats the purpose of having it in base in the first place.

				Best Regards,
				Pavel

> 
> Best,
> Serguei.
> 
> > 
> > ????????????????????????Any thoughts?
> > ????????????????????????Pavel
> > ______________________________________________
> > R-devel at r-project.org?mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> 


From ggrothend|eck @end|ng |rom gm@||@com  Tue Mar  7 13:33:56 2023
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Tue, 7 Mar 2023 07:33:56 -0500
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
In-Reply-To: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
References: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
Message-ID: <CAP01uRk2-FWoH9cceJP61ckxte1hGF3VVcwFjF12ouASvoBZ9g@mail.gmail.com>

This could be extended to sub and gsub as well which gsubfn in the
gusbfn package already does:

  library(gsubfn)
  gsubfn("^..", toupper, c("abc", "xyz"))
  ## [1] "ABc" "XYz"

On Fri, Mar 3, 2023 at 7:22?PM Pavel Krivitsky <p.krivitsky at unsw.edu.au> wrote:
>
> Dear All,
>
> Currently, list= in base::replace(x, list, value) has to be an index
> vector. For me, at least, the most common use case is for list= to be
> some simple property of elements of x, e.g.,
>
> x <- c(1,2,NA,3)
> replace(x, is.na(x), 0)
>
> Particularly when using R pipes, which don't allow multiple
> substitutions, it would simplify many of such cases if list= could be a
> function that returns an index, e.g.,
>
> replace <- function (x, list, values, ...) {
>   # Here, list() refers to the argument, not the built-in.
>   if(is.function(list)) list <- list(x, ...)
>   x[list] <- values
>   x
> }
>
> Then, the following is possible:
>
> c(1,2,NA,3) |> replace(is.na, 0)
>
>                         Any thoughts?
>                         Pavel
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From x|e @end|ng |rom y|hu|@n@me  Tue Mar  7 18:35:41 2023
From: x|e @end|ng |rom y|hu|@n@me (Yihui Xie)
Date: Tue, 7 Mar 2023 11:35:41 -0600
Subject: [Rd] 
 Undocumented change of dirname("C:/") on R-devel on Windows
In-Reply-To: <a182c76a-02f1-2ede-5ded-0752e7a618bd@gmail.com>
References: <CALyqOb8-eihVs9FW2AcH42mOCwZj2gLsq=j1sNUSthnf0k7Zow@mail.gmail.com>
 <1db6ce6b-04f0-b890-c320-3e0cbc20a99f@gmail.com>
 <CALyqOb8fuhNtO3QZVO75Zvb91EbV0ZgLvUPRyC6KkVYBWocUQw@mail.gmail.com>
 <CALyqOb8xCA182niry8_OudVw+xVpg=WiPCMsEQZTP=R7Wc2wzw@mail.gmail.com>
 <CANROs4cp5K5ZC3F8UcZa8Togd4EyuRmBiMxQrq4Du2=Asc5pUQ@mail.gmail.com>
 <a182c76a-02f1-2ede-5ded-0752e7a618bd@gmail.com>
Message-ID: <CANROs4df-Y6T-qp+LEqo3_LK67Hz7Xgm=Bgn7w81FEtbfDOuqQ@mail.gmail.com>

Thanks a lot! I can confirm that it has been fixed indeed.

Regards,
Yihui



On Mon, Feb 27, 2023 at 1:14?PM Tomas Kalibera <tomas.kalibera at gmail.com>
wrote:

>
> On 2/27/23 17:02, Yihui Xie wrote:
>
> Hi Tomas,
>
> There has been an R CMD check error with xfun and r-devel on Windows for a
> while:
> https://www.r-project.org/nosvn/R.check/r-devel-windows-x86_64/xfun-00check.html
> Basically it means that the following would return TRUE before:
>
>   normalizePath('a/b', mustWork = FALSE) == normalizePath('./a/b',
> mustWork = FALSE)
>
> but it became FALSE at some point in r-devel. I think 'a/b' and './a/b`
> should be treated as the same path. Does that make sense? Thanks!
>
> Thanks a lot for spotting and reporting this, fixed in R-devel.
> Normalization of non-existent paths was broken.
>
> Best
> Tomas
>
>
> Regards,
> Yihui
> --
> https://yihui.org
>
>
> On Thu, Feb 23, 2023 at 11:44 PM Hiroaki Yutani <yutani.ini at gmail.com>
> wrote:
>
>> I confirmed the revert fixed my failing test. Thanks!
>>
>> 2023?2?23?(?) 20:12 Hiroaki Yutani <yutani.ini at gmail.com>:
>>
>> > Thanks for the prompt response, I'll confirm it after the new R-devel
>> > binary is available.
>> > Also, thanks for the detailed explanation. I agree with you in general.
>> >
>> > > "/" in "C:/" is a path separator or not, and whether it is trailing or
>> > not
>> >
>> > It seems a Windows' path basically consists of two components; a drive
>> > specification (e.g., C:) and the directory structure within the drive.
>> What
>> > I learned today is that both "C:/" and "C:" are valid path
>> specifications,
>> > but refer to different locations; "C:" is not the root directory of the
>> > drive, but just a relative path [1]. So, I agree with you that the
>> basename
>> > of "C:/" should be "C:/". However, at the same time, I don't feel this
>> is
>> > worth a breaking change, so I think we can preserve the current (R
>> 4.2.2)
>> > behavior.
>> >
>> > [1]:
>> >
>> https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats#apply-the-current-directory
>> >
>> > Best,
>> > Yutani
>> >
>> > 2023?2?23?(?) 17:15 Tomas Kalibera <tomas.kalibera at gmail.com>:
>> >
>> >>
>> >> On 2/23/23 03:27, Hiroaki Yutani wrote:
>> >> > Hi,
>> >> >
>> >> > I found dirname() behaves differently on R-devel on Windows. Since
>> I'm
>> >> not
>> >> > sure which behavior is right, let me ask here before filing this to
>> R's
>> >> > Bigzilla.
>> >> >
>> >> > On R 4.2.2., we get
>> >> >
>> >> >      > dirname("C:/")
>> >> >      [1] "C:/"
>> >> >
>> >> > However, on R-devel (r83888), we get
>> >> >
>> >> >      > dirname("C:/")
>> >> >      [1] "."
>> >> >
>> >> > ?dirname says 'dirname returns the part of the path up to but
>> excluding
>> >> the
>> >> > last path separator, or "." if there is no path separator,' but I
>> don't
>> >> see
>> >> > how the root path is supposed to be treated based on this rule (,
>> >> whether
>> >> > it's WIndows or UNIX-alike).
>> >> Thanks for spotting the difference, I've reverted to the previous
>> >> behavior, the change was unintentional. If you spot any other
>> suspicious
>> >> changes in behavior in file-system operations, please report.
>> >> > What should we expect as the return value of dirname("C:/")? I feel
>> the
>> >> > current behavior on R 4.2.2 is right, but I'd like to confirm.
>> >>
>> >> I also think the old behavior is better, even though it could be argued
>> >> whether the "/" in "C:/" is a path separator or not, and whether it is
>> >> trailing or not. But the behavior is in line with Unix where dirname of
>> >> "/" is also "/". Msys2 would return "C:".
>> >>
>> >> If  "/" in "C:/" is a path separator but not a trailing path separator,
>> >> then basename("C:/") should probably be "" and not "C:", and this would
>> >> be in line with what R does on Unix. However, to be in line with Unix,
>> I
>> >> think the basename of "C:/" should be "C:/". Yet, Msys2 returns "C:"
>> >> which is what R does now.
>> >>
>> >> So what these functions should do on Windows is definitely tricky. In
>> >> either case the behavior is now again as in R 4.2.2.
>> >>
>> >> Best
>> >> Tomas
>> >>
>> >> >
>> >> > Best,
>> >> > Yutani
>> >> >
>> >> >       [[alternative HTML version deleted]]
>> >> >
>> >> > ______________________________________________
>> >> > R-devel at r-project.org mailing list
>> >> > https://stat.ethz.ch/mailman/listinfo/r-devel
>> >>
>> >
>>
>>         [[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>

	[[alternative HTML version deleted]]


From @tevem@rt|n041 @end|ng |rom gm@||@com  Wed Mar  8 03:41:29 2023
From: @tevem@rt|n041 @end|ng |rom gm@||@com (Steve Martin)
Date: Tue, 7 Mar 2023 21:41:29 -0500
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
In-Reply-To: <CAP01uRk2-FWoH9cceJP61ckxte1hGF3VVcwFjF12ouASvoBZ9g@mail.gmail.com>
References: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
 <CAP01uRk2-FWoH9cceJP61ckxte1hGF3VVcwFjF12ouASvoBZ9g@mail.gmail.com>
Message-ID: <CAP=dwz8ZpEbRX40qGBt2L0T6rY5xo6a+QFOBZJfTcjGw8dEHrA@mail.gmail.com>

That's an interesting example, as it's conceptually similar to what
Pavel is proposing, but structurally different. gsubfn() is more
complicated than a simple switch in the body of the function, and
wouldn't work well as an anonymous function.

Multiple dispatch can nicely encompass both of these cases. For replace(),

library(S7)

replace <- new_generic("replace", c("x", "list"), function(x, list,
values, ...) {
  S7_dispatch()
})

method(replace, list(class_any, class_any)) <- base::replace

method(replace, list(class_any, class_function)) <- function(x, list,
values, ...) {
  replace(x, list(x, ...), values)
}

x <- c(1 ,2, NA, 3)
replace(x, is.na(x), 0)
[1] 1 2 0 3

replace(x, is.na, 0)
[1] 1 2 0 3

And for gsub(),

gsub <- new_generic("gsub", c("pattern", "replacement"),
function(pattern, replacement, x, ...) {
  S7_dispatch()
})

method(gsub, list(class_character, class_character)) <- base::gsub

# My quick-and-dirty implementation as an example
method(gsub, list(class_character, class_function)) <-
function(pattern, replacement, x) {
  m <- regexpr(pattern, x)
  res <- replacement(regmatches(x, m))
  mapply(gsub, pattern, as.character(res), x, USE.NAMES = FALSE)
}

gsub("^..", toupper, c("abc", "xyz"))
[1] "ABc" "XYz"

But this isn't a simple change to replace() anymore, and I may just be
spending too much time tinkering with Julia.

Steve

On Tue, 7 Mar 2023 at 07:34, Gabor Grothendieck <ggrothendieck at gmail.com> wrote:
>
> This could be extended to sub and gsub as well which gsubfn in the
> gusbfn package already does:
>
>   library(gsubfn)
>   gsubfn("^..", toupper, c("abc", "xyz"))
>   ## [1] "ABc" "XYz"
>
> On Fri, Mar 3, 2023 at 7:22?PM Pavel Krivitsky <p.krivitsky at unsw.edu.au> wrote:
> >
> > Dear All,
> >
> > Currently, list= in base::replace(x, list, value) has to be an index
> > vector. For me, at least, the most common use case is for list= to be
> > some simple property of elements of x, e.g.,
> >
> > x <- c(1,2,NA,3)
> > replace(x, is.na(x), 0)
> >
> > Particularly when using R pipes, which don't allow multiple
> > substitutions, it would simplify many of such cases if list= could be a
> > function that returns an index, e.g.,
> >
> > replace <- function (x, list, values, ...) {
> >   # Here, list() refers to the argument, not the built-in.
> >   if(is.function(list)) list <- list(x, ...)
> >   x[list] <- values
> >   x
> > }
> >
> > Then, the following is possible:
> >
> > c(1,2,NA,3) |> replace(is.na, 0)
> >
> >                         Any thoughts?
> >                         Pavel
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
>
>
> --
> Statistics & Software Consulting
> GKX Group, GKX Associates Inc.
> tel: 1-877-GKX-GROUP
> email: ggrothendieck at gmail.com
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From ggrothend|eck @end|ng |rom gm@||@com  Wed Mar  8 15:11:06 2023
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Wed, 8 Mar 2023 09:11:06 -0500
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
In-Reply-To: <CAP=dwz8ZpEbRX40qGBt2L0T6rY5xo6a+QFOBZJfTcjGw8dEHrA@mail.gmail.com>
References: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
 <CAP01uRk2-FWoH9cceJP61ckxte1hGF3VVcwFjF12ouASvoBZ9g@mail.gmail.com>
 <CAP=dwz8ZpEbRX40qGBt2L0T6rY5xo6a+QFOBZJfTcjGw8dEHrA@mail.gmail.com>
Message-ID: <CAP01uR=B3=KqmASJGtnPMZv-8J5CNO4fVg6S95FLKSmb5CMD_g@mail.gmail.com>

This is getting way off topic. I wasn't suggesting that gsubfn, which
does a lot more than this simple
example, as the implementation.

I was pointing out that the replace function idea can be extended to
sub and gsub and showing what
it would do.

On Tue, Mar 7, 2023 at 9:41?PM Steve Martin <stevemartin041 at gmail.com> wrote:
>
> That's an interesting example, as it's conceptually similar to what
> Pavel is proposing, but structurally different. gsubfn() is more
> complicated than a simple switch in the body of the function, and
> wouldn't work well as an anonymous function.
>
> Multiple dispatch can nicely encompass both of these cases. For replace(),
>
> library(S7)
>
> replace <- new_generic("replace", c("x", "list"), function(x, list,
> values, ...) {
>   S7_dispatch()
> })
>
> method(replace, list(class_any, class_any)) <- base::replace
>
> method(replace, list(class_any, class_function)) <- function(x, list,
> values, ...) {
>   replace(x, list(x, ...), values)
> }
>
> x <- c(1 ,2, NA, 3)
> replace(x, is.na(x), 0)
> [1] 1 2 0 3
>
> replace(x, is.na, 0)
> [1] 1 2 0 3
>
> And for gsub(),
>
> gsub <- new_generic("gsub", c("pattern", "replacement"),
> function(pattern, replacement, x, ...) {
>   S7_dispatch()
> })
>
> method(gsub, list(class_character, class_character)) <- base::gsub
>
> # My quick-and-dirty implementation as an example
> method(gsub, list(class_character, class_function)) <-
> function(pattern, replacement, x) {
>   m <- regexpr(pattern, x)
>   res <- replacement(regmatches(x, m))
>   mapply(gsub, pattern, as.character(res), x, USE.NAMES = FALSE)
> }
>
> gsub("^..", toupper, c("abc", "xyz"))
> [1] "ABc" "XYz"
>
> But this isn't a simple change to replace() anymore, and I may just be
> spending too much time tinkering with Julia.
>
> Steve
>
> On Tue, 7 Mar 2023 at 07:34, Gabor Grothendieck <ggrothendieck at gmail.com> wrote:
> >
> > This could be extended to sub and gsub as well which gsubfn in the
> > gusbfn package already does:
> >
> >   library(gsubfn)
> >   gsubfn("^..", toupper, c("abc", "xyz"))
> >   ## [1] "ABc" "XYz"
> >
> > On Fri, Mar 3, 2023 at 7:22?PM Pavel Krivitsky <p.krivitsky at unsw.edu.au> wrote:
> > >
> > > Dear All,
> > >
> > > Currently, list= in base::replace(x, list, value) has to be an index
> > > vector. For me, at least, the most common use case is for list= to be
> > > some simple property of elements of x, e.g.,
> > >
> > > x <- c(1,2,NA,3)
> > > replace(x, is.na(x), 0)
> > >
> > > Particularly when using R pipes, which don't allow multiple
> > > substitutions, it would simplify many of such cases if list= could be a
> > > function that returns an index, e.g.,
> > >
> > > replace <- function (x, list, values, ...) {
> > >   # Here, list() refers to the argument, not the built-in.
> > >   if(is.function(list)) list <- list(x, ...)
> > >   x[list] <- values
> > >   x
> > > }
> > >
> > > Then, the following is possible:
> > >
> > > c(1,2,NA,3) |> replace(is.na, 0)
> > >
> > >                         Any thoughts?
> > >                         Pavel
> > > ______________________________________________
> > > R-devel at r-project.org mailing list
> > > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> >
> >
> > --
> > Statistics & Software Consulting
> > GKX Group, GKX Associates Inc.
> > tel: 1-877-GKX-GROUP
> > email: ggrothendieck at gmail.com
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From ht @end|ng |rom he@therturner@net  Thu Mar  9 16:14:01 2023
From: ht @end|ng |rom he@therturner@net (Heather Turner)
Date: Thu, 09 Mar 2023 15:14:01 +0000
Subject: [Rd] R Project Sprint 2023: deadline 10 March (midnight UTC)
Message-ID: <8531a7b7-7f84-432f-bdc9-5985c5c0bea2@app.fastmail.com>

Dear All,

This is a reminder that the deadline to apply to participate in the R Project Sprint 2023 is tomorrow, Friday 10 March. The form will close at midnight UTC.

Details: https://contributor.r-project.org/r-project-sprint-2023/.

Best wishes,
Heather


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Fri Mar 10 13:54:43 2023
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Fri, 10 Mar 2023 13:54:43 +0100
Subject: [Rd] scan(..., skip=1e11): infinite loop; cannot interrupt
In-Reply-To: <20230211113316.44dd813a@Tarkus>
References: <acf79875-5042-1db1-5283-836dedd7f8a0@prodsyse.com>
 <20230211113316.44dd813a@Tarkus>
Message-ID: <c2d3c1eb-9a07-ff7b-3055-497c991535f3@gmail.com>



On 2/11/23 09:33, Ivan Krylov wrote:
> On Fri, 10 Feb 2023 23:38:55 -0600
> Spencer Graves <spencer.graves at prodsyse.com> wrote:
>
>> I have a 4.54 GB file that I'm trying to read in chunks using
>> "scan(..., skip=__)".  It works as expected for small values of
>> "skip" but goes into an infinite loop for "skip=1e11" and similar
>> large values of skip:  I cannot even interrupt it;  I must kill R.
> Skipping lines is done by two nested loops. The outer loop counts the
> lines to skip; the inner loop reads characters until it encounters a
> newline or end of file. The outer loop doesn't check for EOF and keeps
> asking for more characters until the inner loop runs at least once for
> every line it wants to skip. The following patch should avoid the
> wait in such cases:
>
> --- src/main/scan.c	(revision 83797)
> +++ src/main/scan.c	(working copy)
> @@ -835,7 +835,7 @@
>   attribute_hidden SEXP do_scan(SEXP call, SEXP op, SEXP args, SEXP rho)
>   {
>       SEXP ans, file, sep, what, stripwhite, dec, quotes, comstr;
> -    int c, flush, fill, blskip, multiline, escapes, skipNul;
> +    int c = 0, flush, fill, blskip, multiline, escapes, skipNul;
>       R_xlen_t nmax, nlines, nskip;
>       const char *p, *encoding;
>       RCNTXT cntxt;
> @@ -952,7 +952,7 @@
>   	    if(!data.con->canread)
>   		error(_("cannot read from this connection"));
>   	}
> -	for (R_xlen_t i = 0; i < nskip; i++) /* MBCS-safe */
> +	for (R_xlen_t i = 0; i < nskip && c != R_EOF; i++) /* MBCS-safe */
>   	    while ((c = scanchar(FALSE, &data)) != '\n' && c != R_EOF);
>       }
>   
>
> Making it interruptible is a bit more work: we need to ensure that a
> valid context is set up and check regularly for an interrupt.
>
> --- src/main/scan.c	(revision 83797)
> +++ src/main/scan.c	(working copy)
> @@ -835,7 +835,7 @@
>   attribute_hidden SEXP do_scan(SEXP call, SEXP op, SEXP args, SEXP rho)
>   {
>       SEXP ans, file, sep, what, stripwhite, dec, quotes, comstr;
> -    int c, flush, fill, blskip, multiline, escapes, skipNul;
> +    int c = 0, flush, fill, blskip, multiline, escapes, skipNul;
>       R_xlen_t nmax, nlines, nskip;
>       const char *p, *encoding;
>       RCNTXT cntxt;
> @@ -952,8 +952,6 @@
>   	    if(!data.con->canread)
>   		error(_("cannot read from this connection"));
>   	}
> -	for (R_xlen_t i = 0; i < nskip; i++) /* MBCS-safe */
> -	    while ((c = scanchar(FALSE, &data)) != '\n' && c != R_EOF);
>       }
>   
>       ans = R_NilValue;		/* -Wall */
> @@ -966,6 +964,10 @@
>       cntxt.cend = &scan_cleanup;
>       cntxt.cenddata = &data;
>   
> +    if (ii) for (R_xlen_t i = 0, j = 0; i < nskip && c != R_EOF; i++) /* MBCS-safe */
> +	while ((c = scanchar(FALSE, &data)) != '\n' && c != R_EOF)
> +	    if (j++ % 10000 == 9999) R_CheckUserInterrupt();
> +
>       switch (TYPEOF(what)) {
>       case LGLSXP:
>       case INTSXP:
>
> This way, even if you pour a Decanter of Endless Lines (e.g. mkfifo
> LINES; perl -E'print "A"x42 while 1;' > LINES) into scan(), it can
> still be interrupted, even if neither newline nor EOF ever arrives.

Thanks, I've updated the implementation of scan() in R-devel to be 
interruptible while skipping lines.

I've done it slightly differently as I found there already was a memory 
leak, which could be fixed by creating the context a bit earlier.

I've also avoided modulo on the fast path as I saw 13% performance 
overhead on my mailbox file. Decrementing and checking against zero 
didn't have measurable overhead.

Best
Tomas

> (We never skip lines when reading from the console? I suppose it makes
> sense. I think this needs to be documented and can write a
> documentation patch.)
>
> If you actually have 1e11 lines in your file and would like to read it
> in chunks, it may help to use
>
> f <- file('...')
> chunk1 <- scan(f, n = n1, skip = nskip1)
> # the following will continue reading where chunk1 had ended
> chunk2 <- scan(f, n = n2, skip = nskip2)
>
> ...in order to avoid having to skip over chunks you have already read,
> which otherwise makes the algorithm quadratic in number of lines
> instead of linear. (I couldn't determine whether you're already doing
> this, sorry.)
>
> Skipping a fixed number of lines is hard: since they have variable
> length, it's required to read every character in order to determine
> whether it starts a new line. With byte ranges, it would have been
> possible to use seek(), but not here.
>


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Fri Mar 10 16:39:39 2023
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Fri, 10 Mar 2023 16:39:39 +0100
Subject: [Rd] On optimizing `R_NewEnv()`
In-Reply-To: <CABzLhzxrrV7AGg5nCwCdEzqB1aRcRcHByoAXrjiXgRMi7Q=4-A@mail.gmail.com>
References: <CABzLhzxrrV7AGg5nCwCdEzqB1aRcRcHByoAXrjiXgRMi7Q=4-A@mail.gmail.com>
Message-ID: <9bb1f967-9a82-deca-e23a-12ebf515f851@gmail.com>


On 2/8/23 21:51, Davis Vaughan via R-devel wrote:
> Hi all,
>
> I really like the addition of `R_NewEnv()` back in 4.1.0
> https://github.com/wch/r-source/blob/625ab8d45f86f65561e53627e1f0c220bdc5f752/src/main/envir.c#L3619-L3630
>
> I have a use case where I'm likely to call this function a large
> number of times to generate many small hashed environments, so I'd
> like to optimize it as far as possible.
>
> I noticed that it takes `int size`, converts that to a SEXP for
> `R_NewHashedEnv()`, which then simply converts that back to an `int`
> here:
> https://github.com/wch/r-source/blob/625ab8d45f86f65561e53627e1f0c220bdc5f752/src/main/envir.c#L378
>
> I wonder if we could cut out that intermediate SEXP (along with its
> protection) by adjusting `R_NewHashedEnv()` to instead take `int
> size`.
>
> I'd be happy to do a patch if that sounds good. I'd update all uses of
> `R_NewHashedEnv()` to supply `int`s instead, which actually seems like
> it would make every instance of calling that function simpler:
> https://github.com/search?q=repo%3Awch%2Fr-source%20R_NewHashedEnv&type=code
>
> So hopefully a win everywhere?

I've simplified this code in R-devel as suggested.

However, I think that the original performance motivation is weak: if 
some program creates so many, small and little used hashed environments 
that this overhead matters, probably it should use a different data 
structure, and then it will get much bigger performance benefits.

Best,
Tomas

>
> Thanks,
> Davis
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch  Sat Mar 11 10:04:54 2023
From: @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch (Sebastian Martin Krantz)
Date: Sat, 11 Mar 2023 11:04:54 +0200
Subject: [Rd] Multiple Assignment built into the R Interpreter?
Message-ID: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>

Dear R Core,

working on my dynamic factor modelling package, which requires several
subroutines to create and update several system matrices, I come back to
the issue of being annoyed by R not supporting multiple assignment out of
the box like Matlab, Python and julia. e.g. something like

A, C, Q, R = init_matrices(X, Y, Z)

would be a great addition to the language. I know there are several
workarounds such as the %<-% operator in the zeallot package or my own %=%
operator in collapse, but these don't work well for package development as
R CMD Check warns about missing global bindings for the created variables,
e.g. I would have to use

A <- C <- Q <- R <- NULL
.c(A, C, Q, R) %=% init_matrices(X, Y, Z)

in a package, which is simply annoying. Of course the standard way of

init <- init_matrices(X, Y, Z)
 A <- init$A; C <- init$C; Q <- init$Q; R <- init$R
rm(init)

is also super cumbersome compared to Python or Julia. Another reason is of
course performance, even my %=% operator written in C has a non-negligible
performance cost for very tight loops, compared to a solution at the
interpretor level or in a primitive function such as `=`.

So my conclusion at this point is that it is just significantly easier to
implement such codes in Julia, in addition to the greater performance it
offers. There are obvious reasons why I am still coding in R and C, thanks
to the robust API and great ecosystem of packages, but adding this could be
a presumably low-hanging fruit to make my life a bit easier. Several issues
for this have been filed on Stackoverflow, the most popular one (
https://stackoverflow.com/questions/7519790/assign-multiple-new-variables-on-lhs-in-a-single-line)
has been viewed 77 thousand times.

But maybe this has already been discussed here and already decided against.
In that case, a way to browse R-devel archives to find out would be nice.

Best regards,

Sebastian

	[[alternative HTML version deleted]]


From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Mar 11 14:37:24 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sat, 11 Mar 2023 08:37:24 -0500
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
Message-ID: <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>

I think the standard way to do this in R is given by list2env(), as 
described in a couple of answers on the SO page you linked.

The syntax you proposed would be likely to be confusing in complex 
expressions, e.g.

   f(A, C, Q, R = init_matrices(X, Y, Z))

would obviously not work but wouldn't trigger a syntax error, and

   f((A, C, Q, R = init_matrices(X, Y, Z)))

could work, but looks too much like the previous one.  So I think R 
would want Javascript-like

   [A, C, Q, R] <- init_matrices(X, Y, Z)

instead.  But then the question would come up about how to handle the 
RHS.  Does the function have to return a list?  What if the length of 
the list is not 4?  Or is it just guaranteed to be equivalent to

   temp <- init_matrices(X, Y, Z)
   A <- temp[[1]]
   C <- temp[[2]]
   Q <- temp[[3]]
   R <- temp[[4]]

which would work for other vector types besides lists?

BTW, here's a little hack that almost works:

`vals<-` <- function(x, ..., value) {
    others <- substitute(list(...))
    if (length(others) > 1)
      for (i in seq_along(others)[-1])
        assign(as.character(others[[i]]), value[[i]], envir = 
parent.frame())
    value[[1]]
}

You call it as

  vals(a, b, c) <- 1:3

and it assigns 1 to a, 2 to b, and 3 to c.  It doesn't quite do what you 
want because it requires that a exists already, but b and c don't have to.

Duncan Murdoch

On 11/03/2023 4:04 a.m., Sebastian Martin Krantz wrote:
> Dear R Core,
> 
> working on my dynamic factor modelling package, which requires several
> subroutines to create and update several system matrices, I come back to
> the issue of being annoyed by R not supporting multiple assignment out of
> the box like Matlab, Python and julia. e.g. something like
> 
> A, C, Q, R = init_matrices(X, Y, Z)
> 
> would be a great addition to the language. I know there are several
> workarounds such as the %<-% operator in the zeallot package or my own %=%
> operator in collapse, but these don't work well for package development as
> R CMD Check warns about missing global bindings for the created variables,
> e.g. I would have to use
> 
> A <- C <- Q <- R <- NULL
> .c(A, C, Q, R) %=% init_matrices(X, Y, Z)
> 
> in a package, which is simply annoying. Of course the standard way of
> 
> init <- init_matrices(X, Y, Z)
>   A <- init$A; C <- init$C; Q <- init$Q; R <- init$R
> rm(init)
> 
> is also super cumbersome compared to Python or Julia. Another reason is of
> course performance, even my %=% operator written in C has a non-negligible
> performance cost for very tight loops, compared to a solution at the
> interpretor level or in a primitive function such as `=`.
> 
> So my conclusion at this point is that it is just significantly easier to
> implement such codes in Julia, in addition to the greater performance it
> offers. There are obvious reasons why I am still coding in R and C, thanks
> to the robust API and great ecosystem of packages, but adding this could be
> a presumably low-hanging fruit to make my life a bit easier. Several issues
> for this have been filed on Stackoverflow, the most popular one (
> https://stackoverflow.com/questions/7519790/assign-multiple-new-variables-on-lhs-in-a-single-line)
> has been viewed 77 thousand times.
> 
> But maybe this has already been discussed here and already decided against.
> In that case, a way to browse R-devel archives to find out would be nice.
> 
> Best regards,
> 
> Sebastian
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch  Sat Mar 11 15:54:48 2023
From: @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch (Sebastian Martin Krantz)
Date: Sat, 11 Mar 2023 16:54:48 +0200
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
Message-ID: <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>

Thanks Duncan,

I know about list2env(), in fact a previous version of collapse::`%=%` was
coded as

"%=%" <- function(lhs, rhs) {
   if(!is.character(lhs)) stop("lhs needs to be character")
   if(!is.list(rhs)) rhs <- as.vector(rhs, "list")
   if(length(lhs) != length(rhs)) stop("length(lhs) not equal to
length(rhs)")
   list2env(`names<-`(rhs, lhs), envir = parent.frame())
   invisible()
}

but as you say, the input needs to be converted to a list, and it calls
several R functions, which led me to end up writing `%=%` in C:
https://github.com/SebKrantz/collapse/blob/master/src/small_helper.c#L162.
This implementation works in the way you describe, i.e. it has separate
methods for all the standard vector types, and coerces to list otherwise.

That being said, all implementations in packages falls short of being very
useful, because R CMD Check it will still require global bindings for
variables,
unless this becomes a standard feature of the language. So I cannot use
this in packages, and there is still a performance cost to it, in my case a
call to
.Call() and parent.frame(), which is quite low, but still high compared to
the cost of `<-` or `=`.

So what I am requesting is indeed nothing less than to consider making this
a permanent feature of the language itself.
Given that the other 3 major scientific computing languages (Matlab, Python
and Julia) have implemented it very successfully,
I don't think the general practicality of it should be an issue. Regarding
implementation in other languages, Julia works as follows:

function init_matrices()
    A = 1; C = 2; Q = 3; R = 4
    return A, C, Q, R
end

res = init_matrices()             # gives a Julia Tuple (A, C, Q, R)
A, C = init_matrices()           # Works, A is 1, C is 2, the others are
dropped
A, C, Q, R = init_matrices()  # Standard

I think as far as R is concerned multiple return values are not really
necessary given that one can always,
return(list(A, C, Q, R)), although of course there is also a cost to
list(). I also wouldn't mind being strict about it and
not allowing A, C = init_matrices(), but others might disagree.

Best regards,

Sebastian


On Sat, 11 Mar 2023 at 15:37, Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:

> I think the standard way to do this in R is given by list2env(), as
> described in a couple of answers on the SO page you linked.
>
> The syntax you proposed would be likely to be confusing in complex
> expressions, e.g.
>
>    f(A, C, Q, R = init_matrices(X, Y, Z))
>
> would obviously not work but wouldn't trigger a syntax error, and
>
>    f((A, C, Q, R = init_matrices(X, Y, Z)))
>
> could work, but looks too much like the previous one.  So I think R
> would want Javascript-like
>
>    [A, C, Q, R] <- init_matrices(X, Y, Z)
>
> instead.  But then the question would come up about how to handle the
> RHS.  Does the function have to return a list?  What if the length of
> the list is not 4?  Or is it just guaranteed to be equivalent to
>
>    temp <- init_matrices(X, Y, Z)
>    A <- temp[[1]]
>    C <- temp[[2]]
>    Q <- temp[[3]]
>    R <- temp[[4]]
>
> which would work for other vector types besides lists?
>
> BTW, here's a little hack that almost works:
>
> `vals<-` <- function(x, ..., value) {
>     others <- substitute(list(...))
>     if (length(others) > 1)
>       for (i in seq_along(others)[-1])
>         assign(as.character(others[[i]]), value[[i]], envir =
> parent.frame())
>     value[[1]]
> }
>
> You call it as
>
>   vals(a, b, c) <- 1:3
>
> and it assigns 1 to a, 2 to b, and 3 to c.  It doesn't quite do what you
> want because it requires that a exists already, but b and c don't have to.
>
> Duncan Murdoch
>
> On 11/03/2023 4:04 a.m., Sebastian Martin Krantz wrote:
> > Dear R Core,
> >
> > working on my dynamic factor modelling package, which requires several
> > subroutines to create and update several system matrices, I come back to
> > the issue of being annoyed by R not supporting multiple assignment out of
> > the box like Matlab, Python and julia. e.g. something like
> >
> > A, C, Q, R = init_matrices(X, Y, Z)
> >
> > would be a great addition to the language. I know there are several
> > workarounds such as the %<-% operator in the zeallot package or my own
> %=%
> > operator in collapse, but these don't work well for package development
> as
> > R CMD Check warns about missing global bindings for the created
> variables,
> > e.g. I would have to use
> >
> > A <- C <- Q <- R <- NULL
> > .c(A, C, Q, R) %=% init_matrices(X, Y, Z)
> >
> > in a package, which is simply annoying. Of course the standard way of
> >
> > init <- init_matrices(X, Y, Z)
> >   A <- init$A; C <- init$C; Q <- init$Q; R <- init$R
> > rm(init)
> >
> > is also super cumbersome compared to Python or Julia. Another reason is
> of
> > course performance, even my %=% operator written in C has a
> non-negligible
> > performance cost for very tight loops, compared to a solution at the
> > interpretor level or in a primitive function such as `=`.
> >
> > So my conclusion at this point is that it is just significantly easier to
> > implement such codes in Julia, in addition to the greater performance it
> > offers. There are obvious reasons why I am still coding in R and C,
> thanks
> > to the robust API and great ecosystem of packages, but adding this could
> be
> > a presumably low-hanging fruit to make my life a bit easier. Several
> issues
> > for this have been filed on Stackoverflow, the most popular one (
> >
> https://stackoverflow.com/questions/7519790/assign-multiple-new-variables-on-lhs-in-a-single-line
> )
> > has been viewed 77 thousand times.
> >
> > But maybe this has already been discussed here and already decided
> against.
> > In that case, a way to browse R-devel archives to find out would be nice.
> >
> > Best regards,
> >
> > Sebastian
> >
> >       [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
>

	[[alternative HTML version deleted]]


From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Mar 11 17:11:06 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sat, 11 Mar 2023 11:11:06 -0500
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
Message-ID: <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>

On 11/03/2023 9:54 a.m., Sebastian Martin Krantz wrote:
> Thanks Duncan,
> 
> I know about list2env(), in fact a previous version of collapse::`%=%` 
> was coded as
> 
> "%=%" <- function(lhs, rhs) {
>  ?? if(!is.character(lhs)) stop("lhs needs to be character")
>  ?? if(!is.list(rhs)) rhs <- as.vector(rhs, "list")
>  ?? if(length(lhs) != length(rhs)) stop("length(lhs) not equal to 
> length(rhs)")
>  ?? list2env(`names<-`(rhs, lhs), envir = parent.frame())
>  ?? invisible()
> }
> 
> but as you say, the input needs to be converted to a list, and it calls 
> several R functions, which led me to end up writing `%=%` in C:
> https://github.com/SebKrantz/collapse/blob/master/src/small_helper.c#L162 <https://github.com/SebKrantz/collapse/blob/master/src/small_helper.c#L162>.
> This implementation works in the way you describe, i.e. it has separate 
> methods for all the standard vector types, and coerces to list otherwise.
> 
> That being said, all implementations in packages falls short of being 
> very useful, because R CMD Check it will still require global bindings 
> for variables,
> unless this becomes a standard feature of the language. So I cannot use 
> this in packages, and there is still a performance cost to it, in my 
> case a call to
> .Call() and parent.frame(), which is quite low, but still high compared 
> to the cost of `<-` or `=`.

Another R way to do what you're doing would be to stay within a list the 
whole time, i.e. code it as

   mats <- init_matrices(X, Y, Z)
   with(mats, ... do things with A, C, Q, and R ... )

This won't give warnings about globals, and it makes very clear that 
those 4 matrices are all closely related, and it allows you to work with 
multiple 4-tuples of matrices, etc.

> So what I am requesting is indeed nothing less than to consider making 
> this a permanent feature of the language itself.

That's clear, but your proposal violates a very basic property of the 
language, i.e. that all statements are expressions and have a value. 
What's the value of

    1 + (A, C = init_matrices())

?  I think you would disallow the above (though you didn't address it 
when I raised it the first time), which means there would now be two 
kinds of statements:  ones that are expressions and therefore can be 
used as function arguments, and ones that aren't.

> Given that the other 3 major scientific computing languages (Matlab, 
> Python and Julia) have implemented it very successfully,
> I don't think the general practicality of it should be an issue. 
> Regarding implementation in other languages, Julia works as follows:
> 
> function init_matrices()
>  ??? A = 1; C = 2; Q = 3; R = 4
>  ??? return A, C, Q, R
> end
> 
> res = init_matrices()???????????? # gives a Julia Tuple (A, C, Q, R)
> A, C = init_matrices()?????????? # Works, A is 1, C is 2, the others are 
> dropped

That's pretty ugly having a singular LHS handled so much differently 
from a plural LHS.

> A, C, Q, R = init_matrices()? # Standard
> 
> I think as far as R is concerned multiple return values are not really 
> necessary given that one can always,
> return(list(A, C, Q, R)), although of course there is also a cost to 
> list(). I also wouldn't mind being strict about it and
> not allowing A, C = init_matrices(), but others might disagree.

Another ambiguity:  suppose f() returns list(A = 1, B = 2) and I do

   B, A <- f()

Should assignment be by position or by name?

Honestly, given that this is simply syntactic sugar, I don't think I 
would support it.

Duncan Murdoch

> 
> Best regards,
> 
> Sebastian
> 
> 
> On Sat, 11 Mar 2023 at 15:37, Duncan Murdoch <murdoch.duncan at gmail.com 
> <mailto:murdoch.duncan at gmail.com>> wrote:
> 
>     I think the standard way to do this in R is given by list2env(), as
>     described in a couple of answers on the SO page you linked.
> 
>     The syntax you proposed would be likely to be confusing in complex
>     expressions, e.g.
> 
>      ? ?f(A, C, Q, R = init_matrices(X, Y, Z))
> 
>     would obviously not work but wouldn't trigger a syntax error, and
> 
>      ? ?f((A, C, Q, R = init_matrices(X, Y, Z)))
> 
>     could work, but looks too much like the previous one.? So I think R
>     would want Javascript-like
> 
>      ? ?[A, C, Q, R] <- init_matrices(X, Y, Z)
> 
>     instead.? But then the question would come up about how to handle the
>     RHS.? Does the function have to return a list?? What if the length of
>     the list is not 4?? Or is it just guaranteed to be equivalent to
> 
>      ? ?temp <- init_matrices(X, Y, Z)
>      ? ?A <- temp[[1]]
>      ? ?C <- temp[[2]]
>      ? ?Q <- temp[[3]]
>      ? ?R <- temp[[4]]
> 
>     which would work for other vector types besides lists?
> 
>     BTW, here's a little hack that almost works:
> 
>     `vals<-` <- function(x, ..., value) {
>      ? ? others <- substitute(list(...))
>      ? ? if (length(others) > 1)
>      ? ? ? for (i in seq_along(others)[-1])
>      ? ? ? ? assign(as.character(others[[i]]), value[[i]], envir =
>     parent.frame())
>      ? ? value[[1]]
>     }
> 
>     You call it as
> 
>      ? vals(a, b, c) <- 1:3
> 
>     and it assigns 1 to a, 2 to b, and 3 to c.? It doesn't quite do what
>     you
>     want because it requires that a exists already, but b and c don't
>     have to.
> 
>     Duncan Murdoch
> 
>     On 11/03/2023 4:04 a.m., Sebastian Martin Krantz wrote:
>      > Dear R Core,
>      >
>      > working on my dynamic factor modelling package, which requires
>     several
>      > subroutines to create and update several system matrices, I come
>     back to
>      > the issue of being annoyed by R not supporting multiple
>     assignment out of
>      > the box like Matlab, Python and julia. e.g. something like
>      >
>      > A, C, Q, R = init_matrices(X, Y, Z)
>      >
>      > would be a great addition to the language. I know there are several
>      > workarounds such as the %<-% operator in the zeallot package or
>     my own %=%
>      > operator in collapse, but these don't work well for package
>     development as
>      > R CMD Check warns about missing global bindings for the created
>     variables,
>      > e.g. I would have to use
>      >
>      > A <- C <- Q <- R <- NULL
>      > .c(A, C, Q, R) %=% init_matrices(X, Y, Z)
>      >
>      > in a package, which is simply annoying. Of course the standard way of
>      >
>      > init <- init_matrices(X, Y, Z)
>      >? ?A <- init$A; C <- init$C; Q <- init$Q; R <- init$R
>      > rm(init)
>      >
>      > is also super cumbersome compared to Python or Julia. Another
>     reason is of
>      > course performance, even my %=% operator written in C has a
>     non-negligible
>      > performance cost for very tight loops, compared to a solution at the
>      > interpretor level or in a primitive function such as `=`.
>      >
>      > So my conclusion at this point is that it is just significantly
>     easier to
>      > implement such codes in Julia, in addition to the greater
>     performance it
>      > offers. There are obvious reasons why I am still coding in R and
>     C, thanks
>      > to the robust API and great ecosystem of packages, but adding
>     this could be
>      > a presumably low-hanging fruit to make my life a bit easier.
>     Several issues
>      > for this have been filed on Stackoverflow, the most popular one (
>      >
>     https://stackoverflow.com/questions/7519790/assign-multiple-new-variables-on-lhs-in-a-single-line <https://stackoverflow.com/questions/7519790/assign-multiple-new-variables-on-lhs-in-a-single-line>)
>      > has been viewed 77 thousand times.
>      >
>      > But maybe this has already been discussed here and already
>     decided against.
>      > In that case, a way to browse R-devel archives to find out would
>     be nice.
>      >
>      > Best regards,
>      >
>      > Sebastian
>      >
>      >? ? ? ?[[alternative HTML version deleted]]
>      >
>      > ______________________________________________
>      > R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>      > https://stat.ethz.ch/mailman/listinfo/r-devel
>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>


From kry|ov@r00t @end|ng |rom gm@||@com  Sat Mar 11 17:57:08 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Sat, 11 Mar 2023 19:57:08 +0300
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
Message-ID: <20230311195708.794032e8@Tarkus>

On Sat, 11 Mar 2023 11:11:06 -0500
Duncan Murdoch <murdoch.duncan at gmail.com> wrote:

> That's clear, but your proposal violates a very basic property of the 
> language, i.e. that all statements are expressions and have a value. 

How about reframing this feature request from multiple assignment
(which does go contrary to "everything has only one value, even if it's
sometimes invisible(NULL)") to "structured binding" / "destructuring
assignment" [*], which takes this single single value returned by the
expression and subsets it subject to certain rules? It may be easier to
make a decision on the semantics for destructuring assignment (e.g.
languages which have this feature typically allow throwing unneeded
parts of the return value away), and it doesn't seem to break as much
of the rest of the language if implemented.

I see you've already mentioned it ("JavaScript-like"). I think it would
fulfil Sebastian's requirements too, as long as it is considered "true
assignment" by the rest of the language.

The hard part is to propose the actual grammar of the new feature (in
terms of src/main/gram.y, preferably without introducing conflicts) and
its semantics (including the corner cases, some of which you have
already mentioned). I'm not sure I'm up to the task.

-- 
Best regards,
Ivan

[*]
https://en.cppreference.com/w/cpp/language/structured_binding
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment


From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Mar 11 19:38:42 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sat, 11 Mar 2023 13:38:42 -0500
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <20230311195708.794032e8@Tarkus>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
Message-ID: <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>

On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> On Sat, 11 Mar 2023 11:11:06 -0500
> Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> 
>> That's clear, but your proposal violates a very basic property of the
>> language, i.e. that all statements are expressions and have a value.
> 
> How about reframing this feature request from multiple assignment
> (which does go contrary to "everything has only one value, even if it's
> sometimes invisible(NULL)") to "structured binding" / "destructuring
> assignment" [*], which takes this single single value returned by the
> expression and subsets it subject to certain rules? It may be easier to
> make a decision on the semantics for destructuring assignment (e.g.
> languages which have this feature typically allow throwing unneeded
> parts of the return value away), and it doesn't seem to break as much
> of the rest of the language if implemented.
> 
> I see you've already mentioned it ("JavaScript-like"). I think it would
> fulfil Sebastian's requirements too, as long as it is considered "true
> assignment" by the rest of the language.
> 
> The hard part is to propose the actual grammar of the new feature (in
> terms of src/main/gram.y, preferably without introducing conflicts) and
> its semantics (including the corner cases, some of which you have
> already mentioned). I'm not sure I'm up to the task.
> 

If I were doing it, here's what I'd propose:

   '[' formlist ']' LEFT_ASSIGN expr
   '[' formlist ']' EQ_ASSIGN expr
   expr RIGHT_ASSIGN  '[' formlist ']'

where `formlist` has the syntax of the formals list for a function 
definition.  This would have the following semantics:

    {
      *tmp* <- expr

      # For arguments with no "default" expression,

      argname1 <- *tmp*[[1]]
      argname2 <- *tmp*[[2]]
      ...

      # For arguments with a default listed

      argname3 <- with(*tmp*, default3)
    }


The value of the whole thing would therefore be (invisibly) the value of 
the last item in the assignment.

Two examples:

   [A, B, C] <- expr   # assign the first three elements of expr to A, 
B, and C

   [A, B, C = a + b] <- expr  # assign the first two elements of expr
                              # to A and B,
                              # assign with(expr, a + b) to C.

Unfortunately, I don't think this could be done entirely by transforming 
the expression (which is the way |> was done), and that makes it a lot 
harder to write and to reason about.  E.g. what does this do?

   A <- 0
   [A, B = A + 10] <- list(1, A = 2)

According to the recipe above, I think it sets A to 1 and B to 12, but 
maybe a user would expect B to be 10 or 11.  And according to that 
recipe this is an error:

   [A, B = A + 10] <- c(1, A = 2)

which probably isn't what a user would expect, given that this is fine:

   [A, B] <- c(1, 2)

Duncan Murdoch


From @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch  Sat Mar 11 22:42:38 2023
From: @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch (Sebastian Martin Krantz)
Date: Sat, 11 Mar 2023 23:42:38 +0200
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
Message-ID: <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>

Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can follow
all aspects you raised, but to give my limited take on a few:

> your proposal violates a very basic property of the  language, i.e. that all statements are expressions and have a value.
> What's the value of 1 + (A, C = init_matrices()).

I'm not sure I see the point here. I evaluated  1 + (d = dim(mtcars);
nr = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error, as
the above expression should. `%=%` assigns to
environments, so 1 + (c("A", "C") %=% init_matrices()) returns
numeric(0), with A and C having their values assigned.

> suppose f() returns list(A = 1, B = 2) and I do
>  B, A <- f()
> Should assignment be by position or by name?

In other languages this is by position. The feature is not meant to
replace list2env(), and being able to rename objects in the assignment
is a vital feature of codes
using multi input and output functions e.g. in Matlab or Julia.

> Honestly, given that this is simply syntactic sugar, I don't think I would support it.

You can call it that, but it would be used by almost every R user
almost every day. Simple things like nr, nc = dim(x); values, vectors
= eigen(x) etc. where the creation of intermediate objects
is cumbersome and redundant.

> I see you've already mentioned it ("JavaScript-like"). I think it would  fulfil Sebastian's requirements too, as long as it is considered "true assignment" by the rest of the language.

I don't have strong opinions about how the issue is phrased or
implemented. Something like [t, n] = dim(x) might even be more clear.
It's important though that assignment remains by position,
so even if some output gets thrown away that should also be positional.

>  A <- 0
>  [A, B = A + 10] <- list(1, A = 2)

I also fail to see the use of allowing this. something like this is an error.

> A = 2
> (B = A + 1) <- 1
Error in (B = A + 1) <- 1 : could not find function "(<-"

Regarding the practical implementation, I think `collapse::%=%` is a
good starting point. It could be introduced in R as a separate
function, or `=` could be modified to accommodate its capability. It
should be clear that
with more than one LHS variables the assignment is an environment
level operation and the results can only be used in computations once
assigned to the environment, e.g. as in 1 + (c("A", "C") %=%
init_matrices()),
A and C are not available for the addition in this statement. The
interpretor then needs to be modified to read something like nr, nc =
dim(x) or [nr, nc] = dim(x). as an environment-level multiple
assignment operation with no
immediate value. Appears very feasible to my limited understanding,
but I guess there are other things to consider still. Definitely
appreciate the responses so far though.

Best regards,

Sebastian





On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:

> On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> > On Sat, 11 Mar 2023 11:11:06 -0500
> > Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> >
> >> That's clear, but your proposal violates a very basic property of the
> >> language, i.e. that all statements are expressions and have a value.
> >
> > How about reframing this feature request from multiple assignment
> > (which does go contrary to "everything has only one value, even if it's
> > sometimes invisible(NULL)") to "structured binding" / "destructuring
> > assignment" [*], which takes this single single value returned by the
> > expression and subsets it subject to certain rules? It may be easier to
> > make a decision on the semantics for destructuring assignment (e.g.
> > languages which have this feature typically allow throwing unneeded
> > parts of the return value away), and it doesn't seem to break as much
> > of the rest of the language if implemented.
> >
> > I see you've already mentioned it ("JavaScript-like"). I think it would
> > fulfil Sebastian's requirements too, as long as it is considered "true
> > assignment" by the rest of the language.
> >
> > The hard part is to propose the actual grammar of the new feature (in
> > terms of src/main/gram.y, preferably without introducing conflicts) and
> > its semantics (including the corner cases, some of which you have
> > already mentioned). I'm not sure I'm up to the task.
> >
>
> If I were doing it, here's what I'd propose:
>
>    '[' formlist ']' LEFT_ASSIGN expr
>    '[' formlist ']' EQ_ASSIGN expr
>    expr RIGHT_ASSIGN  '[' formlist ']'
>
> where `formlist` has the syntax of the formals list for a function
> definition.  This would have the following semantics:
>
>     {
>       *tmp* <- expr
>
>       # For arguments with no "default" expression,
>
>       argname1 <- *tmp*[[1]]
>       argname2 <- *tmp*[[2]]
>       ...
>
>       # For arguments with a default listed
>
>       argname3 <- with(*tmp*, default3)
>     }
>
>
> The value of the whole thing would therefore be (invisibly) the value of
> the last item in the assignment.
>
> Two examples:
>
>    [A, B, C] <- expr   # assign the first three elements of expr to A,
> B, and C
>
>    [A, B, C = a + b] <- expr  # assign the first two elements of expr
>                               # to A and B,
>                               # assign with(expr, a + b) to C.
>
> Unfortunately, I don't think this could be done entirely by transforming
> the expression (which is the way |> was done), and that makes it a lot
> harder to write and to reason about.  E.g. what does this do?
>
>    A <- 0
>    [A, B = A + 10] <- list(1, A = 2)
>
> According to the recipe above, I think it sets A to 1 and B to 12, but
> maybe a user would expect B to be 10 or 11.  And according to that
> recipe this is an error:
>
>    [A, B = A + 10] <- c(1, A = 2)
>
> which probably isn't what a user would expect, given that this is fine:
>
>    [A, B] <- c(1, 2)
>
> Duncan Murdoch
>

	[[alternative HTML version deleted]]


From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Mar 11 23:42:42 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sat, 11 Mar 2023 17:42:42 -0500
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
Message-ID: <9a7b5d53-6064-497f-6859-31fc77561737@gmail.com>

On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
> Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can 
> follow all aspects you raised, but to give my limited take on a few:
> 
>> your proposal violates a very basic property of the  language, i.e. that all statements are expressions and have a value.  > What's the value of 1 + (A, C = init_matrices()).
> 
> I'm not sure I see the point here. I evaluated 1 + (d = dim(mtcars); nr 
> = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error, as the 
> above expression should. `%=%` assigns to
> environments, so 1 + (c("A", "C") %=% init_matrices()) returns 
> numeric(0), with A and C having their values assigned.
> 
>> suppose f() returns list(A = 1, B = 2) and I do  > B, A <- f() > Should assignment be by position or by name?
> 
> In other languages this is by position. The feature is not meant to 
> replace list2env(), and being able to rename objects in the assignment 
> is a vital feature of codes
> using multi input and output functions e.g. in Matlab or Julia.
> 
>> Honestly, given that this is simply syntactic sugar, I don't think I would support it.
> 
> You can call it that, but it would be used by almost every R user almost 
> every day. Simple things like nr, nc = dim(x); values, vectors = 
> eigen(x) etc. where the creation of intermediate objects
> is cumbersome and redundant.
> 
>> I see you've already mentioned it ("JavaScript-like"). I think it would  fulfil Sebastian's requirements too, as long as it is considered "true assignment" by the rest of the language.
> 
> I don't have strong opinions about how the issue is phrased or 
> implemented. Something like [t, n] = dim(x) might even be more clear. 
> It's important though that assignment remains by position,
> so even if some output gets thrown away that should also be positional.
> 
>>  A <- 0  > [A, B = A + 10] <- list(1, A = 2)
> 
> I also fail to see the use of allowing this. something like this is an 
> error.
> 
>> A = 2
>> (B = A + 1) <- 1
> Error in (B = A + 1) <- 1 : could not find function "(<-"
> 
> Regarding the practical implementation, I think `collapse::%=%` is a 
> good starting point. It could be introduced in R as a separate function, 
> or `=` could be modified to accommodate its capability. It should be 
> clear that
> with more than one LHS variables the assignment is an environment level 
> operation and the results can only be used in computations once assigned 
> to the environment, e.g. as in 1 + (c("A", "C") %=% init_matrices()),
> A and C are not available for the addition in this statement. The 
> interpretor then needs to be modified to read something like nr, nc = 
> dim(x) or [nr, nc] = dim(x). as an environment-level multiple assignment 
> operation with no
> immediate value. Appears very feasible to my limited understanding, but 
> I guess there are other things to consider still. Definitely appreciate 
> the responses so far though.

Show me.

Duncan Murdoch

> 
> Best regards,
> 
> Sebastian
> 
> 
> 
> 
> 
> On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com 
> <mailto:murdoch.duncan at gmail.com>> wrote:
> 
>     On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
>      > On Sat, 11 Mar 2023 11:11:06 -0500
>      > Duncan Murdoch <murdoch.duncan at gmail.com
>     <mailto:murdoch.duncan at gmail.com>> wrote:
>      >
>      >> That's clear, but your proposal violates a very basic property
>     of the
>      >> language, i.e. that all statements are expressions and have a value.
>      >
>      > How about reframing this feature request from multiple assignment
>      > (which does go contrary to "everything has only one value, even
>     if it's
>      > sometimes invisible(NULL)") to "structured binding" / "destructuring
>      > assignment" [*], which takes this single single value returned by the
>      > expression and subsets it subject to certain rules? It may be
>     easier to
>      > make a decision on the semantics for destructuring assignment (e.g.
>      > languages which have this feature typically allow throwing unneeded
>      > parts of the return value away), and it doesn't seem to break as much
>      > of the rest of the language if implemented.
>      >
>      > I see you've already mentioned it ("JavaScript-like"). I think it
>     would
>      > fulfil Sebastian's requirements too, as long as it is considered
>     "true
>      > assignment" by the rest of the language.
>      >
>      > The hard part is to propose the actual grammar of the new feature (in
>      > terms of src/main/gram.y, preferably without introducing
>     conflicts) and
>      > its semantics (including the corner cases, some of which you have
>      > already mentioned). I'm not sure I'm up to the task.
>      >
> 
>     If I were doing it, here's what I'd propose:
> 
>      ? ?'[' formlist ']' LEFT_ASSIGN expr
>      ? ?'[' formlist ']' EQ_ASSIGN expr
>      ? ?expr RIGHT_ASSIGN? '[' formlist ']'
> 
>     where `formlist` has the syntax of the formals list for a function
>     definition.? This would have the following semantics:
> 
>      ? ? {
>      ? ? ? *tmp* <- expr
> 
>      ? ? ? # For arguments with no "default" expression,
> 
>      ? ? ? argname1 <- *tmp*[[1]]
>      ? ? ? argname2 <- *tmp*[[2]]
>      ? ? ? ...
> 
>      ? ? ? # For arguments with a default listed
> 
>      ? ? ? argname3 <- with(*tmp*, default3)
>      ? ? }
> 
> 
>     The value of the whole thing would therefore be (invisibly) the
>     value of
>     the last item in the assignment.
> 
>     Two examples:
> 
>      ? ?[A, B, C] <- expr? ?# assign the first three elements of expr to A,
>     B, and C
> 
>      ? ?[A, B, C = a + b] <- expr? # assign the first two elements of expr
>      ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? # to A and B,
>      ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? # assign with(expr, a + b) to C.
> 
>     Unfortunately, I don't think this could be done entirely by
>     transforming
>     the expression (which is the way |> was done), and that makes it a lot
>     harder to write and to reason about.? E.g. what does this do?
> 
>      ? ?A <- 0
>      ? ?[A, B = A + 10] <- list(1, A = 2)
> 
>     According to the recipe above, I think it sets A to 1 and B to 12, but
>     maybe a user would expect B to be 10 or 11.? And according to that
>     recipe this is an error:
> 
>      ? ?[A, B = A + 10] <- c(1, A = 2)
> 
>     which probably isn't what a user would expect, given that this is fine:
> 
>      ? ?[A, B] <- c(1, 2)
> 
>     Duncan Murdoch
>


From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Mar 11 23:44:16 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sat, 11 Mar 2023 17:44:16 -0500
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
Message-ID: <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>

On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
> Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can 
> follow all aspects you raised, but to give my limited take on a few:
> 
>> your proposal violates a very basic property of the  language, i.e. that all statements are expressions and have a value.  > What's the value of 1 + (A, C = init_matrices()).
> 
> I'm not sure I see the point here. I evaluated 1 + (d = dim(mtcars); nr 
> = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error,


   d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)

is not a statement, it is a sequence of 4 statements.

Duncan Murdoch

  as the
> above expression should. `%=%` assigns to
> environments, so 1 + (c("A", "C") %=% init_matrices()) returns 
> numeric(0), with A and C having their values assigned.
> 
>> suppose f() returns list(A = 1, B = 2) and I do  > B, A <- f() > Should assignment be by position or by name?
> 
> In other languages this is by position. The feature is not meant to 
> replace list2env(), and being able to rename objects in the assignment 
> is a vital feature of codes
> using multi input and output functions e.g. in Matlab or Julia.
> 
>> Honestly, given that this is simply syntactic sugar, I don't think I would support it.
> 
> You can call it that, but it would be used by almost every R user almost 
> every day. Simple things like nr, nc = dim(x); values, vectors = 
> eigen(x) etc. where the creation of intermediate objects
> is cumbersome and redundant.
> 
>> I see you've already mentioned it ("JavaScript-like"). I think it would  fulfil Sebastian's requirements too, as long as it is considered "true assignment" by the rest of the language.
> 
> I don't have strong opinions about how the issue is phrased or 
> implemented. Something like [t, n] = dim(x) might even be more clear. 
> It's important though that assignment remains by position,
> so even if some output gets thrown away that should also be positional.
> 
>>  A <- 0  > [A, B = A + 10] <- list(1, A = 2)
> 
> I also fail to see the use of allowing this. something like this is an 
> error.
> 
>> A = 2
>> (B = A + 1) <- 1
> Error in (B = A + 1) <- 1 : could not find function "(<-"
> 
> Regarding the practical implementation, I think `collapse::%=%` is a 
> good starting point. It could be introduced in R as a separate function, 
> or `=` could be modified to accommodate its capability. It should be 
> clear that
> with more than one LHS variables the assignment is an environment level 
> operation and the results can only be used in computations once assigned 
> to the environment, e.g. as in 1 + (c("A", "C") %=% init_matrices()),
> A and C are not available for the addition in this statement. The 
> interpretor then needs to be modified to read something like nr, nc = 
> dim(x) or [nr, nc] = dim(x). as an environment-level multiple assignment 
> operation with no
> immediate value. Appears very feasible to my limited understanding, but 
> I guess there are other things to consider still. Definitely appreciate 
> the responses so far though.
> 
> Best regards,
> 
> Sebastian
> 
> 
> 
> 
> 
> On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com 
> <mailto:murdoch.duncan at gmail.com>> wrote:
> 
>     On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
>      > On Sat, 11 Mar 2023 11:11:06 -0500
>      > Duncan Murdoch <murdoch.duncan at gmail.com
>     <mailto:murdoch.duncan at gmail.com>> wrote:
>      >
>      >> That's clear, but your proposal violates a very basic property
>     of the
>      >> language, i.e. that all statements are expressions and have a value.
>      >
>      > How about reframing this feature request from multiple assignment
>      > (which does go contrary to "everything has only one value, even
>     if it's
>      > sometimes invisible(NULL)") to "structured binding" / "destructuring
>      > assignment" [*], which takes this single single value returned by the
>      > expression and subsets it subject to certain rules? It may be
>     easier to
>      > make a decision on the semantics for destructuring assignment (e.g.
>      > languages which have this feature typically allow throwing unneeded
>      > parts of the return value away), and it doesn't seem to break as much
>      > of the rest of the language if implemented.
>      >
>      > I see you've already mentioned it ("JavaScript-like"). I think it
>     would
>      > fulfil Sebastian's requirements too, as long as it is considered
>     "true
>      > assignment" by the rest of the language.
>      >
>      > The hard part is to propose the actual grammar of the new feature (in
>      > terms of src/main/gram.y, preferably without introducing
>     conflicts) and
>      > its semantics (including the corner cases, some of which you have
>      > already mentioned). I'm not sure I'm up to the task.
>      >
> 
>     If I were doing it, here's what I'd propose:
> 
>      ? ?'[' formlist ']' LEFT_ASSIGN expr
>      ? ?'[' formlist ']' EQ_ASSIGN expr
>      ? ?expr RIGHT_ASSIGN? '[' formlist ']'
> 
>     where `formlist` has the syntax of the formals list for a function
>     definition.? This would have the following semantics:
> 
>      ? ? {
>      ? ? ? *tmp* <- expr
> 
>      ? ? ? # For arguments with no "default" expression,
> 
>      ? ? ? argname1 <- *tmp*[[1]]
>      ? ? ? argname2 <- *tmp*[[2]]
>      ? ? ? ...
> 
>      ? ? ? # For arguments with a default listed
> 
>      ? ? ? argname3 <- with(*tmp*, default3)
>      ? ? }
> 
> 
>     The value of the whole thing would therefore be (invisibly) the
>     value of
>     the last item in the assignment.
> 
>     Two examples:
> 
>      ? ?[A, B, C] <- expr? ?# assign the first three elements of expr to A,
>     B, and C
> 
>      ? ?[A, B, C = a + b] <- expr? # assign the first two elements of expr
>      ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? # to A and B,
>      ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? # assign with(expr, a + b) to C.
> 
>     Unfortunately, I don't think this could be done entirely by
>     transforming
>     the expression (which is the way |> was done), and that makes it a lot
>     harder to write and to reason about.? E.g. what does this do?
> 
>      ? ?A <- 0
>      ? ?[A, B = A + 10] <- list(1, A = 2)
> 
>     According to the recipe above, I think it sets A to 1 and B to 12, but
>     maybe a user would expect B to be 10 or 11.? And according to that
>     recipe this is an error:
> 
>      ? ?[A, B = A + 10] <- c(1, A = 2)
> 
>     which probably isn't what a user would expect, given that this is fine:
> 
>      ? ?[A, B] <- c(1, 2)
> 
>     Duncan Murdoch
>


From g@bembecker @end|ng |rom gm@||@com  Sat Mar 11 23:54:24 2023
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Sat, 11 Mar 2023 14:54:24 -0800
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
Message-ID: <CAD4oTHGkK_poav1qZF5L73-2J2sE1YwBEt2HWCd_=HaHGc2YzQ@mail.gmail.com>

There are some other considerations too (apologies if these were mentioned
above and I missed them). Also below are initial thoughts, so apologies for
any mistakes or oversights.

For example, if

[a, b] <- my2valuefun()

works the same as

local({
tmp <- my2valuefun()
stopifnot(is.list(tmp) && length(tmp) == 2)
a <<- tmp[[1]]
b <<- tmp[[2]]
})

Do we expect

[a[1], b[3]] <- my2valuefun()

to also work? That doesn't sound very fun to me, personally, but obviously
the "single value return" versions of these do work and have for a long
time, i.e.

a[1] <- my2valuefun()[[1]]
b[3] <- my2valuefun()[[2]]

is perfectly valid R code (though it does call the function twice which is
"silly" in some sense).

Another thing which arises from the Julia API specifically which I think is
problematic is the ambiguity of's atomic "types" being vectors. Consider
the following

coolest_function <- function() c(a = 15, b = 65, c = 275)
a <- coolest_function()

That obviously makes a vector of length 3. Anything else would break *like
all the R code*

But now, what does

[a] <- coolest_function()

do? Does it assign 15 to a, because b and c arent' being assigned to?

Does this mean variables being assigned to actually need to *match the
names within the return object*? I don't think that would work at all in
general...

Alternatively, is the second one an error, because the function isn't
returning a list? This doesn't really fix the problem either though

Because a single list of length > 1 *is a valid thing to return from an R
function*. I think, like in Julia, you'd need to declare the set of things
being returned, and perhaps map them to the variables you want assigned

crazy_notworking_fun <- function() {
  return(a = 5, b = 65, c = 275)
}

[a_val = a, b_val = b] <- crazy_notworking_fun()

Or even,

[a_val <- a, b_val <-b] <- crazy_notworking_fun()


In that case, however, it becomes somewhat unclear (to me at least) what

only_val <- crazy_notworking_fun()

would do. Throw an error because multivalued functions are fundamentally
different and we can't pretend they aren't? This would disallow all of the
things you think "most r users would use every day" (a claim I'm somewhat
skeptical of, to be honest). If thats not it, though, what? I don't think
it can/should return the full list of results, because that introduces the
ambiguity this is trying to avoid right back in.  Perhaps just the first
thing returned? That is internally consistent, but  somewhat strange
behavior...

Best,
~G




On Sat, Mar 11, 2023 at 2:15?PM Sebastian Martin Krantz <
sebastian.krantz at graduateinstitute.ch> wrote:

> Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can follow
> all aspects you raised, but to give my limited take on a few:
>
> > your proposal violates a very basic property of the  language, i.e. that
> all statements are expressions and have a value.
> > What's the value of 1 + (A, C = init_matrices()).
>
> I'm not sure I see the point here. I evaluated  1 + (d = dim(mtcars);
> nr = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error, as
> the above expression should. `%=%` assigns to
> environments, so 1 + (c("A", "C") %=% init_matrices()) returns
> numeric(0), with A and C having their values assigned.
>
> > suppose f() returns list(A = 1, B = 2) and I do
> >  B, A <- f()
> > Should assignment be by position or by name?
>
> In other languages this is by position. The feature is not meant to
> replace list2env(), and being able to rename objects in the assignment
> is a vital feature of codes
> using multi input and output functions e.g. in Matlab or Julia.
>
> > Honestly, given that this is simply syntactic sugar, I don't think I
> would support it.
>
> You can call it that, but it would be used by almost every R user
> almost every day. Simple things like nr, nc = dim(x); values, vectors
> = eigen(x) etc. where the creation of intermediate objects
> is cumbersome and redundant.
>
> > I see you've already mentioned it ("JavaScript-like"). I think it would
> fulfil Sebastian's requirements too, as long as it is considered "true
> assignment" by the rest of the language.
>
> I don't have strong opinions about how the issue is phrased or
> implemented. Something like [t, n] = dim(x) might even be more clear.
> It's important though that assignment remains by position,
> so even if some output gets thrown away that should also be positional.
>
> >  A <- 0
> >  [A, B = A + 10] <- list(1, A = 2)
>
> I also fail to see the use of allowing this. something like this is an
> error.
>
> > A = 2
> > (B = A + 1) <- 1
> Error in (B = A + 1) <- 1 : could not find function "(<-"
>
> Regarding the practical implementation, I think `collapse::%=%` is a
> good starting point. It could be introduced in R as a separate
> function, or `=` could be modified to accommodate its capability. It
> should be clear that
> with more than one LHS variables the assignment is an environment
> level operation and the results can only be used in computations once
> assigned to the environment, e.g. as in 1 + (c("A", "C") %=%
> init_matrices()),
> A and C are not available for the addition in this statement. The
> interpretor then needs to be modified to read something like nr, nc =
> dim(x) or [nr, nc] = dim(x). as an environment-level multiple
> assignment operation with no
> immediate value. Appears very feasible to my limited understanding,
> but I guess there are other things to consider still. Definitely
> appreciate the responses so far though.
>
> Best regards,
>
> Sebastian
>
>
>
>
>
> On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
>
> > On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> > > On Sat, 11 Mar 2023 11:11:06 -0500
> > > Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> > >
> > >> That's clear, but your proposal violates a very basic property of the
> > >> language, i.e. that all statements are expressions and have a value.
> > >
> > > How about reframing this feature request from multiple assignment
> > > (which does go contrary to "everything has only one value, even if it's
> > > sometimes invisible(NULL)") to "structured binding" / "destructuring
> > > assignment" [*], which takes this single single value returned by the
> > > expression and subsets it subject to certain rules? It may be easier to
> > > make a decision on the semantics for destructuring assignment (e.g.
> > > languages which have this feature typically allow throwing unneeded
> > > parts of the return value away), and it doesn't seem to break as much
> > > of the rest of the language if implemented.
> > >
> > > I see you've already mentioned it ("JavaScript-like"). I think it would
> > > fulfil Sebastian's requirements too, as long as it is considered "true
> > > assignment" by the rest of the language.
> > >
> > > The hard part is to propose the actual grammar of the new feature (in
> > > terms of src/main/gram.y, preferably without introducing conflicts) and
> > > its semantics (including the corner cases, some of which you have
> > > already mentioned). I'm not sure I'm up to the task.
> > >
> >
> > If I were doing it, here's what I'd propose:
> >
> >    '[' formlist ']' LEFT_ASSIGN expr
> >    '[' formlist ']' EQ_ASSIGN expr
> >    expr RIGHT_ASSIGN  '[' formlist ']'
> >
> > where `formlist` has the syntax of the formals list for a function
> > definition.  This would have the following semantics:
> >
> >     {
> >       *tmp* <- expr
> >
> >       # For arguments with no "default" expression,
> >
> >       argname1 <- *tmp*[[1]]
> >       argname2 <- *tmp*[[2]]
> >       ...
> >
> >       # For arguments with a default listed
> >
> >       argname3 <- with(*tmp*, default3)
> >     }
> >
> >
> > The value of the whole thing would therefore be (invisibly) the value of
> > the last item in the assignment.
> >
> > Two examples:
> >
> >    [A, B, C] <- expr   # assign the first three elements of expr to A,
> > B, and C
> >
> >    [A, B, C = a + b] <- expr  # assign the first two elements of expr
> >                               # to A and B,
> >                               # assign with(expr, a + b) to C.
> >
> > Unfortunately, I don't think this could be done entirely by transforming
> > the expression (which is the way |> was done), and that makes it a lot
> > harder to write and to reason about.  E.g. what does this do?
> >
> >    A <- 0
> >    [A, B = A + 10] <- list(1, A = 2)
> >
> > According to the recipe above, I think it sets A to 1 and B to 12, but
> > maybe a user would expect B to be 10 or 11.  And according to that
> > recipe this is an error:
> >
> >    [A, B = A + 10] <- c(1, A = 2)
> >
> > which probably isn't what a user would expect, given that this is fine:
> >
> >    [A, B] <- c(1, 2)
> >
> > Duncan Murdoch
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From kev|nu@hey @end|ng |rom gm@||@com  Sun Mar 12 00:00:16 2023
From: kev|nu@hey @end|ng |rom gm@||@com (Kevin Ushey)
Date: Sat, 11 Mar 2023 15:00:16 -0800
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
Message-ID: <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>

FWIW, it's possible to get fairly close to your proposed semantics
using the existing metaprogramming facilities in R. I put together a
prototype package here to demonstrate:

    https://github.com/kevinushey/dotty

The package exports an object called `.`, with a special `[<-.dot` S3
method which enables destructuring assignments. This means you can
write code like:

    .[nr, nc] <- dim(mtcars)

and that will define 'nr' and 'nc' as you expect.

As for R CMD check warnings, you can suppress those through the use of
globalVariables(), and that can also be automated within the package.
The 'dotty' package includes a function 'dotify()' which automates
looking for such usages in your package, and calling globalVariables()
so that R CMD check doesn't warn. In theory, a similar technique would
be applicable to other packages defining similar operators (zeallot,
collapse).

Obviously, globalVariables() is a very heavy hammer to swing for this
issue, but you might consider the benefits worth the tradeoffs.

Best,
Kevin

On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>
> On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
> > Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can
> > follow all aspects you raised, but to give my limited take on a few:
> >
> >> your proposal violates a very basic property of the  language, i.e. that all statements are expressions and have a value.  > What's the value of 1 + (A, C = init_matrices()).
> >
> > I'm not sure I see the point here. I evaluated 1 + (d = dim(mtcars); nr
> > = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error,
>
>
>    d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
>
> is not a statement, it is a sequence of 4 statements.
>
> Duncan Murdoch
>
>   as the
> > above expression should. `%=%` assigns to
> > environments, so 1 + (c("A", "C") %=% init_matrices()) returns
> > numeric(0), with A and C having their values assigned.
> >
> >> suppose f() returns list(A = 1, B = 2) and I do  > B, A <- f() > Should assignment be by position or by name?
> >
> > In other languages this is by position. The feature is not meant to
> > replace list2env(), and being able to rename objects in the assignment
> > is a vital feature of codes
> > using multi input and output functions e.g. in Matlab or Julia.
> >
> >> Honestly, given that this is simply syntactic sugar, I don't think I would support it.
> >
> > You can call it that, but it would be used by almost every R user almost
> > every day. Simple things like nr, nc = dim(x); values, vectors =
> > eigen(x) etc. where the creation of intermediate objects
> > is cumbersome and redundant.
> >
> >> I see you've already mentioned it ("JavaScript-like"). I think it would  fulfil Sebastian's requirements too, as long as it is considered "true assignment" by the rest of the language.
> >
> > I don't have strong opinions about how the issue is phrased or
> > implemented. Something like [t, n] = dim(x) might even be more clear.
> > It's important though that assignment remains by position,
> > so even if some output gets thrown away that should also be positional.
> >
> >>  A <- 0  > [A, B = A + 10] <- list(1, A = 2)
> >
> > I also fail to see the use of allowing this. something like this is an
> > error.
> >
> >> A = 2
> >> (B = A + 1) <- 1
> > Error in (B = A + 1) <- 1 : could not find function "(<-"
> >
> > Regarding the practical implementation, I think `collapse::%=%` is a
> > good starting point. It could be introduced in R as a separate function,
> > or `=` could be modified to accommodate its capability. It should be
> > clear that
> > with more than one LHS variables the assignment is an environment level
> > operation and the results can only be used in computations once assigned
> > to the environment, e.g. as in 1 + (c("A", "C") %=% init_matrices()),
> > A and C are not available for the addition in this statement. The
> > interpretor then needs to be modified to read something like nr, nc =
> > dim(x) or [nr, nc] = dim(x). as an environment-level multiple assignment
> > operation with no
> > immediate value. Appears very feasible to my limited understanding, but
> > I guess there are other things to consider still. Definitely appreciate
> > the responses so far though.
> >
> > Best regards,
> >
> > Sebastian
> >
> >
> >
> >
> >
> > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com
> > <mailto:murdoch.duncan at gmail.com>> wrote:
> >
> >     On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> >      > On Sat, 11 Mar 2023 11:11:06 -0500
> >      > Duncan Murdoch <murdoch.duncan at gmail.com
> >     <mailto:murdoch.duncan at gmail.com>> wrote:
> >      >
> >      >> That's clear, but your proposal violates a very basic property
> >     of the
> >      >> language, i.e. that all statements are expressions and have a value.
> >      >
> >      > How about reframing this feature request from multiple assignment
> >      > (which does go contrary to "everything has only one value, even
> >     if it's
> >      > sometimes invisible(NULL)") to "structured binding" / "destructuring
> >      > assignment" [*], which takes this single single value returned by the
> >      > expression and subsets it subject to certain rules? It may be
> >     easier to
> >      > make a decision on the semantics for destructuring assignment (e.g.
> >      > languages which have this feature typically allow throwing unneeded
> >      > parts of the return value away), and it doesn't seem to break as much
> >      > of the rest of the language if implemented.
> >      >
> >      > I see you've already mentioned it ("JavaScript-like"). I think it
> >     would
> >      > fulfil Sebastian's requirements too, as long as it is considered
> >     "true
> >      > assignment" by the rest of the language.
> >      >
> >      > The hard part is to propose the actual grammar of the new feature (in
> >      > terms of src/main/gram.y, preferably without introducing
> >     conflicts) and
> >      > its semantics (including the corner cases, some of which you have
> >      > already mentioned). I'm not sure I'm up to the task.
> >      >
> >
> >     If I were doing it, here's what I'd propose:
> >
> >         '[' formlist ']' LEFT_ASSIGN expr
> >         '[' formlist ']' EQ_ASSIGN expr
> >         expr RIGHT_ASSIGN  '[' formlist ']'
> >
> >     where `formlist` has the syntax of the formals list for a function
> >     definition.  This would have the following semantics:
> >
> >          {
> >            *tmp* <- expr
> >
> >            # For arguments with no "default" expression,
> >
> >            argname1 <- *tmp*[[1]]
> >            argname2 <- *tmp*[[2]]
> >            ...
> >
> >            # For arguments with a default listed
> >
> >            argname3 <- with(*tmp*, default3)
> >          }
> >
> >
> >     The value of the whole thing would therefore be (invisibly) the
> >     value of
> >     the last item in the assignment.
> >
> >     Two examples:
> >
> >         [A, B, C] <- expr   # assign the first three elements of expr to A,
> >     B, and C
> >
> >         [A, B, C = a + b] <- expr  # assign the first two elements of expr
> >                                    # to A and B,
> >                                    # assign with(expr, a + b) to C.
> >
> >     Unfortunately, I don't think this could be done entirely by
> >     transforming
> >     the expression (which is the way |> was done), and that makes it a lot
> >     harder to write and to reason about.  E.g. what does this do?
> >
> >         A <- 0
> >         [A, B = A + 10] <- list(1, A = 2)
> >
> >     According to the recipe above, I think it sets A to 1 and B to 12, but
> >     maybe a user would expect B to be 10 or 11.  And according to that
> >     recipe this is an error:
> >
> >         [A, B = A + 10] <- c(1, A = 2)
> >
> >     which probably isn't what a user would expect, given that this is fine:
> >
> >         [A, B] <- c(1, 2)
> >
> >     Duncan Murdoch
> >
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @vi@e@gross m@iii@g oii gm@ii@com  Sun Mar 12 02:09:20 2023
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Sat, 11 Mar 2023 20:09:20 -0500
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAD4oTHGkK_poav1qZF5L73-2J2sE1YwBEt2HWCd_=HaHGc2YzQ@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <CAD4oTHGkK_poav1qZF5L73-2J2sE1YwBEt2HWCd_=HaHGc2YzQ@mail.gmail.com>
Message-ID: <002501d9547f$46fa2a40$d4ee7ec0$@gmail.com>

I am not personally for or against changes to the R main language but do find that too many people keep wanting to change R so it should be like some other language. Many features would be nice, especially if they do not break existing code, but the time and effort and other overheads need to be a consideration.

R has long had a concept of returning a data structure with inner parts such as from calling lm() or ggplot() that can be used to store lots of info, often including saved copies of the data and parameters that generated it, and you can often update the object or query it for specific fields or pass it intact to some next step.

Anyone wanting to return multiple results has classically done something like return a list containing named items and your code had the option of unpacking the parts you want and ignoring others. This may not be modern or elegant but so what?

I could go through a long list of nice things I see in other languages and ask if R has that ability now (perhaps in a package) or should have it.

Do we need a swap like:

  a, b <- b, a

Do we need a dual comparative like:

If ( -5 < X < 5) ...

The two examples work fine in Python as do many other things but Python is not R and cannot trivially do many things R does either.

Many programming languages have been converging in some ways. SCALA version 3 simplified many parts of the language by borrowing their own version of using indentation from languages like Haskell and Python. Personally, I like it but it causes some headaches for older code and you have to either change the code or disable the feature. So, anyone think R should follow through and also allow many places that now use grouping by curly braces or other methods, to use indentation level?

I am NOT saying any additions are impossible but we need to keep the base language working well on existing code or perhaps make a clean break and make a new version of R (I assume logically Q as in S went to S-- (AKA R) so R-- would be Q, LOL!

There is a community of users of a language who are partially here based on existing R packages. Some can probably find more and more functionality along the same lines as Python modules and elsewhere with some work and continue in a language that may fit their personal preferences. But the people responsible for maintaining and developing R are not just casual users and would have to do serious amounts of work choosing what it would look like and how to implement it, and deal with edge cases and complaints.

The new R pipe is a case in point. Why was it added? I mean I have been using various pipes including in the tidyverse for years quite happily. I did not need it added except perhaps for performance reasons. But when it came out, it had a rather glaring incompatibility in some ways with not providing a fairly trivial way to pass the pipeline to anything other than the first positional variable. Sure, they added a kludge using a horrible to read anonymous function syntax that I suspect many will not use and rather find their own ways around. 

But am I glad it was added? Sure. Could they have improved something else instead that was missing? I mean I use the glue package but would love something like an f-string built in that did pretty much stuff like that as can be found in other languages. 

This may sound stupid, but if someone wants features from another language, maybe they should consider using the two languages together and alternating which one diddles with your data as can be done multiple ways already.

Will that solve what the OP wants? Nope. They want whatever tool they are using to become a Swiss Army Knife.

But there is something to be said for a sparse language that does a few things well and does not grow just to grow and be like everyone else.






-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel Becker
Sent: Saturday, March 11, 2023 5:54 PM
To: Sebastian Martin Krantz <sebastian.krantz at graduateinstitute.ch>
Cc: r-devel <r-devel at r-project.org>
Subject: Re: [Rd] Multiple Assignment built into the R Interpreter?

There are some other considerations too (apologies if these were mentioned
above and I missed them). Also below are initial thoughts, so apologies for
any mistakes or oversights.

For example, if

[a, b] <- my2valuefun()

works the same as

local({
tmp <- my2valuefun()
stopifnot(is.list(tmp) && length(tmp) == 2)
a <<- tmp[[1]]
b <<- tmp[[2]]
})

Do we expect

[a[1], b[3]] <- my2valuefun()

to also work? That doesn't sound very fun to me, personally, but obviously
the "single value return" versions of these do work and have for a long
time, i.e.

a[1] <- my2valuefun()[[1]]
b[3] <- my2valuefun()[[2]]

is perfectly valid R code (though it does call the function twice which is
"silly" in some sense).

Another thing which arises from the Julia API specifically which I think is
problematic is the ambiguity of's atomic "types" being vectors. Consider
the following

coolest_function <- function() c(a = 15, b = 65, c = 275)
a <- coolest_function()

That obviously makes a vector of length 3. Anything else would break *like
all the R code*

But now, what does

[a] <- coolest_function()

do? Does it assign 15 to a, because b and c arent' being assigned to?

Does this mean variables being assigned to actually need to *match the
names within the return object*? I don't think that would work at all in
general...

Alternatively, is the second one an error, because the function isn't
returning a list? This doesn't really fix the problem either though

Because a single list of length > 1 *is a valid thing to return from an R
function*. I think, like in Julia, you'd need to declare the set of things
being returned, and perhaps map them to the variables you want assigned

crazy_notworking_fun <- function() {
  return(a = 5, b = 65, c = 275)
}

[a_val = a, b_val = b] <- crazy_notworking_fun()

Or even,

[a_val <- a, b_val <-b] <- crazy_notworking_fun()


In that case, however, it becomes somewhat unclear (to me at least) what

only_val <- crazy_notworking_fun()

would do. Throw an error because multivalued functions are fundamentally
different and we can't pretend they aren't? This would disallow all of the
things you think "most r users would use every day" (a claim I'm somewhat
skeptical of, to be honest). If thats not it, though, what? I don't think
it can/should return the full list of results, because that introduces the
ambiguity this is trying to avoid right back in.  Perhaps just the first
thing returned? That is internally consistent, but  somewhat strange
behavior...

Best,
~G




On Sat, Mar 11, 2023 at 2:15?PM Sebastian Martin Krantz <
sebastian.krantz at graduateinstitute.ch> wrote:

> Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can follow
> all aspects you raised, but to give my limited take on a few:
>
> > your proposal violates a very basic property of the  language, i.e. that
> all statements are expressions and have a value.
> > What's the value of 1 + (A, C = init_matrices()).
>
> I'm not sure I see the point here. I evaluated  1 + (d = dim(mtcars);
> nr = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error, as
> the above expression should. `%=%` assigns to
> environments, so 1 + (c("A", "C") %=% init_matrices()) returns
> numeric(0), with A and C having their values assigned.
>
> > suppose f() returns list(A = 1, B = 2) and I do
> >  B, A <- f()
> > Should assignment be by position or by name?
>
> In other languages this is by position. The feature is not meant to
> replace list2env(), and being able to rename objects in the assignment
> is a vital feature of codes
> using multi input and output functions e.g. in Matlab or Julia.
>
> > Honestly, given that this is simply syntactic sugar, I don't think I
> would support it.
>
> You can call it that, but it would be used by almost every R user
> almost every day. Simple things like nr, nc = dim(x); values, vectors
> = eigen(x) etc. where the creation of intermediate objects
> is cumbersome and redundant.
>
> > I see you've already mentioned it ("JavaScript-like"). I think it would
> fulfil Sebastian's requirements too, as long as it is considered "true
> assignment" by the rest of the language.
>
> I don't have strong opinions about how the issue is phrased or
> implemented. Something like [t, n] = dim(x) might even be more clear.
> It's important though that assignment remains by position,
> so even if some output gets thrown away that should also be positional.
>
> >  A <- 0
> >  [A, B = A + 10] <- list(1, A = 2)
>
> I also fail to see the use of allowing this. something like this is an
> error.
>
> > A = 2
> > (B = A + 1) <- 1
> Error in (B = A + 1) <- 1 : could not find function "(<-"
>
> Regarding the practical implementation, I think `collapse::%=%` is a
> good starting point. It could be introduced in R as a separate
> function, or `=` could be modified to accommodate its capability. It
> should be clear that
> with more than one LHS variables the assignment is an environment
> level operation and the results can only be used in computations once
> assigned to the environment, e.g. as in 1 + (c("A", "C") %=%
> init_matrices()),
> A and C are not available for the addition in this statement. The
> interpretor then needs to be modified to read something like nr, nc =
> dim(x) or [nr, nc] = dim(x). as an environment-level multiple
> assignment operation with no
> immediate value. Appears very feasible to my limited understanding,
> but I guess there are other things to consider still. Definitely
> appreciate the responses so far though.
>
> Best regards,
>
> Sebastian
>
>
>
>
>
> On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
>
> > On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> > > On Sat, 11 Mar 2023 11:11:06 -0500
> > > Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> > >
> > >> That's clear, but your proposal violates a very basic property of the
> > >> language, i.e. that all statements are expressions and have a value.
> > >
> > > How about reframing this feature request from multiple assignment
> > > (which does go contrary to "everything has only one value, even if it's
> > > sometimes invisible(NULL)") to "structured binding" / "destructuring
> > > assignment" [*], which takes this single single value returned by the
> > > expression and subsets it subject to certain rules? It may be easier to
> > > make a decision on the semantics for destructuring assignment (e.g.
> > > languages which have this feature typically allow throwing unneeded
> > > parts of the return value away), and it doesn't seem to break as much
> > > of the rest of the language if implemented.
> > >
> > > I see you've already mentioned it ("JavaScript-like"). I think it would
> > > fulfil Sebastian's requirements too, as long as it is considered "true
> > > assignment" by the rest of the language.
> > >
> > > The hard part is to propose the actual grammar of the new feature (in
> > > terms of src/main/gram.y, preferably without introducing conflicts) and
> > > its semantics (including the corner cases, some of which you have
> > > already mentioned). I'm not sure I'm up to the task.
> > >
> >
> > If I were doing it, here's what I'd propose:
> >
> >    '[' formlist ']' LEFT_ASSIGN expr
> >    '[' formlist ']' EQ_ASSIGN expr
> >    expr RIGHT_ASSIGN  '[' formlist ']'
> >
> > where `formlist` has the syntax of the formals list for a function
> > definition.  This would have the following semantics:
> >
> >     {
> >       *tmp* <- expr
> >
> >       # For arguments with no "default" expression,
> >
> >       argname1 <- *tmp*[[1]]
> >       argname2 <- *tmp*[[2]]
> >       ...
> >
> >       # For arguments with a default listed
> >
> >       argname3 <- with(*tmp*, default3)
> >     }
> >
> >
> > The value of the whole thing would therefore be (invisibly) the value of
> > the last item in the assignment.
> >
> > Two examples:
> >
> >    [A, B, C] <- expr   # assign the first three elements of expr to A,
> > B, and C
> >
> >    [A, B, C = a + b] <- expr  # assign the first two elements of expr
> >                               # to A and B,
> >                               # assign with(expr, a + b) to C.
> >
> > Unfortunately, I don't think this could be done entirely by transforming
> > the expression (which is the way |> was done), and that makes it a lot
> > harder to write and to reason about.  E.g. what does this do?
> >
> >    A <- 0
> >    [A, B = A + 10] <- list(1, A = 2)
> >
> > According to the recipe above, I think it sets A to 1 and B to 12, but
> > maybe a user would expect B to be 10 or 11.  And according to that
> > recipe this is an error:
> >
> >    [A, B = A + 10] <- c(1, A = 2)
> >
> > which probably isn't what a user would expect, given that this is fine:
> >
> >    [A, B] <- c(1, 2)
> >
> > Duncan Murdoch
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Mar 12 11:06:33 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sun, 12 Mar 2023 06:06:33 -0400
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
Message-ID: <a5554b05-be93-3661-7dc8-9f6d8e8dd930@gmail.com>

I really like it!  Nicely done.

Duncan Murdoch


On 11/03/2023 6:00 p.m., Kevin Ushey wrote:
> FWIW, it's possible to get fairly close to your proposed semantics
> using the existing metaprogramming facilities in R. I put together a
> prototype package here to demonstrate:
> 
>      https://github.com/kevinushey/dotty
> 
> The package exports an object called `.`, with a special `[<-.dot` S3
> method which enables destructuring assignments. This means you can
> write code like:
> 
>      .[nr, nc] <- dim(mtcars)
> 
> and that will define 'nr' and 'nc' as you expect.
> 
> As for R CMD check warnings, you can suppress those through the use of
> globalVariables(), and that can also be automated within the package.
> The 'dotty' package includes a function 'dotify()' which automates
> looking for such usages in your package, and calling globalVariables()
> so that R CMD check doesn't warn. In theory, a similar technique would
> be applicable to other packages defining similar operators (zeallot,
> collapse).
> 
> Obviously, globalVariables() is a very heavy hammer to swing for this
> issue, but you might consider the benefits worth the tradeoffs.
> 
> Best,
> Kevin
> 
> On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>
>> On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
>>> Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can
>>> follow all aspects you raised, but to give my limited take on a few:
>>>
>>>> your proposal violates a very basic property of the  language, i.e. that all statements are expressions and have a value.  > What's the value of 1 + (A, C = init_matrices()).
>>>
>>> I'm not sure I see the point here. I evaluated 1 + (d = dim(mtcars); nr
>>> = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error,
>>
>>
>>     d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
>>
>> is not a statement, it is a sequence of 4 statements.
>>
>> Duncan Murdoch
>>
>>    as the
>>> above expression should. `%=%` assigns to
>>> environments, so 1 + (c("A", "C") %=% init_matrices()) returns
>>> numeric(0), with A and C having their values assigned.
>>>
>>>> suppose f() returns list(A = 1, B = 2) and I do  > B, A <- f() > Should assignment be by position or by name?
>>>
>>> In other languages this is by position. The feature is not meant to
>>> replace list2env(), and being able to rename objects in the assignment
>>> is a vital feature of codes
>>> using multi input and output functions e.g. in Matlab or Julia.
>>>
>>>> Honestly, given that this is simply syntactic sugar, I don't think I would support it.
>>>
>>> You can call it that, but it would be used by almost every R user almost
>>> every day. Simple things like nr, nc = dim(x); values, vectors =
>>> eigen(x) etc. where the creation of intermediate objects
>>> is cumbersome and redundant.
>>>
>>>> I see you've already mentioned it ("JavaScript-like"). I think it would  fulfil Sebastian's requirements too, as long as it is considered "true assignment" by the rest of the language.
>>>
>>> I don't have strong opinions about how the issue is phrased or
>>> implemented. Something like [t, n] = dim(x) might even be more clear.
>>> It's important though that assignment remains by position,
>>> so even if some output gets thrown away that should also be positional.
>>>
>>>>   A <- 0  > [A, B = A + 10] <- list(1, A = 2)
>>>
>>> I also fail to see the use of allowing this. something like this is an
>>> error.
>>>
>>>> A = 2
>>>> (B = A + 1) <- 1
>>> Error in (B = A + 1) <- 1 : could not find function "(<-"
>>>
>>> Regarding the practical implementation, I think `collapse::%=%` is a
>>> good starting point. It could be introduced in R as a separate function,
>>> or `=` could be modified to accommodate its capability. It should be
>>> clear that
>>> with more than one LHS variables the assignment is an environment level
>>> operation and the results can only be used in computations once assigned
>>> to the environment, e.g. as in 1 + (c("A", "C") %=% init_matrices()),
>>> A and C are not available for the addition in this statement. The
>>> interpretor then needs to be modified to read something like nr, nc =
>>> dim(x) or [nr, nc] = dim(x). as an environment-level multiple assignment
>>> operation with no
>>> immediate value. Appears very feasible to my limited understanding, but
>>> I guess there are other things to consider still. Definitely appreciate
>>> the responses so far though.
>>>
>>> Best regards,
>>>
>>> Sebastian
>>>
>>>
>>>
>>>
>>>
>>> On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com
>>> <mailto:murdoch.duncan at gmail.com>> wrote:
>>>
>>>      On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
>>>       > On Sat, 11 Mar 2023 11:11:06 -0500
>>>       > Duncan Murdoch <murdoch.duncan at gmail.com
>>>      <mailto:murdoch.duncan at gmail.com>> wrote:
>>>       >
>>>       >> That's clear, but your proposal violates a very basic property
>>>      of the
>>>       >> language, i.e. that all statements are expressions and have a value.
>>>       >
>>>       > How about reframing this feature request from multiple assignment
>>>       > (which does go contrary to "everything has only one value, even
>>>      if it's
>>>       > sometimes invisible(NULL)") to "structured binding" / "destructuring
>>>       > assignment" [*], which takes this single single value returned by the
>>>       > expression and subsets it subject to certain rules? It may be
>>>      easier to
>>>       > make a decision on the semantics for destructuring assignment (e.g.
>>>       > languages which have this feature typically allow throwing unneeded
>>>       > parts of the return value away), and it doesn't seem to break as much
>>>       > of the rest of the language if implemented.
>>>       >
>>>       > I see you've already mentioned it ("JavaScript-like"). I think it
>>>      would
>>>       > fulfil Sebastian's requirements too, as long as it is considered
>>>      "true
>>>       > assignment" by the rest of the language.
>>>       >
>>>       > The hard part is to propose the actual grammar of the new feature (in
>>>       > terms of src/main/gram.y, preferably without introducing
>>>      conflicts) and
>>>       > its semantics (including the corner cases, some of which you have
>>>       > already mentioned). I'm not sure I'm up to the task.
>>>       >
>>>
>>>      If I were doing it, here's what I'd propose:
>>>
>>>          '[' formlist ']' LEFT_ASSIGN expr
>>>          '[' formlist ']' EQ_ASSIGN expr
>>>          expr RIGHT_ASSIGN  '[' formlist ']'
>>>
>>>      where `formlist` has the syntax of the formals list for a function
>>>      definition.  This would have the following semantics:
>>>
>>>           {
>>>             *tmp* <- expr
>>>
>>>             # For arguments with no "default" expression,
>>>
>>>             argname1 <- *tmp*[[1]]
>>>             argname2 <- *tmp*[[2]]
>>>             ...
>>>
>>>             # For arguments with a default listed
>>>
>>>             argname3 <- with(*tmp*, default3)
>>>           }
>>>
>>>
>>>      The value of the whole thing would therefore be (invisibly) the
>>>      value of
>>>      the last item in the assignment.
>>>
>>>      Two examples:
>>>
>>>          [A, B, C] <- expr   # assign the first three elements of expr to A,
>>>      B, and C
>>>
>>>          [A, B, C = a + b] <- expr  # assign the first two elements of expr
>>>                                     # to A and B,
>>>                                     # assign with(expr, a + b) to C.
>>>
>>>      Unfortunately, I don't think this could be done entirely by
>>>      transforming
>>>      the expression (which is the way |> was done), and that makes it a lot
>>>      harder to write and to reason about.  E.g. what does this do?
>>>
>>>          A <- 0
>>>          [A, B = A + 10] <- list(1, A = 2)
>>>
>>>      According to the recipe above, I think it sets A to 1 and B to 12, but
>>>      maybe a user would expect B to be 10 or 11.  And according to that
>>>      recipe this is an error:
>>>
>>>          [A, B = A + 10] <- c(1, A = 2)
>>>
>>>      which probably isn't what a user would expect, given that this is fine:
>>>
>>>          [A, B] <- c(1, 2)
>>>
>>>      Duncan Murdoch
>>>
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Mar 12 12:18:20 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sun, 12 Mar 2023 07:18:20 -0400
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxCLE9j1XiGwRevcAHu_EHYXaA=aBSREbb3SDUXWMiNHyg@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
 <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>
 <CAOsNuxCLE9j1XiGwRevcAHu_EHYXaA=aBSREbb3SDUXWMiNHyg@mail.gmail.com>
Message-ID: <05b0cf79-d768-7e6e-6dcf-502a14fcef84@gmail.com>

On 12/03/2023 6:07 a.m., Sebastian Martin Krantz wrote:
> Thinking more about this, and seeing Kevins examples at 
> https://github.com/kevinushey/dotty 
> <https://github.com/kevinushey/dotty>, I think this is the most R-like 
> way of doing it,
> with an additional benefit as it would allow to introduce the useful 
> data.table semantics DT[, .(a = b, c, d)] to more general R. So I would 
> propose to
> introduce a new primitive function . <- function(...) .Primitive(".") in 
> R with an assignment method and the following features:

I think that proposal is very unlikely to be accepted.  If it was a 
primitive function, it could only be maintained by R Core.  They are 
justifiably very reluctant to take on extra work for themselves.

Kevin's package demonstrates that this can be done entirely in a 
contributed package, which means there's no need for R Core to be 
involved.  I don't know if he has plans to turn his prototype into a 
CRAN package.  If he doesn't, then it will be up to some other 
interested maintainer to step up and take on the task, or it will just 
fade away.

I haven't checked whether your proposals below represent changes from 
the current version of dotty, but if they do, the way to proceed is to 
fork that project, implement your changes, and offer to contribute them 
back to the main branch.

Duncan Murdoch



> 
>   * Positional assignment e.g. .[nr, nc] <- dim(x), and named assignment
>     e.g. .[new = carb] <- mtcars or .[new = log(carb)] <- mtcars. All
>     the functionality proposed by Kevin at
>     https://github.com/kevinushey/dotty
>     <https://github.com/kevinushey/dotty> is useful, unambiguous and
>     feasible.
>   * Silent dropping of RHS values e.g. .[mpg_new, cyl_new] <- mtcars.
>   * Mixing of positional and named assignment e.g .[mpg_new, carb_new =
>     carb, cyl_new] <- mtcars. The inputs not assigned by name are simply
>     the elements of RHS in the order they occur, regardless of whether
>     they have been used previously e.g. .[mpg_new, cyl_new = cyl,
>     log_cyl = log(cyl), cyl_new2] <- mtcars is feasible. RHS here could
>     be any named vector type.
>   * Conventional use of the function as lazy version of of list(), as in
>     data.table: .(A = B, C, D) is the same as list(A = B, C = C, D = D).
>     This would also be useful, allowing more parsimonious code, and
>     avoid the need to assign names to all return values in a function
>     return, e.g. if I already have matrices A, C, Q and R as internal
>     objects in my function, I can simply end by return(.(A, C, Q, R))
>     instead of return(list(A = A, C = C, Q = Q, R = R)) if I wanted the
>     list to be named with the object names.
> 
> The implementation of this in R and C should be pretty straightforward. 
> It would just require a modification to R CMD Check to recognize .[<- as 
> assignment.
> 
> Best regards,
> 
> Sebastian
> -
> 2.)
> 
> On Sun, 12 Mar 2023 at 09:42, Sebastian Martin Krantz 
> <sebastian.krantz at graduateinstitute.ch 
> <mailto:sebastian.krantz at graduateinstitute.ch>> wrote:
> 
>     Thanks Gabriel and Kevin for your inputs,
> 
>     regarding your points Gabriel, I think Python and Julia do allow
>     multiple sub-assignment, but in-line with my earlier suggestion in
>     response to Duncan to make multiple assignment an environment-level
>     operation (like collapse::%=% currently works), ?this would not be
>     possible in R.
> 
>     Regarding the [a] <- coolest_function()?syntax, yeah it would mean
>     do multiple assignment and set a equal to the first element dropping
>     all other elements. Multiple assignment should be positional loke in
>     other languages, enabling flexible renaming of objects on the fly.
>     So it should be irrelevant whether the function returns a named or
>     unnamed list or vector.
> 
>     Thanks also Kevin for this contribution. I think it?s a remarkable
>     effort, and I wouldn?t mind such semantics e.g. making it a function
>     call to ?.[? or any other one-letter function, as long as it?s coded
>     in C and recognized by the interpreter as an assignment operation.
> 
>     Best regards,
> 
>     Sebastian
> 
> 
> 
> 
> 
>     On Sun 12. Mar 2023 at 01:00, Kevin Ushey <kevinushey at gmail.com
>     <mailto:kevinushey at gmail.com>> wrote:
> 
>         FWIW, it's possible to get fairly close to your proposed semantics
>         using the existing metaprogramming facilities in R. I put together a
>         prototype package here to demonstrate:
> 
>         https://github.com/kevinushey/dotty
>         <https://github.com/kevinushey/dotty>
> 
>         The package exports an object called `.`, with a special
>         `[<-.dot` S3
>         method which enables destructuring assignments. This means you can
>         write code like:
> 
>          ? ? .[nr, nc] <- dim(mtcars)
> 
>         and that will define 'nr' and 'nc' as you expect.
> 
>         As for R CMD check warnings, you can suppress those through the
>         use of
>         globalVariables(), and that can also be automated within the
>         package.
>         The 'dotty' package includes a function 'dotify()' which automates
>         looking for such usages in your package, and calling
>         globalVariables()
>         so that R CMD check doesn't warn. In theory, a similar technique
>         would
>         be applicable to other packages defining similar operators (zeallot,
>         collapse).
> 
>         Obviously, globalVariables() is a very heavy hammer to swing for
>         this
>         issue, but you might consider the benefits worth the tradeoffs.
> 
>         Best,
>         Kevin
> 
>         On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch
>         <murdoch.duncan at gmail.com <mailto:murdoch.duncan at gmail.com>> wrote:
>          >
>          > On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
>          > > Thanks Duncan and Ivan for the careful thoughts. I'm not
>         sure I can
>          > > follow all aspects you raised, but to give my limited take
>         on a few:
>          > >
>          > >> your proposal violates a very basic property of the 
>         language, i.e. that all statements are expressions and have a
>         value.? > What's the value of 1 + (A, C = init_matrices()).
>          > >
>          > > I'm not sure I see the point here. I evaluated 1 + (d =
>         dim(mtcars); nr
>          > > = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error,
>          >
>          >
>          >? ? d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
>          >
>          > is not a statement, it is a sequence of 4 statements.
>          >
>          > Duncan Murdoch
>          >
>          >? ?as the
>          > > above expression should. `%=%` assigns to
>          > > environments, so 1 + (c("A", "C") %=% init_matrices()) returns
>          > > numeric(0), with A and C having their values assigned.
>          > >
>          > >> suppose f() returns list(A = 1, B = 2) and I do? > B, A <-
>         f() > Should assignment be by position or by name?
>          > >
>          > > In other languages this is by position. The feature is not
>         meant to
>          > > replace list2env(), and being able to rename objects in the
>         assignment
>          > > is a vital feature of codes
>          > > using multi input and output functions e.g. in Matlab or Julia.
>          > >
>          > >> Honestly, given that this is simply syntactic sugar, I
>         don't think I would support it.
>          > >
>          > > You can call it that, but it would be used by almost every
>         R user almost
>          > > every day. Simple things like nr, nc = dim(x); values,
>         vectors =
>          > > eigen(x) etc. where the creation of intermediate objects
>          > > is cumbersome and redundant.
>          > >
>          > >> I see you've already mentioned it ("JavaScript-like"). I
>         think it would? fulfil Sebastian's requirements too, as long as
>         it is considered "true assignment" by the rest of the language.
>          > >
>          > > I don't have strong opinions about how the issue is phrased or
>          > > implemented. Something like [t, n] = dim(x) might even be
>         more clear.
>          > > It's important though that assignment remains by position,
>          > > so even if some output gets thrown away that should also be
>         positional.
>          > >
>          > >>? A <- 0? > [A, B = A + 10] <- list(1, A = 2)
>          > >
>          > > I also fail to see the use of allowing this. something like
>         this is an
>          > > error.
>          > >
>          > >> A = 2
>          > >> (B = A + 1) <- 1
>          > > Error in (B = A + 1) <- 1 : could not find function "(<-"
>          > >
>          > > Regarding the practical implementation, I think
>         `collapse::%=%` is a
>          > > good starting point. It could be introduced in R as a
>         separate function,
>          > > or `=` could be modified to accommodate its capability. It
>         should be
>          > > clear that
>          > > with more than one LHS variables the assignment is an
>         environment level
>          > > operation and the results can only be used in computations
>         once assigned
>          > > to the environment, e.g. as in 1 + (c("A", "C") %=%
>         init_matrices()),
>          > > A and C are not available for the addition in this
>         statement. The
>          > > interpretor then needs to be modified to read something
>         like nr, nc =
>          > > dim(x) or [nr, nc] = dim(x). as an environment-level
>         multiple assignment
>          > > operation with no
>          > > immediate value. Appears very feasible to my limited
>         understanding, but
>          > > I guess there are other things to consider still.
>         Definitely appreciate
>          > > the responses so far though.
>          > >
>          > > Best regards,
>          > >
>          > > Sebastian
>          > >
>          > >
>          > >
>          > >
>          > >
>          > > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch
>         <murdoch.duncan at gmail.com <mailto:murdoch.duncan at gmail.com>
>          > > <mailto:murdoch.duncan at gmail.com
>         <mailto:murdoch.duncan at gmail.com>>> wrote:
>          > >
>          > >? ? ?On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
>          > >? ? ? > On Sat, 11 Mar 2023 11:11:06 -0500
>          > >? ? ? > Duncan Murdoch <murdoch.duncan at gmail.com
>         <mailto:murdoch.duncan at gmail.com>
>          > >? ? ?<mailto:murdoch.duncan at gmail.com
>         <mailto:murdoch.duncan at gmail.com>>> wrote:
>          > >? ? ? >
>          > >? ? ? >> That's clear, but your proposal violates a very
>         basic property
>          > >? ? ?of the
>          > >? ? ? >> language, i.e. that all statements are expressions
>         and have a value.
>          > >? ? ? >
>          > >? ? ? > How about reframing this feature request from
>         multiple assignment
>          > >? ? ? > (which does go contrary to "everything has only one
>         value, even
>          > >? ? ?if it's
>          > >? ? ? > sometimes invisible(NULL)") to "structured binding"
>         / "destructuring
>          > >? ? ? > assignment" [*], which takes this single single
>         value returned by the
>          > >? ? ? > expression and subsets it subject to certain rules?
>         It may be
>          > >? ? ?easier to
>          > >? ? ? > make a decision on the semantics for destructuring
>         assignment (e.g.
>          > >? ? ? > languages which have this feature typically allow
>         throwing unneeded
>          > >? ? ? > parts of the return value away), and it doesn't seem
>         to break as much
>          > >? ? ? > of the rest of the language if implemented.
>          > >? ? ? >
>          > >? ? ? > I see you've already mentioned it
>         ("JavaScript-like"). I think it
>          > >? ? ?would
>          > >? ? ? > fulfil Sebastian's requirements too, as long as it
>         is considered
>          > >? ? ?"true
>          > >? ? ? > assignment" by the rest of the language.
>          > >? ? ? >
>          > >? ? ? > The hard part is to propose the actual grammar of
>         the new feature (in
>          > >? ? ? > terms of src/main/gram.y, preferably without introducing
>          > >? ? ?conflicts) and
>          > >? ? ? > its semantics (including the corner cases, some of
>         which you have
>          > >? ? ? > already mentioned). I'm not sure I'm up to the task.
>          > >? ? ? >
>          > >
>          > >? ? ?If I were doing it, here's what I'd propose:
>          > >
>          > >? ? ? ? ?'[' formlist ']' LEFT_ASSIGN expr
>          > >? ? ? ? ?'[' formlist ']' EQ_ASSIGN expr
>          > >? ? ? ? ?expr RIGHT_ASSIGN? '[' formlist ']'
>          > >
>          > >? ? ?where `formlist` has the syntax of the formals list for
>         a function
>          > >? ? ?definition.? This would have the following semantics:
>          > >
>          > >? ? ? ? ? {
>          > >? ? ? ? ? ? *tmp* <- expr
>          > >
>          > >? ? ? ? ? ? # For arguments with no "default" expression,
>          > >
>          > >? ? ? ? ? ? argname1 <- *tmp*[[1]]
>          > >? ? ? ? ? ? argname2 <- *tmp*[[2]]
>          > >? ? ? ? ? ? ...
>          > >
>          > >? ? ? ? ? ? # For arguments with a default listed
>          > >
>          > >? ? ? ? ? ? argname3 <- with(*tmp*, default3)
>          > >? ? ? ? ? }
>          > >
>          > >
>          > >? ? ?The value of the whole thing would therefore be
>         (invisibly) the
>          > >? ? ?value of
>          > >? ? ?the last item in the assignment.
>          > >
>          > >? ? ?Two examples:
>          > >
>          > >? ? ? ? ?[A, B, C] <- expr? ?# assign the first three
>         elements of expr to A,
>          > >? ? ?B, and C
>          > >
>          > >? ? ? ? ?[A, B, C = a + b] <- expr? # assign the first two
>         elements of expr
>          > >? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? # to A and B,
>          > >? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? # assign with(expr, a +
>         b) to C.
>          > >
>          > >? ? ?Unfortunately, I don't think this could be done entirely by
>          > >? ? ?transforming
>          > >? ? ?the expression (which is the way |> was done), and that
>         makes it a lot
>          > >? ? ?harder to write and to reason about.? E.g. what does
>         this do?
>          > >
>          > >? ? ? ? ?A <- 0
>          > >? ? ? ? ?[A, B = A + 10] <- list(1, A = 2)
>          > >
>          > >? ? ?According to the recipe above, I think it sets A to 1
>         and B to 12, but
>          > >? ? ?maybe a user would expect B to be 10 or 11.? And
>         according to that
>          > >? ? ?recipe this is an error:
>          > >
>          > >? ? ? ? ?[A, B = A + 10] <- c(1, A = 2)
>          > >
>          > >? ? ?which probably isn't what a user would expect, given
>         that this is fine:
>          > >
>          > >? ? ? ? ?[A, B] <- c(1, 2)
>          > >
>          > >? ? ?Duncan Murdoch
>          > >
>          >
>          > ______________________________________________
>          > R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>          > https://stat.ethz.ch/mailman/listinfo/r-devel
>         <https://stat.ethz.ch/mailman/listinfo/r-devel>
>


From @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch  Sun Mar 12 08:42:51 2023
From: @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch (Sebastian Martin Krantz)
Date: Sun, 12 Mar 2023 09:42:51 +0200
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
Message-ID: <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>

Thanks Gabriel and Kevin for your inputs,

regarding your points Gabriel, I think Python and Julia do allow multiple
sub-assignment, but in-line with my earlier suggestion in response to
Duncan to make multiple assignment an environment-level operation (like
collapse::%=% currently works),  this would not be possible in R.

Regarding the [a] <- coolest_function() syntax, yeah it would mean do
multiple assignment and set a equal to the first element dropping all other
elements. Multiple assignment should be positional loke in other languages,
enabling flexible renaming of objects on the fly. So it should be
irrelevant whether the function returns a named or unnamed list or vector.

Thanks also Kevin for this contribution. I think it?s a remarkable effort,
and I wouldn?t mind such semantics e.g. making it a function call to ?.[?
or any other one-letter function, as long as it?s coded in C and recognized
by the interpreter as an assignment operation.

Best regards,

Sebastian





On Sun 12. Mar 2023 at 01:00, Kevin Ushey <kevinushey at gmail.com> wrote:

> FWIW, it's possible to get fairly close to your proposed semantics
> using the existing metaprogramming facilities in R. I put together a
> prototype package here to demonstrate:
>
>     https://github.com/kevinushey/dotty
>
> The package exports an object called `.`, with a special `[<-.dot` S3
> method which enables destructuring assignments. This means you can
> write code like:
>
>     .[nr, nc] <- dim(mtcars)
>
> and that will define 'nr' and 'nc' as you expect.
>
> As for R CMD check warnings, you can suppress those through the use of
> globalVariables(), and that can also be automated within the package.
> The 'dotty' package includes a function 'dotify()' which automates
> looking for such usages in your package, and calling globalVariables()
> so that R CMD check doesn't warn. In theory, a similar technique would
> be applicable to other packages defining similar operators (zeallot,
> collapse).
>
> Obviously, globalVariables() is a very heavy hammer to swing for this
> issue, but you might consider the benefits worth the tradeoffs.
>
> Best,
> Kevin
>
> On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
> >
> > On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
> > > Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can
> > > follow all aspects you raised, but to give my limited take on a few:
> > >
> > >> your proposal violates a very basic property of the  language, i.e.
> that all statements are expressions and have a value.  > What's the value
> of 1 + (A, C = init_matrices()).
> > >
> > > I'm not sure I see the point here. I evaluated 1 + (d = dim(mtcars); nr
> > > = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error,
> >
> >
> >    d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
> >
> > is not a statement, it is a sequence of 4 statements.
> >
> > Duncan Murdoch
> >
> >   as the
> > > above expression should. `%=%` assigns to
> > > environments, so 1 + (c("A", "C") %=% init_matrices()) returns
> > > numeric(0), with A and C having their values assigned.
> > >
> > >> suppose f() returns list(A = 1, B = 2) and I do  > B, A <- f() >
> Should assignment be by position or by name?
> > >
> > > In other languages this is by position. The feature is not meant to
> > > replace list2env(), and being able to rename objects in the assignment
> > > is a vital feature of codes
> > > using multi input and output functions e.g. in Matlab or Julia.
> > >
> > >> Honestly, given that this is simply syntactic sugar, I don't think I
> would support it.
> > >
> > > You can call it that, but it would be used by almost every R user
> almost
> > > every day. Simple things like nr, nc = dim(x); values, vectors =
> > > eigen(x) etc. where the creation of intermediate objects
> > > is cumbersome and redundant.
> > >
> > >> I see you've already mentioned it ("JavaScript-like"). I think it
> would  fulfil Sebastian's requirements too, as long as it is considered
> "true assignment" by the rest of the language.
> > >
> > > I don't have strong opinions about how the issue is phrased or
> > > implemented. Something like [t, n] = dim(x) might even be more clear.
> > > It's important though that assignment remains by position,
> > > so even if some output gets thrown away that should also be positional.
> > >
> > >>  A <- 0  > [A, B = A + 10] <- list(1, A = 2)
> > >
> > > I also fail to see the use of allowing this. something like this is an
> > > error.
> > >
> > >> A = 2
> > >> (B = A + 1) <- 1
> > > Error in (B = A + 1) <- 1 : could not find function "(<-"
> > >
> > > Regarding the practical implementation, I think `collapse::%=%` is a
> > > good starting point. It could be introduced in R as a separate
> function,
> > > or `=` could be modified to accommodate its capability. It should be
> > > clear that
> > > with more than one LHS variables the assignment is an environment level
> > > operation and the results can only be used in computations once
> assigned
> > > to the environment, e.g. as in 1 + (c("A", "C") %=% init_matrices()),
> > > A and C are not available for the addition in this statement. The
> > > interpretor then needs to be modified to read something like nr, nc =
> > > dim(x) or [nr, nc] = dim(x). as an environment-level multiple
> assignment
> > > operation with no
> > > immediate value. Appears very feasible to my limited understanding, but
> > > I guess there are other things to consider still. Definitely appreciate
> > > the responses so far though.
> > >
> > > Best regards,
> > >
> > > Sebastian
> > >
> > >
> > >
> > >
> > >
> > > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com
> > > <mailto:murdoch.duncan at gmail.com>> wrote:
> > >
> > >     On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> > >      > On Sat, 11 Mar 2023 11:11:06 -0500
> > >      > Duncan Murdoch <murdoch.duncan at gmail.com
> > >     <mailto:murdoch.duncan at gmail.com>> wrote:
> > >      >
> > >      >> That's clear, but your proposal violates a very basic property
> > >     of the
> > >      >> language, i.e. that all statements are expressions and have a
> value.
> > >      >
> > >      > How about reframing this feature request from multiple
> assignment
> > >      > (which does go contrary to "everything has only one value, even
> > >     if it's
> > >      > sometimes invisible(NULL)") to "structured binding" /
> "destructuring
> > >      > assignment" [*], which takes this single single value returned
> by the
> > >      > expression and subsets it subject to certain rules? It may be
> > >     easier to
> > >      > make a decision on the semantics for destructuring assignment
> (e.g.
> > >      > languages which have this feature typically allow throwing
> unneeded
> > >      > parts of the return value away), and it doesn't seem to break
> as much
> > >      > of the rest of the language if implemented.
> > >      >
> > >      > I see you've already mentioned it ("JavaScript-like"). I think
> it
> > >     would
> > >      > fulfil Sebastian's requirements too, as long as it is considered
> > >     "true
> > >      > assignment" by the rest of the language.
> > >      >
> > >      > The hard part is to propose the actual grammar of the new
> feature (in
> > >      > terms of src/main/gram.y, preferably without introducing
> > >     conflicts) and
> > >      > its semantics (including the corner cases, some of which you
> have
> > >      > already mentioned). I'm not sure I'm up to the task.
> > >      >
> > >
> > >     If I were doing it, here's what I'd propose:
> > >
> > >         '[' formlist ']' LEFT_ASSIGN expr
> > >         '[' formlist ']' EQ_ASSIGN expr
> > >         expr RIGHT_ASSIGN  '[' formlist ']'
> > >
> > >     where `formlist` has the syntax of the formals list for a function
> > >     definition.  This would have the following semantics:
> > >
> > >          {
> > >            *tmp* <- expr
> > >
> > >            # For arguments with no "default" expression,
> > >
> > >            argname1 <- *tmp*[[1]]
> > >            argname2 <- *tmp*[[2]]
> > >            ...
> > >
> > >            # For arguments with a default listed
> > >
> > >            argname3 <- with(*tmp*, default3)
> > >          }
> > >
> > >
> > >     The value of the whole thing would therefore be (invisibly) the
> > >     value of
> > >     the last item in the assignment.
> > >
> > >     Two examples:
> > >
> > >         [A, B, C] <- expr   # assign the first three elements of expr
> to A,
> > >     B, and C
> > >
> > >         [A, B, C = a + b] <- expr  # assign the first two elements of
> expr
> > >                                    # to A and B,
> > >                                    # assign with(expr, a + b) to C.
> > >
> > >     Unfortunately, I don't think this could be done entirely by
> > >     transforming
> > >     the expression (which is the way |> was done), and that makes it a
> lot
> > >     harder to write and to reason about.  E.g. what does this do?
> > >
> > >         A <- 0
> > >         [A, B = A + 10] <- list(1, A = 2)
> > >
> > >     According to the recipe above, I think it sets A to 1 and B to 12,
> but
> > >     maybe a user would expect B to be 10 or 11.  And according to that
> > >     recipe this is an error:
> > >
> > >         [A, B = A + 10] <- c(1, A = 2)
> > >
> > >     which probably isn't what a user would expect, given that this is
> fine:
> > >
> > >         [A, B] <- c(1, 2)
> > >
> > >     Duncan Murdoch
> > >
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch  Sun Mar 12 11:07:22 2023
From: @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch (Sebastian Martin Krantz)
Date: Sun, 12 Mar 2023 12:07:22 +0200
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
 <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>
Message-ID: <CAOsNuxCLE9j1XiGwRevcAHu_EHYXaA=aBSREbb3SDUXWMiNHyg@mail.gmail.com>

Thinking more about this, and seeing Kevins examples at
https://github.com/kevinushey/dotty, I think this is the most R-like way of
doing it,
with an additional benefit as it would allow to introduce the useful
data.table semantics DT[, .(a = b, c, d)] to more general R. So I would
propose to
introduce a new primitive function . <- function(...) .Primitive(".") in R
with an assignment method and the following features:

   - Positional assignment e.g. .[nr, nc] <- dim(x), and named assignment
   e.g. .[new = carb] <- mtcars or .[new = log(carb)] <- mtcars. All the
   functionality proposed by Kevin at https://github.com/kevinushey/dotty
   is useful, unambiguous and feasible.
   - Silent dropping of RHS values e.g. .[mpg_new, cyl_new] <- mtcars.
   - Mixing of positional and named assignment e.g .[mpg_new, carb_new =
   carb, cyl_new] <- mtcars. The inputs not assigned by name are simply the
   elements of RHS in the order they occur, regardless of whether they have
   been used previously e.g. .[mpg_new, cyl_new = cyl, log_cyl = log(cyl),
   cyl_new2] <- mtcars is feasible. RHS here could be any named vector type.
   - Conventional use of the function as lazy version of of list(), as in
   data.table: .(A = B, C, D) is the same as list(A = B, C = C, D = D). This
   would also be useful, allowing more parsimonious code, and avoid the need
   to assign names to all return values in a function return, e.g. if I
   already have matrices A, C, Q and R as internal objects in my function, I
   can simply end by return(.(A, C, Q, R)) instead of return(list(A = A, C =
   C, Q = Q, R = R)) if I wanted the list to be named with the object names.

The implementation of this in R and C should be pretty straightforward. It
would just require a modification to R CMD Check to recognize .[<- as
assignment.

Best regards,

Sebastian
-
2.)

On Sun, 12 Mar 2023 at 09:42, Sebastian Martin Krantz <
sebastian.krantz at graduateinstitute.ch> wrote:

> Thanks Gabriel and Kevin for your inputs,
>
> regarding your points Gabriel, I think Python and Julia do allow multiple
> sub-assignment, but in-line with my earlier suggestion in response to
> Duncan to make multiple assignment an environment-level operation (like
> collapse::%=% currently works),  this would not be possible in R.
>
> Regarding the [a] <- coolest_function() syntax, yeah it would mean do
> multiple assignment and set a equal to the first element dropping all other
> elements. Multiple assignment should be positional loke in other languages,
> enabling flexible renaming of objects on the fly. So it should be
> irrelevant whether the function returns a named or unnamed list or vector.
>
> Thanks also Kevin for this contribution. I think it?s a remarkable effort,
> and I wouldn?t mind such semantics e.g. making it a function call to ?.[?
> or any other one-letter function, as long as it?s coded in C and recognized
> by the interpreter as an assignment operation.
>
> Best regards,
>
> Sebastian
>
>
>
>
>
> On Sun 12. Mar 2023 at 01:00, Kevin Ushey <kevinushey at gmail.com> wrote:
>
>> FWIW, it's possible to get fairly close to your proposed semantics
>> using the existing metaprogramming facilities in R. I put together a
>> prototype package here to demonstrate:
>>
>>     https://github.com/kevinushey/dotty
>>
>> The package exports an object called `.`, with a special `[<-.dot` S3
>> method which enables destructuring assignments. This means you can
>> write code like:
>>
>>     .[nr, nc] <- dim(mtcars)
>>
>> and that will define 'nr' and 'nc' as you expect.
>>
>> As for R CMD check warnings, you can suppress those through the use of
>> globalVariables(), and that can also be automated within the package.
>> The 'dotty' package includes a function 'dotify()' which automates
>> looking for such usages in your package, and calling globalVariables()
>> so that R CMD check doesn't warn. In theory, a similar technique would
>> be applicable to other packages defining similar operators (zeallot,
>> collapse).
>>
>> Obviously, globalVariables() is a very heavy hammer to swing for this
>> issue, but you might consider the benefits worth the tradeoffs.
>>
>> Best,
>> Kevin
>>
>> On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch <murdoch.duncan at gmail.com>
>> wrote:
>> >
>> > On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
>> > > Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can
>> > > follow all aspects you raised, but to give my limited take on a few:
>> > >
>> > >> your proposal violates a very basic property of the  language, i.e.
>> that all statements are expressions and have a value.  > What's the value
>> of 1 + (A, C = init_matrices()).
>> > >
>> > > I'm not sure I see the point here. I evaluated 1 + (d = dim(mtcars);
>> nr
>> > > = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error,
>> >
>> >
>> >    d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
>> >
>> > is not a statement, it is a sequence of 4 statements.
>> >
>> > Duncan Murdoch
>> >
>> >   as the
>> > > above expression should. `%=%` assigns to
>> > > environments, so 1 + (c("A", "C") %=% init_matrices()) returns
>> > > numeric(0), with A and C having their values assigned.
>> > >
>> > >> suppose f() returns list(A = 1, B = 2) and I do  > B, A <- f() >
>> Should assignment be by position or by name?
>> > >
>> > > In other languages this is by position. The feature is not meant to
>> > > replace list2env(), and being able to rename objects in the assignment
>> > > is a vital feature of codes
>> > > using multi input and output functions e.g. in Matlab or Julia.
>> > >
>> > >> Honestly, given that this is simply syntactic sugar, I don't think I
>> would support it.
>> > >
>> > > You can call it that, but it would be used by almost every R user
>> almost
>> > > every day. Simple things like nr, nc = dim(x); values, vectors =
>> > > eigen(x) etc. where the creation of intermediate objects
>> > > is cumbersome and redundant.
>> > >
>> > >> I see you've already mentioned it ("JavaScript-like"). I think it
>> would  fulfil Sebastian's requirements too, as long as it is considered
>> "true assignment" by the rest of the language.
>> > >
>> > > I don't have strong opinions about how the issue is phrased or
>> > > implemented. Something like [t, n] = dim(x) might even be more clear.
>> > > It's important though that assignment remains by position,
>> > > so even if some output gets thrown away that should also be
>> positional.
>> > >
>> > >>  A <- 0  > [A, B = A + 10] <- list(1, A = 2)
>> > >
>> > > I also fail to see the use of allowing this. something like this is an
>> > > error.
>> > >
>> > >> A = 2
>> > >> (B = A + 1) <- 1
>> > > Error in (B = A + 1) <- 1 : could not find function "(<-"
>> > >
>> > > Regarding the practical implementation, I think `collapse::%=%` is a
>> > > good starting point. It could be introduced in R as a separate
>> function,
>> > > or `=` could be modified to accommodate its capability. It should be
>> > > clear that
>> > > with more than one LHS variables the assignment is an environment
>> level
>> > > operation and the results can only be used in computations once
>> assigned
>> > > to the environment, e.g. as in 1 + (c("A", "C") %=% init_matrices()),
>> > > A and C are not available for the addition in this statement. The
>> > > interpretor then needs to be modified to read something like nr, nc =
>> > > dim(x) or [nr, nc] = dim(x). as an environment-level multiple
>> assignment
>> > > operation with no
>> > > immediate value. Appears very feasible to my limited understanding,
>> but
>> > > I guess there are other things to consider still. Definitely
>> appreciate
>> > > the responses so far though.
>> > >
>> > > Best regards,
>> > >
>> > > Sebastian
>> > >
>> > >
>> > >
>> > >
>> > >
>> > > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <
>> murdoch.duncan at gmail.com
>> > > <mailto:murdoch.duncan at gmail.com>> wrote:
>> > >
>> > >     On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
>> > >      > On Sat, 11 Mar 2023 11:11:06 -0500
>> > >      > Duncan Murdoch <murdoch.duncan at gmail.com
>> > >     <mailto:murdoch.duncan at gmail.com>> wrote:
>> > >      >
>> > >      >> That's clear, but your proposal violates a very basic property
>> > >     of the
>> > >      >> language, i.e. that all statements are expressions and have a
>> value.
>> > >      >
>> > >      > How about reframing this feature request from multiple
>> assignment
>> > >      > (which does go contrary to "everything has only one value, even
>> > >     if it's
>> > >      > sometimes invisible(NULL)") to "structured binding" /
>> "destructuring
>> > >      > assignment" [*], which takes this single single value returned
>> by the
>> > >      > expression and subsets it subject to certain rules? It may be
>> > >     easier to
>> > >      > make a decision on the semantics for destructuring assignment
>> (e.g.
>> > >      > languages which have this feature typically allow throwing
>> unneeded
>> > >      > parts of the return value away), and it doesn't seem to break
>> as much
>> > >      > of the rest of the language if implemented.
>> > >      >
>> > >      > I see you've already mentioned it ("JavaScript-like"). I think
>> it
>> > >     would
>> > >      > fulfil Sebastian's requirements too, as long as it is
>> considered
>> > >     "true
>> > >      > assignment" by the rest of the language.
>> > >      >
>> > >      > The hard part is to propose the actual grammar of the new
>> feature (in
>> > >      > terms of src/main/gram.y, preferably without introducing
>> > >     conflicts) and
>> > >      > its semantics (including the corner cases, some of which you
>> have
>> > >      > already mentioned). I'm not sure I'm up to the task.
>> > >      >
>> > >
>> > >     If I were doing it, here's what I'd propose:
>> > >
>> > >         '[' formlist ']' LEFT_ASSIGN expr
>> > >         '[' formlist ']' EQ_ASSIGN expr
>> > >         expr RIGHT_ASSIGN  '[' formlist ']'
>> > >
>> > >     where `formlist` has the syntax of the formals list for a function
>> > >     definition.  This would have the following semantics:
>> > >
>> > >          {
>> > >            *tmp* <- expr
>> > >
>> > >            # For arguments with no "default" expression,
>> > >
>> > >            argname1 <- *tmp*[[1]]
>> > >            argname2 <- *tmp*[[2]]
>> > >            ...
>> > >
>> > >            # For arguments with a default listed
>> > >
>> > >            argname3 <- with(*tmp*, default3)
>> > >          }
>> > >
>> > >
>> > >     The value of the whole thing would therefore be (invisibly) the
>> > >     value of
>> > >     the last item in the assignment.
>> > >
>> > >     Two examples:
>> > >
>> > >         [A, B, C] <- expr   # assign the first three elements of expr
>> to A,
>> > >     B, and C
>> > >
>> > >         [A, B, C = a + b] <- expr  # assign the first two elements of
>> expr
>> > >                                    # to A and B,
>> > >                                    # assign with(expr, a + b) to C.
>> > >
>> > >     Unfortunately, I don't think this could be done entirely by
>> > >     transforming
>> > >     the expression (which is the way |> was done), and that makes it
>> a lot
>> > >     harder to write and to reason about.  E.g. what does this do?
>> > >
>> > >         A <- 0
>> > >         [A, B = A + 10] <- list(1, A = 2)
>> > >
>> > >     According to the recipe above, I think it sets A to 1 and B to
>> 12, but
>> > >     maybe a user would expect B to be 10 or 11.  And according to that
>> > >     recipe this is an error:
>> > >
>> > >         [A, B = A + 10] <- c(1, A = 2)
>> > >
>> > >     which probably isn't what a user would expect, given that this is
>> fine:
>> > >
>> > >         [A, B] <- c(1, 2)
>> > >
>> > >     Duncan Murdoch
>> > >
>> >
>> > ______________________________________________
>> > R-devel at r-project.org mailing list
>> > https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>

	[[alternative HTML version deleted]]


From @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch  Sun Mar 12 13:05:53 2023
From: @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch (Sebastian Martin Krantz)
Date: Sun, 12 Mar 2023 14:05:53 +0200
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <05b0cf79-d768-7e6e-6dcf-502a14fcef84@gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
 <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>
 <CAOsNuxCLE9j1XiGwRevcAHu_EHYXaA=aBSREbb3SDUXWMiNHyg@mail.gmail.com>
 <05b0cf79-d768-7e6e-6dcf-502a14fcef84@gmail.com>
Message-ID: <CAOsNuxBtYEe9FkMK3QA8PKzar_JX2cVsO1bLNXoZb0GkBPjPQQ@mail.gmail.com>

Kevins package is very nice as a proof of concept, no doubt about that, but
it is not at the level of performance or convenience that a native R
implementation would offer. I would probably not use it to translate matlab
routines into R packages placed on CRAN, because it?s an additional
dependency, I have a performance burden in every iteration, and
utils::globalVariables() is everything but elegant. From that perspective
it would be more convenient for me right now to stick with collapse::%=%,
which is already written in C, and also call
utils::globalVariables().

But again my hope in starting this was that R Core might see that the
addition of multiple assignment would be a significant enhancement to the
language, of the same order as the base pipe |> in my opinion.

I think the discussion so far has at least brought forth a way to implement
this in a way that does not violate fundamental principles of the language.
Which could form a basis for thinking about an actual addition to the
language.

Best regards,

Sebastian


On Sun 12. Mar 2023 at 13:18, Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:

> On 12/03/2023 6:07 a.m., Sebastian Martin Krantz wrote:
> > Thinking more about this, and seeing Kevins examples at
> > https://github.com/kevinushey/dotty
> > <https://github.com/kevinushey/dotty>, I think this is the most R-like
> > way of doing it,
> > with an additional benefit as it would allow to introduce the useful
> > data.table semantics DT[, .(a = b, c, d)] to more general R. So I would
> > propose to
> > introduce a new primitive function . <- function(...) .Primitive(".") in
> > R with an assignment method and the following features:
>
> I think that proposal is very unlikely to be accepted.  If it was a
> primitive function, it could only be maintained by R Core.  They are
> justifiably very reluctant to take on extra work for themselves.
>
> Kevin's package demonstrates that this can be done entirely in a
> contributed package, which means there's no need for R Core to be
> involved.  I don't know if he has plans to turn his prototype into a
> CRAN package.  If he doesn't, then it will be up to some other
> interested maintainer to step up and take on the task, or it will just
> fade away.
>
> I haven't checked whether your proposals below represent changes from
> the current version of dotty, but if they do, the way to proceed is to
> fork that project, implement your changes, and offer to contribute them
> back to the main branch.
>
> Duncan Murdoch
>
>
>
> >
> >   * Positional assignment e.g. .[nr, nc] <- dim(x), and named assignment
> >     e.g. .[new = carb] <- mtcars or .[new = log(carb)] <- mtcars. All
> >     the functionality proposed by Kevin at
> >     https://github.com/kevinushey/dotty
> >     <https://github.com/kevinushey/dotty> is useful, unambiguous and
> >     feasible.
> >   * Silent dropping of RHS values e.g. .[mpg_new, cyl_new] <- mtcars.
> >   * Mixing of positional and named assignment e.g .[mpg_new, carb_new =
> >     carb, cyl_new] <- mtcars. The inputs not assigned by name are simply
> >     the elements of RHS in the order they occur, regardless of whether
> >     they have been used previously e.g. .[mpg_new, cyl_new = cyl,
> >     log_cyl = log(cyl), cyl_new2] <- mtcars is feasible. RHS here could
> >     be any named vector type.
> >   * Conventional use of the function as lazy version of of list(), as in
> >     data.table: .(A = B, C, D) is the same as list(A = B, C = C, D = D).
> >     This would also be useful, allowing more parsimonious code, and
> >     avoid the need to assign names to all return values in a function
> >     return, e.g. if I already have matrices A, C, Q and R as internal
> >     objects in my function, I can simply end by return(.(A, C, Q, R))
> >     instead of return(list(A = A, C = C, Q = Q, R = R)) if I wanted the
> >     list to be named with the object names.
> >
> > The implementation of this in R and C should be pretty straightforward.
> > It would just require a modification to R CMD Check to recognize .[<- as
> > assignment.
> >
> > Best regards,
> >
> > Sebastian
> > -
> > 2.)
> >
> > On Sun, 12 Mar 2023 at 09:42, Sebastian Martin Krantz
> > <sebastian.krantz at graduateinstitute.ch
> > <mailto:sebastian.krantz at graduateinstitute.ch>> wrote:
> >
> >     Thanks Gabriel and Kevin for your inputs,
> >
> >     regarding your points Gabriel, I think Python and Julia do allow
> >     multiple sub-assignment, but in-line with my earlier suggestion in
> >     response to Duncan to make multiple assignment an environment-level
> >     operation (like collapse::%=% currently works),  this would not be
> >     possible in R.
> >
> >     Regarding the [a] <- coolest_function() syntax, yeah it would mean
> >     do multiple assignment and set a equal to the first element dropping
> >     all other elements. Multiple assignment should be positional loke in
> >     other languages, enabling flexible renaming of objects on the fly.
> >     So it should be irrelevant whether the function returns a named or
> >     unnamed list or vector.
> >
> >     Thanks also Kevin for this contribution. I think it?s a remarkable
> >     effort, and I wouldn?t mind such semantics e.g. making it a function
> >     call to ?.[? or any other one-letter function, as long as it?s coded
> >     in C and recognized by the interpreter as an assignment operation.
> >
> >     Best regards,
> >
> >     Sebastian
> >
> >
> >
> >
> >
> >     On Sun 12. Mar 2023 at 01:00, Kevin Ushey <kevinushey at gmail.com
> >     <mailto:kevinushey at gmail.com>> wrote:
> >
> >         FWIW, it's possible to get fairly close to your proposed
> semantics
> >         using the existing metaprogramming facilities in R. I put
> together a
> >         prototype package here to demonstrate:
> >
> >         https://github.com/kevinushey/dotty
> >         <https://github.com/kevinushey/dotty>
> >
> >         The package exports an object called `.`, with a special
> >         `[<-.dot` S3
> >         method which enables destructuring assignments. This means you
> can
> >         write code like:
> >
> >              .[nr, nc] <- dim(mtcars)
> >
> >         and that will define 'nr' and 'nc' as you expect.
> >
> >         As for R CMD check warnings, you can suppress those through the
> >         use of
> >         globalVariables(), and that can also be automated within the
> >         package.
> >         The 'dotty' package includes a function 'dotify()' which
> automates
> >         looking for such usages in your package, and calling
> >         globalVariables()
> >         so that R CMD check doesn't warn. In theory, a similar technique
> >         would
> >         be applicable to other packages defining similar operators
> (zeallot,
> >         collapse).
> >
> >         Obviously, globalVariables() is a very heavy hammer to swing for
> >         this
> >         issue, but you might consider the benefits worth the tradeoffs.
> >
> >         Best,
> >         Kevin
> >
> >         On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch
> >         <murdoch.duncan at gmail.com <mailto:murdoch.duncan at gmail.com>>
> wrote:
> >          >
> >          > On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
> >          > > Thanks Duncan and Ivan for the careful thoughts. I'm not
> >         sure I can
> >          > > follow all aspects you raised, but to give my limited take
> >         on a few:
> >          > >
> >          > >> your proposal violates a very basic property of the
> >         language, i.e. that all statements are expressions and have a
> >         value.  > What's the value of 1 + (A, C = init_matrices()).
> >          > >
> >          > > I'm not sure I see the point here. I evaluated 1 + (d =
> >         dim(mtcars); nr
> >          > > = d[1]; nc = d[2]; rm(d)), which simply gives a syntax
> error,
> >          >
> >          >
> >          >    d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
> >          >
> >          > is not a statement, it is a sequence of 4 statements.
> >          >
> >          > Duncan Murdoch
> >          >
> >          >   as the
> >          > > above expression should. `%=%` assigns to
> >          > > environments, so 1 + (c("A", "C") %=% init_matrices())
> returns
> >          > > numeric(0), with A and C having their values assigned.
> >          > >
> >          > >> suppose f() returns list(A = 1, B = 2) and I do  > B, A <-
> >         f() > Should assignment be by position or by name?
> >          > >
> >          > > In other languages this is by position. The feature is not
> >         meant to
> >          > > replace list2env(), and being able to rename objects in the
> >         assignment
> >          > > is a vital feature of codes
> >          > > using multi input and output functions e.g. in Matlab or
> Julia.
> >          > >
> >          > >> Honestly, given that this is simply syntactic sugar, I
> >         don't think I would support it.
> >          > >
> >          > > You can call it that, but it would be used by almost every
> >         R user almost
> >          > > every day. Simple things like nr, nc = dim(x); values,
> >         vectors =
> >          > > eigen(x) etc. where the creation of intermediate objects
> >          > > is cumbersome and redundant.
> >          > >
> >          > >> I see you've already mentioned it ("JavaScript-like"). I
> >         think it would  fulfil Sebastian's requirements too, as long as
> >         it is considered "true assignment" by the rest of the language.
> >          > >
> >          > > I don't have strong opinions about how the issue is phrased
> or
> >          > > implemented. Something like [t, n] = dim(x) might even be
> >         more clear.
> >          > > It's important though that assignment remains by position,
> >          > > so even if some output gets thrown away that should also be
> >         positional.
> >          > >
> >          > >>  A <- 0  > [A, B = A + 10] <- list(1, A = 2)
> >          > >
> >          > > I also fail to see the use of allowing this. something like
> >         this is an
> >          > > error.
> >          > >
> >          > >> A = 2
> >          > >> (B = A + 1) <- 1
> >          > > Error in (B = A + 1) <- 1 : could not find function "(<-"
> >          > >
> >          > > Regarding the practical implementation, I think
> >         `collapse::%=%` is a
> >          > > good starting point. It could be introduced in R as a
> >         separate function,
> >          > > or `=` could be modified to accommodate its capability. It
> >         should be
> >          > > clear that
> >          > > with more than one LHS variables the assignment is an
> >         environment level
> >          > > operation and the results can only be used in computations
> >         once assigned
> >          > > to the environment, e.g. as in 1 + (c("A", "C") %=%
> >         init_matrices()),
> >          > > A and C are not available for the addition in this
> >         statement. The
> >          > > interpretor then needs to be modified to read something
> >         like nr, nc =
> >          > > dim(x) or [nr, nc] = dim(x). as an environment-level
> >         multiple assignment
> >          > > operation with no
> >          > > immediate value. Appears very feasible to my limited
> >         understanding, but
> >          > > I guess there are other things to consider still.
> >         Definitely appreciate
> >          > > the responses so far though.
> >          > >
> >          > > Best regards,
> >          > >
> >          > > Sebastian
> >          > >
> >          > >
> >          > >
> >          > >
> >          > >
> >          > > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch
> >         <murdoch.duncan at gmail.com <mailto:murdoch.duncan at gmail.com>
> >          > > <mailto:murdoch.duncan at gmail.com
> >         <mailto:murdoch.duncan at gmail.com>>> wrote:
> >          > >
> >          > >     On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> >          > >      > On Sat, 11 Mar 2023 11:11:06 -0500
> >          > >      > Duncan Murdoch <murdoch.duncan at gmail.com
> >         <mailto:murdoch.duncan at gmail.com>
> >          > >     <mailto:murdoch.duncan at gmail.com
> >         <mailto:murdoch.duncan at gmail.com>>> wrote:
> >          > >      >
> >          > >      >> That's clear, but your proposal violates a very
> >         basic property
> >          > >     of the
> >          > >      >> language, i.e. that all statements are expressions
> >         and have a value.
> >          > >      >
> >          > >      > How about reframing this feature request from
> >         multiple assignment
> >          > >      > (which does go contrary to "everything has only one
> >         value, even
> >          > >     if it's
> >          > >      > sometimes invisible(NULL)") to "structured binding"
> >         / "destructuring
> >          > >      > assignment" [*], which takes this single single
> >         value returned by the
> >          > >      > expression and subsets it subject to certain rules?
> >         It may be
> >          > >     easier to
> >          > >      > make a decision on the semantics for destructuring
> >         assignment (e.g.
> >          > >      > languages which have this feature typically allow
> >         throwing unneeded
> >          > >      > parts of the return value away), and it doesn't seem
> >         to break as much
> >          > >      > of the rest of the language if implemented.
> >          > >      >
> >          > >      > I see you've already mentioned it
> >         ("JavaScript-like"). I think it
> >          > >     would
> >          > >      > fulfil Sebastian's requirements too, as long as it
> >         is considered
> >          > >     "true
> >          > >      > assignment" by the rest of the language.
> >          > >      >
> >          > >      > The hard part is to propose the actual grammar of
> >         the new feature (in
> >          > >      > terms of src/main/gram.y, preferably without
> introducing
> >          > >     conflicts) and
> >          > >      > its semantics (including the corner cases, some of
> >         which you have
> >          > >      > already mentioned). I'm not sure I'm up to the task.
> >          > >      >
> >          > >
> >          > >     If I were doing it, here's what I'd propose:
> >          > >
> >          > >         '[' formlist ']' LEFT_ASSIGN expr
> >          > >         '[' formlist ']' EQ_ASSIGN expr
> >          > >         expr RIGHT_ASSIGN  '[' formlist ']'
> >          > >
> >          > >     where `formlist` has the syntax of the formals list for
> >         a function
> >          > >     definition.  This would have the following semantics:
> >          > >
> >          > >          {
> >          > >            *tmp* <- expr
> >          > >
> >          > >            # For arguments with no "default" expression,
> >          > >
> >          > >            argname1 <- *tmp*[[1]]
> >          > >            argname2 <- *tmp*[[2]]
> >          > >            ...
> >          > >
> >          > >            # For arguments with a default listed
> >          > >
> >          > >            argname3 <- with(*tmp*, default3)
> >          > >          }
> >          > >
> >          > >
> >          > >     The value of the whole thing would therefore be
> >         (invisibly) the
> >          > >     value of
> >          > >     the last item in the assignment.
> >          > >
> >          > >     Two examples:
> >          > >
> >          > >         [A, B, C] <- expr   # assign the first three
> >         elements of expr to A,
> >          > >     B, and C
> >          > >
> >          > >         [A, B, C = a + b] <- expr  # assign the first two
> >         elements of expr
> >          > >                                    # to A and B,
> >          > >                                    # assign with(expr, a +
> >         b) to C.
> >          > >
> >          > >     Unfortunately, I don't think this could be done
> entirely by
> >          > >     transforming
> >          > >     the expression (which is the way |> was done), and that
> >         makes it a lot
> >          > >     harder to write and to reason about.  E.g. what does
> >         this do?
> >          > >
> >          > >         A <- 0
> >          > >         [A, B = A + 10] <- list(1, A = 2)
> >          > >
> >          > >     According to the recipe above, I think it sets A to 1
> >         and B to 12, but
> >          > >     maybe a user would expect B to be 10 or 11.  And
> >         according to that
> >          > >     recipe this is an error:
> >          > >
> >          > >         [A, B = A + 10] <- c(1, A = 2)
> >          > >
> >          > >     which probably isn't what a user would expect, given
> >         that this is fine:
> >          > >
> >          > >         [A, B] <- c(1, 2)
> >          > >
> >          > >     Duncan Murdoch
> >          > >
> >          >
> >          > ______________________________________________
> >          > R-devel at r-project.org <mailto:R-devel at r-project.org> mailing
> list
> >          > https://stat.ethz.ch/mailman/listinfo/r-devel
> >         <https://stat.ethz.ch/mailman/listinfo/r-devel>
> >
>
>

	[[alternative HTML version deleted]]


From p@kr|v|t@ky @end|ng |rom un@w@edu@@u  Mon Mar 13 03:36:59 2023
From: p@kr|v|t@ky @end|ng |rom un@w@edu@@u (Pavel Krivitsky)
Date: Mon, 13 Mar 2023 02:36:59 +0000
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxBtYEe9FkMK3QA8PKzar_JX2cVsO1bLNXoZb0GkBPjPQQ@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
 <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>
 <CAOsNuxCLE9j1XiGwRevcAHu_EHYXaA=aBSREbb3SDUXWMiNHyg@mail.gmail.com>
 <05b0cf79-d768-7e6e-6dcf-502a14fcef84@gmail.com>
 <CAOsNuxBtYEe9FkMK3QA8PKzar_JX2cVsO1bLNXoZb0GkBPjPQQ@mail.gmail.com>
Message-ID: <7aedf95ecb2a98531140764db3035449c7bd1147.camel@unsw.edu.au>

Dear All,

As a maintainer of large, complex packages, I can think of many places
in which deconstructing assignment would simplify the code, as well as
facilitate readability by breaking up larger functions into helpers, so
I would be very glad to see this incorporated somehow.

I think the crux of the matter is that while there is a number of ways
to implement deconstructing assignment within R, there is no mechanism
to tell R CMD check about it without also suppressing checks for every
other instance of that variable name. This is particularly problematic
because those variable names are likely to be used elsewhere in the
package.

Workarounds that have been suggested all defeat the conciseness and
clarity of the deconstructing assignment and introduce potential for
subtle bugs.

The check warnings are something that can only be addressed in
'codetools', with a finer API than what utils::globalVariables()
provides.?Perhaps this would have a lower hurdle than modifying R
language itself?

From skimming through the relevant 'codetools' code, one idea for such
an API would be a function, along the lines of

utils::alternativeAssignment(op, assigned)

that sets up a callback assigned = function(op, e) that given the
operator (as string) and the expression it's embedded in, returns a
list of three elements:
 * a character vector containing a list of variables assigned to that
   might not otherwise be detected
 * a character vector containing a list of variables referenced that
   might not otherwise be detected
 * expression e with potentially "offending" elements removed, which
   will then be processed by the rest of the checking code

Then, say, 'zeallot' could implement zeallot::zeallot_assign_detect(),
and a package developer using it could put

utils::alternativeAssignment("%<-%", zeallot::zeallot_assign_detect)

in their .onLoad() function. Similarly, users of 'dotty' could set up
callbacks for all standard assignment operators to inform the code
about the nonstandard assignment.

Best Regards,Pavel

On Sun, 2023-03-12 at 14:05 +0200, Sebastian Martin Krantz wrote:
> Kevins package is very nice as a proof of concept, no doubt about
> that, but
> it is not at the level of performance or convenience that a native R
> implementation would offer. I would probably not use it to translate
> matlab
> routines into R packages placed on CRAN, because it?s an additional
> dependency, I have a performance burden in every iteration, and
> utils::globalVariables() is everything but elegant. From that
> perspective
> it would be more convenient for me right now to stick with
> collapse::%=%,
> which is already written in C, and also call
> utils::globalVariables().
> 
> But again my hope in starting this was that R Core might see that the
> addition of multiple assignment would be a significant enhancement to
> the
> language, of the same order as the base pipe |> in my opinion.
> 
> I think the discussion so far has at least brought forth a way to
> implement
> this in a way that does not violate fundamental principles of the
> language.
> Which could form a basis for thinking about an actual addition to the
> language.
> 
> Best regards,
> 
> Sebastian
> 
> 
> On Sun 12. Mar 2023 at 13:18, Duncan Murdoch
> <murdoch.duncan at gmail.com>
> wrote:
> 
> > On 12/03/2023 6:07 a.m., Sebastian Martin Krantz wrote:
> > > Thinking more about this, and seeing Kevins examples at
> > > https://github.com/kevinushey/dotty
> > > <https://github.com/kevinushey/dotty>, I think this is the most
> > > R-like
> > > way of doing it,
> > > with an additional benefit as it would allow to introduce the
> > > useful
> > > data.table semantics DT[, .(a = b, c, d)] to more general R. So I
> > > would
> > > propose to
> > > introduce a new primitive function . <- function(...)
> > > .Primitive(".") in
> > > R with an assignment method and the following features:
> > 
> > I think that proposal is very unlikely to be accepted.? If it was a
> > primitive function, it could only be maintained by R Core.? They
> > are
> > justifiably very reluctant to take on extra work for themselves.
> > 
> > Kevin's package demonstrates that this can be done entirely in a
> > contributed package, which means there's no need for R Core to be
> > involved.? I don't know if he has plans to turn his prototype into
> > a
> > CRAN package.? If he doesn't, then it will be up to some other
> > interested maintainer to step up and take on the task, or it will
> > just
> > fade away.
> > 
> > I haven't checked whether your proposals below represent changes
> > from
> > the current version of dotty, but if they do, the way to proceed is
> > to
> > fork that project, implement your changes, and offer to contribute
> > them
> > back to the main branch.
> > 
> > Duncan Murdoch
> > 
> > 
> > 
> > > 
> > > ? * Positional assignment e.g. .[nr, nc] <- dim(x), and named
> > > assignment
> > > ??? e.g. .[new = carb] <- mtcars or .[new = log(carb)] <- mtcars.
> > > All
> > > ??? the functionality proposed by Kevin at
> > > ??? https://github.com/kevinushey/dotty
> > > ??? <https://github.com/kevinushey/dotty> is useful, unambiguous
> > > and
> > > ??? feasible.
> > > ? * Silent dropping of RHS values e.g. .[mpg_new, cyl_new] <-
> > > mtcars.
> > > ? * Mixing of positional and named assignment e.g .[mpg_new,
> > > carb_new =
> > > ??? carb, cyl_new] <- mtcars. The inputs not assigned by name are
> > > simply
> > > ??? the elements of RHS in the order they occur, regardless of
> > > whether
> > > ??? they have been used previously e.g. .[mpg_new, cyl_new = cyl,
> > > ??? log_cyl = log(cyl), cyl_new2] <- mtcars is feasible. RHS here
> > > could
> > > ??? be any named vector type.
> > > ? * Conventional use of the function as lazy version of of
> > > list(), as in
> > > ??? data.table: .(A = B, C, D) is the same as list(A = B, C = C,
> > > D = D).
> > > ??? This would also be useful, allowing more parsimonious code,
> > > and
> > > ??? avoid the need to assign names to all return values in a
> > > function
> > > ??? return, e.g. if I already have matrices A, C, Q and R as
> > > internal
> > > ??? objects in my function, I can simply end by return(.(A, C, Q,
> > > R))
> > > ??? instead of return(list(A = A, C = C, Q = Q, R = R)) if I
> > > wanted the
> > > ??? list to be named with the object names.
> > > 
> > > The implementation of this in R and C should be pretty
> > > straightforward.
> > > It would just require a modification to R CMD Check to recognize
> > > .[<- as
> > > assignment.
> > > 
> > > Best regards,
> > > 
> > > Sebastian
> > > -
> > > 2.)
> > > 
> > > On Sun, 12 Mar 2023 at 09:42, Sebastian Martin Krantz
> > > <sebastian.krantz at graduateinstitute.ch
> > > <mailto:sebastian.krantz at graduateinstitute.ch>> wrote:
> > > 
> > > ??? Thanks Gabriel and Kevin for your inputs,
> > > 
> > > ??? regarding your points Gabriel, I think Python and Julia do
> > > allow
> > > ??? multiple sub-assignment, but in-line with my earlier
> > > suggestion in
> > > ??? response to Duncan to make multiple assignment an
> > > environment-level
> > > ??? operation (like collapse::%=% currently works),? this would
> > > not be
> > > ??? possible in R.
> > > 
> > > ??? Regarding the [a] <- coolest_function() syntax, yeah it would
> > > mean
> > > ??? do multiple assignment and set a equal to the first element
> > > dropping
> > > ??? all other elements. Multiple assignment should be positional
> > > loke in
> > > ??? other languages, enabling flexible renaming of objects on the
> > > fly.
> > > ??? So it should be irrelevant whether the function returns a
> > > named or
> > > ??? unnamed list or vector.
> > > 
> > > ??? Thanks also Kevin for this contribution. I think it?s a
> > > remarkable
> > > ??? effort, and I wouldn?t mind such semantics e.g. making it a
> > > function
> > > ??? call to ?.[? or any other one-letter function, as long as
> > > it?s coded
> > > ??? in C and recognized by the interpreter as an assignment
> > > operation.
> > > 
> > > ??? Best regards,
> > > 
> > > ??? Sebastian
> > > 
> > > 
> > > 
> > > 
> > > 
> > > ??? On Sun 12. Mar 2023 at 01:00, Kevin Ushey
> > > <kevinushey at gmail.com
> > > ??? <mailto:kevinushey at gmail.com>> wrote:
> > > 
> > > ??????? FWIW, it's possible to get fairly close to your proposed
> > semantics
> > > ??????? using the existing metaprogramming facilities in R. I put
> > together a
> > > ??????? prototype package here to demonstrate:
> > > 
> > > ??????? https://github.com/kevinushey/dotty
> > > ??????? <https://github.com/kevinushey/dotty>
> > > 
> > > ??????? The package exports an object called `.`, with a special
> > > ??????? `[<-.dot` S3
> > > ??????? method which enables destructuring assignments. This
> > > means you
> > can
> > > ??????? write code like:
> > > 
> > > ???????????? .[nr, nc] <- dim(mtcars)
> > > 
> > > ??????? and that will define 'nr' and 'nc' as you expect.
> > > 
> > > ??????? As for R CMD check warnings, you can suppress those
> > > through the
> > > ??????? use of
> > > ??????? globalVariables(), and that can also be automated within
> > > the
> > > ??????? package.
> > > ??????? The 'dotty' package includes a function 'dotify()' which
> > automates
> > > ??????? looking for such usages in your package, and calling
> > > ??????? globalVariables()
> > > ??????? so that R CMD check doesn't warn. In theory, a similar
> > > technique
> > > ??????? would
> > > ??????? be applicable to other packages defining similar
> > > operators
> > (zeallot,
> > > ??????? collapse).
> > > 
> > > ??????? Obviously, globalVariables() is a very heavy hammer to
> > > swing for
> > > ??????? this
> > > ??????? issue, but you might consider the benefits worth the
> > > tradeoffs.
> > > 
> > > ??????? Best,
> > > ??????? Kevin
> > > 
> > > ??????? On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch
> > > ???????
> > > <murdoch.duncan at gmail.com?<mailto:murdoch.duncan at gmail.com>>
> > wrote:
> > > ???????? >
> > > ???????? > On 11/03/2023 4:42 p.m., Sebastian Martin Krantz
> > > wrote:
> > > ???????? > > Thanks Duncan and Ivan for the careful thoughts. I'm
> > > not
> > > ??????? sure I can
> > > ???????? > > follow all aspects you raised, but to give my
> > > limited take
> > > ??????? on a few:
> > > ???????? > >
> > > ???????? > >> your proposal violates a very basic property of the
> > > ??????? language, i.e. that all statements are expressions and
> > > have a
> > > ??????? value.? > What's the value of 1 + (A, C =
> > > init_matrices()).
> > > ???????? > >
> > > ???????? > > I'm not sure I see the point here. I evaluated 1 +
> > > (d =
> > > ??????? dim(mtcars); nr
> > > ???????? > > = d[1]; nc = d[2]; rm(d)), which simply gives a
> > > syntax
> > error,
> > > ???????? >
> > > ???????? >
> > > ???????? >??? d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
> > > ???????? >
> > > ???????? > is not a statement, it is a sequence of 4 statements.
> > > ???????? >
> > > ???????? > Duncan Murdoch
> > > ???????? >
> > > ???????? >?? as the
> > > ???????? > > above expression should. `%=%` assigns to
> > > ???????? > > environments, so 1 + (c("A", "C") %=%
> > > init_matrices())
> > returns
> > > ???????? > > numeric(0), with A and C having their values
> > > assigned.
> > > ???????? > >
> > > ???????? > >> suppose f() returns list(A = 1, B = 2) and I do? >
> > > B, A <-
> > > ??????? f() > Should assignment be by position or by name?
> > > ???????? > >
> > > ???????? > > In other languages this is by position. The feature
> > > is not
> > > ??????? meant to
> > > ???????? > > replace list2env(), and being able to rename objects
> > > in the
> > > ??????? assignment
> > > ???????? > > is a vital feature of codes
> > > ???????? > > using multi input and output functions e.g. in
> > > Matlab or
> > Julia.
> > > ???????? > >
> > > ???????? > >> Honestly, given that this is simply syntactic
> > > sugar, I
> > > ??????? don't think I would support it.
> > > ???????? > >
> > > ???????? > > You can call it that, but it would be used by almost
> > > every
> > > ??????? R user almost
> > > ???????? > > every day. Simple things like nr, nc = dim(x);
> > > values,
> > > ??????? vectors =
> > > ???????? > > eigen(x) etc. where the creation of intermediate
> > > objects
> > > ???????? > > is cumbersome and redundant.
> > > ???????? > >
> > > ???????? > >> I see you've already mentioned it ("JavaScript-
> > > like"). I
> > > ??????? think it would? fulfil Sebastian's requirements too, as
> > > long as
> > > ??????? it is considered "true assignment" by the rest of the
> > > language.
> > > ???????? > >
> > > ???????? > > I don't have strong opinions about how the issue is
> > > phrased
> > or
> > > ???????? > > implemented. Something like [t, n] = dim(x) might
> > > even be
> > > ??????? more clear.
> > > ???????? > > It's important though that assignment remains by
> > > position,
> > > ???????? > > so even if some output gets thrown away that should
> > > also be
> > > ??????? positional.
> > > ???????? > >
> > > ???????? > >>? A <- 0? > [A, B = A + 10] <- list(1, A = 2)
> > > ???????? > >
> > > ???????? > > I also fail to see the use of allowing this.
> > > something like
> > > ??????? this is an
> > > ???????? > > error.
> > > ???????? > >
> > > ???????? > >> A = 2
> > > ???????? > >> (B = A + 1) <- 1
> > > ???????? > > Error in (B = A + 1) <- 1 : could not find function
> > > "(<-"
> > > ???????? > >
> > > ???????? > > Regarding the practical implementation, I think
> > > ??????? `collapse::%=%` is a
> > > ???????? > > good starting point. It could be introduced in R as
> > > a
> > > ??????? separate function,
> > > ???????? > > or `=` could be modified to accommodate its
> > > capability. It
> > > ??????? should be
> > > ???????? > > clear that
> > > ???????? > > with more than one LHS variables the assignment is
> > > an
> > > ??????? environment level
> > > ???????? > > operation and the results can only be used in
> > > computations
> > > ??????? once assigned
> > > ???????? > > to the environment, e.g. as in 1 + (c("A", "C") %=%
> > > ??????? init_matrices()),
> > > ???????? > > A and C are not available for the addition in this
> > > ??????? statement. The
> > > ???????? > > interpretor then needs to be modified to read
> > > something
> > > ??????? like nr, nc =
> > > ???????? > > dim(x) or [nr, nc] = dim(x). as an environment-level
> > > ??????? multiple assignment
> > > ???????? > > operation with no
> > > ???????? > > immediate value. Appears very feasible to my limited
> > > ??????? understanding, but
> > > ???????? > > I guess there are other things to consider still.
> > > ??????? Definitely appreciate
> > > ???????? > > the responses so far though.
> > > ???????? > >
> > > ???????? > > Best regards,
> > > ???????? > >
> > > ???????? > > Sebastian
> > > ???????? > >
> > > ???????? > >
> > > ???????? > >
> > > ???????? > >
> > > ???????? > >
> > > ???????? > > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch
> > > ???????
> > > <murdoch.duncan at gmail.com?<mailto:murdoch.duncan at gmail.com>
> > > ???????? > > <mailto:murdoch.duncan at gmail.com
> > > ??????? <mailto:murdoch.duncan at gmail.com>>> wrote:
> > > ???????? > >
> > > ???????? > >???? On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> > > ???????? > >????? > On Sat, 11 Mar 2023 11:11:06 -0500
> > > ???????? > >????? > Duncan Murdoch <murdoch.duncan at gmail.com
> > > ??????? <mailto:murdoch.duncan at gmail.com>
> > > ???????? > >???? <mailto:murdoch.duncan at gmail.com
> > > ??????? <mailto:murdoch.duncan at gmail.com>>> wrote:
> > > ???????? > >????? >
> > > ???????? > >????? >> That's clear, but your proposal violates a
> > > very
> > > ??????? basic property
> > > ???????? > >???? of the
> > > ???????? > >????? >> language, i.e. that all statements are
> > > expressions
> > > ??????? and have a value.
> > > ???????? > >????? >
> > > ???????? > >????? > How about reframing this feature request from
> > > ??????? multiple assignment
> > > ???????? > >????? > (which does go contrary to "everything has
> > > only one
> > > ??????? value, even
> > > ???????? > >???? if it's
> > > ???????? > >????? > sometimes invisible(NULL)") to "structured
> > > binding"
> > > ??????? / "destructuring
> > > ???????? > >????? > assignment" [*], which takes this single
> > > single
> > > ??????? value returned by the
> > > ???????? > >????? > expression and subsets it subject to certain
> > > rules?
> > > ??????? It may be
> > > ???????? > >???? easier to
> > > ???????? > >????? > make a decision on the semantics for
> > > destructuring
> > > ??????? assignment (e.g.
> > > ???????? > >????? > languages which have this feature typically
> > > allow
> > > ??????? throwing unneeded
> > > ???????? > >????? > parts of the return value away), and it
> > > doesn't seem
> > > ??????? to break as much
> > > ???????? > >????? > of the rest of the language if implemented.
> > > ???????? > >????? >
> > > ???????? > >????? > I see you've already mentioned it
> > > ??????? ("JavaScript-like"). I think it
> > > ???????? > >???? would
> > > ???????? > >????? > fulfil Sebastian's requirements too, as long
> > > as it
> > > ??????? is considered
> > > ???????? > >???? "true
> > > ???????? > >????? > assignment" by the rest of the language.
> > > ???????? > >????? >
> > > ???????? > >????? > The hard part is to propose the actual
> > > grammar of
> > > ??????? the new feature (in
> > > ???????? > >????? > terms of src/main/gram.y, preferably without
> > introducing
> > > ???????? > >???? conflicts) and
> > > ???????? > >????? > its semantics (including the corner cases,
> > > some of
> > > ??????? which you have
> > > ???????? > >????? > already mentioned). I'm not sure I'm up to
> > > the task.
> > > ???????? > >????? >
> > > ???????? > >
> > > ???????? > >???? If I were doing it, here's what I'd propose:
> > > ???????? > >
> > > ???????? > >???????? '[' formlist ']' LEFT_ASSIGN expr
> > > ???????? > >???????? '[' formlist ']' EQ_ASSIGN expr
> > > ???????? > >???????? expr RIGHT_ASSIGN? '[' formlist ']'
> > > ???????? > >
> > > ???????? > >???? where `formlist` has the syntax of the formals
> > > list for
> > > ??????? a function
> > > ???????? > >???? definition.? This would have the following
> > > semantics:
> > > ???????? > >
> > > ???????? > >????????? {
> > > ???????? > >??????????? *tmp* <- expr
> > > ???????? > >
> > > ???????? > >??????????? # For arguments with no "default"
> > > expression,
> > > ???????? > >
> > > ???????? > >??????????? argname1 <- *tmp*[[1]]
> > > ???????? > >??????????? argname2 <- *tmp*[[2]]
> > > ???????? > >??????????? ...
> > > ???????? > >
> > > ???????? > >??????????? # For arguments with a default listed
> > > ???????? > >
> > > ???????? > >??????????? argname3 <- with(*tmp*, default3)
> > > ???????? > >????????? }
> > > ???????? > >
> > > ???????? > >
> > > ???????? > >???? The value of the whole thing would therefore be
> > > ??????? (invisibly) the
> > > ???????? > >???? value of
> > > ???????? > >???? the last item in the assignment.
> > > ???????? > >
> > > ???????? > >???? Two examples:
> > > ???????? > >
> > > ???????? > >???????? [A, B, C] <- expr?? # assign the first three
> > > ??????? elements of expr to A,
> > > ???????? > >???? B, and C
> > > ???????? > >
> > > ???????? > >???????? [A, B, C = a + b] <- expr? # assign the
> > > first two
> > > ??????? elements of expr
> > > ???????? > >??????????????????????????????????? # to A and B,
> > > ???????? > >??????????????????????????????????? # assign
> > > with(expr, a +
> > > ??????? b) to C.
> > > ???????? > >
> > > ???????? > >???? Unfortunately, I don't think this could be done
> > entirely by
> > > ???????? > >???? transforming
> > > ???????? > >???? the expression (which is the way |> was done),
> > > and that
> > > ??????? makes it a lot
> > > ???????? > >???? harder to write and to reason about.? E.g. what
> > > does
> > > ??????? this do?
> > > ???????? > >
> > > ???????? > >???????? A <- 0
> > > ???????? > >???????? [A, B = A + 10] <- list(1, A = 2)
> > > ???????? > >
> > > ???????? > >???? According to the recipe above, I think it sets A
> > > to 1
> > > ??????? and B to 12, but
> > > ???????? > >???? maybe a user would expect B to be 10 or 11.? And
> > > ??????? according to that
> > > ???????? > >???? recipe this is an error:
> > > ???????? > >
> > > ???????? > >???????? [A, B = A + 10] <- c(1, A = 2)
> > > ???????? > >
> > > ???????? > >???? which probably isn't what a user would expect,
> > > given
> > > ??????? that this is fine:
> > > ???????? > >
> > > ???????? > >???????? [A, B] <- c(1, 2)
> > > ???????? > >
> > > ???????? > >???? Duncan Murdoch
> > > ???????? > >
> > > ???????? >
> > > ???????? > ______________________________________________
> > > ???????? > R-devel at r-project.org?<mailto:R-devel at r-project.org>
> > > mailing
> > list
> > > ???????? > https://stat.ethz.ch/mailman/listinfo/r-devel
> > > ??????? <https://stat.ethz.ch/mailman/listinfo/r-devel>
> > > 
> > 
> > 
> 
> ????????[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org?mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Mon Mar 13 11:01:07 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Mon, 13 Mar 2023 06:01:07 -0400
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <7aedf95ecb2a98531140764db3035449c7bd1147.camel@unsw.edu.au>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
 <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>
 <CAOsNuxCLE9j1XiGwRevcAHu_EHYXaA=aBSREbb3SDUXWMiNHyg@mail.gmail.com>
 <05b0cf79-d768-7e6e-6dcf-502a14fcef84@gmail.com>
 <CAOsNuxBtYEe9FkMK3QA8PKzar_JX2cVsO1bLNXoZb0GkBPjPQQ@mail.gmail.com>
 <7aedf95ecb2a98531140764db3035449c7bd1147.camel@unsw.edu.au>
Message-ID: <db71f2b8-d7ef-aad5-0369-79bc21fe4213@gmail.com>

Yes, this is really a problem with the checks, not with the language.

A simpler approach than your alternativeAssignment function would be 
simply to allow globalVariables() to be limited to a single function as 
the note in its help page says.

This might be tedious to write by hand, but could be automated using 
methods like "dotify" in dotty.

Duncan Murdoch


On 12/03/2023 10:36 p.m., Pavel Krivitsky wrote:
> Dear All,
> 
> As a maintainer of large, complex packages, I can think of many places
> in which deconstructing assignment would simplify the code, as well as
> facilitate readability by breaking up larger functions into helpers, so
> I would be very glad to see this incorporated somehow.
> 
> I think the crux of the matter is that while there is a number of ways
> to implement deconstructing assignment within R, there is no mechanism
> to tell R CMD check about it without also suppressing checks for every
> other instance of that variable name. This is particularly problematic
> because those variable names are likely to be used elsewhere in the
> package.
> 
> Workarounds that have been suggested all defeat the conciseness and
> clarity of the deconstructing assignment and introduce potential for
> subtle bugs.
> 
> The check warnings are something that can only be addressed in
> 'codetools', with a finer API than what utils::globalVariables()
> provides.?Perhaps this would have a lower hurdle than modifying R
> language itself?
> 
>  From skimming through the relevant 'codetools' code, one idea for such
> an API would be a function, along the lines of
> 
> utils::alternativeAssignment(op, assigned)
> 
> that sets up a callback assigned = function(op, e) that given the
> operator (as string) and the expression it's embedded in, returns a
> list of three elements:
>   * a character vector containing a list of variables assigned to that
>     might not otherwise be detected
>   * a character vector containing a list of variables referenced that
>     might not otherwise be detected
>   * expression e with potentially "offending" elements removed, which
>     will then be processed by the rest of the checking code
> 
> Then, say, 'zeallot' could implement zeallot::zeallot_assign_detect(),
> and a package developer using it could put
> 
> utils::alternativeAssignment("%<-%", zeallot::zeallot_assign_detect)
> 
> in their .onLoad() function. Similarly, users of 'dotty' could set up
> callbacks for all standard assignment operators to inform the code
> about the nonstandard assignment.
> 
> Best Regards,Pavel
> 
> On Sun, 2023-03-12 at 14:05 +0200, Sebastian Martin Krantz wrote:
>> Kevins package is very nice as a proof of concept, no doubt about
>> that, but
>> it is not at the level of performance or convenience that a native R
>> implementation would offer. I would probably not use it to translate
>> matlab
>> routines into R packages placed on CRAN, because it?s an additional
>> dependency, I have a performance burden in every iteration, and
>> utils::globalVariables() is everything but elegant. From that
>> perspective
>> it would be more convenient for me right now to stick with
>> collapse::%=%,
>> which is already written in C, and also call
>> utils::globalVariables().
>>
>> But again my hope in starting this was that R Core might see that the
>> addition of multiple assignment would be a significant enhancement to
>> the
>> language, of the same order as the base pipe |> in my opinion.
>>
>> I think the discussion so far has at least brought forth a way to
>> implement
>> this in a way that does not violate fundamental principles of the
>> language.
>> Which could form a basis for thinking about an actual addition to the
>> language.
>>
>> Best regards,
>>
>> Sebastian
>>
>>
>> On Sun 12. Mar 2023 at 13:18, Duncan Murdoch
>> <murdoch.duncan at gmail.com>
>> wrote:
>>
>>> On 12/03/2023 6:07 a.m., Sebastian Martin Krantz wrote:
>>>> Thinking more about this, and seeing Kevins examples at
>>>> https://github.com/kevinushey/dotty
>>>> <https://github.com/kevinushey/dotty>, I think this is the most
>>>> R-like
>>>> way of doing it,
>>>> with an additional benefit as it would allow to introduce the
>>>> useful
>>>> data.table semantics DT[, .(a = b, c, d)] to more general R. So I
>>>> would
>>>> propose to
>>>> introduce a new primitive function . <- function(...)
>>>> .Primitive(".") in
>>>> R with an assignment method and the following features:
>>>
>>> I think that proposal is very unlikely to be accepted.? If it was a
>>> primitive function, it could only be maintained by R Core.? They
>>> are
>>> justifiably very reluctant to take on extra work for themselves.
>>>
>>> Kevin's package demonstrates that this can be done entirely in a
>>> contributed package, which means there's no need for R Core to be
>>> involved.? I don't know if he has plans to turn his prototype into
>>> a
>>> CRAN package.? If he doesn't, then it will be up to some other
>>> interested maintainer to step up and take on the task, or it will
>>> just
>>> fade away.
>>>
>>> I haven't checked whether your proposals below represent changes
>>> from
>>> the current version of dotty, but if they do, the way to proceed is
>>> to
>>> fork that project, implement your changes, and offer to contribute
>>> them
>>> back to the main branch.
>>>
>>> Duncan Murdoch
>>>
>>>
>>>
>>>>
>>>>  ? * Positional assignment e.g. .[nr, nc] <- dim(x), and named
>>>> assignment
>>>>  ??? e.g. .[new = carb] <- mtcars or .[new = log(carb)] <- mtcars.
>>>> All
>>>>  ??? the functionality proposed by Kevin at
>>>>  ??? https://github.com/kevinushey/dotty
>>>>  ??? <https://github.com/kevinushey/dotty> is useful, unambiguous
>>>> and
>>>>  ??? feasible.
>>>>  ? * Silent dropping of RHS values e.g. .[mpg_new, cyl_new] <-
>>>> mtcars.
>>>>  ? * Mixing of positional and named assignment e.g .[mpg_new,
>>>> carb_new =
>>>>  ??? carb, cyl_new] <- mtcars. The inputs not assigned by name are
>>>> simply
>>>>  ??? the elements of RHS in the order they occur, regardless of
>>>> whether
>>>>  ??? they have been used previously e.g. .[mpg_new, cyl_new = cyl,
>>>>  ??? log_cyl = log(cyl), cyl_new2] <- mtcars is feasible. RHS here
>>>> could
>>>>  ??? be any named vector type.
>>>>  ? * Conventional use of the function as lazy version of of
>>>> list(), as in
>>>>  ??? data.table: .(A = B, C, D) is the same as list(A = B, C = C,
>>>> D = D).
>>>>  ??? This would also be useful, allowing more parsimonious code,
>>>> and
>>>>  ??? avoid the need to assign names to all return values in a
>>>> function
>>>>  ??? return, e.g. if I already have matrices A, C, Q and R as
>>>> internal
>>>>  ??? objects in my function, I can simply end by return(.(A, C, Q,
>>>> R))
>>>>  ??? instead of return(list(A = A, C = C, Q = Q, R = R)) if I
>>>> wanted the
>>>>  ??? list to be named with the object names.
>>>>
>>>> The implementation of this in R and C should be pretty
>>>> straightforward.
>>>> It would just require a modification to R CMD Check to recognize
>>>> .[<- as
>>>> assignment.
>>>>
>>>> Best regards,
>>>>
>>>> Sebastian
>>>> -
>>>> 2.)
>>>>
>>>> On Sun, 12 Mar 2023 at 09:42, Sebastian Martin Krantz
>>>> <sebastian.krantz at graduateinstitute.ch
>>>> <mailto:sebastian.krantz at graduateinstitute.ch>> wrote:
>>>>
>>>>  ??? Thanks Gabriel and Kevin for your inputs,
>>>>
>>>>  ??? regarding your points Gabriel, I think Python and Julia do
>>>> allow
>>>>  ??? multiple sub-assignment, but in-line with my earlier
>>>> suggestion in
>>>>  ??? response to Duncan to make multiple assignment an
>>>> environment-level
>>>>  ??? operation (like collapse::%=% currently works),? this would
>>>> not be
>>>>  ??? possible in R.
>>>>
>>>>  ??? Regarding the [a] <- coolest_function() syntax, yeah it would
>>>> mean
>>>>  ??? do multiple assignment and set a equal to the first element
>>>> dropping
>>>>  ??? all other elements. Multiple assignment should be positional
>>>> loke in
>>>>  ??? other languages, enabling flexible renaming of objects on the
>>>> fly.
>>>>  ??? So it should be irrelevant whether the function returns a
>>>> named or
>>>>  ??? unnamed list or vector.
>>>>
>>>>  ??? Thanks also Kevin for this contribution. I think it?s a
>>>> remarkable
>>>>  ??? effort, and I wouldn?t mind such semantics e.g. making it a
>>>> function
>>>>  ??? call to ?.[? or any other one-letter function, as long as
>>>> it?s coded
>>>>  ??? in C and recognized by the interpreter as an assignment
>>>> operation.
>>>>
>>>>  ??? Best regards,
>>>>
>>>>  ??? Sebastian
>>>>
>>>>
>>>>
>>>>
>>>>
>>>>  ??? On Sun 12. Mar 2023 at 01:00, Kevin Ushey
>>>> <kevinushey at gmail.com
>>>>  ??? <mailto:kevinushey at gmail.com>> wrote:
>>>>
>>>>  ??????? FWIW, it's possible to get fairly close to your proposed
>>> semantics
>>>>  ??????? using the existing metaprogramming facilities in R. I put
>>> together a
>>>>  ??????? prototype package here to demonstrate:
>>>>
>>>>  ??????? https://github.com/kevinushey/dotty
>>>>  ??????? <https://github.com/kevinushey/dotty>
>>>>
>>>>  ??????? The package exports an object called `.`, with a special
>>>>  ??????? `[<-.dot` S3
>>>>  ??????? method which enables destructuring assignments. This
>>>> means you
>>> can
>>>>  ??????? write code like:
>>>>
>>>>  ???????????? .[nr, nc] <- dim(mtcars)
>>>>
>>>>  ??????? and that will define 'nr' and 'nc' as you expect.
>>>>
>>>>  ??????? As for R CMD check warnings, you can suppress those
>>>> through the
>>>>  ??????? use of
>>>>  ??????? globalVariables(), and that can also be automated within
>>>> the
>>>>  ??????? package.
>>>>  ??????? The 'dotty' package includes a function 'dotify()' which
>>> automates
>>>>  ??????? looking for such usages in your package, and calling
>>>>  ??????? globalVariables()
>>>>  ??????? so that R CMD check doesn't warn. In theory, a similar
>>>> technique
>>>>  ??????? would
>>>>  ??????? be applicable to other packages defining similar
>>>> operators
>>> (zeallot,
>>>>  ??????? collapse).
>>>>
>>>>  ??????? Obviously, globalVariables() is a very heavy hammer to
>>>> swing for
>>>>  ??????? this
>>>>  ??????? issue, but you might consider the benefits worth the
>>>> tradeoffs.
>>>>
>>>>  ??????? Best,
>>>>  ??????? Kevin
>>>>
>>>>  ??????? On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch
>>>>         
>>>> <murdoch.duncan at gmail.com?<mailto:murdoch.duncan at gmail.com>>
>>> wrote:
>>>>  ???????? >
>>>>  ???????? > On 11/03/2023 4:42 p.m., Sebastian Martin Krantz
>>>> wrote:
>>>>  ???????? > > Thanks Duncan and Ivan for the careful thoughts. I'm
>>>> not
>>>>  ??????? sure I can
>>>>  ???????? > > follow all aspects you raised, but to give my
>>>> limited take
>>>>  ??????? on a few:
>>>>  ???????? > >
>>>>  ???????? > >> your proposal violates a very basic property of the
>>>>  ??????? language, i.e. that all statements are expressions and
>>>> have a
>>>>  ??????? value.? > What's the value of 1 + (A, C =
>>>> init_matrices()).
>>>>  ???????? > >
>>>>  ???????? > > I'm not sure I see the point here. I evaluated 1 +
>>>> (d =
>>>>  ??????? dim(mtcars); nr
>>>>  ???????? > > = d[1]; nc = d[2]; rm(d)), which simply gives a
>>>> syntax
>>> error,
>>>>  ???????? >
>>>>  ???????? >
>>>>  ???????? >??? d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
>>>>  ???????? >
>>>>  ???????? > is not a statement, it is a sequence of 4 statements.
>>>>  ???????? >
>>>>  ???????? > Duncan Murdoch
>>>>  ???????? >
>>>>  ???????? >?? as the
>>>>  ???????? > > above expression should. `%=%` assigns to
>>>>  ???????? > > environments, so 1 + (c("A", "C") %=%
>>>> init_matrices())
>>> returns
>>>>  ???????? > > numeric(0), with A and C having their values
>>>> assigned.
>>>>  ???????? > >
>>>>  ???????? > >> suppose f() returns list(A = 1, B = 2) and I do? >
>>>> B, A <-
>>>>  ??????? f() > Should assignment be by position or by name?
>>>>  ???????? > >
>>>>  ???????? > > In other languages this is by position. The feature
>>>> is not
>>>>  ??????? meant to
>>>>  ???????? > > replace list2env(), and being able to rename objects
>>>> in the
>>>>  ??????? assignment
>>>>  ???????? > > is a vital feature of codes
>>>>  ???????? > > using multi input and output functions e.g. in
>>>> Matlab or
>>> Julia.
>>>>  ???????? > >
>>>>  ???????? > >> Honestly, given that this is simply syntactic
>>>> sugar, I
>>>>  ??????? don't think I would support it.
>>>>  ???????? > >
>>>>  ???????? > > You can call it that, but it would be used by almost
>>>> every
>>>>  ??????? R user almost
>>>>  ???????? > > every day. Simple things like nr, nc = dim(x);
>>>> values,
>>>>  ??????? vectors =
>>>>  ???????? > > eigen(x) etc. where the creation of intermediate
>>>> objects
>>>>  ???????? > > is cumbersome and redundant.
>>>>  ???????? > >
>>>>  ???????? > >> I see you've already mentioned it ("JavaScript-
>>>> like"). I
>>>>  ??????? think it would? fulfil Sebastian's requirements too, as
>>>> long as
>>>>  ??????? it is considered "true assignment" by the rest of the
>>>> language.
>>>>  ???????? > >
>>>>  ???????? > > I don't have strong opinions about how the issue is
>>>> phrased
>>> or
>>>>  ???????? > > implemented. Something like [t, n] = dim(x) might
>>>> even be
>>>>  ??????? more clear.
>>>>  ???????? > > It's important though that assignment remains by
>>>> position,
>>>>  ???????? > > so even if some output gets thrown away that should
>>>> also be
>>>>  ??????? positional.
>>>>  ???????? > >
>>>>  ???????? > >>? A <- 0? > [A, B = A + 10] <- list(1, A = 2)
>>>>  ???????? > >
>>>>  ???????? > > I also fail to see the use of allowing this.
>>>> something like
>>>>  ??????? this is an
>>>>  ???????? > > error.
>>>>  ???????? > >
>>>>  ???????? > >> A = 2
>>>>  ???????? > >> (B = A + 1) <- 1
>>>>  ???????? > > Error in (B = A + 1) <- 1 : could not find function
>>>> "(<-"
>>>>  ???????? > >
>>>>  ???????? > > Regarding the practical implementation, I think
>>>>  ??????? `collapse::%=%` is a
>>>>  ???????? > > good starting point. It could be introduced in R as
>>>> a
>>>>  ??????? separate function,
>>>>  ???????? > > or `=` could be modified to accommodate its
>>>> capability. It
>>>>  ??????? should be
>>>>  ???????? > > clear that
>>>>  ???????? > > with more than one LHS variables the assignment is
>>>> an
>>>>  ??????? environment level
>>>>  ???????? > > operation and the results can only be used in
>>>> computations
>>>>  ??????? once assigned
>>>>  ???????? > > to the environment, e.g. as in 1 + (c("A", "C") %=%
>>>>  ??????? init_matrices()),
>>>>  ???????? > > A and C are not available for the addition in this
>>>>  ??????? statement. The
>>>>  ???????? > > interpretor then needs to be modified to read
>>>> something
>>>>  ??????? like nr, nc =
>>>>  ???????? > > dim(x) or [nr, nc] = dim(x). as an environment-level
>>>>  ??????? multiple assignment
>>>>  ???????? > > operation with no
>>>>  ???????? > > immediate value. Appears very feasible to my limited
>>>>  ??????? understanding, but
>>>>  ???????? > > I guess there are other things to consider still.
>>>>  ??????? Definitely appreciate
>>>>  ???????? > > the responses so far though.
>>>>  ???????? > >
>>>>  ???????? > > Best regards,
>>>>  ???????? > >
>>>>  ???????? > > Sebastian
>>>>  ???????? > >
>>>>  ???????? > >
>>>>  ???????? > >
>>>>  ???????? > >
>>>>  ???????? > >
>>>>  ???????? > > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch
>>>>         
>>>> <murdoch.duncan at gmail.com?<mailto:murdoch.duncan at gmail.com>
>>>>  ???????? > > <mailto:murdoch.duncan at gmail.com
>>>>  ??????? <mailto:murdoch.duncan at gmail.com>>> wrote:
>>>>  ???????? > >
>>>>  ???????? > >???? On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
>>>>  ???????? > >????? > On Sat, 11 Mar 2023 11:11:06 -0500
>>>>  ???????? > >????? > Duncan Murdoch <murdoch.duncan at gmail.com
>>>>  ??????? <mailto:murdoch.duncan at gmail.com>
>>>>  ???????? > >???? <mailto:murdoch.duncan at gmail.com
>>>>  ??????? <mailto:murdoch.duncan at gmail.com>>> wrote:
>>>>  ???????? > >????? >
>>>>  ???????? > >????? >> That's clear, but your proposal violates a
>>>> very
>>>>  ??????? basic property
>>>>  ???????? > >???? of the
>>>>  ???????? > >????? >> language, i.e. that all statements are
>>>> expressions
>>>>  ??????? and have a value.
>>>>  ???????? > >????? >
>>>>  ???????? > >????? > How about reframing this feature request from
>>>>  ??????? multiple assignment
>>>>  ???????? > >????? > (which does go contrary to "everything has
>>>> only one
>>>>  ??????? value, even
>>>>  ???????? > >???? if it's
>>>>  ???????? > >????? > sometimes invisible(NULL)") to "structured
>>>> binding"
>>>>  ??????? / "destructuring
>>>>  ???????? > >????? > assignment" [*], which takes this single
>>>> single
>>>>  ??????? value returned by the
>>>>  ???????? > >????? > expression and subsets it subject to certain
>>>> rules?
>>>>  ??????? It may be
>>>>  ???????? > >???? easier to
>>>>  ???????? > >????? > make a decision on the semantics for
>>>> destructuring
>>>>  ??????? assignment (e.g.
>>>>  ???????? > >????? > languages which have this feature typically
>>>> allow
>>>>  ??????? throwing unneeded
>>>>  ???????? > >????? > parts of the return value away), and it
>>>> doesn't seem
>>>>  ??????? to break as much
>>>>  ???????? > >????? > of the rest of the language if implemented.
>>>>  ???????? > >????? >
>>>>  ???????? > >????? > I see you've already mentioned it
>>>>  ??????? ("JavaScript-like"). I think it
>>>>  ???????? > >???? would
>>>>  ???????? > >????? > fulfil Sebastian's requirements too, as long
>>>> as it
>>>>  ??????? is considered
>>>>  ???????? > >???? "true
>>>>  ???????? > >????? > assignment" by the rest of the language.
>>>>  ???????? > >????? >
>>>>  ???????? > >????? > The hard part is to propose the actual
>>>> grammar of
>>>>  ??????? the new feature (in
>>>>  ???????? > >????? > terms of src/main/gram.y, preferably without
>>> introducing
>>>>  ???????? > >???? conflicts) and
>>>>  ???????? > >????? > its semantics (including the corner cases,
>>>> some of
>>>>  ??????? which you have
>>>>  ???????? > >????? > already mentioned). I'm not sure I'm up to
>>>> the task.
>>>>  ???????? > >????? >
>>>>  ???????? > >
>>>>  ???????? > >???? If I were doing it, here's what I'd propose:
>>>>  ???????? > >
>>>>  ???????? > >???????? '[' formlist ']' LEFT_ASSIGN expr
>>>>  ???????? > >???????? '[' formlist ']' EQ_ASSIGN expr
>>>>  ???????? > >???????? expr RIGHT_ASSIGN? '[' formlist ']'
>>>>  ???????? > >
>>>>  ???????? > >???? where `formlist` has the syntax of the formals
>>>> list for
>>>>  ??????? a function
>>>>  ???????? > >???? definition.? This would have the following
>>>> semantics:
>>>>  ???????? > >
>>>>  ???????? > >????????? {
>>>>  ???????? > >??????????? *tmp* <- expr
>>>>  ???????? > >
>>>>  ???????? > >??????????? # For arguments with no "default"
>>>> expression,
>>>>  ???????? > >
>>>>  ???????? > >??????????? argname1 <- *tmp*[[1]]
>>>>  ???????? > >??????????? argname2 <- *tmp*[[2]]
>>>>  ???????? > >??????????? ...
>>>>  ???????? > >
>>>>  ???????? > >??????????? # For arguments with a default listed
>>>>  ???????? > >
>>>>  ???????? > >??????????? argname3 <- with(*tmp*, default3)
>>>>  ???????? > >????????? }
>>>>  ???????? > >
>>>>  ???????? > >
>>>>  ???????? > >???? The value of the whole thing would therefore be
>>>>  ??????? (invisibly) the
>>>>  ???????? > >???? value of
>>>>  ???????? > >???? the last item in the assignment.
>>>>  ???????? > >
>>>>  ???????? > >???? Two examples:
>>>>  ???????? > >
>>>>  ???????? > >???????? [A, B, C] <- expr?? # assign the first three
>>>>  ??????? elements of expr to A,
>>>>  ???????? > >???? B, and C
>>>>  ???????? > >
>>>>  ???????? > >???????? [A, B, C = a + b] <- expr? # assign the
>>>> first two
>>>>  ??????? elements of expr
>>>>  ???????? > >??????????????????????????????????? # to A and B,
>>>>  ???????? > >??????????????????????????????????? # assign
>>>> with(expr, a +
>>>>  ??????? b) to C.
>>>>  ???????? > >
>>>>  ???????? > >???? Unfortunately, I don't think this could be done
>>> entirely by
>>>>  ???????? > >???? transforming
>>>>  ???????? > >???? the expression (which is the way |> was done),
>>>> and that
>>>>  ??????? makes it a lot
>>>>  ???????? > >???? harder to write and to reason about.? E.g. what
>>>> does
>>>>  ??????? this do?
>>>>  ???????? > >
>>>>  ???????? > >???????? A <- 0
>>>>  ???????? > >???????? [A, B = A + 10] <- list(1, A = 2)
>>>>  ???????? > >
>>>>  ???????? > >???? According to the recipe above, I think it sets A
>>>> to 1
>>>>  ??????? and B to 12, but
>>>>  ???????? > >???? maybe a user would expect B to be 10 or 11.? And
>>>>  ??????? according to that
>>>>  ???????? > >???? recipe this is an error:
>>>>  ???????? > >
>>>>  ???????? > >???????? [A, B = A + 10] <- c(1, A = 2)
>>>>  ???????? > >
>>>>  ???????? > >???? which probably isn't what a user would expect,
>>>> given
>>>>  ??????? that this is fine:
>>>>  ???????? > >
>>>>  ???????? > >???????? [A, B] <- c(1, 2)
>>>>  ???????? > >
>>>>  ???????? > >???? Duncan Murdoch
>>>>  ???????? > >
>>>>  ???????? >
>>>>  ???????? > ______________________________________________
>>>>  ???????? > R-devel at r-project.org?<mailto:R-devel at r-project.org>
>>>> mailing
>>> list
>>>>  ???????? > https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>  ??????? <https://stat.ethz.ch/mailman/listinfo/r-devel>
>>>>
>>>
>>>
>>
>>  ????????[[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-devel at r-project.org?mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From ggrothend|eck @end|ng |rom gm@||@com  Mon Mar 13 13:29:52 2023
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Mon, 13 Mar 2023 08:29:52 -0400
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
Message-ID: <CAP01uRkDEKhfVsO0XAPdy+DZvtfPX=YKbHUnvReL0Hv5jshQCw@mail.gmail.com>

The gsubfn package can do that.

    library(gsubfn)

    # swap a and b without explicitly creating a temporary
     a <- 1; b <- 2
     list[a,b] <- list(b,a)

     # get eigenvectors and eigenvalues
     list[eval, evec] <- eigen(cbind(1,1:3,3:1))

     # get today's month, day, year
     require(chron)
     list[Month, Day, Year] <- month.day.year(unclass(Sys.Date()))

     # get first two components of linear model ignoring rest
     list[Coef, Resid] <- lm(rnorm(10) ~ seq(10))

     # assign Green and Blue (but not Red) components
     list[,Green,Blue]  <- col2rgb("aquamarine")

     # Assign QR and QRaux but not other components
     list[QR,,QRaux]  <- qr(c(1,1:3,3:1))


On Sat, Mar 11, 2023 at 7:47?AM Sebastian Martin Krantz
<sebastian.krantz at graduateinstitute.ch> wrote:
>
> Dear R Core,
>
> working on my dynamic factor modelling package, which requires several
> subroutines to create and update several system matrices, I come back to
> the issue of being annoyed by R not supporting multiple assignment out of
> the box like Matlab, Python and julia. e.g. something like
>
> A, C, Q, R = init_matrices(X, Y, Z)
>
> would be a great addition to the language. I know there are several
> workarounds such as the %<-% operator in the zeallot package or my own %=%
> operator in collapse, but these don't work well for package development as
> R CMD Check warns about missing global bindings for the created variables,
> e.g. I would have to use
>
> A <- C <- Q <- R <- NULL
> .c(A, C, Q, R) %=% init_matrices(X, Y, Z)
>
> in a package, which is simply annoying. Of course the standard way of
>
> init <- init_matrices(X, Y, Z)
>  A <- init$A; C <- init$C; Q <- init$Q; R <- init$R
> rm(init)
>
> is also super cumbersome compared to Python or Julia. Another reason is of
> course performance, even my %=% operator written in C has a non-negligible
> performance cost for very tight loops, compared to a solution at the
> interpretor level or in a primitive function such as `=`.
>
> So my conclusion at this point is that it is just significantly easier to
> implement such codes in Julia, in addition to the greater performance it
> offers. There are obvious reasons why I am still coding in R and C, thanks
> to the robust API and great ecosystem of packages, but adding this could be
> a presumably low-hanging fruit to make my life a bit easier. Several issues
> for this have been filed on Stackoverflow, the most popular one (
> https://stackoverflow.com/questions/7519790/assign-multiple-new-variables-on-lhs-in-a-single-line)
> has been viewed 77 thousand times.
>
> But maybe this has already been discussed here and already decided against.
> In that case, a way to browse R-devel archives to find out would be nice.
>
> Best regards,
>
> Sebastian
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From ezr@ @end|ng |rom |@ndtucker@com  Mon Mar 13 16:53:56 2023
From: ezr@ @end|ng |rom |@ndtucker@com (Ezra Tucker)
Date: Mon, 13 Mar 2023 11:53:56 -0400
Subject: [Rd] Adding support for S7 to base R
In-Reply-To: <9fea1857-e3fe-e0c4-5d31-702c482f320c@gmail.com>
References: <CALWM=9b2izXXmLOQQOf4Ssg+11E5fdy5DfM4P2NqCPeBpLGSwg@mail.gmail.com>
 <9d257ea4-d757-f88e-e9d0-383f8cc8b45b@gmail.com>
 <9fea1857-e3fe-e0c4-5d31-702c482f320c@gmail.com>
Message-ID: <CAEToJBHfJ2VqdQUk7UgQ8zoCY-nCGrTT6S-GbkyvNcQhkwOD0Q@mail.gmail.com>

I don't know if this is the right forum, but I'd like to ask an open-ended
question about the goals of the S7 OOP system, which is, where do we see
the ultimate future of object-oriented programming in R being? Do we see S7
eventually complementing S3 and S4 in "base" (in quotes because S4 is
provided by the methods package), or do we see (or even wish?) for S7 to
supplant both S3 and S4 eventually within base R?

My own personal experience, I usually use S4 - why, because it's there, and
also, some of my favorite packages (sp and Matrix) use it, and I like my
code to look like the source code for the language. To that end, when I'm
training up engineers or data scientists to use OOP in R, I have them look
at source code-- but then also have to be choosy about source code for what
lest they become confused by the differences between S3 and S4 (not to
mention R6, RC, and whatever else might be out there).

R is the only language I know of that has multiple different object
oriented systems, and that makes it a big barrier to entry for people
learning the language, and I think the language as a whole would benefit
greatly from having a single standard.

-Ezra

On Sat, Feb 18, 2023 at 12:38?PM Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:

> On 18/02/2023 9:51 a.m., Duncan Murdoch wrote:
> > One more comment:
> >
> > The utils::setBreakpoint() function should be updated to be able to set
> > breakpoints in S7 methods, or a substitute function should be added to
> > the S7 package.
> >
> > RStudio 2022.12.0+353 (not sure if that's the latest) also needs to be
> > taught how to do that, since it doesn't seem to use setBreakpoint.
>
> I took a look at updating setBreakpoint().  I can get findLineNum() to
> work, but setBreakpoint() doesn't work because trace() doesn't work.
> debug() doesn't work either:  it looks as though it is trying to treat
> an S7 method as an S4 method.
>
> Will the already proposed changes help with debugging, or is that a
> completely separate issue?
>
> Duncan Murdoch
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From po@@enr|ede @end|ng |rom gm@||@com  Mon Mar 13 17:31:19 2023
From: po@@enr|ede @end|ng |rom gm@||@com (Daniel Possenriede)
Date: Mon, 13 Mar 2023 17:31:19 +0100
Subject: [Rd] Versioning Rtools ARP entries
Message-ID: <CANu2KkPeXi3=0=KyvjfELrE1A_aRO1yrbqmRPavKo-3siJZ_og@mail.gmail.com>

Hi,

If I am not mistaken, all Rtools 4.2 (and 4.3) revisions have the same
ARP [1] entries, i.e. all report version 4.2.0.1 (or 4.3.0.1). This
makes it difficult to determine the installed version (is it possible
to determine the installed revision?) and impossible for tools like
winget [2] to update Rtools to the latest revision, AFAICT.

Would it be possible to track the version in the installer [3] for
future Rtools releases again, like it used to be in Rtools 4.0 [4]?

Thanks!

Daniel

[1] https://github.com/microsoft/winget-pkgs/blob/master/FAQ.md#what-is-an-arp-entry
[2] https://github.com/microsoft/winget-cli
[3] https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/rtools/rtools64.iss
[4] https://github.com/r-windows/rtools-installer/commit/7f23f0d0442d72922014ec4082c8bdd437364cef


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Mon Mar 13 17:57:45 2023
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Mon, 13 Mar 2023 17:57:45 +0100
Subject: [Rd] Versioning Rtools ARP entries
In-Reply-To: <CANu2KkPeXi3=0=KyvjfELrE1A_aRO1yrbqmRPavKo-3siJZ_og@mail.gmail.com>
References: <CANu2KkPeXi3=0=KyvjfELrE1A_aRO1yrbqmRPavKo-3siJZ_og@mail.gmail.com>
Message-ID: <d45cbe35-c093-ff9e-f31d-48f3144f7568@gmail.com>


On 3/13/23 17:31, Daniel Possenriede wrote:
> Hi,
>
> If I am not mistaken, all Rtools 4.2 (and 4.3) revisions have the same
> ARP [1] entries, i.e. all report version 4.2.0.1 (or 4.3.0.1). This
> makes it difficult to determine the installed version (is it possible
> to determine the installed revision?) and impossible for tools like
> winget [2] to update Rtools to the latest revision, AFAICT.
>
> Would it be possible to track the version in the installer [3] for
> future Rtools releases again, like it used to be in Rtools 4.0 [4]?

Well the thing is that once you install Rtools 42/43, you can then 
upgrade it internally (without Windows knowing). You can upgrade the 
Msys2 part, or the MXE part, or both. The MXE part (customized for 
Rtools) does have a single version number, which can be found in the 
installation. The Msys2 part doesn't, afaik.

See e.g. "Upgrading Rtools43" in 
https://cran.r-project.org/bin/windows/base/howto-R-devel.html for how 
to upgrade and how to find out the current version number of the MXE part.

So, right, I could e.g. add a non-decreasing unique version to the build 
of the installer (e.g. based on that from the SVN where it lives and the 
MXE part version originally included), but I doubt how useful that would 
be, given that a particular installation can be upgraded/modified by the 
user. It could actually be misleading.

Note Rtools40 also could be updated by the user internally.

Tomas

>
> Thanks!
>
> Daniel
>
> [1] https://github.com/microsoft/winget-pkgs/blob/master/FAQ.md#what-is-an-arp-entry
> [2] https://github.com/microsoft/winget-cli
> [3] https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/rtools/rtools64.iss
> [4] https://github.com/r-windows/rtools-installer/commit/7f23f0d0442d72922014ec4082c8bdd437364cef
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @uh@rto_@nggono @end|ng |rom y@hoo@com  Mon Mar 13 19:42:06 2023
From: @uh@rto_@nggono @end|ng |rom y@hoo@com (Suharto Anggono Suharto Anggono)
Date: Mon, 13 Mar 2023 18:42:06 +0000 (UTC)
Subject: [Rd] scan(..., skip=1e11): infinite loop; cannot interrupt
References: <1949927453.3306156.1678732926720.ref@mail.yahoo.com>
Message-ID: <1949927453.3306156.1678732926720@mail.yahoo.com>


With

?if?(!j--)?{
?????R_CheckUserInterrupt();
?????j?=?10000;
?}

as?in?current?R?devel?(r83976),?j goes negative (-1) and interrupt is checked every 10001 instead of 10000. I?prefer

?if?(!--j)?{
?????R_CheckUserInterrupt();
?????j?=?10000;
?}

.


In?current?R?devel?(r83976),?if?EOF?is?reached,?the?outer?loop?keeps?going,?i?keeps?incrementing?until?nskip.

The?outer?loop?could?be?made?to?also?stop?on?EOF.

Alternatively,?not?using?nested?loop?is?possible,?like?the?following.

?if?(nskip)?for?(R_xlen_t?i?=?0,?j?=?10000;?;?)?{?/*?MBCS-safe?*/
?c?=?scanchar(FALSE,?&data);
?if?(!j--)?{
?????R_CheckUserInterrupt();
?????j?=?10000;
?}
?if?((c?==?'\n'?&&?++i?==?nskip)?||?c?==?R_EOF)
?????break;
?}


-----------
On?2/11/23?09:33,?Ivan?Krylov?wrote:
>?On?Fri,?10?Feb?2023?23:38:55?-0600
>?Spencer?Graves?<spencer.graves?using?prodsyse.com>?wrote:
>
>>?I?have?a?4.54?GB?file?that?I'm?trying?to?read?in?chunks?using
>>?"scan(...,?skip=__)".??It?works?as?expected?for?small?values?of
>>?"skip"?but?goes?into?an?infinite?loop?for?"skip=1e11"?and?similar
>>?large?values?of?skip:??I?cannot?even?interrupt?it;??I?must?kill?R.
>?Skipping?lines?is?done?by?two?nested?loops.?The?outer?loop?counts?the
>?lines?to?skip;?the?inner?loop?reads?characters?until?it?encounters?a
>?newline?or?end?of?file.?The?outer?loop?doesn't?check?for?EOF?and?keeps
>?asking?for?more?characters?until?the?inner?loop?runs?at?least?once?for
>?every?line?it?wants?to?skip.?The?following?patch?should?avoid?the
>?wait?in?such?cases:
>
>?---?src/main/scan.c?(revision?83797)
>?+++?src/main/scan.c?(working?copy)
>?@@?-835,7?+835,7?@@
>???attribute_hidden?SEXP?do_scan(SEXP?call,?SEXP?op,?SEXP?args,?SEXP?rho)
>???{
>???????SEXP?ans,?file,?sep,?what,?stripwhite,?dec,?quotes,?comstr;
>?-????int?c,?flush,?fill,?blskip,?multiline,?escapes,?skipNul;
>?+????int?c?=?0,?flush,?fill,?blskip,?multiline,?escapes,?skipNul;
>???????R_xlen_t?nmax,?nlines,?nskip;
>???????const?char?*p,?*encoding;
>???????RCNTXT?cntxt;
>?@@?-952,7?+952,7?@@
>????????if(!data.con->canread)
>????error(_("cannot?read?from?this?connection"));
>????}
>?-?for?(R_xlen_t?i?=?0;?i?<?nskip;?i++)?/*?MBCS-safe?*/
>?+?for?(R_xlen_t?i?=?0;?i?<?nskip?&&?c?!=?R_EOF;?i++)?/*?MBCS-safe?*/
>????????while?((c?=?scanchar(FALSE,?&data))?!=?'\n'?&&?c?!=?R_EOF);
>???????}
>
>
>?Making?it?interruptible?is?a?bit?more?work:?we?need?to?ensure?that?a
>?valid?context?is?set?up?and?check?regularly?for?an?interrupt.
>
>?---?src/main/scan.c?(revision?83797)
>?+++?src/main/scan.c?(working?copy)
>?@@?-835,7?+835,7?@@
>???attribute_hidden?SEXP?do_scan(SEXP?call,?SEXP?op,?SEXP?args,?SEXP?rho)
>???{
>???????SEXP?ans,?file,?sep,?what,?stripwhite,?dec,?quotes,?comstr;
>?-????int?c,?flush,?fill,?blskip,?multiline,?escapes,?skipNul;
>?+????int?c?=?0,?flush,?fill,?blskip,?multiline,?escapes,?skipNul;
>???????R_xlen_t?nmax,?nlines,?nskip;
>???????const?char?*p,?*encoding;
>???????RCNTXT?cntxt;
>?@@?-952,8?+952,6?@@
>????????if(!data.con->canread)
>????error(_("cannot?read?from?this?connection"));
>????}
>?-?for?(R_xlen_t?i?=?0;?i?<?nskip;?i++)?/*?MBCS-safe?*/
>?-?????while?((c?=?scanchar(FALSE,?&data))?!=?'\n'?&&?c?!=?R_EOF);
>???????}
>
>???????ans?=?R_NilValue;?/*?-Wall?*/
>?@@?-966,6?+964,10?@@
>???????cntxt.cend?=?&scan_cleanup;
>???????cntxt.cenddata?=?&data;
>
>?+????if?(ii)?for?(R_xlen_t?i?=?0,?j?=?0;?i?<?nskip?&&?c?!=?R_EOF;?i++)?/*?MBCS-safe?*/
>?+?while?((c?=?scanchar(FALSE,?&data))?!=?'\n'?&&?c?!=?R_EOF)
>?+?????if?(j++?%?10000?==?9999)?R_CheckUserInterrupt();
>?+
>???????switch?(TYPEOF(what))?{
>???????case?LGLSXP:
>???????case?INTSXP:
>
>?This?way,?even?if?you?pour?a?Decanter?of?Endless?Lines?(e.g.?mkfifo
>?LINES;?perl?-E'print?"A"x42?while?1;'?>?LINES)?into?scan(),?it?can
>?still?be?interrupted,?even?if?neither?newline?nor?EOF?ever?arrives.

Thanks,?I've?updated?the?implementation?of?scan()?in?R-devel?to?be
interruptible?while?skipping?lines.

I've?done?it?slightly?differently?as?I?found?there?already?was?a?memory
leak,?which?could?be?fixed?by?creating?the?context?a?bit?earlier.

I've?also?avoided?modulo?on?the?fast?path?as?I?saw?13%?performance
overhead?on?my?mailbox?file.?Decrementing?and?checking?against?zero
didn't?have?measurable?overhead.

Best
Tomas

[snip]


