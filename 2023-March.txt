From ch|r|com @end|ng |rom goog|e@com  Wed Mar  1 10:36:02 2023
From: ch|r|com @end|ng |rom goog|e@com (Michael Chirico)
Date: Wed, 1 Mar 2023 01:36:02 -0800
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
Message-ID: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>

Consider:

x <- list(`a b` = 1)
x$a<tab>

(i.e., press the 'tab' key after typing 'x$a')

The auto-complete mechanism will fill the buffer like so:
x$a b

This is not particularly helpful because this is now a syntax error.

It seems to me there's a simple fix -- in
utils:::specialCompletions(), we can wrap the result of
utils:::specialOpCompletionsHelper() with backticks for non-syntactic
names ([1]):

comps <- specialOpCompletionsHelper(op, suffix, prefix)
if (length(comps) == 0L) comps <- ""
+non_syntactic <- make.names(comps) != comps
+comps[non_syntactic] <- paste0("`", comps[non_syntactic], "`")
sprintf("%s%s%s", prefix, op, comps)

I'm somewhat surprised this hasn't come up before (I searched for
'completeToken', 'specialCompletions', and
'specialOpCompletionsHelper' here and on Bugzilla), so I'm checking
with the list first if I'm missing anything before filing a patch.

Mike C

[1] https://github.com/r-devel/r-svn/blob/4657f65a377cb5ef318c6548bc264e3b0f9517a0/src/library/utils/R/completion.R#L536-L538


From kry|ov@r00t @end|ng |rom gm@||@com  Wed Mar  1 10:56:47 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Wed, 1 Mar 2023 12:56:47 +0300
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
Message-ID: <20230301125647.765cda59@arachnoid>

? Wed, 1 Mar 2023 01:36:02 -0800
Michael Chirico via R-devel <r-devel at r-project.org> ?????:

> +comps[non_syntactic] <- paste0("`", comps[non_syntactic], "`")

There are a few more corner cases. For example, comps could contain
backticks (which should be escaped with backslashes) and backslashes
(which should also be escaped). Thankfully, \uXXXX-style Unicode escape
sequences are not currently supported inside backticks, and "escape the
backslash" rule already takes care of them.

The deparse() function already knows these rules:

name <- 'hello world ` \\uFF'
cat(deparse1(as.name(name), backtick=TRUE), '\n')
# `hello world \` \\uFF`
`hello world \` \\uFF` <- 'hello'
`hello world \` \\uFF`
# [1] "hello"

-- 
Best regards,
Ivan


From @|@ergbox @end|ng |rom gm@||@com  Wed Mar  1 01:19:00 2023
From: @|@ergbox @end|ng |rom gm@||@com (Alexey Sergushichev)
Date: Tue, 28 Feb 2023 18:19:00 -0600
Subject: [Rd] Incorrect behavior of ks.test and psmirnov functions with
 exact=TRUE
Message-ID: <CAMGHQ95wXZ=LMVkUjDRsCJ_0P2VAbWnQrj-4_NvdXRGMuvVDvA@mail.gmail.com>

HI,

I've noticed what I think is an incorrect behavior of stats::psmirnov
function and consequently of ks.test when run in an exact mode.

For example:
psmirnov(1, sizes=c(50, 50), z=1:100, two.sided = FALSE, lower.tail = F,
exact=TRUE)

produces 2.775558e-15

However, the exact value should be 1/combination(100, 50), which is
9.9e-30. While the absolute error is small, the relative error is huge, and
it is not fixed by setting option log.p=T

To compare, SciPy has a correct implementation in scipy.stats.ks_2samp:
scipy.stats.ks_2samp(list(range(1,51)), list(range(51, 101)),
alternative="greater", method="exact")
returns 9.911653021418333e-30.

I've tried to dig in a bit and the problem comes down to how the final
value is calculated in psmirnov function:

    if (log.p & !lower.tail)
        return(log1p(-ret/exp(logdenom)))
    if (!log.p & !lower.tail)
        return(1 - ret/exp(logdenom))

There exp(logdenom) is a relatively good (but not perfect) approximation of
combination(100, 50) = 1.008913e+29, ret is also a good approximation of
combination(100, 50)-1 = 1.008913e+29 but there is not enough double
precision for 1 - ret/exp(logdenom) to capture 1/combination(100, 50).

I don't have time to provide a fix, at least not now, but I think this
behavior (good absolute error, but poor relative error for small values)
should at least be mentioned in the manual of the methods psmirnov and/or
ks.test

Best,
Alexey Sergushichev

	[[alternative HTML version deleted]]


From pd@me@ @end|ng |rom cb@@dk  Wed Mar  1 13:04:56 2023
From: pd@me@ @end|ng |rom cb@@dk (Peter Dalgaard)
Date: Wed, 1 Mar 2023 12:04:56 +0000
Subject: [Rd] R 4.2.3 scheduled for March 15
Message-ID: <0698828C-0FC0-421C-92DC-045717E4F7A2@cbs.dk>

Full schedule available on developer.r-project.org in a short while.

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From @nto|ne@|@br| @end|ng |rom gm@||@com  Wed Mar  1 13:53:21 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Wed, 1 Mar 2023 13:53:21 +0100
Subject: [Rd] confusing all.equal output
Message-ID: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>

dear r-devel,

This has probably been forever like this but is this satisfying ?

all.equal(c(1,NA,NA), c(1,NA,3))
#> [1] "'is.NA' value mismatch: 1 in current 2 in target"

is.NA() doesn't exist (is.na() does), and is.na() is never 1 or 2.

In this example it's obvious that we're counting missing values, in a
general situation I believe it isn't (we might understand it as the
position of the first NA for instance).

I would expect something like "'amount of missing values mismatch: 1 in
current 2 in target"

Thanks,

Antoine

	[[alternative HTML version deleted]]


From ch|r|com @end|ng |rom goog|e@com  Wed Mar  1 17:48:08 2023
From: ch|r|com @end|ng |rom goog|e@com (Michael Chirico)
Date: Wed, 1 Mar 2023 08:48:08 -0800
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <20230301125647.765cda59@arachnoid>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
Message-ID: <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>

Great suggestion! I've started a patch:
https://bugs.r-project.org/show_bug.cgi?id=18479

On Wed, Mar 1, 2023 at 1:56 AM Ivan Krylov <krylov.r00t at gmail.com> wrote:
>
> ? Wed, 1 Mar 2023 01:36:02 -0800
> Michael Chirico via R-devel <r-devel at r-project.org> ?????:
>
> > +comps[non_syntactic] <- paste0("`", comps[non_syntactic], "`")
>
> There are a few more corner cases. For example, comps could contain
> backticks (which should be escaped with backslashes) and backslashes
> (which should also be escaped). Thankfully, \uXXXX-style Unicode escape
> sequences are not currently supported inside backticks, and "escape the
> backslash" rule already takes care of them.
>
> The deparse() function already knows these rules:
>
> name <- 'hello world ` \\uFF'
> cat(deparse1(as.name(name), backtick=TRUE), '\n')
> # `hello world \` \\uFF`
> `hello world \` \\uFF` <- 'hello'
> `hello world \` \\uFF`
> # [1] "hello"
>
> --
> Best regards,
> Ivan


From AHL27 @end|ng |rom p|tt@edu  Wed Mar  1 17:52:20 2023
From: AHL27 @end|ng |rom p|tt@edu (Lakshman, Aidan H)
Date: Wed, 1 Mar 2023 16:52:20 +0000
Subject: [Rd] `dendrapply` Enhancements
In-Reply-To: <BL0PR04MB4706A66884728B9419CEAE00D9A89@BL0PR04MB4706.namprd04.prod.outlook.com>
References: <BL0PR04MB47068D544F5A49315EF1D042D9AB9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <CALK03d1PWiA4tfbRkxMBU6tckhfB2JRGUmnuqh5ygLcCLHDXNw@mail.gmail.com>
 <BL0PR04MB4706A66884728B9419CEAE00D9A89@BL0PR04MB4706.namprd04.prod.outlook.com>
Message-ID: <BL0PR04MB4706B185A345A98AB4AB829AD9AC9@BL0PR04MB4706.namprd04.prod.outlook.com>

Just wanted to give an update on the status of this, since it?s been a couple days and I?ve had a chance to work on it a little more.

Improvements:
- Fixed a few bugs, added some more robust checking to ensure correct checking for leaf nodes
- Corrected references to ?in-order? traversals, I actually meant ?pre-order?
- Added new documentation, including some new examples to the ?Usage? section
- Cleaned up some names/variables/identifiers
- Added some additional code to have function accurately replicate a weird bug of `stats::dendrapply` that is used in CRAN packages. Full details are in my PR (linked below).


I?ve integrated this into the svn mirror at r-devel/r-svn, and put out a PR at https://github.com/r-devel/r-svn/pull/111. Current PR is passing all build checks aside from Windows, which is throwing the error `Sorry, but: Error response from server: 500` while installing Miktex. I?m not sure what?s causing this, but it seems to be something aside from my code because it?s also crashing builds for other PRs.

A link to the diff file is here: https://patch-diff.githubusercontent.com/raw/r-devel/r-svn/pull/111.diff

Happy to open a Bugzilla report as well; this is enough code that a discussion is probably warranted, and Bugzilla may be an easier place to discuss compared to here. Also happy to discuss on the PR itself.

Thank you to everyone that has taken a look at my code, I appreciate people taking the time to read through it.

Sincerely,
Aidan Lakshman

-----------------------
Aidan Lakshman (he/him)<https://www.ahl27.com/>
Doctoral Candidate, Wright Lab<https://www.wrightlabscience.com/>
University of Pittsburgh School of Medicine
Department of Biomedical Informatics
ahl27 at pitt.edu
(724) 612-9940


From: Lakshman, Aidan H <AHL27 at pitt.edu>
Date: Friday, February 24, 2023 at 07:42
To: Toby Hocking <tdhock5 at gmail.com>
Cc: R-devel at r-project.org <R-devel at r-project.org>
Subject: Re: [Rd] `dendrapply` Enhancements
Hi Toby,

Thanks for your reply! I haven?t heard about the R project sprint, but I?ll definitely check it out. UK is going to be a little hard for me to get to funding-wise, but I?ll try to apply for funding.

I appreciate your other comments. As far as coding style, I did do everything I could think of to make sure it?s a drop-in replacement for the current version with the default settings, so all the user-exposed arguments/variables should be identical. I used the conventions in https://github.com/wch/r-source/wiki/Contributing for commenting and whitespace, so hopefully that all looks okay. I?m realizing there may be some differences in tab widths, but I can fix that later today.

-Aidan

-----------------------
Aidan Lakshman (he/him)<https://www.ahl27.com/>
Doctoral Candidate, Wright Lab<https://www.wrightlabscience.com/>
University of Pittsburgh School of Medicine
Department of Biomedical Informatics
ahl27 at pitt.edu
(724) 612-9940


From: Toby Hocking <tdhock5 at gmail.com>
Date: Friday, February 24, 2023 at 06:57
To: Lakshman, Aidan H <AHL27 at pitt.edu>
Cc: R-devel at r-project.org <R-devel at r-project.org>
Subject: Re: [Rd] `dendrapply` Enhancements
Hi Aidan, I think you are on the right email list.
I'm not R-core, but this looks like an interesting/meaningful/significant contribution to base R.
I'm not sure what the original dendrapply looks like in terms of code style (variable names/white space formatting/etc) but in my experience it is important that your code contribution makes minimal changes in that area.
Did you hear about the R project sprint 2023? https://contributor.r-project.org/r-project-sprint-2023/<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fcontributor.r-project.org%2Fr-project-sprint-2023%2F&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=oB%2BBivUsBjIgBtZNU8mh%2Fz2rujD3bv9MbWdxqNtyUFk%3D&reserved=0> Your work falls into the "new developments" category so I think you could apply for that funding to participate.
Toby

On Fri, Feb 24, 2023 at 3:47 AM Lakshman, Aidan H <AHL27 at pitt.edu<mailto:AHL27 at pitt.edu>> wrote:
Hi everyone,

My apologies if this isn?t the right place to submit this?I?m new to the R-devel community and still figuring out what is where.

If people want to skip my writeup and just look at the code, I?ve made a repository for it here: https://github.com/ahl27/new_dendrapply/tree/master<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fahl27%2Fnew_dendrapply%2Ftree%2Fmaster&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=QI%2B5t1C%2BJB15D8o8noZra4W87fgyITm12nluGN%2BFNoE%3D&reserved=0>. I?m not quite sure how to integrate it into a fork of R-devel; the package structure is different from what I?m used to.

I had written a slightly improved version of dendrapply for one of my research projects, and my advisor encouraged me to submit it to the R project. It took me longer than I expected, but I?ve finally gotten my implementation to be a drop-in replacement for `stats::dendrapply`. The man page for `stats::dendrapply` says ?The implementation is somewhat experimental and suggestions for enhancements (or nice examples of usage) are very welcome,? so I figured this had the potential to be a worthwhile contribution. I wanted to send it out to R-devel to see if this was something worth pursuing as an enhancement to R.

The implementation I have is based in C, which I understand implies an increased burden of maintenance over pure R code. However, it does come with the following benefits:

- Completely eliminates recursion, so no memory overhead from function calls or possibility of stack overflows (this was a major issue reported on some of the functions in one of our Bioconductor packages that previously used `dendrapply`).
- Modest runtime improvement, around 2x on my computer (2021 MBP, 32GB RAM). I?m relatively confident this could be optimized more.
- Seemingly significant reduction in memory reduction, still working on a robust benchmark. Suggestions for the best way to do that are welcome.
- Support for applying functions with an inorder traversal (as in `stats::dendrapply`) as well as using a postorder traversal.

This implementation was tested manually as well as running all the unit tests in `dendextend`, which comprises a lot of applications of `dendrapply`.

The postorder traversal would be a significant new functionality to dendrapply, as it would allow for functions that use the child nodes to correctly execute. A toy example of this is something like:
```
exFunc <- function(x){
  attr(x, 'newA') <- 'a'
  if(is.null(attr(x, 'leaf'))){
    cat(attr(x[[1]], 'newA'), attr(x[[2]], 'newA'))
    cat('\n')
  }
  x
})

dendrapply(dend, exFunc)
```

With the current version of dendrapply, this prints nothing, but the postorder traversal version will print ?a? twice for each internal branch. If this would be a worthwhile addition, I can refactor the code for brevity and add a `how=c("in.order", "post.order")`, with the default value ?in.order? to maintain backwards compatibility. A preorder traversal version should also be possible, I just haven?t gotten to it yet.

I think the runtime could be optimized more as well.

Thank you in advance for looking at my code and offering feedback; I?m excited at the possibility of helping contribute to the R project! I?m happy to discuss more either here, on GitHub, or on the R Contributors Slack.

Sincerely,
Aidan Lakshman

-----------------------
Aidan Lakshman (he/him)<https://www.ahl27.com/<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.ahl27.com%2F&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=7KUpJpdulSIzSXbpDJlyUV8pMJm%2BSVFvDOJTlVs9lhc%3D&reserved=0>>
Doctoral Candidate, Wright Lab<https://www.wrightlabscience.com/<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.wrightlabscience.com%2F&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=JMgw%2BMiQ6xdp3OokToJ2nyyco%2BryiFH%2B9ap5iU3yJH8%3D&reserved=0>>
University of Pittsburgh School of Medicine
Department of Biomedical Informatics
ahl27 at pitt.edu<mailto:ahl27 at pitt.edu>
(724) 612-9940


        [[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=05%7C01%7CAHL27%40pitt.edu%7C41b702f139034cd7165608db165e4530%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638128366414606277%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=I88%2FQhGHXDRS2yHqvh53k3MSWHSd5z2KBgORUHIxfG0%3D&reserved=0>

	[[alternative HTML version deleted]]


From kry|ov@r00t @end|ng |rom gm@||@com  Thu Mar  2 09:39:38 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Thu, 2 Mar 2023 11:39:38 +0300
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
 <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
Message-ID: <20230302113938.26be9522@Tarkus>

There turn out to be a few more things to fix.

One problem is easy to solve: vapply() needs a third argument
specifying the type of the return value. (Can we have unit tests for
tab completion?)

The other problem is harder: `comps` defaults to an empty string, and
you can't have a symbol consisting of an empty string, because this
value is internally reserved for missing function arguments. I think
you can return(paste0(prefix, op)) if length(comps) == 0L, but this is
still somewhat worrying. R tries to prevent empty names, so I wouldn't
expect specialOpCompletionsHelper() to return an empty string, but I
can't prove it right now.

On the other hand, x$'a string' is the same as x$`a string`. Could we
just drop as.name() and keep the return value being a string literal?
I'm not sure about this, either.

-- 
Best regards,
Ivan


From deep@y@n@@@rk@r @end|ng |rom gm@||@com  Thu Mar  2 10:03:03 2023
From: deep@y@n@@@rk@r @end|ng |rom gm@||@com (Deepayan Sarkar)
Date: Thu, 2 Mar 2023 14:33:03 +0530
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <20230302113938.26be9522@Tarkus>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
 <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
 <20230302113938.26be9522@Tarkus>
Message-ID: <CADfFDC6CQRJ6fP2vSc+WKibccFN_j1jeKvgptF-Da15MWpomZQ@mail.gmail.com>

On Thu, Mar 2, 2023 at 2:09?PM Ivan Krylov <krylov.r00t at gmail.com> wrote:
>
> There turn out to be a few more things to fix.
>
> One problem is easy to solve: vapply() needs a third argument
> specifying the type of the return value. (Can we have unit tests for
> tab completion?)

There are tests in

src/library/utils/tests/completion.R

which should get run by make check-devel (which runs R CMD check on
all base packages).

> The other problem is harder: `comps` defaults to an empty string, and
> you can't have a symbol consisting of an empty string, because this
> value is internally reserved for missing function arguments. I think
> you can return(paste0(prefix, op)) if length(comps) == 0L, but this is
> still somewhat worrying. R tries to prevent empty names, so I wouldn't
> expect specialOpCompletionsHelper() to return an empty string, but I
> can't prove it right now.
>
> On the other hand, x$'a string' is the same as x$`a string`. Could we
> just drop as.name() and keep the return value being a string literal?
> I'm not sure about this, either.

See my just-posted response on bugzilla for other issues to look out for.

Best,
-Deepayan

> --
> Best regards,
> Ivan
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From ch|r|com @end|ng |rom goog|e@com  Thu Mar  2 10:37:09 2023
From: ch|r|com @end|ng |rom goog|e@com (Michael Chirico)
Date: Thu, 2 Mar 2023 01:37:09 -0800
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <20230302113938.26be9522@Tarkus>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
 <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
 <20230302113938.26be9522@Tarkus>
Message-ID: <CAD7Bkx8YZgYo8bBoYegXQG+vcJmxbTSE+9uMOf8nZ2iOig0q7g@mail.gmail.com>

I personally wouldn't like using a string, and this comment makes me
think it's against the r-core preference as well:

https://bugs.r-project.org/show_bug.cgi?id=18429#c1

Thanks both for catching the sloppy mistake in vapply() :)

Let's continue discussion on the bug/PR.

On Thu, Mar 2, 2023 at 12:39 AM Ivan Krylov <krylov.r00t at gmail.com> wrote:
>
> There turn out to be a few more things to fix.
>
> One problem is easy to solve: vapply() needs a third argument
> specifying the type of the return value. (Can we have unit tests for
> tab completion?)
>
> The other problem is harder: `comps` defaults to an empty string, and
> you can't have a symbol consisting of an empty string, because this
> value is internally reserved for missing function arguments. I think
> you can return(paste0(prefix, op)) if length(comps) == 0L, but this is
> still somewhat worrying. R tries to prevent empty names, so I wouldn't
> expect specialOpCompletionsHelper() to return an empty string, but I
> can't prove it right now.
>
> On the other hand, x$'a string' is the same as x$`a string`. Could we
> just drop as.name() and keep the return value being a string literal?
> I'm not sure about this, either.
>
> --
> Best regards,
> Ivan


From pd@|gd @end|ng |rom gm@||@com  Thu Mar  2 14:18:34 2023
From: pd@|gd @end|ng |rom gm@||@com (peter dalgaard)
Date: Thu, 2 Mar 2023 14:18:34 +0100
Subject: [Rd] confusing all.equal output
In-Reply-To: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
Message-ID: <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>

Yes... Also, of course, the sentence after colon does not the describe the cause of the mismatch, e.g.

> all.equal(c(1,NA,NA), c(NA,NA,3))
[1] "'is.NA' value mismatch: 2 in current 2 in target"

could be confusing. 

Perhaps "is.na() mismatch (2 positions)", with the count calculated as sum(is.na(current) != is.na(target)) instead? 

Or you could give both off-diagonal elements of the confusion matrix:

"target-only: 1, current-only: 1"

but actually, the whole current/target terminology is somewhat unclear.

-pd

> On 1 Mar 2023, at 13:53 , Antoine Fabri <antoine.fabri at gmail.com> wrote:
> 
> dear r-devel,
> 
> This has probably been forever like this but is this satisfying ?
> 
> all.equal(c(1,NA,NA), c(1,NA,3))
> #> [1] "'is.NA' value mismatch: 1 in current 2 in target"
> 
> is.NA() doesn't exist (is.na() does), and is.na() is never 1 or 2.
> 
> In this example it's obvious that we're counting missing values, in a
> general situation I believe it isn't (we might understand it as the
> position of the first NA for instance).
> 
> I would expect something like "'amount of missing values mismatch: 1 in
> current 2 in target"
> 
> Thanks,
> 
> Antoine
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From kry|ov@r00t @end|ng |rom gm@||@com  Thu Mar  2 15:47:50 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Thu, 2 Mar 2023 17:47:50 +0300
Subject: [Rd] `dendrapply` Enhancements
In-Reply-To: <BL0PR04MB4706B185A345A98AB4AB829AD9AC9@BL0PR04MB4706.namprd04.prod.outlook.com>
References: <BL0PR04MB47068D544F5A49315EF1D042D9AB9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <CALK03d1PWiA4tfbRkxMBU6tckhfB2JRGUmnuqh5ygLcCLHDXNw@mail.gmail.com>
 <BL0PR04MB4706A66884728B9419CEAE00D9A89@BL0PR04MB4706.namprd04.prod.outlook.com>
 <BL0PR04MB4706B185A345A98AB4AB829AD9AC9@BL0PR04MB4706.namprd04.prod.outlook.com>
Message-ID: <20230302174750.19c3b247@arachnoid>

Dear Aidan Lakshman,

To answer your implicit question, VECTOR_ELT() unclasses the nodes
because it doesn't go through the stats:::`[[.dendrogram` method,
instead dereferencing the data pointer directly.

Other *apply functions in base R create a call to the `[[` operator,
letting the language dispatch the generic call, allowing the method to
assign a class to the return value. The following example is taken from
src/main/apply.c:do_lapply():

// prepare a call to FUN(X[[i]], ...)

    SEXP isym = install("i");
    SEXP tmp = PROTECT(lang3(R_Bracket2Symbol, X, isym));
    SEXP R_fcall = PROTECT(lang3(FUN, tmp, R_DotsSymbol));
    MARK_NOT_MUTABLE(R_fcall);

// inside the loop: evaluate the call

        tmp = R_forceAndCall(R_fcall, 1, rho);

Not sure which way is faster, but it may make sense to try, and it's
probably more correct in (contrived) cases where unclass(node)[[i]] is
invalid because it relies on a hypothetical `[[.subclass-of-dendrogram`
to restore some invariants.

Would you mind telling me more about the following case?

> if(!(inherits(res,c('dendrogram', 'list')))){
>  res1 <- lapply(unclass(node), \(x) x)
> }

If you're looking to improve the performance, there might be a way to
avoid the wrapper and this lapply(unclass(node), identity) call in it.

-- 
Best regards,
Ivan


From AHL27 @end|ng |rom p|tt@edu  Thu Mar  2 16:38:20 2023
From: AHL27 @end|ng |rom p|tt@edu (Lakshman, Aidan H)
Date: Thu, 2 Mar 2023 15:38:20 +0000
Subject: [Rd] `dendrapply` Enhancements
In-Reply-To: <20230302174750.19c3b247@arachnoid>
References: <BL0PR04MB47068D544F5A49315EF1D042D9AB9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <CALK03d1PWiA4tfbRkxMBU6tckhfB2JRGUmnuqh5ygLcCLHDXNw@mail.gmail.com>
 <BL0PR04MB4706A66884728B9419CEAE00D9A89@BL0PR04MB4706.namprd04.prod.outlook.com>
 <BL0PR04MB4706B185A345A98AB4AB829AD9AC9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <20230302174750.19c3b247@arachnoid>
Message-ID: <BL0PR04MB47069CCBD8C6EB57BB22533ED9B29@BL0PR04MB4706.namprd04.prod.outlook.com>

Thanks for your reply!

> To answer your implicit question, VECTOR_ELT() unclasses the nodes
> because it doesn't go through the stats:::`[[.dendrogram` method,
> instead dereferencing the data pointer directly.

That?s roughly what I had suspected?I appreciate the clarification.

To your point on other *apply functions, I wasn?t actually aware of that implementation, but it?s definitely a smarter way to do it. I?ll try later today/tomorrow to incorporate that method; it seems much better and more future-proof than my approach. Definitely agree with you with respect to cases where unclass(node)[[i]] is invalid. It may be slightly slower due to having to rely on R method dispatch, but I think the benefits outweigh the drawbacks in this case.

> Would you mind telling me more about the following case?

> > if(!(inherits(res,c('dendrogram', 'list')))){
> >   res1 <- lapply(unclass(node), \(x) x)
> > }

> If you're looking to improve the performance, there might be a way to
> avoid the wrapper and this lapply(unclass(node), identity) call in it.

This was a product of trying to get performance to be the same as in the current method?I agree that it?s probably not the best way to do this. The use-case is when you apply a function to the dendrogram that doesn?t return a dendrogram object. One example is the one from reg-tests-1c.R:

```
D <- as.dendrogram(hclust(dist(cbind(setNames(c(0,1,4), LETTERS[1:3])))))

dendrapply(D, labels))



# Expected result:

#
# [[1]]

# ?C?
#
# [[2]]
# [[2]][[1]]
# ?A?

#

# [[2]][[2]]

# ?B?

#

# [[3]]

# ?C?
```

Applying labels to the root node returns c(?C?, ?A?, ?B?), and if we convert that to a list, we get a length 3 list of length 1 character vectors. However, when traversing the dendrogram pre-order, this would break things, since then the first entry of the node is no longer a dendrogram object, it?s been replaced by a character vector. I had written it this way with the unclass so that I could replace entries that needed to be evaluated at child nodes with child nodes. For example, in this instance, after evaluating the function at the root, the tree would look like:

```
[[1]]
<unclassed D[[1]]>

[[2]]
<unclassed D[[2]]>

[[3]]
?B?
```

To answer the question on why there?s an lapply(?, identity) call, I think I ended up doing it this way because I was having some issues with not getting the elements to populate correctly from the dendrogram. Looking back on it now, there?s definitely an easier way to do this that isn?t so hard to understand code-wise?.
```
if(!is.leaf(node)){
      if(!is.list(res)){
        res <- as.list(res)
      }
      res[seq_along(node)] <- node
    }
```
That should perform almost identically and make more sense, with the added benefit that it doesn?t unclass the child nodes, so (when I also incorporate the other fix you suggested) we shouldn?t have any unexpected performance from functions relying on a hypothetical `subclass-of-dendrogram`. This implementation is also slightly faster due to no lapply call and is.list() over inherits(?).

Result after applying to root node with this approach:
```
[[1]]
D[[1]]

[[2]]
D[[2]]

[[3]]
?B?
```
Classes of D[[1]] and D[[2]] are preserved for future evaluations.

Thanks for pointing this out, I?ll incorporate this into the code when I check the `[[` case later. If you have any other questions/comments/suggestions I would love to hear them! Happy to clarify further as well if I didn?t answer your questions fully.

Sincerely,
Aidan

-----------------------
Aidan Lakshman (he/him)<https://www.ahl27.com/>
Doctoral Candidate, Wright Lab<https://www.wrightlabscience.com/>
University of Pittsburgh School of Medicine
Department of Biomedical Informatics
ahl27 at pitt.edu
(724) 612-9940


From: Ivan Krylov <krylov.r00t at gmail.com>
Date: Thursday, March 2, 2023 at 09:47
To: Lakshman, Aidan H <AHL27 at pitt.edu>
Cc: R-devel at r-project.org <R-devel at r-project.org>
Subject: Re: [Rd] `dendrapply` Enhancements
Dear Aidan Lakshman,

To answer your implicit question, VECTOR_ELT() unclasses the nodes
because it doesn't go through the stats:::`[[.dendrogram` method,
instead dereferencing the data pointer directly.

Other *apply functions in base R create a call to the `[[` operator,
letting the language dispatch the generic call, allowing the method to
assign a class to the return value. The following example is taken from
src/main/apply.c:do_lapply():

// prepare a call to FUN(X[[i]], ...)

    SEXP isym = install("i");
    SEXP tmp = PROTECT(lang3(R_Bracket2Symbol, X, isym));
    SEXP R_fcall = PROTECT(lang3(FUN, tmp, R_DotsSymbol));
    MARK_NOT_MUTABLE(R_fcall);

// inside the loop: evaluate the call

        tmp = R_forceAndCall(R_fcall, 1, rho);

Not sure which way is faster, but it may make sense to try, and it's
probably more correct in (contrived) cases where unclass(node)[[i]] is
invalid because it relies on a hypothetical `[[.subclass-of-dendrogram`
to restore some invariants.

Would you mind telling me more about the following case?

> if(!(inherits(res,c('dendrogram', 'list')))){
>  res1 <- lapply(unclass(node), \(x) x)
> }

If you're looking to improve the performance, there might be a way to
avoid the wrapper and this lapply(unclass(node), identity) call in it.

--
Best regards,
Ivan

	[[alternative HTML version deleted]]


From @nto|ne@|@br| @end|ng |rom gm@||@com  Thu Mar  2 18:23:12 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Thu, 2 Mar 2023 18:23:12 +0100
Subject: [Rd] confusing all.equal output
In-Reply-To: <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
 <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
Message-ID: <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>

Good points. I don't mind the terminology since target and current are the
names of the arguments. As the function is already designed to stop at the
first failing check we might not need to enumerate or count the mismatches,
instead we could have "`NA` found in `target` but not in `current` at
position <FIRST_MISMATCH>"

	[[alternative HTML version deleted]]


From w||||@mwdun|@p @end|ng |rom gm@||@com  Thu Mar  2 18:39:24 2023
From: w||||@mwdun|@p @end|ng |rom gm@||@com (Bill Dunlap)
Date: Thu, 2 Mar 2023 09:39:24 -0800
Subject: [Rd] tab-complete for non-syntactic names could attempt
 backtick-wrapping
In-Reply-To: <20230302113938.26be9522@Tarkus>
References: <CAD7Bkx_=noLWcQLFps7HMxQw65e4_+3O=Rtr158ttgfnCbyskw@mail.gmail.com>
 <20230301125647.765cda59@arachnoid>
 <CAD7Bkx-Mvh-3R62WARmSDqTwb94oCT9yLMzXAHVbZTU1xKTQfw@mail.gmail.com>
 <20230302113938.26be9522@Tarkus>
Message-ID: <CAHqSRuRaASWG-Dka76Vb4J9JXWJJKssN8ZfHjt=gQf6RmTaduQ@mail.gmail.com>

x$`string` is not the same as x$'string'.  They may act similarly now, but
they do not parse the same.

> vapply(as.list(quote(list$`component`)), typeof, "")
[1] "symbol" "symbol" "symbol"
> vapply(as.list(quote(list$"component")), typeof, "")
[1] "symbol"    "symbol"    "character"
> vapply(as.list(quote(list$'component')), typeof, "")
[1] "symbol"    "symbol"    "character"

Single and double quoted character sequences do parse to the same thing
(character) but backquoted ones parse to symbols (aka names).

-Bill

On Thu, Mar 2, 2023 at 12:39?AM Ivan Krylov <krylov.r00t at gmail.com> wrote:

> There turn out to be a few more things to fix.
>
> One problem is easy to solve: vapply() needs a third argument
> specifying the type of the return value. (Can we have unit tests for
> tab completion?)
>
> The other problem is harder: `comps` defaults to an empty string, and
> you can't have a symbol consisting of an empty string, because this
> value is internally reserved for missing function arguments. I think
> you can return(paste0(prefix, op)) if length(comps) == 0L, but this is
> still somewhat worrying. R tries to prevent empty names, so I wouldn't
> expect specialOpCompletionsHelper() to return an empty string, but I
> can't prove it right now.
>
> On the other hand, x$'a string' is the same as x$`a string`. Could we
> just drop as.name() and keep the return value being a string literal?
> I'm not sure about this, either.
>
> --
> Best regards,
> Ivan
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From @nto|ne@|@br| @end|ng |rom gm@||@com  Thu Mar  2 18:49:52 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Thu, 2 Mar 2023 18:49:52 +0100
Subject: [Rd] transform.data.frame() ignores unnamed arguments when no named
 argument is provided
Message-ID: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>

Dear r-devel,

See below:


transform(data.frame(a = 1), 2, 3)

#>   a

#> 1 1


transform(data.frame(a = 1), b=2, 3)

#>   a b X3

#> 1 1 2  3


We need a small modification to make it work consistently, see below:


transform.data.frame <- function (`_data`, ...) {

  e <- eval(substitute(list(...)), `_data`, parent.frame())

  tags <- names(e)

  ## NEW LINE -----------------------------------------------

  if (is.null(tags)) tags <- character(length(e))

  inx <- match(tags, names(`_data`))

  matched <- !is.na(inx)

  if (any(matched)) {

    `_data`[inx[matched]] <- e[matched]

    `_data` <- data.frame(`_data`)

  }

  if (!all(matched))

    do.call("data.frame", c(list(`_data`), e[!matched]))

  else `_data`

}


transform(data.frame(a = 1), 2, 3)

#>   a X2 X3

#> 1 1  2  3

transform(data.frame(a = 1), b=2, 3)

#>   a b X3

#> 1 1 2  3


Thanks,


Antoine

	[[alternative HTML version deleted]]


From @vi@e@gross m@iii@g oii gm@ii@com  Thu Mar  2 19:30:42 2023
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Thu, 2 Mar 2023 13:30:42 -0500
Subject: [Rd] confusing all.equal output
In-Reply-To: <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
 <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
 <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>
Message-ID: <001d01d94d35$187fbb90$497f32b0$@gmail.com>

I think if you step back, you can ask what the purpose of an error message
is and who designs it.

Is the message for the developer or others on their team or something an
end-user knowing nothing about R will see.

This reminds me a bit of legal mumbo jumbo that turns many reading it off as
it keeps talking about the party of the first part or the plaintiff as
compared to somewhat straighter talk.

The scenario is that you are comparing two things. Their names are not
things like "target" or "current" so even other programmers not involved in
your code will pause and wonder.

One view is to use phrases like first and second arguments/lists/whatever.
You might talk about the one on the left (but using LHS is a bit opaque)
versus the one on the right. 

But sometimes it can be too verbose. Sometimes the error message is being
generated not where everything is clear.

So ideally you could say:

WARNING Danger Will Robinson.
Comparing two things for equality.
Result finds mismatches.
There were NA found on the (left or right) that were not matched on the
other side.
Number of such found: 2

If you had a Systems Engineer write detailed requirements that included
something a bit better than the example and the programmer was able to
supply the data using the words and guidelines, it might fit some needs but
maybe not satisfy other programmers. But there are human factors people
whose job it is to help choose among alternatives and although they may not
choose well, letting a programmer come up with whatever they feel like is
generally worse. 

Yes, in their microcosm centered on a dozen lines of code, "current" and
"target" may have meaning. But are they the intended user of the product?

-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Antoine Fabri
Sent: Thursday, March 2, 2023 12:23 PM
To: peter dalgaard <pdalgd at gmail.com>
Cc: R-devel <r-devel at r-project.org>
Subject: Re: [Rd] confusing all.equal output

Good points. I don't mind the terminology since target and current are the
names of the arguments. As the function is already designed to stop at the
first failing check we might not need to enumerate or count the mismatches,
instead we could have "`NA` found in `target` but not in `current` at
position <FIRST_MISMATCH>"

	[[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From pd@|gd @end|ng |rom gm@||@com  Thu Mar  2 19:47:59 2023
From: pd@|gd @end|ng |rom gm@||@com (peter dalgaard)
Date: Thu, 2 Mar 2023 19:47:59 +0100
Subject: [Rd] confusing all.equal output
In-Reply-To: <001d01d94d35$187fbb90$497f32b0$@gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
 <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
 <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>
 <001d01d94d35$187fbb90$497f32b0$@gmail.com>
Message-ID: <B97B1379-B884-4DBF-A926-82789F81B93B@gmail.com>

I believe the wording goes back to Martin Maechler many moons ago (AFAICT towards the end of the last millennium.)

We might leave it to him to change it?

- Peter D.

> On 2 Mar 2023, at 19:30 , avi.e.gross at gmail.com wrote:
> 
> I think if you step back, you can ask what the purpose of an error message
> is and who designs it.
> 
> Is the message for the developer or others on their team or something an
> end-user knowing nothing about R will see.
> 
> This reminds me a bit of legal mumbo jumbo that turns many reading it off as
> it keeps talking about the party of the first part or the plaintiff as
> compared to somewhat straighter talk.
> 
> The scenario is that you are comparing two things. Their names are not
> things like "target" or "current" so even other programmers not involved in
> your code will pause and wonder.
> 
> One view is to use phrases like first and second arguments/lists/whatever.
> You might talk about the one on the left (but using LHS is a bit opaque)
> versus the one on the right. 
> 
> But sometimes it can be too verbose. Sometimes the error message is being
> generated not where everything is clear.
> 
> So ideally you could say:
> 
> WARNING Danger Will Robinson.
> Comparing two things for equality.
> Result finds mismatches.
> There were NA found on the (left or right) that were not matched on the
> other side.
> Number of such found: 2
> 
> If you had a Systems Engineer write detailed requirements that included
> something a bit better than the example and the programmer was able to
> supply the data using the words and guidelines, it might fit some needs but
> maybe not satisfy other programmers. But there are human factors people
> whose job it is to help choose among alternatives and although they may not
> choose well, letting a programmer come up with whatever they feel like is
> generally worse. 
> 
> Yes, in their microcosm centered on a dozen lines of code, "current" and
> "target" may have meaning. But are they the intended user of the product?
> 
> -----Original Message-----
> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Antoine Fabri
> Sent: Thursday, March 2, 2023 12:23 PM
> To: peter dalgaard <pdalgd at gmail.com>
> Cc: R-devel <r-devel at r-project.org>
> Subject: Re: [Rd] confusing all.equal output
> 
> Good points. I don't mind the terminology since target and current are the
> names of the arguments. As the function is already designed to stop at the
> first failing check we might not need to enumerate or count the mismatches,
> instead we could have "`NA` found in `target` but not in `current` at
> position <FIRST_MISMATCH>"
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From @eb@meyer @end|ng |rom |@u@de  Thu Mar  2 22:34:33 2023
From: @eb@meyer @end|ng |rom |@u@de (Sebastian Meyer)
Date: Thu, 2 Mar 2023 22:34:33 +0100
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
Message-ID: <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>

Note that ?transform.data.frame says arguments need to be named, so you 
are testing unspecified behaviour. I guess this falls in a similar 
category as the note

      If some of the values are not vectors of the appropriate length,
      you deserve whatever you get!

Experiments for a related Problem Report 
(<https://bugs.r-project.org/show_bug.cgi?id=17890>) showed that 
packages bravely ignore the caveats mentioned on the help page, 
including to assume recycling the rows of the input data frame. I didn't 
yet see any uses of unnamed arguments, though.

That said, I agree that transform.data.frame() should be improved. Maybe 
unnamed arguments should always be ignored with a warning. My feeling is 
that these would more often be usage errors than intentional, e.g.:

 > data.frame(a = 1) |> transform(b = 2, a + 2)  # "forgetting" a=
   a b X3
1 1 2  3

I also think the implicit check.names=TRUE behaviour should be disabled. In

 > list2DF(list(`A-1` = 1)) |> transform(B = 2)
   A.1 B
1   1 2

transforming B should not touch the other columns.

I'm less sure about some other forms of undocumented behaviour as 
described in Comment 6 of the linked PR.

	Sebastian Meyer


Am 02.03.23 um 18:49 schrieb Antoine Fabri:
> Dear r-devel,
> 
> See below:
> 
> 
> transform(data.frame(a = 1), 2, 3)
> 
> #>   a
> 
> #> 1 1
> 
> 
> transform(data.frame(a = 1), b=2, 3)
> 
> #>   a b X3
> 
> #> 1 1 2  3
> 
> 
> We need a small modification to make it work consistently, see below:
> 
> 
> transform.data.frame <- function (`_data`, ...) {
> 
>    e <- eval(substitute(list(...)), `_data`, parent.frame())
> 
>    tags <- names(e)
> 
>    ## NEW LINE -----------------------------------------------
> 
>    if (is.null(tags)) tags <- character(length(e))
> 
>    inx <- match(tags, names(`_data`))
> 
>    matched <- !is.na(inx)
> 
>    if (any(matched)) {
> 
>      `_data`[inx[matched]] <- e[matched]
> 
>      `_data` <- data.frame(`_data`)
> 
>    }
> 
>    if (!all(matched))
> 
>      do.call("data.frame", c(list(`_data`), e[!matched]))
> 
>    else `_data`
> 
> }
> 
> 
> transform(data.frame(a = 1), 2, 3)
> 
> #>   a X2 X3
> 
> #> 1 1  2  3
> 
> transform(data.frame(a = 1), b=2, 3)
> 
> #>   a b X3
> 
> #> 1 1 2  3
> 
> 
> Thanks,
> 
> 
> Antoine
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @nto|ne@|@br| @end|ng |rom gm@||@com  Thu Mar  2 23:01:41 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Thu, 2 Mar 2023 23:01:41 +0100
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
Message-ID: <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>

Thanks and good point about unspecified behavior. The way it behaves now
(when it doesn't ignore) is more consistent with data.frame() though so I
prefer that to a "warn and ignore" behaviour:

data.frame(a = 1, b = 2, 3)

#>   a b X3

#> 1 1 2  3


data.frame(a = 1, 2, 3)

#>   a X2 X3

#> 1 1  2  3


(and in general warnings make for unpleasant debugging so I prefer when we
don't add new ones if avoidable)


playing a bit more with it, it would make sense to me that the following
have the same output:


coefficient <- 3


data.frame(value1 = 5) |> transform(coefficient, value2 = coefficient *
value1)

#>   value1 X3 value2

#> 1      5  3     15


data.frame(value1 = 5, coefficient) |> transform(value2 = coefficient *
value1)

#>   value1 coefficient value2

#> 1      5           3     15

	[[alternative HTML version deleted]]


From g@bembecker @end|ng |rom gm@||@com  Thu Mar  2 23:37:18 2023
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Thu, 2 Mar 2023 14:37:18 -0800
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
Message-ID: <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>

On Thu, Mar 2, 2023 at 2:02?PM Antoine Fabri <antoine.fabri at gmail.com>
wrote:

> Thanks and good point about unspecified behavior. The way it behaves now
> (when it doesn't ignore) is more consistent with data.frame() though so I
> prefer that to a "warn and ignore" behaviour:
>
> data.frame(a = 1, b = 2, 3)
>
> #>   a b X3
>
> #> 1 1 2  3
>
>
> data.frame(a = 1, 2, 3)
>
> #>   a X2 X3
>
> #> 1 1  2  3
>
>
> (and in general warnings make for unpleasant debugging so I prefer when we
> don't add new ones if avoidable)
>

I find silence to be much more unpleasant in practice when debugging,
myself, but that may be a personal preference.


>
>
> playing a bit more with it, it would make sense to me that the following
> have the same output:
>
>
> coefficient <- 3
>
>
> data.frame(value1 = 5) |> transform(coefficient, value2 = coefficient *
> value1)
>
> #>   value1 X3 value2
>
> #> 1      5  3     15
>
>
> data.frame(value1 = 5, coefficient) |> transform(value2 = coefficient *
> value1)
>
> #>   value1 coefficient value2
>
> #> 1      5           3     15
>
>
I'm not so sure. data.frame() is doing some substitute magic to get the
column name coefficient there.

> coefficient = 3

> data.frame(value1 = 5, coefficient)

  value1 coefficient

1      5           3

Beyond that these two pieces of code are doing subtly but crucially
different things; in the latter, coefficient is a variable in the
data.frame, and when transform resolves that symbol during calculation of
value2, it *gets the column in the incoming data.frame*.

In the former case, coefficient does not exist in the data.frame, so the
symbol is being resolved somewhere else in the scope chain (in this case,
the global environment).

These happen to be the same, except for the column name , but we can see
the difference if we change the code to

> coefficient <- 3

> data.frame(value1 = 5, coefficient = 4)  |> transform(value2 = value1 *
coefficient)

  value1 coefficient value2

1      5           4     20

> data.frame(value1 = 5) |> transform(coefficient = 4, value2 = value1 *
coefficient)

  value1 coefficient *value2*

1      5           4     *15*

Please note that another way this difference could rear its head is if
these arent' directly one after eachother in a pipe:

> coefficient <- 3

> df1 <- data.frame(value1 = 5, coefficient)

> coefficient <- 4

> df2 <- data.frame(value1 = 5)

> df1 |> transform(value2 = value1 * coefficient)

  value1 coefficient value2

1      5           3     15

> df2 |> transform(coefficient, value2 = value1 * coefficient)

  value1 X4 value2

1      5  4     20


Cause you know someday the place where you do that transform and the place
where coefficient is initially set are gonna be far away from eachother, so
whether you put coefficient into the incoming data, or don't will matter.


Best,
~G

        [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Fri Mar  3 16:25:30 2023
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Fri, 3 Mar 2023 16:25:30 +0100
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
Message-ID: <25602.4458.303335.397238@stat.math.ethz.ch>

>>>>> Gabriel Becker 
>>>>>     on Thu, 2 Mar 2023 14:37:18 -0800 writes:

    > On Thu, Mar 2, 2023 at 2:02?PM Antoine Fabri
    > <antoine.fabri at gmail.com> wrote:

    >> Thanks and good point about unspecified behavior. The way
    >> it behaves now (when it doesn't ignore) is more
    >> consistent with data.frame() though so I prefer that to a
    >> "warn and ignore" behaviour:
    >> 
    >> data.frame(a = 1, b = 2, 3)
    >> 
    >> #> a b X3
    >> 
    >> #> 1 1 2 3
    >> 
    >> 
    >> data.frame(a = 1, 2, 3)
    >> 
    >> #> a X2 X3
    >> 
    >> #> 1 1 2 3
    >> 
    >> 
    >> (and in general warnings make for unpleasant debugging so
    >> I prefer when we don't add new ones if avoidable)
    >> 

    > I find silence to be much more unpleasant in practice when
    > debugging, myself, but that may be a personal preference.

+1

I also *strongly* disagree with the claim

   " in general warnings make for unpleasant debugging "

That may be true for beginners (for whom debugging is often not really
feasible anyway ..), but somewhat experienced useRs should know

about
    options(warn = 1) # or
    options(warn = 2) # plus  options(error = recover) #
or
    tryCatch( ...,  warning = ..)

or  {even more}

Martin

--
Martin Maechler
ETH Zurich  and  R Core team


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Fri Mar  3 18:01:06 2023
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Fri, 3 Mar 2023 18:01:06 +0100
Subject: [Rd] confusing all.equal output
In-Reply-To: <B97B1379-B884-4DBF-A926-82789F81B93B@gmail.com>
References: <CAEKh8uj-pp63WGDvG7YtsMqrMnqHUcWq0Ex2ObPxOPzEh3hLxQ@mail.gmail.com>
 <0C58DB1A-E9CC-4CDC-9A06-9BCD3303409A@gmail.com>
 <CAEKh8ugAEttrCqNjgRDny9DQvQdfOpSqvbsyYNunE6d6+y7q8g@mail.gmail.com>
 <001d01d94d35$187fbb90$497f32b0$@gmail.com>
 <B97B1379-B884-4DBF-A926-82789F81B93B@gmail.com>
Message-ID: <25602.10194.172872.572433@stat.math.ethz.ch>

>>>>> peter dalgaard 
>>>>>     on Thu, 2 Mar 2023 19:47:59 +0100 writes:

    > I believe the wording goes back to Martin Maechler many
    > moons ago (AFAICT towards the end of the last millennium.)
    > We might leave it to him to change it?
    > - Peter D.

Thank you, Peter.

Yes, this is *very* old.  I could claim that R users seem to get
more and more confused over time, because nobody had ever
complained for a quarter of a century .. (;-) ;-)

I know I had been inspired by the all.equal() implementation of
S-PLUS version 3.x (x = 4, IIRC) at the time, but then I also think
that I have to take the "full blame" on this :

Trying to think like myself "yesterday, when I was young ..",
I guess the argumentation for using  is.NA  was what I
considered helpful to the non experienced S / R user at the time:
Everybody has seen 'NA' before (and they see it in their objects
in this case) but only somewhat more experienced useRs would
know about is.na(). .. and it may be that at the time I found it
"slick" to combine the "NA" and "is.na" into  "is.NA" ...

About the other wording and how the mismatches should be counted, I
have no recollection.

But indeed, already in 1999, i.e., before R 1.0.0 existed,
that part of the code was

    out <- is.na(target)
    if(any(out != is.na(current)))
	return(paste("`is.NA' value mismatches:", sum(is.na(current)),
		     "in current,", sum(out), " in target"))

- - - 

Ok, now I need to work to commit a (completely orthogonal) change to
all.equal.numeric()  which had been lying around with me for
about a year at least... so I can start looking at your proposed
changes ...

Martin


    >> On 2 Mar 2023, at 19:30 , avi.e.gross at gmail.com wrote:
    >> 
    >> I think if you step back, you can ask what the purpose of
    >> an error message is and who designs it.
    >> 
    >> Is the message for the developer or others on their team
    >> or something an end-user knowing nothing about R will
    >> see.
    >> 
    >> This reminds me a bit of legal mumbo jumbo that turns
    >> many reading it off as it keeps talking about the party
    >> of the first part or the plaintiff as compared to
    >> somewhat straighter talk.
    >> 
    >> The scenario is that you are comparing two things. Their
    >> names are not things like "target" or "current" so even
    >> other programmers not involved in your code will pause
    >> and wonder.
    >> 
    >> One view is to use phrases like first and second
    >> arguments/lists/whatever.  You might talk about the one
    >> on the left (but using LHS is a bit opaque) versus the
    >> one on the right.
    >> 
    >> But sometimes it can be too verbose. Sometimes the error
    >> message is being generated not where everything is clear.
    >> 
    >> So ideally you could say:
    >> 
    >> WARNING Danger Will Robinson.  Comparing two things for
    >> equality.  Result finds mismatches.  There were NA found
    >> on the (left or right) that were not matched on the other
    >> side.  Number of such found: 2
    >> 
    >> If you had a Systems Engineer write detailed requirements
    >> that included something a bit better than the example and
    >> the programmer was able to supply the data using the
    >> words and guidelines, it might fit some needs but maybe
    >> not satisfy other programmers. But there are human
    >> factors people whose job it is to help choose among
    >> alternatives and although they may not choose well,
    >> letting a programmer come up with whatever they feel like
    >> is generally worse.
    >> 
    >> Yes, in their microcosm centered on a dozen lines of
    >> code, "current" and "target" may have meaning. But are
    >> they the intended user of the product?
    >> 
    >> -----Original Message----- From: R-devel
    >> <r-devel-bounces at r-project.org> On Behalf Of Antoine
    >> Fabri Sent: Thursday, March 2, 2023 12:23 PM To: peter
    >> dalgaard <pdalgd at gmail.com> Cc: R-devel
    >> <r-devel at r-project.org> Subject: Re: [Rd] confusing
    >> all.equal output
    >> 
    >> Good points. I don't mind the terminology since target
    >> and current are the names of the arguments. As the
    >> function is already designed to stop at the first failing
    >> check we might not need to enumerate or count the
    >> mismatches, instead we could have "`NA` found in `target`
    >> but not in `current` at position <FIRST_MISMATCH>"
    >> 
    >> [[alternative HTML version deleted]]
    >> 
    >> ______________________________________________
    >> R-devel at r-project.org mailing list
    >> https://stat.ethz.ch/mailman/listinfo/r-devel
    >> 
    >> ______________________________________________
    >> R-devel at r-project.org mailing list
    >> https://stat.ethz.ch/mailman/listinfo/r-devel

    > -- 
    > Peter Dalgaard, Professor, Center for Statistics,
    > Copenhagen Business School Solbjerg Plads 3, 2000
    > Frederiksberg, Denmark Phone: (+45)38153501 Office: A 4.23
    > Email: pd.mes at cbs.dk Priv: PDalgd at gmail.com


From @nto|ne@|@br| @end|ng |rom gm@||@com  Fri Mar  3 18:17:18 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Fri, 3 Mar 2023 18:17:18 +0100
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <25602.4458.303335.397238@stat.math.ethz.ch>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
 <25602.4458.303335.397238@stat.math.ethz.ch>
Message-ID: <CAEKh8uh2pY5N98eufV2DX01wfCp++rMDSEPwXA-AUCogHBkDGA@mail.gmail.com>

Let me expand a bit, I might have expressed myself poorly.

 If there is a good reason for a warning I want a warning, and because I
take them seriously I don't want my console cluttered with those that can
be avoided. I strongly believe we should strive to make our code silent,
and I like my console to tell me only what I need to know. In my opinion
many warnings would be better designed as errors, sometimes with an
argument to opt in the behaviour, or a documented way to work around. Some
other warnings should just be documented behavior, because the behavior is
not all that surprising.

Some reasons why I find warnings hard to debug:
- options(warn = 1) is not always enough to spot the source of the warning
- options(warn = 2) fails at every warning, including the ones that are not
interesting to the user and that they may not do anything about, in these
cases you'll have to find a way to shut off the first to get to the second,
and if it's packaged code that's not fun.
- Unlike with errors, traceback() won't help.
- tryCatch() will help you only if you call it at the right place, assuming
you've found it.
- We might also have many harmless warnings triggered through loops and
hiding important ones.
- When you are sure that you are OK with your code despite the warning, say
`as.numeric(c("1", "2", "foo"))`, a workaround might be expensive (here we
could use regex first to ditch the non numeric strings but who does that)
so you're tempted to use `suppressWarnings()`, but then you might be
suppressing other important warnings so you just made your code less safe
because the developper wanted to make it safer (you might say it's on the
user but still, we get suboptimal code that was avoidable).

Of course I might miss some approaches that would make my experience of
debugging warnings more pleasant.

In our precise case I don't find the behavior surprising enough to warrant
more precious red ink since it's close to what we get with data.frame(),
and close to what we get with dplyr::mutate() FWIW, so I'd be personally
happier to have this documented and work silently.

Either way I appreciate you considering the problem.

Thanks,

Antoine

	[[alternative HTML version deleted]]


From bbo|ker @end|ng |rom gm@||@com  Fri Mar  3 21:58:30 2023
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Fri, 3 Mar 2023 15:58:30 -0500
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <CAEKh8uh2pY5N98eufV2DX01wfCp++rMDSEPwXA-AUCogHBkDGA@mail.gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
 <25602.4458.303335.397238@stat.math.ethz.ch>
 <CAEKh8uh2pY5N98eufV2DX01wfCp++rMDSEPwXA-AUCogHBkDGA@mail.gmail.com>
Message-ID: <CABghstT+5CX8f15X8zTFp_DgKGwe6g2F6=g9bJvworFhyLXHTQ@mail.gmail.com>

   For what it's worth I think the increased emphasis on classed
errors should help with this (i.e., it will be easier to filter out
errors you know are false positives/irrelevant for your use case).

On Fri, Mar 3, 2023 at 12:17?PM Antoine Fabri <antoine.fabri at gmail.com> wrote:
>
> Let me expand a bit, I might have expressed myself poorly.
>
>  If there is a good reason for a warning I want a warning, and because I
> take them seriously I don't want my console cluttered with those that can
> be avoided. I strongly believe we should strive to make our code silent,
> and I like my console to tell me only what I need to know. In my opinion
> many warnings would be better designed as errors, sometimes with an
> argument to opt in the behaviour, or a documented way to work around. Some
> other warnings should just be documented behavior, because the behavior is
> not all that surprising.
>
> Some reasons why I find warnings hard to debug:
> - options(warn = 1) is not always enough to spot the source of the warning
> - options(warn = 2) fails at every warning, including the ones that are not
> interesting to the user and that they may not do anything about, in these
> cases you'll have to find a way to shut off the first to get to the second,
> and if it's packaged code that's not fun.
> - Unlike with errors, traceback() won't help.
> - tryCatch() will help you only if you call it at the right place, assuming
> you've found it.
> - We might also have many harmless warnings triggered through loops and
> hiding important ones.
> - When you are sure that you are OK with your code despite the warning, say
> `as.numeric(c("1", "2", "foo"))`, a workaround might be expensive (here we
> could use regex first to ditch the non numeric strings but who does that)
> so you're tempted to use `suppressWarnings()`, but then you might be
> suppressing other important warnings so you just made your code less safe
> because the developper wanted to make it safer (you might say it's on the
> user but still, we get suboptimal code that was avoidable).
>
> Of course I might miss some approaches that would make my experience of
> debugging warnings more pleasant.
>
> In our precise case I don't find the behavior surprising enough to warrant
> more precious red ink since it's close to what we get with data.frame(),
> and close to what we get with dplyr::mutate() FWIW, so I'd be personally
> happier to have this documented and work silently.
>
> Either way I appreciate you considering the problem.
>
> Thanks,
>
> Antoine
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From p@kr|v|t@ky @end|ng |rom un@w@edu@@u  Sat Mar  4 01:21:48 2023
From: p@kr|v|t@ky @end|ng |rom un@w@edu@@u (Pavel Krivitsky)
Date: Sat, 4 Mar 2023 00:21:48 +0000
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
Message-ID: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>

Dear All,

Currently, list= in base::replace(x, list, value) has to be an index
vector. For me, at least, the most common use case is for list= to be
some simple property of elements of x, e.g.,

x <- c(1,2,NA,3)
replace(x, is.na(x), 0)

Particularly when using R pipes, which don't allow multiple
substitutions, it would simplify many of such cases if list= could be a
function that returns an index, e.g.,

replace <- function (x, list, values, ...) {
  # Here, list() refers to the argument, not the built-in.
  if(is.function(list)) list <- list(x, ...)
  x[list] <- values
  x
}

Then, the following is possible:

c(1,2,NA,3) |> replace(is.na, 0)

			Any thoughts?
			Pavel

From @vi@e@gross m@iii@g oii gm@ii@com  Sat Mar  4 06:06:40 2023
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Sat, 4 Mar 2023 00:06:40 -0500
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <25602.4458.303335.397238@stat.math.ethz.ch>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
 <25602.4458.303335.397238@stat.math.ethz.ch>
Message-ID: <012001d94e57$1b4c0b30$51e42190$@gmail.com>

I am probably mistaken but it looks to me like the design of much of the data.frame infrastructure not only does not insist you give columns names, but even has all kinds of options such as check.names and fix.empty.names

https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/data.frame

During the lifetime of a column, it can get removed, renamed, transfomed in many ways and so on. A data.frame read in from a file such as a .CSV often begins with temporary created names. 

It is so common, that sometimes not giving a name is a choice and not in any way an error. I have seen some rather odd names in backticks that include spaces and seen duplicate names. The reality is you can index by column number two and maybe no actual name was needed by the one creating or modifying the data.

Some placed warnings are welcome as they tend to reflect a possibly serious error.  But that error may not easily be at this point versus later in the game.  If later the program tries to access the misnamed column, then an error makes sense. Warnings, if overused, get old quickly and you regularly see code written to suppress startup messages or warnings because the same message shown every day becomes something you ignore mentally even if not suppressed. How many times has loading the tidyverse reminded me it is shadowing a few base R functions? How many times have I really cared?

What makes some sense to me is to add an argument to some functions BEGGING to be shown the errors of your ways and turn that on as you wish, often after something has gone wrong.

-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Martin Maechler
Sent: Friday, March 3, 2023 10:26 AM
To: Gabriel Becker <gabembecker at gmail.com>
Cc: Antoine Fabri <antoine.fabri at gmail.com>; R-devel <r-devel at r-project.org>
Subject: Re: [Rd] transform.data.frame() ignores unnamed arguments when no named argument is provided

>>>>> Gabriel Becker 
>>>>>     on Thu, 2 Mar 2023 14:37:18 -0800 writes:

    > On Thu, Mar 2, 2023 at 2:02?PM Antoine Fabri
    > <antoine.fabri at gmail.com> wrote:

    >> Thanks and good point about unspecified behavior. The way
    >> it behaves now (when it doesn't ignore) is more
    >> consistent with data.frame() though so I prefer that to a
    >> "warn and ignore" behaviour:
    >> 
    >> data.frame(a = 1, b = 2, 3)
    >> 
    >> #> a b X3
    >> 
    >> #> 1 1 2 3
    >> 
    >> 
    >> data.frame(a = 1, 2, 3)
    >> 
    >> #> a X2 X3
    >> 
    >> #> 1 1 2 3
    >> 
    >> 
    >> (and in general warnings make for unpleasant debugging so
    >> I prefer when we don't add new ones if avoidable)
    >> 

    > I find silence to be much more unpleasant in practice when
    > debugging, myself, but that may be a personal preference.

+1

I also *strongly* disagree with the claim

   " in general warnings make for unpleasant debugging "

That may be true for beginners (for whom debugging is often not really
feasible anyway ..), but somewhat experienced useRs should know

about
    options(warn = 1) # or
    options(warn = 2) # plus  options(error = recover) #
or
    tryCatch( ...,  warning = ..)

or  {even more}

Martin

--
Martin Maechler
ETH Zurich  and  R Core team

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From g@bembecker @end|ng |rom gm@||@com  Sat Mar  4 22:44:03 2023
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Sat, 4 Mar 2023 13:44:03 -0800
Subject: [Rd] 
 transform.data.frame() ignores unnamed arguments when no named
 argument is provided
In-Reply-To: <012001d94e57$1b4c0b30$51e42190$@gmail.com>
References: <CAEKh8ug=Vy=rDkqCEKnrGL4h7A7fPmF_zpcwq2CTybNmOTgNnw@mail.gmail.com>
 <e9c6473a-a005-5236-a616-4c34b596e593@fau.de>
 <CAEKh8uhE=JEWRvio1DqabZ4MyWM7p_7NCmVkQ_6k8Ovy6N22WA@mail.gmail.com>
 <CAD4oTHE43AFFkQFGrL5jDs9U5Jon99ZvYwTTt+6pT5A-2R-FhQ@mail.gmail.com>
 <25602.4458.303335.397238@stat.math.ethz.ch>
 <012001d94e57$1b4c0b30$51e42190$@gmail.com>
Message-ID: <CAD4oTHEgE9+PdpOtvgRV1823OrNW3K-ufqZf=j9D0MPBNiyStA@mail.gmail.com>

Hi Avi,

On Fri, Mar 3, 2023 at 9:07?PM <avi.e.gross at gmail.com> wrote:

> I am probably mistaken but it looks to me like the design of much of the
> data.frame infrastructure not only does not insist you give columns names,
> but even has all kinds of options such as check.names and fix.empty.names
>
>
> https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/data.frame
>
>
I think this is true, but thats for the *construction* of a data.frame,
where as, in my opinion from what I can tell, transform is for operating on
a data.frame that has already been constructed. I'm not personally
convinced the same allowances should be made at this conceptually later
stage in data processing.


> During the lifetime of a column, it can get removed, renamed, transfomed
> in many ways and so on. A data.frame read in from a file such as a .CSV
> often begins with temporary created names.
>
> It is so common, that sometimes not giving a name is a choice and not in
> any way an error. I have seen some rather odd names in backticks that
> include spaces and seen duplicate names. The reality is you can index by
> column number two and maybe no actual name was needed by the one creating
> or modifying the data.
>

You can but this creates brittle, difficult to maintain code to the extent
that I consider this an anti-pattern, and I don't believe I'm alone in that.


>
> Some placed warnings are welcome as they tend to reflect a possibly
> serious error.  But that error may not easily be at this point versus later
> in the game.  If later the program tries to access the misnamed column,
> then an error makes sense. Warnings, if overused, get old quickly and you
> regularly see code written to suppress startup messages or warnings because
> the same message shown every day becomes something you ignore mentally even
> if not suppressed. How many times has loading the tidyverse reminded me it
> is shadowing a few base R functions? How many times have I really cared?
>

I think this is a bad example to make your case on, because symbol masking
is actually *really* important. In bioinformatics, Bioconductor is the
flagship (which sails upon the sea that R provides), but guess what; dplyr
and Bioconductor both define filter, and they do so meaning completely
different incompatible things.

I have seen code that wanted one version and got the other in both
directions, and in neither case is it fun, but without that warning it
would be a dystopian nightmarescape that scarcely bears thinking about.


> What makes some sense to me is to add an argument to some functions
> BEGGING to be shown the errors of your ways and turn that on as you wish,
> often after something has gone wrong.
>


Flipping this on its head, I wonder, alternatively, if there might be a
"strict" mode for transform which errors out on unnamed arguments, instead
of providing the current undefined behavior.

Best,
~G


>
> -----Original Message-----
> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Martin Maechler
> Sent: Friday, March 3, 2023 10:26 AM
> To: Gabriel Becker <gabembecker at gmail.com>
> Cc: Antoine Fabri <antoine.fabri at gmail.com>; R-devel <
> r-devel at r-project.org>
> Subject: Re: [Rd] transform.data.frame() ignores unnamed arguments when no
> named argument is provided
>
> >>>>> Gabriel Becker
> >>>>>     on Thu, 2 Mar 2023 14:37:18 -0800 writes:
>
>     > On Thu, Mar 2, 2023 at 2:02?PM Antoine Fabri
>     > <antoine.fabri at gmail.com> wrote:
>
>     >> Thanks and good point about unspecified behavior. The way
>     >> it behaves now (when it doesn't ignore) is more
>     >> consistent with data.frame() though so I prefer that to a
>     >> "warn and ignore" behaviour:
>     >>
>     >> data.frame(a = 1, b = 2, 3)
>     >>
>     >> #> a b X3
>     >>
>     >> #> 1 1 2 3
>     >>
>     >>
>     >> data.frame(a = 1, 2, 3)
>     >>
>     >> #> a X2 X3
>     >>
>     >> #> 1 1 2 3
>     >>
>     >>
>     >> (and in general warnings make for unpleasant debugging so
>     >> I prefer when we don't add new ones if avoidable)
>     >>
>
>     > I find silence to be much more unpleasant in practice when
>     > debugging, myself, but that may be a personal preference.
>
> +1
>
> I also *strongly* disagree with the claim
>
>    " in general warnings make for unpleasant debugging "
>
> That may be true for beginners (for whom debugging is often not really
> feasible anyway ..), but somewhat experienced useRs should know
>
> about
>     options(warn = 1) # or
>     options(warn = 2) # plus  options(error = recover) #
> or
>     tryCatch( ...,  warning = ..)
>
> or  {even more}
>
> Martin
>
> --
> Martin Maechler
> ETH Zurich  and  R Core team
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From @oko| @end|ng |rom |n@@-tou|ou@e@|r  Mon Mar  6 09:45:21 2023
From: @oko| @end|ng |rom |n@@-tou|ou@e@|r (Serguei Sokol)
Date: Mon, 6 Mar 2023 09:45:21 +0100
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
In-Reply-To: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
References: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
Message-ID: <60f31223-033a-21ee-67fd-b1a6566a0278@insa-toulouse.fr>

Le 04/03/2023 ? 01:21, Pavel Krivitsky a ?crit?:
> Dear All,
>
> Currently, list= in base::replace(x, list, value) has to be an index
> vector. For me, at least, the most common use case is for list= to be
> some simple property of elements of x, e.g.,
>
> x <- c(1,2,NA,3)
> replace(x, is.na(x), 0)
>
> Particularly when using R pipes, which don't allow multiple
> substitutions,
Right, but anonymous function syntax can palliate to this:

x |> (\(x) replace(x, is.na(x), 0))()


>   it would simplify many of such cases if list= could be a
> function that returns an index, e.g.,
>
> replace <- function (x, list, values, ...) {
>    # Here, list() refers to the argument, not the built-in.
>    if(is.function(list)) list <- list(x, ...)
>    x[list] <- values
>    x
> }
Before modifying the base of R, we should examine existing possibilities 
to achieve the same goal.
In this particular case and if the previous solution (anonymous 
function) is not satisfactory a thin one-line wrapper can make the job:

freplace <- function (x, list, values, ...) replace(x, 
if(is.function(list)) list <- list(x, ...) else list, values)

>
> Then, the following is possible:
>
> c(1,2,NA,3) |> replace(is.na, 0)
this becomes

c(1,2,NA,3) |> freplace(is.na, 0)

and looks quite acceptable for me.

Best,
Serguei.

>
> 			Any thoughts?
> 			Pavel
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


-- 
Serguei Sokol
Ingenieur de recherche INRAE

Cellule Math?matiques
TBI, INSA/INRAE UMR 792, INSA/CNRS UMR 5504
135 Avenue de Rangueil
31077 Toulouse Cedex 04

tel: +33 5 61 55 98 49
email: sokol at insa-toulouse.fr
http://www.toulouse-biotechnology-institute.fr/en/technology_platforms/mathematics-cell.html


From p@kr|v|t@ky @end|ng |rom un@w@edu@@u  Tue Mar  7 11:49:41 2023
From: p@kr|v|t@ky @end|ng |rom un@w@edu@@u (Pavel Krivitsky)
Date: Tue, 7 Mar 2023 10:49:41 +0000
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
In-Reply-To: <60f31223-033a-21ee-67fd-b1a6566a0278@insa-toulouse.fr>
References: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
 <60f31223-033a-21ee-67fd-b1a6566a0278@insa-toulouse.fr>
Message-ID: <d9dc22049a09fdbf55b43b21a947f61dda3d0720.camel@unsw.edu.au>

Dear Serguei,

On Mon, 2023-03-06 at 09:45 +0100, Serguei Sokol wrote:
> Right, but anonymous function syntax can palliate to this:
> 
> x |> (\(x) replace(x, is.na(x), 0))()

This approach hardly makes for concise or readable code.

> 
> Before modifying the base of R, we should examine existing
> possibilities to achieve the same goal.

Backwards-compatible enhancements to existing functions in base R
appear in every major release. In this case, the proposed behaviour of
replace() would be consistent with that of the *apply() family of
functions.

> In this particular case and if the previous solution (anonymous 
> function) is not satisfactory a thin one-line wrapper can make the
> job:
> 
> freplace <- function (x, list, values, ...) replace(x, 
> if(is.function(list)) list <- list(x, ...) else list, values)
> 
> this becomes
> 
> c(1,2,NA,3) |> freplace(is.na, 0)
> 
> and looks quite acceptable for me.

One could always implement a function that has this functionality, of
course. In fact, one could write,

replace <- function (x, list, values, ...) base::replace(x, 
  if(is.function(list)) list <- list(x, ...) else list, values)

and not even have to change the name. However, having to write it every
time defeats the purpose of having it in base in the first place.

				Best Regards,
				Pavel

> 
> Best,
> Serguei.
> 
> > 
> > ????????????????????????Any thoughts?
> > ????????????????????????Pavel
> > ______________________________________________
> > R-devel at r-project.org?mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> 


From ggrothend|eck @end|ng |rom gm@||@com  Tue Mar  7 13:33:56 2023
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Tue, 7 Mar 2023 07:33:56 -0500
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
In-Reply-To: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
References: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
Message-ID: <CAP01uRk2-FWoH9cceJP61ckxte1hGF3VVcwFjF12ouASvoBZ9g@mail.gmail.com>

This could be extended to sub and gsub as well which gsubfn in the
gusbfn package already does:

  library(gsubfn)
  gsubfn("^..", toupper, c("abc", "xyz"))
  ## [1] "ABc" "XYz"

On Fri, Mar 3, 2023 at 7:22?PM Pavel Krivitsky <p.krivitsky at unsw.edu.au> wrote:
>
> Dear All,
>
> Currently, list= in base::replace(x, list, value) has to be an index
> vector. For me, at least, the most common use case is for list= to be
> some simple property of elements of x, e.g.,
>
> x <- c(1,2,NA,3)
> replace(x, is.na(x), 0)
>
> Particularly when using R pipes, which don't allow multiple
> substitutions, it would simplify many of such cases if list= could be a
> function that returns an index, e.g.,
>
> replace <- function (x, list, values, ...) {
>   # Here, list() refers to the argument, not the built-in.
>   if(is.function(list)) list <- list(x, ...)
>   x[list] <- values
>   x
> }
>
> Then, the following is possible:
>
> c(1,2,NA,3) |> replace(is.na, 0)
>
>                         Any thoughts?
>                         Pavel
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From x|e @end|ng |rom y|hu|@n@me  Tue Mar  7 18:35:41 2023
From: x|e @end|ng |rom y|hu|@n@me (Yihui Xie)
Date: Tue, 7 Mar 2023 11:35:41 -0600
Subject: [Rd] 
 Undocumented change of dirname("C:/") on R-devel on Windows
In-Reply-To: <a182c76a-02f1-2ede-5ded-0752e7a618bd@gmail.com>
References: <CALyqOb8-eihVs9FW2AcH42mOCwZj2gLsq=j1sNUSthnf0k7Zow@mail.gmail.com>
 <1db6ce6b-04f0-b890-c320-3e0cbc20a99f@gmail.com>
 <CALyqOb8fuhNtO3QZVO75Zvb91EbV0ZgLvUPRyC6KkVYBWocUQw@mail.gmail.com>
 <CALyqOb8xCA182niry8_OudVw+xVpg=WiPCMsEQZTP=R7Wc2wzw@mail.gmail.com>
 <CANROs4cp5K5ZC3F8UcZa8Togd4EyuRmBiMxQrq4Du2=Asc5pUQ@mail.gmail.com>
 <a182c76a-02f1-2ede-5ded-0752e7a618bd@gmail.com>
Message-ID: <CANROs4df-Y6T-qp+LEqo3_LK67Hz7Xgm=Bgn7w81FEtbfDOuqQ@mail.gmail.com>

Thanks a lot! I can confirm that it has been fixed indeed.

Regards,
Yihui



On Mon, Feb 27, 2023 at 1:14?PM Tomas Kalibera <tomas.kalibera at gmail.com>
wrote:

>
> On 2/27/23 17:02, Yihui Xie wrote:
>
> Hi Tomas,
>
> There has been an R CMD check error with xfun and r-devel on Windows for a
> while:
> https://www.r-project.org/nosvn/R.check/r-devel-windows-x86_64/xfun-00check.html
> Basically it means that the following would return TRUE before:
>
>   normalizePath('a/b', mustWork = FALSE) == normalizePath('./a/b',
> mustWork = FALSE)
>
> but it became FALSE at some point in r-devel. I think 'a/b' and './a/b`
> should be treated as the same path. Does that make sense? Thanks!
>
> Thanks a lot for spotting and reporting this, fixed in R-devel.
> Normalization of non-existent paths was broken.
>
> Best
> Tomas
>
>
> Regards,
> Yihui
> --
> https://yihui.org
>
>
> On Thu, Feb 23, 2023 at 11:44 PM Hiroaki Yutani <yutani.ini at gmail.com>
> wrote:
>
>> I confirmed the revert fixed my failing test. Thanks!
>>
>> 2023?2?23?(?) 20:12 Hiroaki Yutani <yutani.ini at gmail.com>:
>>
>> > Thanks for the prompt response, I'll confirm it after the new R-devel
>> > binary is available.
>> > Also, thanks for the detailed explanation. I agree with you in general.
>> >
>> > > "/" in "C:/" is a path separator or not, and whether it is trailing or
>> > not
>> >
>> > It seems a Windows' path basically consists of two components; a drive
>> > specification (e.g., C:) and the directory structure within the drive.
>> What
>> > I learned today is that both "C:/" and "C:" are valid path
>> specifications,
>> > but refer to different locations; "C:" is not the root directory of the
>> > drive, but just a relative path [1]. So, I agree with you that the
>> basename
>> > of "C:/" should be "C:/". However, at the same time, I don't feel this
>> is
>> > worth a breaking change, so I think we can preserve the current (R
>> 4.2.2)
>> > behavior.
>> >
>> > [1]:
>> >
>> https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats#apply-the-current-directory
>> >
>> > Best,
>> > Yutani
>> >
>> > 2023?2?23?(?) 17:15 Tomas Kalibera <tomas.kalibera at gmail.com>:
>> >
>> >>
>> >> On 2/23/23 03:27, Hiroaki Yutani wrote:
>> >> > Hi,
>> >> >
>> >> > I found dirname() behaves differently on R-devel on Windows. Since
>> I'm
>> >> not
>> >> > sure which behavior is right, let me ask here before filing this to
>> R's
>> >> > Bigzilla.
>> >> >
>> >> > On R 4.2.2., we get
>> >> >
>> >> >      > dirname("C:/")
>> >> >      [1] "C:/"
>> >> >
>> >> > However, on R-devel (r83888), we get
>> >> >
>> >> >      > dirname("C:/")
>> >> >      [1] "."
>> >> >
>> >> > ?dirname says 'dirname returns the part of the path up to but
>> excluding
>> >> the
>> >> > last path separator, or "." if there is no path separator,' but I
>> don't
>> >> see
>> >> > how the root path is supposed to be treated based on this rule (,
>> >> whether
>> >> > it's WIndows or UNIX-alike).
>> >> Thanks for spotting the difference, I've reverted to the previous
>> >> behavior, the change was unintentional. If you spot any other
>> suspicious
>> >> changes in behavior in file-system operations, please report.
>> >> > What should we expect as the return value of dirname("C:/")? I feel
>> the
>> >> > current behavior on R 4.2.2 is right, but I'd like to confirm.
>> >>
>> >> I also think the old behavior is better, even though it could be argued
>> >> whether the "/" in "C:/" is a path separator or not, and whether it is
>> >> trailing or not. But the behavior is in line with Unix where dirname of
>> >> "/" is also "/". Msys2 would return "C:".
>> >>
>> >> If  "/" in "C:/" is a path separator but not a trailing path separator,
>> >> then basename("C:/") should probably be "" and not "C:", and this would
>> >> be in line with what R does on Unix. However, to be in line with Unix,
>> I
>> >> think the basename of "C:/" should be "C:/". Yet, Msys2 returns "C:"
>> >> which is what R does now.
>> >>
>> >> So what these functions should do on Windows is definitely tricky. In
>> >> either case the behavior is now again as in R 4.2.2.
>> >>
>> >> Best
>> >> Tomas
>> >>
>> >> >
>> >> > Best,
>> >> > Yutani
>> >> >
>> >> >       [[alternative HTML version deleted]]
>> >> >
>> >> > ______________________________________________
>> >> > R-devel at r-project.org mailing list
>> >> > https://stat.ethz.ch/mailman/listinfo/r-devel
>> >>
>> >
>>
>>         [[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>

	[[alternative HTML version deleted]]


From @tevem@rt|n041 @end|ng |rom gm@||@com  Wed Mar  8 03:41:29 2023
From: @tevem@rt|n041 @end|ng |rom gm@||@com (Steve Martin)
Date: Tue, 7 Mar 2023 21:41:29 -0500
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
In-Reply-To: <CAP01uRk2-FWoH9cceJP61ckxte1hGF3VVcwFjF12ouASvoBZ9g@mail.gmail.com>
References: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
 <CAP01uRk2-FWoH9cceJP61ckxte1hGF3VVcwFjF12ouASvoBZ9g@mail.gmail.com>
Message-ID: <CAP=dwz8ZpEbRX40qGBt2L0T6rY5xo6a+QFOBZJfTcjGw8dEHrA@mail.gmail.com>

That's an interesting example, as it's conceptually similar to what
Pavel is proposing, but structurally different. gsubfn() is more
complicated than a simple switch in the body of the function, and
wouldn't work well as an anonymous function.

Multiple dispatch can nicely encompass both of these cases. For replace(),

library(S7)

replace <- new_generic("replace", c("x", "list"), function(x, list,
values, ...) {
  S7_dispatch()
})

method(replace, list(class_any, class_any)) <- base::replace

method(replace, list(class_any, class_function)) <- function(x, list,
values, ...) {
  replace(x, list(x, ...), values)
}

x <- c(1 ,2, NA, 3)
replace(x, is.na(x), 0)
[1] 1 2 0 3

replace(x, is.na, 0)
[1] 1 2 0 3

And for gsub(),

gsub <- new_generic("gsub", c("pattern", "replacement"),
function(pattern, replacement, x, ...) {
  S7_dispatch()
})

method(gsub, list(class_character, class_character)) <- base::gsub

# My quick-and-dirty implementation as an example
method(gsub, list(class_character, class_function)) <-
function(pattern, replacement, x) {
  m <- regexpr(pattern, x)
  res <- replacement(regmatches(x, m))
  mapply(gsub, pattern, as.character(res), x, USE.NAMES = FALSE)
}

gsub("^..", toupper, c("abc", "xyz"))
[1] "ABc" "XYz"

But this isn't a simple change to replace() anymore, and I may just be
spending too much time tinkering with Julia.

Steve

On Tue, 7 Mar 2023 at 07:34, Gabor Grothendieck <ggrothendieck at gmail.com> wrote:
>
> This could be extended to sub and gsub as well which gsubfn in the
> gusbfn package already does:
>
>   library(gsubfn)
>   gsubfn("^..", toupper, c("abc", "xyz"))
>   ## [1] "ABc" "XYz"
>
> On Fri, Mar 3, 2023 at 7:22?PM Pavel Krivitsky <p.krivitsky at unsw.edu.au> wrote:
> >
> > Dear All,
> >
> > Currently, list= in base::replace(x, list, value) has to be an index
> > vector. For me, at least, the most common use case is for list= to be
> > some simple property of elements of x, e.g.,
> >
> > x <- c(1,2,NA,3)
> > replace(x, is.na(x), 0)
> >
> > Particularly when using R pipes, which don't allow multiple
> > substitutions, it would simplify many of such cases if list= could be a
> > function that returns an index, e.g.,
> >
> > replace <- function (x, list, values, ...) {
> >   # Here, list() refers to the argument, not the built-in.
> >   if(is.function(list)) list <- list(x, ...)
> >   x[list] <- values
> >   x
> > }
> >
> > Then, the following is possible:
> >
> > c(1,2,NA,3) |> replace(is.na, 0)
> >
> >                         Any thoughts?
> >                         Pavel
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
>
>
> --
> Statistics & Software Consulting
> GKX Group, GKX Associates Inc.
> tel: 1-877-GKX-GROUP
> email: ggrothendieck at gmail.com
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From ggrothend|eck @end|ng |rom gm@||@com  Wed Mar  8 15:11:06 2023
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Wed, 8 Mar 2023 09:11:06 -0500
Subject: [Rd] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
In-Reply-To: <CAP=dwz8ZpEbRX40qGBt2L0T6rY5xo6a+QFOBZJfTcjGw8dEHrA@mail.gmail.com>
References: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
 <CAP01uRk2-FWoH9cceJP61ckxte1hGF3VVcwFjF12ouASvoBZ9g@mail.gmail.com>
 <CAP=dwz8ZpEbRX40qGBt2L0T6rY5xo6a+QFOBZJfTcjGw8dEHrA@mail.gmail.com>
Message-ID: <CAP01uR=B3=KqmASJGtnPMZv-8J5CNO4fVg6S95FLKSmb5CMD_g@mail.gmail.com>

This is getting way off topic. I wasn't suggesting that gsubfn, which
does a lot more than this simple
example, as the implementation.

I was pointing out that the replace function idea can be extended to
sub and gsub and showing what
it would do.

On Tue, Mar 7, 2023 at 9:41?PM Steve Martin <stevemartin041 at gmail.com> wrote:
>
> That's an interesting example, as it's conceptually similar to what
> Pavel is proposing, but structurally different. gsubfn() is more
> complicated than a simple switch in the body of the function, and
> wouldn't work well as an anonymous function.
>
> Multiple dispatch can nicely encompass both of these cases. For replace(),
>
> library(S7)
>
> replace <- new_generic("replace", c("x", "list"), function(x, list,
> values, ...) {
>   S7_dispatch()
> })
>
> method(replace, list(class_any, class_any)) <- base::replace
>
> method(replace, list(class_any, class_function)) <- function(x, list,
> values, ...) {
>   replace(x, list(x, ...), values)
> }
>
> x <- c(1 ,2, NA, 3)
> replace(x, is.na(x), 0)
> [1] 1 2 0 3
>
> replace(x, is.na, 0)
> [1] 1 2 0 3
>
> And for gsub(),
>
> gsub <- new_generic("gsub", c("pattern", "replacement"),
> function(pattern, replacement, x, ...) {
>   S7_dispatch()
> })
>
> method(gsub, list(class_character, class_character)) <- base::gsub
>
> # My quick-and-dirty implementation as an example
> method(gsub, list(class_character, class_function)) <-
> function(pattern, replacement, x) {
>   m <- regexpr(pattern, x)
>   res <- replacement(regmatches(x, m))
>   mapply(gsub, pattern, as.character(res), x, USE.NAMES = FALSE)
> }
>
> gsub("^..", toupper, c("abc", "xyz"))
> [1] "ABc" "XYz"
>
> But this isn't a simple change to replace() anymore, and I may just be
> spending too much time tinkering with Julia.
>
> Steve
>
> On Tue, 7 Mar 2023 at 07:34, Gabor Grothendieck <ggrothendieck at gmail.com> wrote:
> >
> > This could be extended to sub and gsub as well which gsubfn in the
> > gusbfn package already does:
> >
> >   library(gsubfn)
> >   gsubfn("^..", toupper, c("abc", "xyz"))
> >   ## [1] "ABc" "XYz"
> >
> > On Fri, Mar 3, 2023 at 7:22?PM Pavel Krivitsky <p.krivitsky at unsw.edu.au> wrote:
> > >
> > > Dear All,
> > >
> > > Currently, list= in base::replace(x, list, value) has to be an index
> > > vector. For me, at least, the most common use case is for list= to be
> > > some simple property of elements of x, e.g.,
> > >
> > > x <- c(1,2,NA,3)
> > > replace(x, is.na(x), 0)
> > >
> > > Particularly when using R pipes, which don't allow multiple
> > > substitutions, it would simplify many of such cases if list= could be a
> > > function that returns an index, e.g.,
> > >
> > > replace <- function (x, list, values, ...) {
> > >   # Here, list() refers to the argument, not the built-in.
> > >   if(is.function(list)) list <- list(x, ...)
> > >   x[list] <- values
> > >   x
> > > }
> > >
> > > Then, the following is possible:
> > >
> > > c(1,2,NA,3) |> replace(is.na, 0)
> > >
> > >                         Any thoughts?
> > >                         Pavel
> > > ______________________________________________
> > > R-devel at r-project.org mailing list
> > > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> >
> >
> > --
> > Statistics & Software Consulting
> > GKX Group, GKX Associates Inc.
> > tel: 1-877-GKX-GROUP
> > email: ggrothendieck at gmail.com
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From ht @end|ng |rom he@therturner@net  Thu Mar  9 16:14:01 2023
From: ht @end|ng |rom he@therturner@net (Heather Turner)
Date: Thu, 09 Mar 2023 15:14:01 +0000
Subject: [Rd] R Project Sprint 2023: deadline 10 March (midnight UTC)
Message-ID: <8531a7b7-7f84-432f-bdc9-5985c5c0bea2@app.fastmail.com>

Dear All,

This is a reminder that the deadline to apply to participate in the R Project Sprint 2023 is tomorrow, Friday 10 March. The form will close at midnight UTC.

Details: https://contributor.r-project.org/r-project-sprint-2023/.

Best wishes,
Heather


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Fri Mar 10 13:54:43 2023
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Fri, 10 Mar 2023 13:54:43 +0100
Subject: [Rd] scan(..., skip=1e11): infinite loop; cannot interrupt
In-Reply-To: <20230211113316.44dd813a@Tarkus>
References: <acf79875-5042-1db1-5283-836dedd7f8a0@prodsyse.com>
 <20230211113316.44dd813a@Tarkus>
Message-ID: <c2d3c1eb-9a07-ff7b-3055-497c991535f3@gmail.com>



On 2/11/23 09:33, Ivan Krylov wrote:
> On Fri, 10 Feb 2023 23:38:55 -0600
> Spencer Graves <spencer.graves at prodsyse.com> wrote:
>
>> I have a 4.54 GB file that I'm trying to read in chunks using
>> "scan(..., skip=__)".  It works as expected for small values of
>> "skip" but goes into an infinite loop for "skip=1e11" and similar
>> large values of skip:  I cannot even interrupt it;  I must kill R.
> Skipping lines is done by two nested loops. The outer loop counts the
> lines to skip; the inner loop reads characters until it encounters a
> newline or end of file. The outer loop doesn't check for EOF and keeps
> asking for more characters until the inner loop runs at least once for
> every line it wants to skip. The following patch should avoid the
> wait in such cases:
>
> --- src/main/scan.c	(revision 83797)
> +++ src/main/scan.c	(working copy)
> @@ -835,7 +835,7 @@
>   attribute_hidden SEXP do_scan(SEXP call, SEXP op, SEXP args, SEXP rho)
>   {
>       SEXP ans, file, sep, what, stripwhite, dec, quotes, comstr;
> -    int c, flush, fill, blskip, multiline, escapes, skipNul;
> +    int c = 0, flush, fill, blskip, multiline, escapes, skipNul;
>       R_xlen_t nmax, nlines, nskip;
>       const char *p, *encoding;
>       RCNTXT cntxt;
> @@ -952,7 +952,7 @@
>   	    if(!data.con->canread)
>   		error(_("cannot read from this connection"));
>   	}
> -	for (R_xlen_t i = 0; i < nskip; i++) /* MBCS-safe */
> +	for (R_xlen_t i = 0; i < nskip && c != R_EOF; i++) /* MBCS-safe */
>   	    while ((c = scanchar(FALSE, &data)) != '\n' && c != R_EOF);
>       }
>   
>
> Making it interruptible is a bit more work: we need to ensure that a
> valid context is set up and check regularly for an interrupt.
>
> --- src/main/scan.c	(revision 83797)
> +++ src/main/scan.c	(working copy)
> @@ -835,7 +835,7 @@
>   attribute_hidden SEXP do_scan(SEXP call, SEXP op, SEXP args, SEXP rho)
>   {
>       SEXP ans, file, sep, what, stripwhite, dec, quotes, comstr;
> -    int c, flush, fill, blskip, multiline, escapes, skipNul;
> +    int c = 0, flush, fill, blskip, multiline, escapes, skipNul;
>       R_xlen_t nmax, nlines, nskip;
>       const char *p, *encoding;
>       RCNTXT cntxt;
> @@ -952,8 +952,6 @@
>   	    if(!data.con->canread)
>   		error(_("cannot read from this connection"));
>   	}
> -	for (R_xlen_t i = 0; i < nskip; i++) /* MBCS-safe */
> -	    while ((c = scanchar(FALSE, &data)) != '\n' && c != R_EOF);
>       }
>   
>       ans = R_NilValue;		/* -Wall */
> @@ -966,6 +964,10 @@
>       cntxt.cend = &scan_cleanup;
>       cntxt.cenddata = &data;
>   
> +    if (ii) for (R_xlen_t i = 0, j = 0; i < nskip && c != R_EOF; i++) /* MBCS-safe */
> +	while ((c = scanchar(FALSE, &data)) != '\n' && c != R_EOF)
> +	    if (j++ % 10000 == 9999) R_CheckUserInterrupt();
> +
>       switch (TYPEOF(what)) {
>       case LGLSXP:
>       case INTSXP:
>
> This way, even if you pour a Decanter of Endless Lines (e.g. mkfifo
> LINES; perl -E'print "A"x42 while 1;' > LINES) into scan(), it can
> still be interrupted, even if neither newline nor EOF ever arrives.

Thanks, I've updated the implementation of scan() in R-devel to be 
interruptible while skipping lines.

I've done it slightly differently as I found there already was a memory 
leak, which could be fixed by creating the context a bit earlier.

I've also avoided modulo on the fast path as I saw 13% performance 
overhead on my mailbox file. Decrementing and checking against zero 
didn't have measurable overhead.

Best
Tomas

> (We never skip lines when reading from the console? I suppose it makes
> sense. I think this needs to be documented and can write a
> documentation patch.)
>
> If you actually have 1e11 lines in your file and would like to read it
> in chunks, it may help to use
>
> f <- file('...')
> chunk1 <- scan(f, n = n1, skip = nskip1)
> # the following will continue reading where chunk1 had ended
> chunk2 <- scan(f, n = n2, skip = nskip2)
>
> ...in order to avoid having to skip over chunks you have already read,
> which otherwise makes the algorithm quadratic in number of lines
> instead of linear. (I couldn't determine whether you're already doing
> this, sorry.)
>
> Skipping a fixed number of lines is hard: since they have variable
> length, it's required to read every character in order to determine
> whether it starts a new line. With byte ranges, it would have been
> possible to use seek(), but not here.
>


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Fri Mar 10 16:39:39 2023
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Fri, 10 Mar 2023 16:39:39 +0100
Subject: [Rd] On optimizing `R_NewEnv()`
In-Reply-To: <CABzLhzxrrV7AGg5nCwCdEzqB1aRcRcHByoAXrjiXgRMi7Q=4-A@mail.gmail.com>
References: <CABzLhzxrrV7AGg5nCwCdEzqB1aRcRcHByoAXrjiXgRMi7Q=4-A@mail.gmail.com>
Message-ID: <9bb1f967-9a82-deca-e23a-12ebf515f851@gmail.com>


On 2/8/23 21:51, Davis Vaughan via R-devel wrote:
> Hi all,
>
> I really like the addition of `R_NewEnv()` back in 4.1.0
> https://github.com/wch/r-source/blob/625ab8d45f86f65561e53627e1f0c220bdc5f752/src/main/envir.c#L3619-L3630
>
> I have a use case where I'm likely to call this function a large
> number of times to generate many small hashed environments, so I'd
> like to optimize it as far as possible.
>
> I noticed that it takes `int size`, converts that to a SEXP for
> `R_NewHashedEnv()`, which then simply converts that back to an `int`
> here:
> https://github.com/wch/r-source/blob/625ab8d45f86f65561e53627e1f0c220bdc5f752/src/main/envir.c#L378
>
> I wonder if we could cut out that intermediate SEXP (along with its
> protection) by adjusting `R_NewHashedEnv()` to instead take `int
> size`.
>
> I'd be happy to do a patch if that sounds good. I'd update all uses of
> `R_NewHashedEnv()` to supply `int`s instead, which actually seems like
> it would make every instance of calling that function simpler:
> https://github.com/search?q=repo%3Awch%2Fr-source%20R_NewHashedEnv&type=code
>
> So hopefully a win everywhere?

I've simplified this code in R-devel as suggested.

However, I think that the original performance motivation is weak: if 
some program creates so many, small and little used hashed environments 
that this overhead matters, probably it should use a different data 
structure, and then it will get much bigger performance benefits.

Best,
Tomas

>
> Thanks,
> Davis
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch  Sat Mar 11 10:04:54 2023
From: @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch (Sebastian Martin Krantz)
Date: Sat, 11 Mar 2023 11:04:54 +0200
Subject: [Rd] Multiple Assignment built into the R Interpreter?
Message-ID: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>

Dear R Core,

working on my dynamic factor modelling package, which requires several
subroutines to create and update several system matrices, I come back to
the issue of being annoyed by R not supporting multiple assignment out of
the box like Matlab, Python and julia. e.g. something like

A, C, Q, R = init_matrices(X, Y, Z)

would be a great addition to the language. I know there are several
workarounds such as the %<-% operator in the zeallot package or my own %=%
operator in collapse, but these don't work well for package development as
R CMD Check warns about missing global bindings for the created variables,
e.g. I would have to use

A <- C <- Q <- R <- NULL
.c(A, C, Q, R) %=% init_matrices(X, Y, Z)

in a package, which is simply annoying. Of course the standard way of

init <- init_matrices(X, Y, Z)
 A <- init$A; C <- init$C; Q <- init$Q; R <- init$R
rm(init)

is also super cumbersome compared to Python or Julia. Another reason is of
course performance, even my %=% operator written in C has a non-negligible
performance cost for very tight loops, compared to a solution at the
interpretor level or in a primitive function such as `=`.

So my conclusion at this point is that it is just significantly easier to
implement such codes in Julia, in addition to the greater performance it
offers. There are obvious reasons why I am still coding in R and C, thanks
to the robust API and great ecosystem of packages, but adding this could be
a presumably low-hanging fruit to make my life a bit easier. Several issues
for this have been filed on Stackoverflow, the most popular one (
https://stackoverflow.com/questions/7519790/assign-multiple-new-variables-on-lhs-in-a-single-line)
has been viewed 77 thousand times.

But maybe this has already been discussed here and already decided against.
In that case, a way to browse R-devel archives to find out would be nice.

Best regards,

Sebastian

	[[alternative HTML version deleted]]


From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Mar 11 14:37:24 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sat, 11 Mar 2023 08:37:24 -0500
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
Message-ID: <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>

I think the standard way to do this in R is given by list2env(), as 
described in a couple of answers on the SO page you linked.

The syntax you proposed would be likely to be confusing in complex 
expressions, e.g.

   f(A, C, Q, R = init_matrices(X, Y, Z))

would obviously not work but wouldn't trigger a syntax error, and

   f((A, C, Q, R = init_matrices(X, Y, Z)))

could work, but looks too much like the previous one.  So I think R 
would want Javascript-like

   [A, C, Q, R] <- init_matrices(X, Y, Z)

instead.  But then the question would come up about how to handle the 
RHS.  Does the function have to return a list?  What if the length of 
the list is not 4?  Or is it just guaranteed to be equivalent to

   temp <- init_matrices(X, Y, Z)
   A <- temp[[1]]
   C <- temp[[2]]
   Q <- temp[[3]]
   R <- temp[[4]]

which would work for other vector types besides lists?

BTW, here's a little hack that almost works:

`vals<-` <- function(x, ..., value) {
    others <- substitute(list(...))
    if (length(others) > 1)
      for (i in seq_along(others)[-1])
        assign(as.character(others[[i]]), value[[i]], envir = 
parent.frame())
    value[[1]]
}

You call it as

  vals(a, b, c) <- 1:3

and it assigns 1 to a, 2 to b, and 3 to c.  It doesn't quite do what you 
want because it requires that a exists already, but b and c don't have to.

Duncan Murdoch

On 11/03/2023 4:04 a.m., Sebastian Martin Krantz wrote:
> Dear R Core,
> 
> working on my dynamic factor modelling package, which requires several
> subroutines to create and update several system matrices, I come back to
> the issue of being annoyed by R not supporting multiple assignment out of
> the box like Matlab, Python and julia. e.g. something like
> 
> A, C, Q, R = init_matrices(X, Y, Z)
> 
> would be a great addition to the language. I know there are several
> workarounds such as the %<-% operator in the zeallot package or my own %=%
> operator in collapse, but these don't work well for package development as
> R CMD Check warns about missing global bindings for the created variables,
> e.g. I would have to use
> 
> A <- C <- Q <- R <- NULL
> .c(A, C, Q, R) %=% init_matrices(X, Y, Z)
> 
> in a package, which is simply annoying. Of course the standard way of
> 
> init <- init_matrices(X, Y, Z)
>   A <- init$A; C <- init$C; Q <- init$Q; R <- init$R
> rm(init)
> 
> is also super cumbersome compared to Python or Julia. Another reason is of
> course performance, even my %=% operator written in C has a non-negligible
> performance cost for very tight loops, compared to a solution at the
> interpretor level or in a primitive function such as `=`.
> 
> So my conclusion at this point is that it is just significantly easier to
> implement such codes in Julia, in addition to the greater performance it
> offers. There are obvious reasons why I am still coding in R and C, thanks
> to the robust API and great ecosystem of packages, but adding this could be
> a presumably low-hanging fruit to make my life a bit easier. Several issues
> for this have been filed on Stackoverflow, the most popular one (
> https://stackoverflow.com/questions/7519790/assign-multiple-new-variables-on-lhs-in-a-single-line)
> has been viewed 77 thousand times.
> 
> But maybe this has already been discussed here and already decided against.
> In that case, a way to browse R-devel archives to find out would be nice.
> 
> Best regards,
> 
> Sebastian
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch  Sat Mar 11 15:54:48 2023
From: @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch (Sebastian Martin Krantz)
Date: Sat, 11 Mar 2023 16:54:48 +0200
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
Message-ID: <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>

Thanks Duncan,

I know about list2env(), in fact a previous version of collapse::`%=%` was
coded as

"%=%" <- function(lhs, rhs) {
   if(!is.character(lhs)) stop("lhs needs to be character")
   if(!is.list(rhs)) rhs <- as.vector(rhs, "list")
   if(length(lhs) != length(rhs)) stop("length(lhs) not equal to
length(rhs)")
   list2env(`names<-`(rhs, lhs), envir = parent.frame())
   invisible()
}

but as you say, the input needs to be converted to a list, and it calls
several R functions, which led me to end up writing `%=%` in C:
https://github.com/SebKrantz/collapse/blob/master/src/small_helper.c#L162.
This implementation works in the way you describe, i.e. it has separate
methods for all the standard vector types, and coerces to list otherwise.

That being said, all implementations in packages falls short of being very
useful, because R CMD Check it will still require global bindings for
variables,
unless this becomes a standard feature of the language. So I cannot use
this in packages, and there is still a performance cost to it, in my case a
call to
.Call() and parent.frame(), which is quite low, but still high compared to
the cost of `<-` or `=`.

So what I am requesting is indeed nothing less than to consider making this
a permanent feature of the language itself.
Given that the other 3 major scientific computing languages (Matlab, Python
and Julia) have implemented it very successfully,
I don't think the general practicality of it should be an issue. Regarding
implementation in other languages, Julia works as follows:

function init_matrices()
    A = 1; C = 2; Q = 3; R = 4
    return A, C, Q, R
end

res = init_matrices()             # gives a Julia Tuple (A, C, Q, R)
A, C = init_matrices()           # Works, A is 1, C is 2, the others are
dropped
A, C, Q, R = init_matrices()  # Standard

I think as far as R is concerned multiple return values are not really
necessary given that one can always,
return(list(A, C, Q, R)), although of course there is also a cost to
list(). I also wouldn't mind being strict about it and
not allowing A, C = init_matrices(), but others might disagree.

Best regards,

Sebastian


On Sat, 11 Mar 2023 at 15:37, Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:

> I think the standard way to do this in R is given by list2env(), as
> described in a couple of answers on the SO page you linked.
>
> The syntax you proposed would be likely to be confusing in complex
> expressions, e.g.
>
>    f(A, C, Q, R = init_matrices(X, Y, Z))
>
> would obviously not work but wouldn't trigger a syntax error, and
>
>    f((A, C, Q, R = init_matrices(X, Y, Z)))
>
> could work, but looks too much like the previous one.  So I think R
> would want Javascript-like
>
>    [A, C, Q, R] <- init_matrices(X, Y, Z)
>
> instead.  But then the question would come up about how to handle the
> RHS.  Does the function have to return a list?  What if the length of
> the list is not 4?  Or is it just guaranteed to be equivalent to
>
>    temp <- init_matrices(X, Y, Z)
>    A <- temp[[1]]
>    C <- temp[[2]]
>    Q <- temp[[3]]
>    R <- temp[[4]]
>
> which would work for other vector types besides lists?
>
> BTW, here's a little hack that almost works:
>
> `vals<-` <- function(x, ..., value) {
>     others <- substitute(list(...))
>     if (length(others) > 1)
>       for (i in seq_along(others)[-1])
>         assign(as.character(others[[i]]), value[[i]], envir =
> parent.frame())
>     value[[1]]
> }
>
> You call it as
>
>   vals(a, b, c) <- 1:3
>
> and it assigns 1 to a, 2 to b, and 3 to c.  It doesn't quite do what you
> want because it requires that a exists already, but b and c don't have to.
>
> Duncan Murdoch
>
> On 11/03/2023 4:04 a.m., Sebastian Martin Krantz wrote:
> > Dear R Core,
> >
> > working on my dynamic factor modelling package, which requires several
> > subroutines to create and update several system matrices, I come back to
> > the issue of being annoyed by R not supporting multiple assignment out of
> > the box like Matlab, Python and julia. e.g. something like
> >
> > A, C, Q, R = init_matrices(X, Y, Z)
> >
> > would be a great addition to the language. I know there are several
> > workarounds such as the %<-% operator in the zeallot package or my own
> %=%
> > operator in collapse, but these don't work well for package development
> as
> > R CMD Check warns about missing global bindings for the created
> variables,
> > e.g. I would have to use
> >
> > A <- C <- Q <- R <- NULL
> > .c(A, C, Q, R) %=% init_matrices(X, Y, Z)
> >
> > in a package, which is simply annoying. Of course the standard way of
> >
> > init <- init_matrices(X, Y, Z)
> >   A <- init$A; C <- init$C; Q <- init$Q; R <- init$R
> > rm(init)
> >
> > is also super cumbersome compared to Python or Julia. Another reason is
> of
> > course performance, even my %=% operator written in C has a
> non-negligible
> > performance cost for very tight loops, compared to a solution at the
> > interpretor level or in a primitive function such as `=`.
> >
> > So my conclusion at this point is that it is just significantly easier to
> > implement such codes in Julia, in addition to the greater performance it
> > offers. There are obvious reasons why I am still coding in R and C,
> thanks
> > to the robust API and great ecosystem of packages, but adding this could
> be
> > a presumably low-hanging fruit to make my life a bit easier. Several
> issues
> > for this have been filed on Stackoverflow, the most popular one (
> >
> https://stackoverflow.com/questions/7519790/assign-multiple-new-variables-on-lhs-in-a-single-line
> )
> > has been viewed 77 thousand times.
> >
> > But maybe this has already been discussed here and already decided
> against.
> > In that case, a way to browse R-devel archives to find out would be nice.
> >
> > Best regards,
> >
> > Sebastian
> >
> >       [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
>

	[[alternative HTML version deleted]]


From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Mar 11 17:11:06 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sat, 11 Mar 2023 11:11:06 -0500
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
Message-ID: <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>

On 11/03/2023 9:54 a.m., Sebastian Martin Krantz wrote:
> Thanks Duncan,
> 
> I know about list2env(), in fact a previous version of collapse::`%=%` 
> was coded as
> 
> "%=%" <- function(lhs, rhs) {
>  ?? if(!is.character(lhs)) stop("lhs needs to be character")
>  ?? if(!is.list(rhs)) rhs <- as.vector(rhs, "list")
>  ?? if(length(lhs) != length(rhs)) stop("length(lhs) not equal to 
> length(rhs)")
>  ?? list2env(`names<-`(rhs, lhs), envir = parent.frame())
>  ?? invisible()
> }
> 
> but as you say, the input needs to be converted to a list, and it calls 
> several R functions, which led me to end up writing `%=%` in C:
> https://github.com/SebKrantz/collapse/blob/master/src/small_helper.c#L162 <https://github.com/SebKrantz/collapse/blob/master/src/small_helper.c#L162>.
> This implementation works in the way you describe, i.e. it has separate 
> methods for all the standard vector types, and coerces to list otherwise.
> 
> That being said, all implementations in packages falls short of being 
> very useful, because R CMD Check it will still require global bindings 
> for variables,
> unless this becomes a standard feature of the language. So I cannot use 
> this in packages, and there is still a performance cost to it, in my 
> case a call to
> .Call() and parent.frame(), which is quite low, but still high compared 
> to the cost of `<-` or `=`.

Another R way to do what you're doing would be to stay within a list the 
whole time, i.e. code it as

   mats <- init_matrices(X, Y, Z)
   with(mats, ... do things with A, C, Q, and R ... )

This won't give warnings about globals, and it makes very clear that 
those 4 matrices are all closely related, and it allows you to work with 
multiple 4-tuples of matrices, etc.

> So what I am requesting is indeed nothing less than to consider making 
> this a permanent feature of the language itself.

That's clear, but your proposal violates a very basic property of the 
language, i.e. that all statements are expressions and have a value. 
What's the value of

    1 + (A, C = init_matrices())

?  I think you would disallow the above (though you didn't address it 
when I raised it the first time), which means there would now be two 
kinds of statements:  ones that are expressions and therefore can be 
used as function arguments, and ones that aren't.

> Given that the other 3 major scientific computing languages (Matlab, 
> Python and Julia) have implemented it very successfully,
> I don't think the general practicality of it should be an issue. 
> Regarding implementation in other languages, Julia works as follows:
> 
> function init_matrices()
>  ??? A = 1; C = 2; Q = 3; R = 4
>  ??? return A, C, Q, R
> end
> 
> res = init_matrices()???????????? # gives a Julia Tuple (A, C, Q, R)
> A, C = init_matrices()?????????? # Works, A is 1, C is 2, the others are 
> dropped

That's pretty ugly having a singular LHS handled so much differently 
from a plural LHS.

> A, C, Q, R = init_matrices()? # Standard
> 
> I think as far as R is concerned multiple return values are not really 
> necessary given that one can always,
> return(list(A, C, Q, R)), although of course there is also a cost to 
> list(). I also wouldn't mind being strict about it and
> not allowing A, C = init_matrices(), but others might disagree.

Another ambiguity:  suppose f() returns list(A = 1, B = 2) and I do

   B, A <- f()

Should assignment be by position or by name?

Honestly, given that this is simply syntactic sugar, I don't think I 
would support it.

Duncan Murdoch

> 
> Best regards,
> 
> Sebastian
> 
> 
> On Sat, 11 Mar 2023 at 15:37, Duncan Murdoch <murdoch.duncan at gmail.com 
> <mailto:murdoch.duncan at gmail.com>> wrote:
> 
>     I think the standard way to do this in R is given by list2env(), as
>     described in a couple of answers on the SO page you linked.
> 
>     The syntax you proposed would be likely to be confusing in complex
>     expressions, e.g.
> 
>      ? ?f(A, C, Q, R = init_matrices(X, Y, Z))
> 
>     would obviously not work but wouldn't trigger a syntax error, and
> 
>      ? ?f((A, C, Q, R = init_matrices(X, Y, Z)))
> 
>     could work, but looks too much like the previous one.? So I think R
>     would want Javascript-like
> 
>      ? ?[A, C, Q, R] <- init_matrices(X, Y, Z)
> 
>     instead.? But then the question would come up about how to handle the
>     RHS.? Does the function have to return a list?? What if the length of
>     the list is not 4?? Or is it just guaranteed to be equivalent to
> 
>      ? ?temp <- init_matrices(X, Y, Z)
>      ? ?A <- temp[[1]]
>      ? ?C <- temp[[2]]
>      ? ?Q <- temp[[3]]
>      ? ?R <- temp[[4]]
> 
>     which would work for other vector types besides lists?
> 
>     BTW, here's a little hack that almost works:
> 
>     `vals<-` <- function(x, ..., value) {
>      ? ? others <- substitute(list(...))
>      ? ? if (length(others) > 1)
>      ? ? ? for (i in seq_along(others)[-1])
>      ? ? ? ? assign(as.character(others[[i]]), value[[i]], envir =
>     parent.frame())
>      ? ? value[[1]]
>     }
> 
>     You call it as
> 
>      ? vals(a, b, c) <- 1:3
> 
>     and it assigns 1 to a, 2 to b, and 3 to c.? It doesn't quite do what
>     you
>     want because it requires that a exists already, but b and c don't
>     have to.
> 
>     Duncan Murdoch
> 
>     On 11/03/2023 4:04 a.m., Sebastian Martin Krantz wrote:
>      > Dear R Core,
>      >
>      > working on my dynamic factor modelling package, which requires
>     several
>      > subroutines to create and update several system matrices, I come
>     back to
>      > the issue of being annoyed by R not supporting multiple
>     assignment out of
>      > the box like Matlab, Python and julia. e.g. something like
>      >
>      > A, C, Q, R = init_matrices(X, Y, Z)
>      >
>      > would be a great addition to the language. I know there are several
>      > workarounds such as the %<-% operator in the zeallot package or
>     my own %=%
>      > operator in collapse, but these don't work well for package
>     development as
>      > R CMD Check warns about missing global bindings for the created
>     variables,
>      > e.g. I would have to use
>      >
>      > A <- C <- Q <- R <- NULL
>      > .c(A, C, Q, R) %=% init_matrices(X, Y, Z)
>      >
>      > in a package, which is simply annoying. Of course the standard way of
>      >
>      > init <- init_matrices(X, Y, Z)
>      >? ?A <- init$A; C <- init$C; Q <- init$Q; R <- init$R
>      > rm(init)
>      >
>      > is also super cumbersome compared to Python or Julia. Another
>     reason is of
>      > course performance, even my %=% operator written in C has a
>     non-negligible
>      > performance cost for very tight loops, compared to a solution at the
>      > interpretor level or in a primitive function such as `=`.
>      >
>      > So my conclusion at this point is that it is just significantly
>     easier to
>      > implement such codes in Julia, in addition to the greater
>     performance it
>      > offers. There are obvious reasons why I am still coding in R and
>     C, thanks
>      > to the robust API and great ecosystem of packages, but adding
>     this could be
>      > a presumably low-hanging fruit to make my life a bit easier.
>     Several issues
>      > for this have been filed on Stackoverflow, the most popular one (
>      >
>     https://stackoverflow.com/questions/7519790/assign-multiple-new-variables-on-lhs-in-a-single-line <https://stackoverflow.com/questions/7519790/assign-multiple-new-variables-on-lhs-in-a-single-line>)
>      > has been viewed 77 thousand times.
>      >
>      > But maybe this has already been discussed here and already
>     decided against.
>      > In that case, a way to browse R-devel archives to find out would
>     be nice.
>      >
>      > Best regards,
>      >
>      > Sebastian
>      >
>      >? ? ? ?[[alternative HTML version deleted]]
>      >
>      > ______________________________________________
>      > R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>      > https://stat.ethz.ch/mailman/listinfo/r-devel
>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>


From kry|ov@r00t @end|ng |rom gm@||@com  Sat Mar 11 17:57:08 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Sat, 11 Mar 2023 19:57:08 +0300
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
Message-ID: <20230311195708.794032e8@Tarkus>

On Sat, 11 Mar 2023 11:11:06 -0500
Duncan Murdoch <murdoch.duncan at gmail.com> wrote:

> That's clear, but your proposal violates a very basic property of the 
> language, i.e. that all statements are expressions and have a value. 

How about reframing this feature request from multiple assignment
(which does go contrary to "everything has only one value, even if it's
sometimes invisible(NULL)") to "structured binding" / "destructuring
assignment" [*], which takes this single single value returned by the
expression and subsets it subject to certain rules? It may be easier to
make a decision on the semantics for destructuring assignment (e.g.
languages which have this feature typically allow throwing unneeded
parts of the return value away), and it doesn't seem to break as much
of the rest of the language if implemented.

I see you've already mentioned it ("JavaScript-like"). I think it would
fulfil Sebastian's requirements too, as long as it is considered "true
assignment" by the rest of the language.

The hard part is to propose the actual grammar of the new feature (in
terms of src/main/gram.y, preferably without introducing conflicts) and
its semantics (including the corner cases, some of which you have
already mentioned). I'm not sure I'm up to the task.

-- 
Best regards,
Ivan

[*]
https://en.cppreference.com/w/cpp/language/structured_binding
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment


From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Mar 11 19:38:42 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sat, 11 Mar 2023 13:38:42 -0500
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <20230311195708.794032e8@Tarkus>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
Message-ID: <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>

On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> On Sat, 11 Mar 2023 11:11:06 -0500
> Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> 
>> That's clear, but your proposal violates a very basic property of the
>> language, i.e. that all statements are expressions and have a value.
> 
> How about reframing this feature request from multiple assignment
> (which does go contrary to "everything has only one value, even if it's
> sometimes invisible(NULL)") to "structured binding" / "destructuring
> assignment" [*], which takes this single single value returned by the
> expression and subsets it subject to certain rules? It may be easier to
> make a decision on the semantics for destructuring assignment (e.g.
> languages which have this feature typically allow throwing unneeded
> parts of the return value away), and it doesn't seem to break as much
> of the rest of the language if implemented.
> 
> I see you've already mentioned it ("JavaScript-like"). I think it would
> fulfil Sebastian's requirements too, as long as it is considered "true
> assignment" by the rest of the language.
> 
> The hard part is to propose the actual grammar of the new feature (in
> terms of src/main/gram.y, preferably without introducing conflicts) and
> its semantics (including the corner cases, some of which you have
> already mentioned). I'm not sure I'm up to the task.
> 

If I were doing it, here's what I'd propose:

   '[' formlist ']' LEFT_ASSIGN expr
   '[' formlist ']' EQ_ASSIGN expr
   expr RIGHT_ASSIGN  '[' formlist ']'

where `formlist` has the syntax of the formals list for a function 
definition.  This would have the following semantics:

    {
      *tmp* <- expr

      # For arguments with no "default" expression,

      argname1 <- *tmp*[[1]]
      argname2 <- *tmp*[[2]]
      ...

      # For arguments with a default listed

      argname3 <- with(*tmp*, default3)
    }


The value of the whole thing would therefore be (invisibly) the value of 
the last item in the assignment.

Two examples:

   [A, B, C] <- expr   # assign the first three elements of expr to A, 
B, and C

   [A, B, C = a + b] <- expr  # assign the first two elements of expr
                              # to A and B,
                              # assign with(expr, a + b) to C.

Unfortunately, I don't think this could be done entirely by transforming 
the expression (which is the way |> was done), and that makes it a lot 
harder to write and to reason about.  E.g. what does this do?

   A <- 0
   [A, B = A + 10] <- list(1, A = 2)

According to the recipe above, I think it sets A to 1 and B to 12, but 
maybe a user would expect B to be 10 or 11.  And according to that 
recipe this is an error:

   [A, B = A + 10] <- c(1, A = 2)

which probably isn't what a user would expect, given that this is fine:

   [A, B] <- c(1, 2)

Duncan Murdoch


From @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch  Sat Mar 11 22:42:38 2023
From: @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch (Sebastian Martin Krantz)
Date: Sat, 11 Mar 2023 23:42:38 +0200
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
Message-ID: <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>

Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can follow
all aspects you raised, but to give my limited take on a few:

> your proposal violates a very basic property of the  language, i.e. that all statements are expressions and have a value.
> What's the value of 1 + (A, C = init_matrices()).

I'm not sure I see the point here. I evaluated  1 + (d = dim(mtcars);
nr = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error, as
the above expression should. `%=%` assigns to
environments, so 1 + (c("A", "C") %=% init_matrices()) returns
numeric(0), with A and C having their values assigned.

> suppose f() returns list(A = 1, B = 2) and I do
>  B, A <- f()
> Should assignment be by position or by name?

In other languages this is by position. The feature is not meant to
replace list2env(), and being able to rename objects in the assignment
is a vital feature of codes
using multi input and output functions e.g. in Matlab or Julia.

> Honestly, given that this is simply syntactic sugar, I don't think I would support it.

You can call it that, but it would be used by almost every R user
almost every day. Simple things like nr, nc = dim(x); values, vectors
= eigen(x) etc. where the creation of intermediate objects
is cumbersome and redundant.

> I see you've already mentioned it ("JavaScript-like"). I think it would  fulfil Sebastian's requirements too, as long as it is considered "true assignment" by the rest of the language.

I don't have strong opinions about how the issue is phrased or
implemented. Something like [t, n] = dim(x) might even be more clear.
It's important though that assignment remains by position,
so even if some output gets thrown away that should also be positional.

>  A <- 0
>  [A, B = A + 10] <- list(1, A = 2)

I also fail to see the use of allowing this. something like this is an error.

> A = 2
> (B = A + 1) <- 1
Error in (B = A + 1) <- 1 : could not find function "(<-"

Regarding the practical implementation, I think `collapse::%=%` is a
good starting point. It could be introduced in R as a separate
function, or `=` could be modified to accommodate its capability. It
should be clear that
with more than one LHS variables the assignment is an environment
level operation and the results can only be used in computations once
assigned to the environment, e.g. as in 1 + (c("A", "C") %=%
init_matrices()),
A and C are not available for the addition in this statement. The
interpretor then needs to be modified to read something like nr, nc =
dim(x) or [nr, nc] = dim(x). as an environment-level multiple
assignment operation with no
immediate value. Appears very feasible to my limited understanding,
but I guess there are other things to consider still. Definitely
appreciate the responses so far though.

Best regards,

Sebastian





On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:

> On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> > On Sat, 11 Mar 2023 11:11:06 -0500
> > Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> >
> >> That's clear, but your proposal violates a very basic property of the
> >> language, i.e. that all statements are expressions and have a value.
> >
> > How about reframing this feature request from multiple assignment
> > (which does go contrary to "everything has only one value, even if it's
> > sometimes invisible(NULL)") to "structured binding" / "destructuring
> > assignment" [*], which takes this single single value returned by the
> > expression and subsets it subject to certain rules? It may be easier to
> > make a decision on the semantics for destructuring assignment (e.g.
> > languages which have this feature typically allow throwing unneeded
> > parts of the return value away), and it doesn't seem to break as much
> > of the rest of the language if implemented.
> >
> > I see you've already mentioned it ("JavaScript-like"). I think it would
> > fulfil Sebastian's requirements too, as long as it is considered "true
> > assignment" by the rest of the language.
> >
> > The hard part is to propose the actual grammar of the new feature (in
> > terms of src/main/gram.y, preferably without introducing conflicts) and
> > its semantics (including the corner cases, some of which you have
> > already mentioned). I'm not sure I'm up to the task.
> >
>
> If I were doing it, here's what I'd propose:
>
>    '[' formlist ']' LEFT_ASSIGN expr
>    '[' formlist ']' EQ_ASSIGN expr
>    expr RIGHT_ASSIGN  '[' formlist ']'
>
> where `formlist` has the syntax of the formals list for a function
> definition.  This would have the following semantics:
>
>     {
>       *tmp* <- expr
>
>       # For arguments with no "default" expression,
>
>       argname1 <- *tmp*[[1]]
>       argname2 <- *tmp*[[2]]
>       ...
>
>       # For arguments with a default listed
>
>       argname3 <- with(*tmp*, default3)
>     }
>
>
> The value of the whole thing would therefore be (invisibly) the value of
> the last item in the assignment.
>
> Two examples:
>
>    [A, B, C] <- expr   # assign the first three elements of expr to A,
> B, and C
>
>    [A, B, C = a + b] <- expr  # assign the first two elements of expr
>                               # to A and B,
>                               # assign with(expr, a + b) to C.
>
> Unfortunately, I don't think this could be done entirely by transforming
> the expression (which is the way |> was done), and that makes it a lot
> harder to write and to reason about.  E.g. what does this do?
>
>    A <- 0
>    [A, B = A + 10] <- list(1, A = 2)
>
> According to the recipe above, I think it sets A to 1 and B to 12, but
> maybe a user would expect B to be 10 or 11.  And according to that
> recipe this is an error:
>
>    [A, B = A + 10] <- c(1, A = 2)
>
> which probably isn't what a user would expect, given that this is fine:
>
>    [A, B] <- c(1, 2)
>
> Duncan Murdoch
>

	[[alternative HTML version deleted]]


From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Mar 11 23:42:42 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sat, 11 Mar 2023 17:42:42 -0500
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
Message-ID: <9a7b5d53-6064-497f-6859-31fc77561737@gmail.com>

On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
> Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can 
> follow all aspects you raised, but to give my limited take on a few:
> 
>> your proposal violates a very basic property of the  language, i.e. that all statements are expressions and have a value.  > What's the value of 1 + (A, C = init_matrices()).
> 
> I'm not sure I see the point here. I evaluated 1 + (d = dim(mtcars); nr 
> = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error, as the 
> above expression should. `%=%` assigns to
> environments, so 1 + (c("A", "C") %=% init_matrices()) returns 
> numeric(0), with A and C having their values assigned.
> 
>> suppose f() returns list(A = 1, B = 2) and I do  > B, A <- f() > Should assignment be by position or by name?
> 
> In other languages this is by position. The feature is not meant to 
> replace list2env(), and being able to rename objects in the assignment 
> is a vital feature of codes
> using multi input and output functions e.g. in Matlab or Julia.
> 
>> Honestly, given that this is simply syntactic sugar, I don't think I would support it.
> 
> You can call it that, but it would be used by almost every R user almost 
> every day. Simple things like nr, nc = dim(x); values, vectors = 
> eigen(x) etc. where the creation of intermediate objects
> is cumbersome and redundant.
> 
>> I see you've already mentioned it ("JavaScript-like"). I think it would  fulfil Sebastian's requirements too, as long as it is considered "true assignment" by the rest of the language.
> 
> I don't have strong opinions about how the issue is phrased or 
> implemented. Something like [t, n] = dim(x) might even be more clear. 
> It's important though that assignment remains by position,
> so even if some output gets thrown away that should also be positional.
> 
>>  A <- 0  > [A, B = A + 10] <- list(1, A = 2)
> 
> I also fail to see the use of allowing this. something like this is an 
> error.
> 
>> A = 2
>> (B = A + 1) <- 1
> Error in (B = A + 1) <- 1 : could not find function "(<-"
> 
> Regarding the practical implementation, I think `collapse::%=%` is a 
> good starting point. It could be introduced in R as a separate function, 
> or `=` could be modified to accommodate its capability. It should be 
> clear that
> with more than one LHS variables the assignment is an environment level 
> operation and the results can only be used in computations once assigned 
> to the environment, e.g. as in 1 + (c("A", "C") %=% init_matrices()),
> A and C are not available for the addition in this statement. The 
> interpretor then needs to be modified to read something like nr, nc = 
> dim(x) or [nr, nc] = dim(x). as an environment-level multiple assignment 
> operation with no
> immediate value. Appears very feasible to my limited understanding, but 
> I guess there are other things to consider still. Definitely appreciate 
> the responses so far though.

Show me.

Duncan Murdoch

> 
> Best regards,
> 
> Sebastian
> 
> 
> 
> 
> 
> On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com 
> <mailto:murdoch.duncan at gmail.com>> wrote:
> 
>     On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
>      > On Sat, 11 Mar 2023 11:11:06 -0500
>      > Duncan Murdoch <murdoch.duncan at gmail.com
>     <mailto:murdoch.duncan at gmail.com>> wrote:
>      >
>      >> That's clear, but your proposal violates a very basic property
>     of the
>      >> language, i.e. that all statements are expressions and have a value.
>      >
>      > How about reframing this feature request from multiple assignment
>      > (which does go contrary to "everything has only one value, even
>     if it's
>      > sometimes invisible(NULL)") to "structured binding" / "destructuring
>      > assignment" [*], which takes this single single value returned by the
>      > expression and subsets it subject to certain rules? It may be
>     easier to
>      > make a decision on the semantics for destructuring assignment (e.g.
>      > languages which have this feature typically allow throwing unneeded
>      > parts of the return value away), and it doesn't seem to break as much
>      > of the rest of the language if implemented.
>      >
>      > I see you've already mentioned it ("JavaScript-like"). I think it
>     would
>      > fulfil Sebastian's requirements too, as long as it is considered
>     "true
>      > assignment" by the rest of the language.
>      >
>      > The hard part is to propose the actual grammar of the new feature (in
>      > terms of src/main/gram.y, preferably without introducing
>     conflicts) and
>      > its semantics (including the corner cases, some of which you have
>      > already mentioned). I'm not sure I'm up to the task.
>      >
> 
>     If I were doing it, here's what I'd propose:
> 
>      ? ?'[' formlist ']' LEFT_ASSIGN expr
>      ? ?'[' formlist ']' EQ_ASSIGN expr
>      ? ?expr RIGHT_ASSIGN? '[' formlist ']'
> 
>     where `formlist` has the syntax of the formals list for a function
>     definition.? This would have the following semantics:
> 
>      ? ? {
>      ? ? ? *tmp* <- expr
> 
>      ? ? ? # For arguments with no "default" expression,
> 
>      ? ? ? argname1 <- *tmp*[[1]]
>      ? ? ? argname2 <- *tmp*[[2]]
>      ? ? ? ...
> 
>      ? ? ? # For arguments with a default listed
> 
>      ? ? ? argname3 <- with(*tmp*, default3)
>      ? ? }
> 
> 
>     The value of the whole thing would therefore be (invisibly) the
>     value of
>     the last item in the assignment.
> 
>     Two examples:
> 
>      ? ?[A, B, C] <- expr? ?# assign the first three elements of expr to A,
>     B, and C
> 
>      ? ?[A, B, C = a + b] <- expr? # assign the first two elements of expr
>      ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? # to A and B,
>      ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? # assign with(expr, a + b) to C.
> 
>     Unfortunately, I don't think this could be done entirely by
>     transforming
>     the expression (which is the way |> was done), and that makes it a lot
>     harder to write and to reason about.? E.g. what does this do?
> 
>      ? ?A <- 0
>      ? ?[A, B = A + 10] <- list(1, A = 2)
> 
>     According to the recipe above, I think it sets A to 1 and B to 12, but
>     maybe a user would expect B to be 10 or 11.? And according to that
>     recipe this is an error:
> 
>      ? ?[A, B = A + 10] <- c(1, A = 2)
> 
>     which probably isn't what a user would expect, given that this is fine:
> 
>      ? ?[A, B] <- c(1, 2)
> 
>     Duncan Murdoch
>


From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Mar 11 23:44:16 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sat, 11 Mar 2023 17:44:16 -0500
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
Message-ID: <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>

On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
> Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can 
> follow all aspects you raised, but to give my limited take on a few:
> 
>> your proposal violates a very basic property of the  language, i.e. that all statements are expressions and have a value.  > What's the value of 1 + (A, C = init_matrices()).
> 
> I'm not sure I see the point here. I evaluated 1 + (d = dim(mtcars); nr 
> = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error,


   d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)

is not a statement, it is a sequence of 4 statements.

Duncan Murdoch

  as the
> above expression should. `%=%` assigns to
> environments, so 1 + (c("A", "C") %=% init_matrices()) returns 
> numeric(0), with A and C having their values assigned.
> 
>> suppose f() returns list(A = 1, B = 2) and I do  > B, A <- f() > Should assignment be by position or by name?
> 
> In other languages this is by position. The feature is not meant to 
> replace list2env(), and being able to rename objects in the assignment 
> is a vital feature of codes
> using multi input and output functions e.g. in Matlab or Julia.
> 
>> Honestly, given that this is simply syntactic sugar, I don't think I would support it.
> 
> You can call it that, but it would be used by almost every R user almost 
> every day. Simple things like nr, nc = dim(x); values, vectors = 
> eigen(x) etc. where the creation of intermediate objects
> is cumbersome and redundant.
> 
>> I see you've already mentioned it ("JavaScript-like"). I think it would  fulfil Sebastian's requirements too, as long as it is considered "true assignment" by the rest of the language.
> 
> I don't have strong opinions about how the issue is phrased or 
> implemented. Something like [t, n] = dim(x) might even be more clear. 
> It's important though that assignment remains by position,
> so even if some output gets thrown away that should also be positional.
> 
>>  A <- 0  > [A, B = A + 10] <- list(1, A = 2)
> 
> I also fail to see the use of allowing this. something like this is an 
> error.
> 
>> A = 2
>> (B = A + 1) <- 1
> Error in (B = A + 1) <- 1 : could not find function "(<-"
> 
> Regarding the practical implementation, I think `collapse::%=%` is a 
> good starting point. It could be introduced in R as a separate function, 
> or `=` could be modified to accommodate its capability. It should be 
> clear that
> with more than one LHS variables the assignment is an environment level 
> operation and the results can only be used in computations once assigned 
> to the environment, e.g. as in 1 + (c("A", "C") %=% init_matrices()),
> A and C are not available for the addition in this statement. The 
> interpretor then needs to be modified to read something like nr, nc = 
> dim(x) or [nr, nc] = dim(x). as an environment-level multiple assignment 
> operation with no
> immediate value. Appears very feasible to my limited understanding, but 
> I guess there are other things to consider still. Definitely appreciate 
> the responses so far though.
> 
> Best regards,
> 
> Sebastian
> 
> 
> 
> 
> 
> On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com 
> <mailto:murdoch.duncan at gmail.com>> wrote:
> 
>     On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
>      > On Sat, 11 Mar 2023 11:11:06 -0500
>      > Duncan Murdoch <murdoch.duncan at gmail.com
>     <mailto:murdoch.duncan at gmail.com>> wrote:
>      >
>      >> That's clear, but your proposal violates a very basic property
>     of the
>      >> language, i.e. that all statements are expressions and have a value.
>      >
>      > How about reframing this feature request from multiple assignment
>      > (which does go contrary to "everything has only one value, even
>     if it's
>      > sometimes invisible(NULL)") to "structured binding" / "destructuring
>      > assignment" [*], which takes this single single value returned by the
>      > expression and subsets it subject to certain rules? It may be
>     easier to
>      > make a decision on the semantics for destructuring assignment (e.g.
>      > languages which have this feature typically allow throwing unneeded
>      > parts of the return value away), and it doesn't seem to break as much
>      > of the rest of the language if implemented.
>      >
>      > I see you've already mentioned it ("JavaScript-like"). I think it
>     would
>      > fulfil Sebastian's requirements too, as long as it is considered
>     "true
>      > assignment" by the rest of the language.
>      >
>      > The hard part is to propose the actual grammar of the new feature (in
>      > terms of src/main/gram.y, preferably without introducing
>     conflicts) and
>      > its semantics (including the corner cases, some of which you have
>      > already mentioned). I'm not sure I'm up to the task.
>      >
> 
>     If I were doing it, here's what I'd propose:
> 
>      ? ?'[' formlist ']' LEFT_ASSIGN expr
>      ? ?'[' formlist ']' EQ_ASSIGN expr
>      ? ?expr RIGHT_ASSIGN? '[' formlist ']'
> 
>     where `formlist` has the syntax of the formals list for a function
>     definition.? This would have the following semantics:
> 
>      ? ? {
>      ? ? ? *tmp* <- expr
> 
>      ? ? ? # For arguments with no "default" expression,
> 
>      ? ? ? argname1 <- *tmp*[[1]]
>      ? ? ? argname2 <- *tmp*[[2]]
>      ? ? ? ...
> 
>      ? ? ? # For arguments with a default listed
> 
>      ? ? ? argname3 <- with(*tmp*, default3)
>      ? ? }
> 
> 
>     The value of the whole thing would therefore be (invisibly) the
>     value of
>     the last item in the assignment.
> 
>     Two examples:
> 
>      ? ?[A, B, C] <- expr? ?# assign the first three elements of expr to A,
>     B, and C
> 
>      ? ?[A, B, C = a + b] <- expr? # assign the first two elements of expr
>      ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? # to A and B,
>      ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? # assign with(expr, a + b) to C.
> 
>     Unfortunately, I don't think this could be done entirely by
>     transforming
>     the expression (which is the way |> was done), and that makes it a lot
>     harder to write and to reason about.? E.g. what does this do?
> 
>      ? ?A <- 0
>      ? ?[A, B = A + 10] <- list(1, A = 2)
> 
>     According to the recipe above, I think it sets A to 1 and B to 12, but
>     maybe a user would expect B to be 10 or 11.? And according to that
>     recipe this is an error:
> 
>      ? ?[A, B = A + 10] <- c(1, A = 2)
> 
>     which probably isn't what a user would expect, given that this is fine:
> 
>      ? ?[A, B] <- c(1, 2)
> 
>     Duncan Murdoch
>


From g@bembecker @end|ng |rom gm@||@com  Sat Mar 11 23:54:24 2023
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Sat, 11 Mar 2023 14:54:24 -0800
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
Message-ID: <CAD4oTHGkK_poav1qZF5L73-2J2sE1YwBEt2HWCd_=HaHGc2YzQ@mail.gmail.com>

There are some other considerations too (apologies if these were mentioned
above and I missed them). Also below are initial thoughts, so apologies for
any mistakes or oversights.

For example, if

[a, b] <- my2valuefun()

works the same as

local({
tmp <- my2valuefun()
stopifnot(is.list(tmp) && length(tmp) == 2)
a <<- tmp[[1]]
b <<- tmp[[2]]
})

Do we expect

[a[1], b[3]] <- my2valuefun()

to also work? That doesn't sound very fun to me, personally, but obviously
the "single value return" versions of these do work and have for a long
time, i.e.

a[1] <- my2valuefun()[[1]]
b[3] <- my2valuefun()[[2]]

is perfectly valid R code (though it does call the function twice which is
"silly" in some sense).

Another thing which arises from the Julia API specifically which I think is
problematic is the ambiguity of's atomic "types" being vectors. Consider
the following

coolest_function <- function() c(a = 15, b = 65, c = 275)
a <- coolest_function()

That obviously makes a vector of length 3. Anything else would break *like
all the R code*

But now, what does

[a] <- coolest_function()

do? Does it assign 15 to a, because b and c arent' being assigned to?

Does this mean variables being assigned to actually need to *match the
names within the return object*? I don't think that would work at all in
general...

Alternatively, is the second one an error, because the function isn't
returning a list? This doesn't really fix the problem either though

Because a single list of length > 1 *is a valid thing to return from an R
function*. I think, like in Julia, you'd need to declare the set of things
being returned, and perhaps map them to the variables you want assigned

crazy_notworking_fun <- function() {
  return(a = 5, b = 65, c = 275)
}

[a_val = a, b_val = b] <- crazy_notworking_fun()

Or even,

[a_val <- a, b_val <-b] <- crazy_notworking_fun()


In that case, however, it becomes somewhat unclear (to me at least) what

only_val <- crazy_notworking_fun()

would do. Throw an error because multivalued functions are fundamentally
different and we can't pretend they aren't? This would disallow all of the
things you think "most r users would use every day" (a claim I'm somewhat
skeptical of, to be honest). If thats not it, though, what? I don't think
it can/should return the full list of results, because that introduces the
ambiguity this is trying to avoid right back in.  Perhaps just the first
thing returned? That is internally consistent, but  somewhat strange
behavior...

Best,
~G




On Sat, Mar 11, 2023 at 2:15?PM Sebastian Martin Krantz <
sebastian.krantz at graduateinstitute.ch> wrote:

> Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can follow
> all aspects you raised, but to give my limited take on a few:
>
> > your proposal violates a very basic property of the  language, i.e. that
> all statements are expressions and have a value.
> > What's the value of 1 + (A, C = init_matrices()).
>
> I'm not sure I see the point here. I evaluated  1 + (d = dim(mtcars);
> nr = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error, as
> the above expression should. `%=%` assigns to
> environments, so 1 + (c("A", "C") %=% init_matrices()) returns
> numeric(0), with A and C having their values assigned.
>
> > suppose f() returns list(A = 1, B = 2) and I do
> >  B, A <- f()
> > Should assignment be by position or by name?
>
> In other languages this is by position. The feature is not meant to
> replace list2env(), and being able to rename objects in the assignment
> is a vital feature of codes
> using multi input and output functions e.g. in Matlab or Julia.
>
> > Honestly, given that this is simply syntactic sugar, I don't think I
> would support it.
>
> You can call it that, but it would be used by almost every R user
> almost every day. Simple things like nr, nc = dim(x); values, vectors
> = eigen(x) etc. where the creation of intermediate objects
> is cumbersome and redundant.
>
> > I see you've already mentioned it ("JavaScript-like"). I think it would
> fulfil Sebastian's requirements too, as long as it is considered "true
> assignment" by the rest of the language.
>
> I don't have strong opinions about how the issue is phrased or
> implemented. Something like [t, n] = dim(x) might even be more clear.
> It's important though that assignment remains by position,
> so even if some output gets thrown away that should also be positional.
>
> >  A <- 0
> >  [A, B = A + 10] <- list(1, A = 2)
>
> I also fail to see the use of allowing this. something like this is an
> error.
>
> > A = 2
> > (B = A + 1) <- 1
> Error in (B = A + 1) <- 1 : could not find function "(<-"
>
> Regarding the practical implementation, I think `collapse::%=%` is a
> good starting point. It could be introduced in R as a separate
> function, or `=` could be modified to accommodate its capability. It
> should be clear that
> with more than one LHS variables the assignment is an environment
> level operation and the results can only be used in computations once
> assigned to the environment, e.g. as in 1 + (c("A", "C") %=%
> init_matrices()),
> A and C are not available for the addition in this statement. The
> interpretor then needs to be modified to read something like nr, nc =
> dim(x) or [nr, nc] = dim(x). as an environment-level multiple
> assignment operation with no
> immediate value. Appears very feasible to my limited understanding,
> but I guess there are other things to consider still. Definitely
> appreciate the responses so far though.
>
> Best regards,
>
> Sebastian
>
>
>
>
>
> On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
>
> > On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> > > On Sat, 11 Mar 2023 11:11:06 -0500
> > > Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> > >
> > >> That's clear, but your proposal violates a very basic property of the
> > >> language, i.e. that all statements are expressions and have a value.
> > >
> > > How about reframing this feature request from multiple assignment
> > > (which does go contrary to "everything has only one value, even if it's
> > > sometimes invisible(NULL)") to "structured binding" / "destructuring
> > > assignment" [*], which takes this single single value returned by the
> > > expression and subsets it subject to certain rules? It may be easier to
> > > make a decision on the semantics for destructuring assignment (e.g.
> > > languages which have this feature typically allow throwing unneeded
> > > parts of the return value away), and it doesn't seem to break as much
> > > of the rest of the language if implemented.
> > >
> > > I see you've already mentioned it ("JavaScript-like"). I think it would
> > > fulfil Sebastian's requirements too, as long as it is considered "true
> > > assignment" by the rest of the language.
> > >
> > > The hard part is to propose the actual grammar of the new feature (in
> > > terms of src/main/gram.y, preferably without introducing conflicts) and
> > > its semantics (including the corner cases, some of which you have
> > > already mentioned). I'm not sure I'm up to the task.
> > >
> >
> > If I were doing it, here's what I'd propose:
> >
> >    '[' formlist ']' LEFT_ASSIGN expr
> >    '[' formlist ']' EQ_ASSIGN expr
> >    expr RIGHT_ASSIGN  '[' formlist ']'
> >
> > where `formlist` has the syntax of the formals list for a function
> > definition.  This would have the following semantics:
> >
> >     {
> >       *tmp* <- expr
> >
> >       # For arguments with no "default" expression,
> >
> >       argname1 <- *tmp*[[1]]
> >       argname2 <- *tmp*[[2]]
> >       ...
> >
> >       # For arguments with a default listed
> >
> >       argname3 <- with(*tmp*, default3)
> >     }
> >
> >
> > The value of the whole thing would therefore be (invisibly) the value of
> > the last item in the assignment.
> >
> > Two examples:
> >
> >    [A, B, C] <- expr   # assign the first three elements of expr to A,
> > B, and C
> >
> >    [A, B, C = a + b] <- expr  # assign the first two elements of expr
> >                               # to A and B,
> >                               # assign with(expr, a + b) to C.
> >
> > Unfortunately, I don't think this could be done entirely by transforming
> > the expression (which is the way |> was done), and that makes it a lot
> > harder to write and to reason about.  E.g. what does this do?
> >
> >    A <- 0
> >    [A, B = A + 10] <- list(1, A = 2)
> >
> > According to the recipe above, I think it sets A to 1 and B to 12, but
> > maybe a user would expect B to be 10 or 11.  And according to that
> > recipe this is an error:
> >
> >    [A, B = A + 10] <- c(1, A = 2)
> >
> > which probably isn't what a user would expect, given that this is fine:
> >
> >    [A, B] <- c(1, 2)
> >
> > Duncan Murdoch
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From kev|nu@hey @end|ng |rom gm@||@com  Sun Mar 12 00:00:16 2023
From: kev|nu@hey @end|ng |rom gm@||@com (Kevin Ushey)
Date: Sat, 11 Mar 2023 15:00:16 -0800
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
Message-ID: <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>

FWIW, it's possible to get fairly close to your proposed semantics
using the existing metaprogramming facilities in R. I put together a
prototype package here to demonstrate:

    https://github.com/kevinushey/dotty

The package exports an object called `.`, with a special `[<-.dot` S3
method which enables destructuring assignments. This means you can
write code like:

    .[nr, nc] <- dim(mtcars)

and that will define 'nr' and 'nc' as you expect.

As for R CMD check warnings, you can suppress those through the use of
globalVariables(), and that can also be automated within the package.
The 'dotty' package includes a function 'dotify()' which automates
looking for such usages in your package, and calling globalVariables()
so that R CMD check doesn't warn. In theory, a similar technique would
be applicable to other packages defining similar operators (zeallot,
collapse).

Obviously, globalVariables() is a very heavy hammer to swing for this
issue, but you might consider the benefits worth the tradeoffs.

Best,
Kevin

On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>
> On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
> > Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can
> > follow all aspects you raised, but to give my limited take on a few:
> >
> >> your proposal violates a very basic property of the  language, i.e. that all statements are expressions and have a value.  > What's the value of 1 + (A, C = init_matrices()).
> >
> > I'm not sure I see the point here. I evaluated 1 + (d = dim(mtcars); nr
> > = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error,
>
>
>    d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
>
> is not a statement, it is a sequence of 4 statements.
>
> Duncan Murdoch
>
>   as the
> > above expression should. `%=%` assigns to
> > environments, so 1 + (c("A", "C") %=% init_matrices()) returns
> > numeric(0), with A and C having their values assigned.
> >
> >> suppose f() returns list(A = 1, B = 2) and I do  > B, A <- f() > Should assignment be by position or by name?
> >
> > In other languages this is by position. The feature is not meant to
> > replace list2env(), and being able to rename objects in the assignment
> > is a vital feature of codes
> > using multi input and output functions e.g. in Matlab or Julia.
> >
> >> Honestly, given that this is simply syntactic sugar, I don't think I would support it.
> >
> > You can call it that, but it would be used by almost every R user almost
> > every day. Simple things like nr, nc = dim(x); values, vectors =
> > eigen(x) etc. where the creation of intermediate objects
> > is cumbersome and redundant.
> >
> >> I see you've already mentioned it ("JavaScript-like"). I think it would  fulfil Sebastian's requirements too, as long as it is considered "true assignment" by the rest of the language.
> >
> > I don't have strong opinions about how the issue is phrased or
> > implemented. Something like [t, n] = dim(x) might even be more clear.
> > It's important though that assignment remains by position,
> > so even if some output gets thrown away that should also be positional.
> >
> >>  A <- 0  > [A, B = A + 10] <- list(1, A = 2)
> >
> > I also fail to see the use of allowing this. something like this is an
> > error.
> >
> >> A = 2
> >> (B = A + 1) <- 1
> > Error in (B = A + 1) <- 1 : could not find function "(<-"
> >
> > Regarding the practical implementation, I think `collapse::%=%` is a
> > good starting point. It could be introduced in R as a separate function,
> > or `=` could be modified to accommodate its capability. It should be
> > clear that
> > with more than one LHS variables the assignment is an environment level
> > operation and the results can only be used in computations once assigned
> > to the environment, e.g. as in 1 + (c("A", "C") %=% init_matrices()),
> > A and C are not available for the addition in this statement. The
> > interpretor then needs to be modified to read something like nr, nc =
> > dim(x) or [nr, nc] = dim(x). as an environment-level multiple assignment
> > operation with no
> > immediate value. Appears very feasible to my limited understanding, but
> > I guess there are other things to consider still. Definitely appreciate
> > the responses so far though.
> >
> > Best regards,
> >
> > Sebastian
> >
> >
> >
> >
> >
> > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com
> > <mailto:murdoch.duncan at gmail.com>> wrote:
> >
> >     On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> >      > On Sat, 11 Mar 2023 11:11:06 -0500
> >      > Duncan Murdoch <murdoch.duncan at gmail.com
> >     <mailto:murdoch.duncan at gmail.com>> wrote:
> >      >
> >      >> That's clear, but your proposal violates a very basic property
> >     of the
> >      >> language, i.e. that all statements are expressions and have a value.
> >      >
> >      > How about reframing this feature request from multiple assignment
> >      > (which does go contrary to "everything has only one value, even
> >     if it's
> >      > sometimes invisible(NULL)") to "structured binding" / "destructuring
> >      > assignment" [*], which takes this single single value returned by the
> >      > expression and subsets it subject to certain rules? It may be
> >     easier to
> >      > make a decision on the semantics for destructuring assignment (e.g.
> >      > languages which have this feature typically allow throwing unneeded
> >      > parts of the return value away), and it doesn't seem to break as much
> >      > of the rest of the language if implemented.
> >      >
> >      > I see you've already mentioned it ("JavaScript-like"). I think it
> >     would
> >      > fulfil Sebastian's requirements too, as long as it is considered
> >     "true
> >      > assignment" by the rest of the language.
> >      >
> >      > The hard part is to propose the actual grammar of the new feature (in
> >      > terms of src/main/gram.y, preferably without introducing
> >     conflicts) and
> >      > its semantics (including the corner cases, some of which you have
> >      > already mentioned). I'm not sure I'm up to the task.
> >      >
> >
> >     If I were doing it, here's what I'd propose:
> >
> >         '[' formlist ']' LEFT_ASSIGN expr
> >         '[' formlist ']' EQ_ASSIGN expr
> >         expr RIGHT_ASSIGN  '[' formlist ']'
> >
> >     where `formlist` has the syntax of the formals list for a function
> >     definition.  This would have the following semantics:
> >
> >          {
> >            *tmp* <- expr
> >
> >            # For arguments with no "default" expression,
> >
> >            argname1 <- *tmp*[[1]]
> >            argname2 <- *tmp*[[2]]
> >            ...
> >
> >            # For arguments with a default listed
> >
> >            argname3 <- with(*tmp*, default3)
> >          }
> >
> >
> >     The value of the whole thing would therefore be (invisibly) the
> >     value of
> >     the last item in the assignment.
> >
> >     Two examples:
> >
> >         [A, B, C] <- expr   # assign the first three elements of expr to A,
> >     B, and C
> >
> >         [A, B, C = a + b] <- expr  # assign the first two elements of expr
> >                                    # to A and B,
> >                                    # assign with(expr, a + b) to C.
> >
> >     Unfortunately, I don't think this could be done entirely by
> >     transforming
> >     the expression (which is the way |> was done), and that makes it a lot
> >     harder to write and to reason about.  E.g. what does this do?
> >
> >         A <- 0
> >         [A, B = A + 10] <- list(1, A = 2)
> >
> >     According to the recipe above, I think it sets A to 1 and B to 12, but
> >     maybe a user would expect B to be 10 or 11.  And according to that
> >     recipe this is an error:
> >
> >         [A, B = A + 10] <- c(1, A = 2)
> >
> >     which probably isn't what a user would expect, given that this is fine:
> >
> >         [A, B] <- c(1, 2)
> >
> >     Duncan Murdoch
> >
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @vi@e@gross m@iii@g oii gm@ii@com  Sun Mar 12 02:09:20 2023
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Sat, 11 Mar 2023 20:09:20 -0500
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAD4oTHGkK_poav1qZF5L73-2J2sE1YwBEt2HWCd_=HaHGc2YzQ@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <CAD4oTHGkK_poav1qZF5L73-2J2sE1YwBEt2HWCd_=HaHGc2YzQ@mail.gmail.com>
Message-ID: <002501d9547f$46fa2a40$d4ee7ec0$@gmail.com>

I am not personally for or against changes to the R main language but do find that too many people keep wanting to change R so it should be like some other language. Many features would be nice, especially if they do not break existing code, but the time and effort and other overheads need to be a consideration.

R has long had a concept of returning a data structure with inner parts such as from calling lm() or ggplot() that can be used to store lots of info, often including saved copies of the data and parameters that generated it, and you can often update the object or query it for specific fields or pass it intact to some next step.

Anyone wanting to return multiple results has classically done something like return a list containing named items and your code had the option of unpacking the parts you want and ignoring others. This may not be modern or elegant but so what?

I could go through a long list of nice things I see in other languages and ask if R has that ability now (perhaps in a package) or should have it.

Do we need a swap like:

  a, b <- b, a

Do we need a dual comparative like:

If ( -5 < X < 5) ...

The two examples work fine in Python as do many other things but Python is not R and cannot trivially do many things R does either.

Many programming languages have been converging in some ways. SCALA version 3 simplified many parts of the language by borrowing their own version of using indentation from languages like Haskell and Python. Personally, I like it but it causes some headaches for older code and you have to either change the code or disable the feature. So, anyone think R should follow through and also allow many places that now use grouping by curly braces or other methods, to use indentation level?

I am NOT saying any additions are impossible but we need to keep the base language working well on existing code or perhaps make a clean break and make a new version of R (I assume logically Q as in S went to S-- (AKA R) so R-- would be Q, LOL!

There is a community of users of a language who are partially here based on existing R packages. Some can probably find more and more functionality along the same lines as Python modules and elsewhere with some work and continue in a language that may fit their personal preferences. But the people responsible for maintaining and developing R are not just casual users and would have to do serious amounts of work choosing what it would look like and how to implement it, and deal with edge cases and complaints.

The new R pipe is a case in point. Why was it added? I mean I have been using various pipes including in the tidyverse for years quite happily. I did not need it added except perhaps for performance reasons. But when it came out, it had a rather glaring incompatibility in some ways with not providing a fairly trivial way to pass the pipeline to anything other than the first positional variable. Sure, they added a kludge using a horrible to read anonymous function syntax that I suspect many will not use and rather find their own ways around. 

But am I glad it was added? Sure. Could they have improved something else instead that was missing? I mean I use the glue package but would love something like an f-string built in that did pretty much stuff like that as can be found in other languages. 

This may sound stupid, but if someone wants features from another language, maybe they should consider using the two languages together and alternating which one diddles with your data as can be done multiple ways already.

Will that solve what the OP wants? Nope. They want whatever tool they are using to become a Swiss Army Knife.

But there is something to be said for a sparse language that does a few things well and does not grow just to grow and be like everyone else.






-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel Becker
Sent: Saturday, March 11, 2023 5:54 PM
To: Sebastian Martin Krantz <sebastian.krantz at graduateinstitute.ch>
Cc: r-devel <r-devel at r-project.org>
Subject: Re: [Rd] Multiple Assignment built into the R Interpreter?

There are some other considerations too (apologies if these were mentioned
above and I missed them). Also below are initial thoughts, so apologies for
any mistakes or oversights.

For example, if

[a, b] <- my2valuefun()

works the same as

local({
tmp <- my2valuefun()
stopifnot(is.list(tmp) && length(tmp) == 2)
a <<- tmp[[1]]
b <<- tmp[[2]]
})

Do we expect

[a[1], b[3]] <- my2valuefun()

to also work? That doesn't sound very fun to me, personally, but obviously
the "single value return" versions of these do work and have for a long
time, i.e.

a[1] <- my2valuefun()[[1]]
b[3] <- my2valuefun()[[2]]

is perfectly valid R code (though it does call the function twice which is
"silly" in some sense).

Another thing which arises from the Julia API specifically which I think is
problematic is the ambiguity of's atomic "types" being vectors. Consider
the following

coolest_function <- function() c(a = 15, b = 65, c = 275)
a <- coolest_function()

That obviously makes a vector of length 3. Anything else would break *like
all the R code*

But now, what does

[a] <- coolest_function()

do? Does it assign 15 to a, because b and c arent' being assigned to?

Does this mean variables being assigned to actually need to *match the
names within the return object*? I don't think that would work at all in
general...

Alternatively, is the second one an error, because the function isn't
returning a list? This doesn't really fix the problem either though

Because a single list of length > 1 *is a valid thing to return from an R
function*. I think, like in Julia, you'd need to declare the set of things
being returned, and perhaps map them to the variables you want assigned

crazy_notworking_fun <- function() {
  return(a = 5, b = 65, c = 275)
}

[a_val = a, b_val = b] <- crazy_notworking_fun()

Or even,

[a_val <- a, b_val <-b] <- crazy_notworking_fun()


In that case, however, it becomes somewhat unclear (to me at least) what

only_val <- crazy_notworking_fun()

would do. Throw an error because multivalued functions are fundamentally
different and we can't pretend they aren't? This would disallow all of the
things you think "most r users would use every day" (a claim I'm somewhat
skeptical of, to be honest). If thats not it, though, what? I don't think
it can/should return the full list of results, because that introduces the
ambiguity this is trying to avoid right back in.  Perhaps just the first
thing returned? That is internally consistent, but  somewhat strange
behavior...

Best,
~G




On Sat, Mar 11, 2023 at 2:15?PM Sebastian Martin Krantz <
sebastian.krantz at graduateinstitute.ch> wrote:

> Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can follow
> all aspects you raised, but to give my limited take on a few:
>
> > your proposal violates a very basic property of the  language, i.e. that
> all statements are expressions and have a value.
> > What's the value of 1 + (A, C = init_matrices()).
>
> I'm not sure I see the point here. I evaluated  1 + (d = dim(mtcars);
> nr = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error, as
> the above expression should. `%=%` assigns to
> environments, so 1 + (c("A", "C") %=% init_matrices()) returns
> numeric(0), with A and C having their values assigned.
>
> > suppose f() returns list(A = 1, B = 2) and I do
> >  B, A <- f()
> > Should assignment be by position or by name?
>
> In other languages this is by position. The feature is not meant to
> replace list2env(), and being able to rename objects in the assignment
> is a vital feature of codes
> using multi input and output functions e.g. in Matlab or Julia.
>
> > Honestly, given that this is simply syntactic sugar, I don't think I
> would support it.
>
> You can call it that, but it would be used by almost every R user
> almost every day. Simple things like nr, nc = dim(x); values, vectors
> = eigen(x) etc. where the creation of intermediate objects
> is cumbersome and redundant.
>
> > I see you've already mentioned it ("JavaScript-like"). I think it would
> fulfil Sebastian's requirements too, as long as it is considered "true
> assignment" by the rest of the language.
>
> I don't have strong opinions about how the issue is phrased or
> implemented. Something like [t, n] = dim(x) might even be more clear.
> It's important though that assignment remains by position,
> so even if some output gets thrown away that should also be positional.
>
> >  A <- 0
> >  [A, B = A + 10] <- list(1, A = 2)
>
> I also fail to see the use of allowing this. something like this is an
> error.
>
> > A = 2
> > (B = A + 1) <- 1
> Error in (B = A + 1) <- 1 : could not find function "(<-"
>
> Regarding the practical implementation, I think `collapse::%=%` is a
> good starting point. It could be introduced in R as a separate
> function, or `=` could be modified to accommodate its capability. It
> should be clear that
> with more than one LHS variables the assignment is an environment
> level operation and the results can only be used in computations once
> assigned to the environment, e.g. as in 1 + (c("A", "C") %=%
> init_matrices()),
> A and C are not available for the addition in this statement. The
> interpretor then needs to be modified to read something like nr, nc =
> dim(x) or [nr, nc] = dim(x). as an environment-level multiple
> assignment operation with no
> immediate value. Appears very feasible to my limited understanding,
> but I guess there are other things to consider still. Definitely
> appreciate the responses so far though.
>
> Best regards,
>
> Sebastian
>
>
>
>
>
> On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
>
> > On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> > > On Sat, 11 Mar 2023 11:11:06 -0500
> > > Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> > >
> > >> That's clear, but your proposal violates a very basic property of the
> > >> language, i.e. that all statements are expressions and have a value.
> > >
> > > How about reframing this feature request from multiple assignment
> > > (which does go contrary to "everything has only one value, even if it's
> > > sometimes invisible(NULL)") to "structured binding" / "destructuring
> > > assignment" [*], which takes this single single value returned by the
> > > expression and subsets it subject to certain rules? It may be easier to
> > > make a decision on the semantics for destructuring assignment (e.g.
> > > languages which have this feature typically allow throwing unneeded
> > > parts of the return value away), and it doesn't seem to break as much
> > > of the rest of the language if implemented.
> > >
> > > I see you've already mentioned it ("JavaScript-like"). I think it would
> > > fulfil Sebastian's requirements too, as long as it is considered "true
> > > assignment" by the rest of the language.
> > >
> > > The hard part is to propose the actual grammar of the new feature (in
> > > terms of src/main/gram.y, preferably without introducing conflicts) and
> > > its semantics (including the corner cases, some of which you have
> > > already mentioned). I'm not sure I'm up to the task.
> > >
> >
> > If I were doing it, here's what I'd propose:
> >
> >    '[' formlist ']' LEFT_ASSIGN expr
> >    '[' formlist ']' EQ_ASSIGN expr
> >    expr RIGHT_ASSIGN  '[' formlist ']'
> >
> > where `formlist` has the syntax of the formals list for a function
> > definition.  This would have the following semantics:
> >
> >     {
> >       *tmp* <- expr
> >
> >       # For arguments with no "default" expression,
> >
> >       argname1 <- *tmp*[[1]]
> >       argname2 <- *tmp*[[2]]
> >       ...
> >
> >       # For arguments with a default listed
> >
> >       argname3 <- with(*tmp*, default3)
> >     }
> >
> >
> > The value of the whole thing would therefore be (invisibly) the value of
> > the last item in the assignment.
> >
> > Two examples:
> >
> >    [A, B, C] <- expr   # assign the first three elements of expr to A,
> > B, and C
> >
> >    [A, B, C = a + b] <- expr  # assign the first two elements of expr
> >                               # to A and B,
> >                               # assign with(expr, a + b) to C.
> >
> > Unfortunately, I don't think this could be done entirely by transforming
> > the expression (which is the way |> was done), and that makes it a lot
> > harder to write and to reason about.  E.g. what does this do?
> >
> >    A <- 0
> >    [A, B = A + 10] <- list(1, A = 2)
> >
> > According to the recipe above, I think it sets A to 1 and B to 12, but
> > maybe a user would expect B to be 10 or 11.  And according to that
> > recipe this is an error:
> >
> >    [A, B = A + 10] <- c(1, A = 2)
> >
> > which probably isn't what a user would expect, given that this is fine:
> >
> >    [A, B] <- c(1, 2)
> >
> > Duncan Murdoch
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Mar 12 11:06:33 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sun, 12 Mar 2023 06:06:33 -0400
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
Message-ID: <a5554b05-be93-3661-7dc8-9f6d8e8dd930@gmail.com>

I really like it!  Nicely done.

Duncan Murdoch


On 11/03/2023 6:00 p.m., Kevin Ushey wrote:
> FWIW, it's possible to get fairly close to your proposed semantics
> using the existing metaprogramming facilities in R. I put together a
> prototype package here to demonstrate:
> 
>      https://github.com/kevinushey/dotty
> 
> The package exports an object called `.`, with a special `[<-.dot` S3
> method which enables destructuring assignments. This means you can
> write code like:
> 
>      .[nr, nc] <- dim(mtcars)
> 
> and that will define 'nr' and 'nc' as you expect.
> 
> As for R CMD check warnings, you can suppress those through the use of
> globalVariables(), and that can also be automated within the package.
> The 'dotty' package includes a function 'dotify()' which automates
> looking for such usages in your package, and calling globalVariables()
> so that R CMD check doesn't warn. In theory, a similar technique would
> be applicable to other packages defining similar operators (zeallot,
> collapse).
> 
> Obviously, globalVariables() is a very heavy hammer to swing for this
> issue, but you might consider the benefits worth the tradeoffs.
> 
> Best,
> Kevin
> 
> On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>
>> On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
>>> Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can
>>> follow all aspects you raised, but to give my limited take on a few:
>>>
>>>> your proposal violates a very basic property of the  language, i.e. that all statements are expressions and have a value.  > What's the value of 1 + (A, C = init_matrices()).
>>>
>>> I'm not sure I see the point here. I evaluated 1 + (d = dim(mtcars); nr
>>> = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error,
>>
>>
>>     d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
>>
>> is not a statement, it is a sequence of 4 statements.
>>
>> Duncan Murdoch
>>
>>    as the
>>> above expression should. `%=%` assigns to
>>> environments, so 1 + (c("A", "C") %=% init_matrices()) returns
>>> numeric(0), with A and C having their values assigned.
>>>
>>>> suppose f() returns list(A = 1, B = 2) and I do  > B, A <- f() > Should assignment be by position or by name?
>>>
>>> In other languages this is by position. The feature is not meant to
>>> replace list2env(), and being able to rename objects in the assignment
>>> is a vital feature of codes
>>> using multi input and output functions e.g. in Matlab or Julia.
>>>
>>>> Honestly, given that this is simply syntactic sugar, I don't think I would support it.
>>>
>>> You can call it that, but it would be used by almost every R user almost
>>> every day. Simple things like nr, nc = dim(x); values, vectors =
>>> eigen(x) etc. where the creation of intermediate objects
>>> is cumbersome and redundant.
>>>
>>>> I see you've already mentioned it ("JavaScript-like"). I think it would  fulfil Sebastian's requirements too, as long as it is considered "true assignment" by the rest of the language.
>>>
>>> I don't have strong opinions about how the issue is phrased or
>>> implemented. Something like [t, n] = dim(x) might even be more clear.
>>> It's important though that assignment remains by position,
>>> so even if some output gets thrown away that should also be positional.
>>>
>>>>   A <- 0  > [A, B = A + 10] <- list(1, A = 2)
>>>
>>> I also fail to see the use of allowing this. something like this is an
>>> error.
>>>
>>>> A = 2
>>>> (B = A + 1) <- 1
>>> Error in (B = A + 1) <- 1 : could not find function "(<-"
>>>
>>> Regarding the practical implementation, I think `collapse::%=%` is a
>>> good starting point. It could be introduced in R as a separate function,
>>> or `=` could be modified to accommodate its capability. It should be
>>> clear that
>>> with more than one LHS variables the assignment is an environment level
>>> operation and the results can only be used in computations once assigned
>>> to the environment, e.g. as in 1 + (c("A", "C") %=% init_matrices()),
>>> A and C are not available for the addition in this statement. The
>>> interpretor then needs to be modified to read something like nr, nc =
>>> dim(x) or [nr, nc] = dim(x). as an environment-level multiple assignment
>>> operation with no
>>> immediate value. Appears very feasible to my limited understanding, but
>>> I guess there are other things to consider still. Definitely appreciate
>>> the responses so far though.
>>>
>>> Best regards,
>>>
>>> Sebastian
>>>
>>>
>>>
>>>
>>>
>>> On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com
>>> <mailto:murdoch.duncan at gmail.com>> wrote:
>>>
>>>      On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
>>>       > On Sat, 11 Mar 2023 11:11:06 -0500
>>>       > Duncan Murdoch <murdoch.duncan at gmail.com
>>>      <mailto:murdoch.duncan at gmail.com>> wrote:
>>>       >
>>>       >> That's clear, but your proposal violates a very basic property
>>>      of the
>>>       >> language, i.e. that all statements are expressions and have a value.
>>>       >
>>>       > How about reframing this feature request from multiple assignment
>>>       > (which does go contrary to "everything has only one value, even
>>>      if it's
>>>       > sometimes invisible(NULL)") to "structured binding" / "destructuring
>>>       > assignment" [*], which takes this single single value returned by the
>>>       > expression and subsets it subject to certain rules? It may be
>>>      easier to
>>>       > make a decision on the semantics for destructuring assignment (e.g.
>>>       > languages which have this feature typically allow throwing unneeded
>>>       > parts of the return value away), and it doesn't seem to break as much
>>>       > of the rest of the language if implemented.
>>>       >
>>>       > I see you've already mentioned it ("JavaScript-like"). I think it
>>>      would
>>>       > fulfil Sebastian's requirements too, as long as it is considered
>>>      "true
>>>       > assignment" by the rest of the language.
>>>       >
>>>       > The hard part is to propose the actual grammar of the new feature (in
>>>       > terms of src/main/gram.y, preferably without introducing
>>>      conflicts) and
>>>       > its semantics (including the corner cases, some of which you have
>>>       > already mentioned). I'm not sure I'm up to the task.
>>>       >
>>>
>>>      If I were doing it, here's what I'd propose:
>>>
>>>          '[' formlist ']' LEFT_ASSIGN expr
>>>          '[' formlist ']' EQ_ASSIGN expr
>>>          expr RIGHT_ASSIGN  '[' formlist ']'
>>>
>>>      where `formlist` has the syntax of the formals list for a function
>>>      definition.  This would have the following semantics:
>>>
>>>           {
>>>             *tmp* <- expr
>>>
>>>             # For arguments with no "default" expression,
>>>
>>>             argname1 <- *tmp*[[1]]
>>>             argname2 <- *tmp*[[2]]
>>>             ...
>>>
>>>             # For arguments with a default listed
>>>
>>>             argname3 <- with(*tmp*, default3)
>>>           }
>>>
>>>
>>>      The value of the whole thing would therefore be (invisibly) the
>>>      value of
>>>      the last item in the assignment.
>>>
>>>      Two examples:
>>>
>>>          [A, B, C] <- expr   # assign the first three elements of expr to A,
>>>      B, and C
>>>
>>>          [A, B, C = a + b] <- expr  # assign the first two elements of expr
>>>                                     # to A and B,
>>>                                     # assign with(expr, a + b) to C.
>>>
>>>      Unfortunately, I don't think this could be done entirely by
>>>      transforming
>>>      the expression (which is the way |> was done), and that makes it a lot
>>>      harder to write and to reason about.  E.g. what does this do?
>>>
>>>          A <- 0
>>>          [A, B = A + 10] <- list(1, A = 2)
>>>
>>>      According to the recipe above, I think it sets A to 1 and B to 12, but
>>>      maybe a user would expect B to be 10 or 11.  And according to that
>>>      recipe this is an error:
>>>
>>>          [A, B = A + 10] <- c(1, A = 2)
>>>
>>>      which probably isn't what a user would expect, given that this is fine:
>>>
>>>          [A, B] <- c(1, 2)
>>>
>>>      Duncan Murdoch
>>>
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Mar 12 12:18:20 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sun, 12 Mar 2023 07:18:20 -0400
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxCLE9j1XiGwRevcAHu_EHYXaA=aBSREbb3SDUXWMiNHyg@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
 <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>
 <CAOsNuxCLE9j1XiGwRevcAHu_EHYXaA=aBSREbb3SDUXWMiNHyg@mail.gmail.com>
Message-ID: <05b0cf79-d768-7e6e-6dcf-502a14fcef84@gmail.com>

On 12/03/2023 6:07 a.m., Sebastian Martin Krantz wrote:
> Thinking more about this, and seeing Kevins examples at 
> https://github.com/kevinushey/dotty 
> <https://github.com/kevinushey/dotty>, I think this is the most R-like 
> way of doing it,
> with an additional benefit as it would allow to introduce the useful 
> data.table semantics DT[, .(a = b, c, d)] to more general R. So I would 
> propose to
> introduce a new primitive function . <- function(...) .Primitive(".") in 
> R with an assignment method and the following features:

I think that proposal is very unlikely to be accepted.  If it was a 
primitive function, it could only be maintained by R Core.  They are 
justifiably very reluctant to take on extra work for themselves.

Kevin's package demonstrates that this can be done entirely in a 
contributed package, which means there's no need for R Core to be 
involved.  I don't know if he has plans to turn his prototype into a 
CRAN package.  If he doesn't, then it will be up to some other 
interested maintainer to step up and take on the task, or it will just 
fade away.

I haven't checked whether your proposals below represent changes from 
the current version of dotty, but if they do, the way to proceed is to 
fork that project, implement your changes, and offer to contribute them 
back to the main branch.

Duncan Murdoch



> 
>   * Positional assignment e.g. .[nr, nc] <- dim(x), and named assignment
>     e.g. .[new = carb] <- mtcars or .[new = log(carb)] <- mtcars. All
>     the functionality proposed by Kevin at
>     https://github.com/kevinushey/dotty
>     <https://github.com/kevinushey/dotty> is useful, unambiguous and
>     feasible.
>   * Silent dropping of RHS values e.g. .[mpg_new, cyl_new] <- mtcars.
>   * Mixing of positional and named assignment e.g .[mpg_new, carb_new =
>     carb, cyl_new] <- mtcars. The inputs not assigned by name are simply
>     the elements of RHS in the order they occur, regardless of whether
>     they have been used previously e.g. .[mpg_new, cyl_new = cyl,
>     log_cyl = log(cyl), cyl_new2] <- mtcars is feasible. RHS here could
>     be any named vector type.
>   * Conventional use of the function as lazy version of of list(), as in
>     data.table: .(A = B, C, D) is the same as list(A = B, C = C, D = D).
>     This would also be useful, allowing more parsimonious code, and
>     avoid the need to assign names to all return values in a function
>     return, e.g. if I already have matrices A, C, Q and R as internal
>     objects in my function, I can simply end by return(.(A, C, Q, R))
>     instead of return(list(A = A, C = C, Q = Q, R = R)) if I wanted the
>     list to be named with the object names.
> 
> The implementation of this in R and C should be pretty straightforward. 
> It would just require a modification to R CMD Check to recognize .[<- as 
> assignment.
> 
> Best regards,
> 
> Sebastian
> -
> 2.)
> 
> On Sun, 12 Mar 2023 at 09:42, Sebastian Martin Krantz 
> <sebastian.krantz at graduateinstitute.ch 
> <mailto:sebastian.krantz at graduateinstitute.ch>> wrote:
> 
>     Thanks Gabriel and Kevin for your inputs,
> 
>     regarding your points Gabriel, I think Python and Julia do allow
>     multiple sub-assignment, but in-line with my earlier suggestion in
>     response to Duncan to make multiple assignment an environment-level
>     operation (like collapse::%=% currently works), ?this would not be
>     possible in R.
> 
>     Regarding the [a] <- coolest_function()?syntax, yeah it would mean
>     do multiple assignment and set a equal to the first element dropping
>     all other elements. Multiple assignment should be positional loke in
>     other languages, enabling flexible renaming of objects on the fly.
>     So it should be irrelevant whether the function returns a named or
>     unnamed list or vector.
> 
>     Thanks also Kevin for this contribution. I think it?s a remarkable
>     effort, and I wouldn?t mind such semantics e.g. making it a function
>     call to ?.[? or any other one-letter function, as long as it?s coded
>     in C and recognized by the interpreter as an assignment operation.
> 
>     Best regards,
> 
>     Sebastian
> 
> 
> 
> 
> 
>     On Sun 12. Mar 2023 at 01:00, Kevin Ushey <kevinushey at gmail.com
>     <mailto:kevinushey at gmail.com>> wrote:
> 
>         FWIW, it's possible to get fairly close to your proposed semantics
>         using the existing metaprogramming facilities in R. I put together a
>         prototype package here to demonstrate:
> 
>         https://github.com/kevinushey/dotty
>         <https://github.com/kevinushey/dotty>
> 
>         The package exports an object called `.`, with a special
>         `[<-.dot` S3
>         method which enables destructuring assignments. This means you can
>         write code like:
> 
>          ? ? .[nr, nc] <- dim(mtcars)
> 
>         and that will define 'nr' and 'nc' as you expect.
> 
>         As for R CMD check warnings, you can suppress those through the
>         use of
>         globalVariables(), and that can also be automated within the
>         package.
>         The 'dotty' package includes a function 'dotify()' which automates
>         looking for such usages in your package, and calling
>         globalVariables()
>         so that R CMD check doesn't warn. In theory, a similar technique
>         would
>         be applicable to other packages defining similar operators (zeallot,
>         collapse).
> 
>         Obviously, globalVariables() is a very heavy hammer to swing for
>         this
>         issue, but you might consider the benefits worth the tradeoffs.
> 
>         Best,
>         Kevin
> 
>         On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch
>         <murdoch.duncan at gmail.com <mailto:murdoch.duncan at gmail.com>> wrote:
>          >
>          > On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
>          > > Thanks Duncan and Ivan for the careful thoughts. I'm not
>         sure I can
>          > > follow all aspects you raised, but to give my limited take
>         on a few:
>          > >
>          > >> your proposal violates a very basic property of the 
>         language, i.e. that all statements are expressions and have a
>         value.? > What's the value of 1 + (A, C = init_matrices()).
>          > >
>          > > I'm not sure I see the point here. I evaluated 1 + (d =
>         dim(mtcars); nr
>          > > = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error,
>          >
>          >
>          >? ? d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
>          >
>          > is not a statement, it is a sequence of 4 statements.
>          >
>          > Duncan Murdoch
>          >
>          >? ?as the
>          > > above expression should. `%=%` assigns to
>          > > environments, so 1 + (c("A", "C") %=% init_matrices()) returns
>          > > numeric(0), with A and C having their values assigned.
>          > >
>          > >> suppose f() returns list(A = 1, B = 2) and I do? > B, A <-
>         f() > Should assignment be by position or by name?
>          > >
>          > > In other languages this is by position. The feature is not
>         meant to
>          > > replace list2env(), and being able to rename objects in the
>         assignment
>          > > is a vital feature of codes
>          > > using multi input and output functions e.g. in Matlab or Julia.
>          > >
>          > >> Honestly, given that this is simply syntactic sugar, I
>         don't think I would support it.
>          > >
>          > > You can call it that, but it would be used by almost every
>         R user almost
>          > > every day. Simple things like nr, nc = dim(x); values,
>         vectors =
>          > > eigen(x) etc. where the creation of intermediate objects
>          > > is cumbersome and redundant.
>          > >
>          > >> I see you've already mentioned it ("JavaScript-like"). I
>         think it would? fulfil Sebastian's requirements too, as long as
>         it is considered "true assignment" by the rest of the language.
>          > >
>          > > I don't have strong opinions about how the issue is phrased or
>          > > implemented. Something like [t, n] = dim(x) might even be
>         more clear.
>          > > It's important though that assignment remains by position,
>          > > so even if some output gets thrown away that should also be
>         positional.
>          > >
>          > >>? A <- 0? > [A, B = A + 10] <- list(1, A = 2)
>          > >
>          > > I also fail to see the use of allowing this. something like
>         this is an
>          > > error.
>          > >
>          > >> A = 2
>          > >> (B = A + 1) <- 1
>          > > Error in (B = A + 1) <- 1 : could not find function "(<-"
>          > >
>          > > Regarding the practical implementation, I think
>         `collapse::%=%` is a
>          > > good starting point. It could be introduced in R as a
>         separate function,
>          > > or `=` could be modified to accommodate its capability. It
>         should be
>          > > clear that
>          > > with more than one LHS variables the assignment is an
>         environment level
>          > > operation and the results can only be used in computations
>         once assigned
>          > > to the environment, e.g. as in 1 + (c("A", "C") %=%
>         init_matrices()),
>          > > A and C are not available for the addition in this
>         statement. The
>          > > interpretor then needs to be modified to read something
>         like nr, nc =
>          > > dim(x) or [nr, nc] = dim(x). as an environment-level
>         multiple assignment
>          > > operation with no
>          > > immediate value. Appears very feasible to my limited
>         understanding, but
>          > > I guess there are other things to consider still.
>         Definitely appreciate
>          > > the responses so far though.
>          > >
>          > > Best regards,
>          > >
>          > > Sebastian
>          > >
>          > >
>          > >
>          > >
>          > >
>          > > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch
>         <murdoch.duncan at gmail.com <mailto:murdoch.duncan at gmail.com>
>          > > <mailto:murdoch.duncan at gmail.com
>         <mailto:murdoch.duncan at gmail.com>>> wrote:
>          > >
>          > >? ? ?On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
>          > >? ? ? > On Sat, 11 Mar 2023 11:11:06 -0500
>          > >? ? ? > Duncan Murdoch <murdoch.duncan at gmail.com
>         <mailto:murdoch.duncan at gmail.com>
>          > >? ? ?<mailto:murdoch.duncan at gmail.com
>         <mailto:murdoch.duncan at gmail.com>>> wrote:
>          > >? ? ? >
>          > >? ? ? >> That's clear, but your proposal violates a very
>         basic property
>          > >? ? ?of the
>          > >? ? ? >> language, i.e. that all statements are expressions
>         and have a value.
>          > >? ? ? >
>          > >? ? ? > How about reframing this feature request from
>         multiple assignment
>          > >? ? ? > (which does go contrary to "everything has only one
>         value, even
>          > >? ? ?if it's
>          > >? ? ? > sometimes invisible(NULL)") to "structured binding"
>         / "destructuring
>          > >? ? ? > assignment" [*], which takes this single single
>         value returned by the
>          > >? ? ? > expression and subsets it subject to certain rules?
>         It may be
>          > >? ? ?easier to
>          > >? ? ? > make a decision on the semantics for destructuring
>         assignment (e.g.
>          > >? ? ? > languages which have this feature typically allow
>         throwing unneeded
>          > >? ? ? > parts of the return value away), and it doesn't seem
>         to break as much
>          > >? ? ? > of the rest of the language if implemented.
>          > >? ? ? >
>          > >? ? ? > I see you've already mentioned it
>         ("JavaScript-like"). I think it
>          > >? ? ?would
>          > >? ? ? > fulfil Sebastian's requirements too, as long as it
>         is considered
>          > >? ? ?"true
>          > >? ? ? > assignment" by the rest of the language.
>          > >? ? ? >
>          > >? ? ? > The hard part is to propose the actual grammar of
>         the new feature (in
>          > >? ? ? > terms of src/main/gram.y, preferably without introducing
>          > >? ? ?conflicts) and
>          > >? ? ? > its semantics (including the corner cases, some of
>         which you have
>          > >? ? ? > already mentioned). I'm not sure I'm up to the task.
>          > >? ? ? >
>          > >
>          > >? ? ?If I were doing it, here's what I'd propose:
>          > >
>          > >? ? ? ? ?'[' formlist ']' LEFT_ASSIGN expr
>          > >? ? ? ? ?'[' formlist ']' EQ_ASSIGN expr
>          > >? ? ? ? ?expr RIGHT_ASSIGN? '[' formlist ']'
>          > >
>          > >? ? ?where `formlist` has the syntax of the formals list for
>         a function
>          > >? ? ?definition.? This would have the following semantics:
>          > >
>          > >? ? ? ? ? {
>          > >? ? ? ? ? ? *tmp* <- expr
>          > >
>          > >? ? ? ? ? ? # For arguments with no "default" expression,
>          > >
>          > >? ? ? ? ? ? argname1 <- *tmp*[[1]]
>          > >? ? ? ? ? ? argname2 <- *tmp*[[2]]
>          > >? ? ? ? ? ? ...
>          > >
>          > >? ? ? ? ? ? # For arguments with a default listed
>          > >
>          > >? ? ? ? ? ? argname3 <- with(*tmp*, default3)
>          > >? ? ? ? ? }
>          > >
>          > >
>          > >? ? ?The value of the whole thing would therefore be
>         (invisibly) the
>          > >? ? ?value of
>          > >? ? ?the last item in the assignment.
>          > >
>          > >? ? ?Two examples:
>          > >
>          > >? ? ? ? ?[A, B, C] <- expr? ?# assign the first three
>         elements of expr to A,
>          > >? ? ?B, and C
>          > >
>          > >? ? ? ? ?[A, B, C = a + b] <- expr? # assign the first two
>         elements of expr
>          > >? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? # to A and B,
>          > >? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? # assign with(expr, a +
>         b) to C.
>          > >
>          > >? ? ?Unfortunately, I don't think this could be done entirely by
>          > >? ? ?transforming
>          > >? ? ?the expression (which is the way |> was done), and that
>         makes it a lot
>          > >? ? ?harder to write and to reason about.? E.g. what does
>         this do?
>          > >
>          > >? ? ? ? ?A <- 0
>          > >? ? ? ? ?[A, B = A + 10] <- list(1, A = 2)
>          > >
>          > >? ? ?According to the recipe above, I think it sets A to 1
>         and B to 12, but
>          > >? ? ?maybe a user would expect B to be 10 or 11.? And
>         according to that
>          > >? ? ?recipe this is an error:
>          > >
>          > >? ? ? ? ?[A, B = A + 10] <- c(1, A = 2)
>          > >
>          > >? ? ?which probably isn't what a user would expect, given
>         that this is fine:
>          > >
>          > >? ? ? ? ?[A, B] <- c(1, 2)
>          > >
>          > >? ? ?Duncan Murdoch
>          > >
>          >
>          > ______________________________________________
>          > R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>          > https://stat.ethz.ch/mailman/listinfo/r-devel
>         <https://stat.ethz.ch/mailman/listinfo/r-devel>
>


From @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch  Sun Mar 12 08:42:51 2023
From: @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch (Sebastian Martin Krantz)
Date: Sun, 12 Mar 2023 09:42:51 +0200
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
Message-ID: <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>

Thanks Gabriel and Kevin for your inputs,

regarding your points Gabriel, I think Python and Julia do allow multiple
sub-assignment, but in-line with my earlier suggestion in response to
Duncan to make multiple assignment an environment-level operation (like
collapse::%=% currently works),  this would not be possible in R.

Regarding the [a] <- coolest_function() syntax, yeah it would mean do
multiple assignment and set a equal to the first element dropping all other
elements. Multiple assignment should be positional loke in other languages,
enabling flexible renaming of objects on the fly. So it should be
irrelevant whether the function returns a named or unnamed list or vector.

Thanks also Kevin for this contribution. I think it?s a remarkable effort,
and I wouldn?t mind such semantics e.g. making it a function call to ?.[?
or any other one-letter function, as long as it?s coded in C and recognized
by the interpreter as an assignment operation.

Best regards,

Sebastian





On Sun 12. Mar 2023 at 01:00, Kevin Ushey <kevinushey at gmail.com> wrote:

> FWIW, it's possible to get fairly close to your proposed semantics
> using the existing metaprogramming facilities in R. I put together a
> prototype package here to demonstrate:
>
>     https://github.com/kevinushey/dotty
>
> The package exports an object called `.`, with a special `[<-.dot` S3
> method which enables destructuring assignments. This means you can
> write code like:
>
>     .[nr, nc] <- dim(mtcars)
>
> and that will define 'nr' and 'nc' as you expect.
>
> As for R CMD check warnings, you can suppress those through the use of
> globalVariables(), and that can also be automated within the package.
> The 'dotty' package includes a function 'dotify()' which automates
> looking for such usages in your package, and calling globalVariables()
> so that R CMD check doesn't warn. In theory, a similar technique would
> be applicable to other packages defining similar operators (zeallot,
> collapse).
>
> Obviously, globalVariables() is a very heavy hammer to swing for this
> issue, but you might consider the benefits worth the tradeoffs.
>
> Best,
> Kevin
>
> On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
> >
> > On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
> > > Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can
> > > follow all aspects you raised, but to give my limited take on a few:
> > >
> > >> your proposal violates a very basic property of the  language, i.e.
> that all statements are expressions and have a value.  > What's the value
> of 1 + (A, C = init_matrices()).
> > >
> > > I'm not sure I see the point here. I evaluated 1 + (d = dim(mtcars); nr
> > > = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error,
> >
> >
> >    d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
> >
> > is not a statement, it is a sequence of 4 statements.
> >
> > Duncan Murdoch
> >
> >   as the
> > > above expression should. `%=%` assigns to
> > > environments, so 1 + (c("A", "C") %=% init_matrices()) returns
> > > numeric(0), with A and C having their values assigned.
> > >
> > >> suppose f() returns list(A = 1, B = 2) and I do  > B, A <- f() >
> Should assignment be by position or by name?
> > >
> > > In other languages this is by position. The feature is not meant to
> > > replace list2env(), and being able to rename objects in the assignment
> > > is a vital feature of codes
> > > using multi input and output functions e.g. in Matlab or Julia.
> > >
> > >> Honestly, given that this is simply syntactic sugar, I don't think I
> would support it.
> > >
> > > You can call it that, but it would be used by almost every R user
> almost
> > > every day. Simple things like nr, nc = dim(x); values, vectors =
> > > eigen(x) etc. where the creation of intermediate objects
> > > is cumbersome and redundant.
> > >
> > >> I see you've already mentioned it ("JavaScript-like"). I think it
> would  fulfil Sebastian's requirements too, as long as it is considered
> "true assignment" by the rest of the language.
> > >
> > > I don't have strong opinions about how the issue is phrased or
> > > implemented. Something like [t, n] = dim(x) might even be more clear.
> > > It's important though that assignment remains by position,
> > > so even if some output gets thrown away that should also be positional.
> > >
> > >>  A <- 0  > [A, B = A + 10] <- list(1, A = 2)
> > >
> > > I also fail to see the use of allowing this. something like this is an
> > > error.
> > >
> > >> A = 2
> > >> (B = A + 1) <- 1
> > > Error in (B = A + 1) <- 1 : could not find function "(<-"
> > >
> > > Regarding the practical implementation, I think `collapse::%=%` is a
> > > good starting point. It could be introduced in R as a separate
> function,
> > > or `=` could be modified to accommodate its capability. It should be
> > > clear that
> > > with more than one LHS variables the assignment is an environment level
> > > operation and the results can only be used in computations once
> assigned
> > > to the environment, e.g. as in 1 + (c("A", "C") %=% init_matrices()),
> > > A and C are not available for the addition in this statement. The
> > > interpretor then needs to be modified to read something like nr, nc =
> > > dim(x) or [nr, nc] = dim(x). as an environment-level multiple
> assignment
> > > operation with no
> > > immediate value. Appears very feasible to my limited understanding, but
> > > I guess there are other things to consider still. Definitely appreciate
> > > the responses so far though.
> > >
> > > Best regards,
> > >
> > > Sebastian
> > >
> > >
> > >
> > >
> > >
> > > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <murdoch.duncan at gmail.com
> > > <mailto:murdoch.duncan at gmail.com>> wrote:
> > >
> > >     On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> > >      > On Sat, 11 Mar 2023 11:11:06 -0500
> > >      > Duncan Murdoch <murdoch.duncan at gmail.com
> > >     <mailto:murdoch.duncan at gmail.com>> wrote:
> > >      >
> > >      >> That's clear, but your proposal violates a very basic property
> > >     of the
> > >      >> language, i.e. that all statements are expressions and have a
> value.
> > >      >
> > >      > How about reframing this feature request from multiple
> assignment
> > >      > (which does go contrary to "everything has only one value, even
> > >     if it's
> > >      > sometimes invisible(NULL)") to "structured binding" /
> "destructuring
> > >      > assignment" [*], which takes this single single value returned
> by the
> > >      > expression and subsets it subject to certain rules? It may be
> > >     easier to
> > >      > make a decision on the semantics for destructuring assignment
> (e.g.
> > >      > languages which have this feature typically allow throwing
> unneeded
> > >      > parts of the return value away), and it doesn't seem to break
> as much
> > >      > of the rest of the language if implemented.
> > >      >
> > >      > I see you've already mentioned it ("JavaScript-like"). I think
> it
> > >     would
> > >      > fulfil Sebastian's requirements too, as long as it is considered
> > >     "true
> > >      > assignment" by the rest of the language.
> > >      >
> > >      > The hard part is to propose the actual grammar of the new
> feature (in
> > >      > terms of src/main/gram.y, preferably without introducing
> > >     conflicts) and
> > >      > its semantics (including the corner cases, some of which you
> have
> > >      > already mentioned). I'm not sure I'm up to the task.
> > >      >
> > >
> > >     If I were doing it, here's what I'd propose:
> > >
> > >         '[' formlist ']' LEFT_ASSIGN expr
> > >         '[' formlist ']' EQ_ASSIGN expr
> > >         expr RIGHT_ASSIGN  '[' formlist ']'
> > >
> > >     where `formlist` has the syntax of the formals list for a function
> > >     definition.  This would have the following semantics:
> > >
> > >          {
> > >            *tmp* <- expr
> > >
> > >            # For arguments with no "default" expression,
> > >
> > >            argname1 <- *tmp*[[1]]
> > >            argname2 <- *tmp*[[2]]
> > >            ...
> > >
> > >            # For arguments with a default listed
> > >
> > >            argname3 <- with(*tmp*, default3)
> > >          }
> > >
> > >
> > >     The value of the whole thing would therefore be (invisibly) the
> > >     value of
> > >     the last item in the assignment.
> > >
> > >     Two examples:
> > >
> > >         [A, B, C] <- expr   # assign the first three elements of expr
> to A,
> > >     B, and C
> > >
> > >         [A, B, C = a + b] <- expr  # assign the first two elements of
> expr
> > >                                    # to A and B,
> > >                                    # assign with(expr, a + b) to C.
> > >
> > >     Unfortunately, I don't think this could be done entirely by
> > >     transforming
> > >     the expression (which is the way |> was done), and that makes it a
> lot
> > >     harder to write and to reason about.  E.g. what does this do?
> > >
> > >         A <- 0
> > >         [A, B = A + 10] <- list(1, A = 2)
> > >
> > >     According to the recipe above, I think it sets A to 1 and B to 12,
> but
> > >     maybe a user would expect B to be 10 or 11.  And according to that
> > >     recipe this is an error:
> > >
> > >         [A, B = A + 10] <- c(1, A = 2)
> > >
> > >     which probably isn't what a user would expect, given that this is
> fine:
> > >
> > >         [A, B] <- c(1, 2)
> > >
> > >     Duncan Murdoch
> > >
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch  Sun Mar 12 11:07:22 2023
From: @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch (Sebastian Martin Krantz)
Date: Sun, 12 Mar 2023 12:07:22 +0200
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
 <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>
Message-ID: <CAOsNuxCLE9j1XiGwRevcAHu_EHYXaA=aBSREbb3SDUXWMiNHyg@mail.gmail.com>

Thinking more about this, and seeing Kevins examples at
https://github.com/kevinushey/dotty, I think this is the most R-like way of
doing it,
with an additional benefit as it would allow to introduce the useful
data.table semantics DT[, .(a = b, c, d)] to more general R. So I would
propose to
introduce a new primitive function . <- function(...) .Primitive(".") in R
with an assignment method and the following features:

   - Positional assignment e.g. .[nr, nc] <- dim(x), and named assignment
   e.g. .[new = carb] <- mtcars or .[new = log(carb)] <- mtcars. All the
   functionality proposed by Kevin at https://github.com/kevinushey/dotty
   is useful, unambiguous and feasible.
   - Silent dropping of RHS values e.g. .[mpg_new, cyl_new] <- mtcars.
   - Mixing of positional and named assignment e.g .[mpg_new, carb_new =
   carb, cyl_new] <- mtcars. The inputs not assigned by name are simply the
   elements of RHS in the order they occur, regardless of whether they have
   been used previously e.g. .[mpg_new, cyl_new = cyl, log_cyl = log(cyl),
   cyl_new2] <- mtcars is feasible. RHS here could be any named vector type.
   - Conventional use of the function as lazy version of of list(), as in
   data.table: .(A = B, C, D) is the same as list(A = B, C = C, D = D). This
   would also be useful, allowing more parsimonious code, and avoid the need
   to assign names to all return values in a function return, e.g. if I
   already have matrices A, C, Q and R as internal objects in my function, I
   can simply end by return(.(A, C, Q, R)) instead of return(list(A = A, C =
   C, Q = Q, R = R)) if I wanted the list to be named with the object names.

The implementation of this in R and C should be pretty straightforward. It
would just require a modification to R CMD Check to recognize .[<- as
assignment.

Best regards,

Sebastian
-
2.)

On Sun, 12 Mar 2023 at 09:42, Sebastian Martin Krantz <
sebastian.krantz at graduateinstitute.ch> wrote:

> Thanks Gabriel and Kevin for your inputs,
>
> regarding your points Gabriel, I think Python and Julia do allow multiple
> sub-assignment, but in-line with my earlier suggestion in response to
> Duncan to make multiple assignment an environment-level operation (like
> collapse::%=% currently works),  this would not be possible in R.
>
> Regarding the [a] <- coolest_function() syntax, yeah it would mean do
> multiple assignment and set a equal to the first element dropping all other
> elements. Multiple assignment should be positional loke in other languages,
> enabling flexible renaming of objects on the fly. So it should be
> irrelevant whether the function returns a named or unnamed list or vector.
>
> Thanks also Kevin for this contribution. I think it?s a remarkable effort,
> and I wouldn?t mind such semantics e.g. making it a function call to ?.[?
> or any other one-letter function, as long as it?s coded in C and recognized
> by the interpreter as an assignment operation.
>
> Best regards,
>
> Sebastian
>
>
>
>
>
> On Sun 12. Mar 2023 at 01:00, Kevin Ushey <kevinushey at gmail.com> wrote:
>
>> FWIW, it's possible to get fairly close to your proposed semantics
>> using the existing metaprogramming facilities in R. I put together a
>> prototype package here to demonstrate:
>>
>>     https://github.com/kevinushey/dotty
>>
>> The package exports an object called `.`, with a special `[<-.dot` S3
>> method which enables destructuring assignments. This means you can
>> write code like:
>>
>>     .[nr, nc] <- dim(mtcars)
>>
>> and that will define 'nr' and 'nc' as you expect.
>>
>> As for R CMD check warnings, you can suppress those through the use of
>> globalVariables(), and that can also be automated within the package.
>> The 'dotty' package includes a function 'dotify()' which automates
>> looking for such usages in your package, and calling globalVariables()
>> so that R CMD check doesn't warn. In theory, a similar technique would
>> be applicable to other packages defining similar operators (zeallot,
>> collapse).
>>
>> Obviously, globalVariables() is a very heavy hammer to swing for this
>> issue, but you might consider the benefits worth the tradeoffs.
>>
>> Best,
>> Kevin
>>
>> On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch <murdoch.duncan at gmail.com>
>> wrote:
>> >
>> > On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
>> > > Thanks Duncan and Ivan for the careful thoughts. I'm not sure I can
>> > > follow all aspects you raised, but to give my limited take on a few:
>> > >
>> > >> your proposal violates a very basic property of the  language, i.e.
>> that all statements are expressions and have a value.  > What's the value
>> of 1 + (A, C = init_matrices()).
>> > >
>> > > I'm not sure I see the point here. I evaluated 1 + (d = dim(mtcars);
>> nr
>> > > = d[1]; nc = d[2]; rm(d)), which simply gives a syntax error,
>> >
>> >
>> >    d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
>> >
>> > is not a statement, it is a sequence of 4 statements.
>> >
>> > Duncan Murdoch
>> >
>> >   as the
>> > > above expression should. `%=%` assigns to
>> > > environments, so 1 + (c("A", "C") %=% init_matrices()) returns
>> > > numeric(0), with A and C having their values assigned.
>> > >
>> > >> suppose f() returns list(A = 1, B = 2) and I do  > B, A <- f() >
>> Should assignment be by position or by name?
>> > >
>> > > In other languages this is by position. The feature is not meant to
>> > > replace list2env(), and being able to rename objects in the assignment
>> > > is a vital feature of codes
>> > > using multi input and output functions e.g. in Matlab or Julia.
>> > >
>> > >> Honestly, given that this is simply syntactic sugar, I don't think I
>> would support it.
>> > >
>> > > You can call it that, but it would be used by almost every R user
>> almost
>> > > every day. Simple things like nr, nc = dim(x); values, vectors =
>> > > eigen(x) etc. where the creation of intermediate objects
>> > > is cumbersome and redundant.
>> > >
>> > >> I see you've already mentioned it ("JavaScript-like"). I think it
>> would  fulfil Sebastian's requirements too, as long as it is considered
>> "true assignment" by the rest of the language.
>> > >
>> > > I don't have strong opinions about how the issue is phrased or
>> > > implemented. Something like [t, n] = dim(x) might even be more clear.
>> > > It's important though that assignment remains by position,
>> > > so even if some output gets thrown away that should also be
>> positional.
>> > >
>> > >>  A <- 0  > [A, B = A + 10] <- list(1, A = 2)
>> > >
>> > > I also fail to see the use of allowing this. something like this is an
>> > > error.
>> > >
>> > >> A = 2
>> > >> (B = A + 1) <- 1
>> > > Error in (B = A + 1) <- 1 : could not find function "(<-"
>> > >
>> > > Regarding the practical implementation, I think `collapse::%=%` is a
>> > > good starting point. It could be introduced in R as a separate
>> function,
>> > > or `=` could be modified to accommodate its capability. It should be
>> > > clear that
>> > > with more than one LHS variables the assignment is an environment
>> level
>> > > operation and the results can only be used in computations once
>> assigned
>> > > to the environment, e.g. as in 1 + (c("A", "C") %=% init_matrices()),
>> > > A and C are not available for the addition in this statement. The
>> > > interpretor then needs to be modified to read something like nr, nc =
>> > > dim(x) or [nr, nc] = dim(x). as an environment-level multiple
>> assignment
>> > > operation with no
>> > > immediate value. Appears very feasible to my limited understanding,
>> but
>> > > I guess there are other things to consider still. Definitely
>> appreciate
>> > > the responses so far though.
>> > >
>> > > Best regards,
>> > >
>> > > Sebastian
>> > >
>> > >
>> > >
>> > >
>> > >
>> > > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch <
>> murdoch.duncan at gmail.com
>> > > <mailto:murdoch.duncan at gmail.com>> wrote:
>> > >
>> > >     On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
>> > >      > On Sat, 11 Mar 2023 11:11:06 -0500
>> > >      > Duncan Murdoch <murdoch.duncan at gmail.com
>> > >     <mailto:murdoch.duncan at gmail.com>> wrote:
>> > >      >
>> > >      >> That's clear, but your proposal violates a very basic property
>> > >     of the
>> > >      >> language, i.e. that all statements are expressions and have a
>> value.
>> > >      >
>> > >      > How about reframing this feature request from multiple
>> assignment
>> > >      > (which does go contrary to "everything has only one value, even
>> > >     if it's
>> > >      > sometimes invisible(NULL)") to "structured binding" /
>> "destructuring
>> > >      > assignment" [*], which takes this single single value returned
>> by the
>> > >      > expression and subsets it subject to certain rules? It may be
>> > >     easier to
>> > >      > make a decision on the semantics for destructuring assignment
>> (e.g.
>> > >      > languages which have this feature typically allow throwing
>> unneeded
>> > >      > parts of the return value away), and it doesn't seem to break
>> as much
>> > >      > of the rest of the language if implemented.
>> > >      >
>> > >      > I see you've already mentioned it ("JavaScript-like"). I think
>> it
>> > >     would
>> > >      > fulfil Sebastian's requirements too, as long as it is
>> considered
>> > >     "true
>> > >      > assignment" by the rest of the language.
>> > >      >
>> > >      > The hard part is to propose the actual grammar of the new
>> feature (in
>> > >      > terms of src/main/gram.y, preferably without introducing
>> > >     conflicts) and
>> > >      > its semantics (including the corner cases, some of which you
>> have
>> > >      > already mentioned). I'm not sure I'm up to the task.
>> > >      >
>> > >
>> > >     If I were doing it, here's what I'd propose:
>> > >
>> > >         '[' formlist ']' LEFT_ASSIGN expr
>> > >         '[' formlist ']' EQ_ASSIGN expr
>> > >         expr RIGHT_ASSIGN  '[' formlist ']'
>> > >
>> > >     where `formlist` has the syntax of the formals list for a function
>> > >     definition.  This would have the following semantics:
>> > >
>> > >          {
>> > >            *tmp* <- expr
>> > >
>> > >            # For arguments with no "default" expression,
>> > >
>> > >            argname1 <- *tmp*[[1]]
>> > >            argname2 <- *tmp*[[2]]
>> > >            ...
>> > >
>> > >            # For arguments with a default listed
>> > >
>> > >            argname3 <- with(*tmp*, default3)
>> > >          }
>> > >
>> > >
>> > >     The value of the whole thing would therefore be (invisibly) the
>> > >     value of
>> > >     the last item in the assignment.
>> > >
>> > >     Two examples:
>> > >
>> > >         [A, B, C] <- expr   # assign the first three elements of expr
>> to A,
>> > >     B, and C
>> > >
>> > >         [A, B, C = a + b] <- expr  # assign the first two elements of
>> expr
>> > >                                    # to A and B,
>> > >                                    # assign with(expr, a + b) to C.
>> > >
>> > >     Unfortunately, I don't think this could be done entirely by
>> > >     transforming
>> > >     the expression (which is the way |> was done), and that makes it
>> a lot
>> > >     harder to write and to reason about.  E.g. what does this do?
>> > >
>> > >         A <- 0
>> > >         [A, B = A + 10] <- list(1, A = 2)
>> > >
>> > >     According to the recipe above, I think it sets A to 1 and B to
>> 12, but
>> > >     maybe a user would expect B to be 10 or 11.  And according to that
>> > >     recipe this is an error:
>> > >
>> > >         [A, B = A + 10] <- c(1, A = 2)
>> > >
>> > >     which probably isn't what a user would expect, given that this is
>> fine:
>> > >
>> > >         [A, B] <- c(1, 2)
>> > >
>> > >     Duncan Murdoch
>> > >
>> >
>> > ______________________________________________
>> > R-devel at r-project.org mailing list
>> > https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>

	[[alternative HTML version deleted]]


From @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch  Sun Mar 12 13:05:53 2023
From: @eb@@t|@n@kr@ntz @end|ng |rom gr@du@te|n@t|tute@ch (Sebastian Martin Krantz)
Date: Sun, 12 Mar 2023 14:05:53 +0200
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <05b0cf79-d768-7e6e-6dcf-502a14fcef84@gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
 <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>
 <CAOsNuxCLE9j1XiGwRevcAHu_EHYXaA=aBSREbb3SDUXWMiNHyg@mail.gmail.com>
 <05b0cf79-d768-7e6e-6dcf-502a14fcef84@gmail.com>
Message-ID: <CAOsNuxBtYEe9FkMK3QA8PKzar_JX2cVsO1bLNXoZb0GkBPjPQQ@mail.gmail.com>

Kevins package is very nice as a proof of concept, no doubt about that, but
it is not at the level of performance or convenience that a native R
implementation would offer. I would probably not use it to translate matlab
routines into R packages placed on CRAN, because it?s an additional
dependency, I have a performance burden in every iteration, and
utils::globalVariables() is everything but elegant. From that perspective
it would be more convenient for me right now to stick with collapse::%=%,
which is already written in C, and also call
utils::globalVariables().

But again my hope in starting this was that R Core might see that the
addition of multiple assignment would be a significant enhancement to the
language, of the same order as the base pipe |> in my opinion.

I think the discussion so far has at least brought forth a way to implement
this in a way that does not violate fundamental principles of the language.
Which could form a basis for thinking about an actual addition to the
language.

Best regards,

Sebastian


On Sun 12. Mar 2023 at 13:18, Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:

> On 12/03/2023 6:07 a.m., Sebastian Martin Krantz wrote:
> > Thinking more about this, and seeing Kevins examples at
> > https://github.com/kevinushey/dotty
> > <https://github.com/kevinushey/dotty>, I think this is the most R-like
> > way of doing it,
> > with an additional benefit as it would allow to introduce the useful
> > data.table semantics DT[, .(a = b, c, d)] to more general R. So I would
> > propose to
> > introduce a new primitive function . <- function(...) .Primitive(".") in
> > R with an assignment method and the following features:
>
> I think that proposal is very unlikely to be accepted.  If it was a
> primitive function, it could only be maintained by R Core.  They are
> justifiably very reluctant to take on extra work for themselves.
>
> Kevin's package demonstrates that this can be done entirely in a
> contributed package, which means there's no need for R Core to be
> involved.  I don't know if he has plans to turn his prototype into a
> CRAN package.  If he doesn't, then it will be up to some other
> interested maintainer to step up and take on the task, or it will just
> fade away.
>
> I haven't checked whether your proposals below represent changes from
> the current version of dotty, but if they do, the way to proceed is to
> fork that project, implement your changes, and offer to contribute them
> back to the main branch.
>
> Duncan Murdoch
>
>
>
> >
> >   * Positional assignment e.g. .[nr, nc] <- dim(x), and named assignment
> >     e.g. .[new = carb] <- mtcars or .[new = log(carb)] <- mtcars. All
> >     the functionality proposed by Kevin at
> >     https://github.com/kevinushey/dotty
> >     <https://github.com/kevinushey/dotty> is useful, unambiguous and
> >     feasible.
> >   * Silent dropping of RHS values e.g. .[mpg_new, cyl_new] <- mtcars.
> >   * Mixing of positional and named assignment e.g .[mpg_new, carb_new =
> >     carb, cyl_new] <- mtcars. The inputs not assigned by name are simply
> >     the elements of RHS in the order they occur, regardless of whether
> >     they have been used previously e.g. .[mpg_new, cyl_new = cyl,
> >     log_cyl = log(cyl), cyl_new2] <- mtcars is feasible. RHS here could
> >     be any named vector type.
> >   * Conventional use of the function as lazy version of of list(), as in
> >     data.table: .(A = B, C, D) is the same as list(A = B, C = C, D = D).
> >     This would also be useful, allowing more parsimonious code, and
> >     avoid the need to assign names to all return values in a function
> >     return, e.g. if I already have matrices A, C, Q and R as internal
> >     objects in my function, I can simply end by return(.(A, C, Q, R))
> >     instead of return(list(A = A, C = C, Q = Q, R = R)) if I wanted the
> >     list to be named with the object names.
> >
> > The implementation of this in R and C should be pretty straightforward.
> > It would just require a modification to R CMD Check to recognize .[<- as
> > assignment.
> >
> > Best regards,
> >
> > Sebastian
> > -
> > 2.)
> >
> > On Sun, 12 Mar 2023 at 09:42, Sebastian Martin Krantz
> > <sebastian.krantz at graduateinstitute.ch
> > <mailto:sebastian.krantz at graduateinstitute.ch>> wrote:
> >
> >     Thanks Gabriel and Kevin for your inputs,
> >
> >     regarding your points Gabriel, I think Python and Julia do allow
> >     multiple sub-assignment, but in-line with my earlier suggestion in
> >     response to Duncan to make multiple assignment an environment-level
> >     operation (like collapse::%=% currently works),  this would not be
> >     possible in R.
> >
> >     Regarding the [a] <- coolest_function() syntax, yeah it would mean
> >     do multiple assignment and set a equal to the first element dropping
> >     all other elements. Multiple assignment should be positional loke in
> >     other languages, enabling flexible renaming of objects on the fly.
> >     So it should be irrelevant whether the function returns a named or
> >     unnamed list or vector.
> >
> >     Thanks also Kevin for this contribution. I think it?s a remarkable
> >     effort, and I wouldn?t mind such semantics e.g. making it a function
> >     call to ?.[? or any other one-letter function, as long as it?s coded
> >     in C and recognized by the interpreter as an assignment operation.
> >
> >     Best regards,
> >
> >     Sebastian
> >
> >
> >
> >
> >
> >     On Sun 12. Mar 2023 at 01:00, Kevin Ushey <kevinushey at gmail.com
> >     <mailto:kevinushey at gmail.com>> wrote:
> >
> >         FWIW, it's possible to get fairly close to your proposed
> semantics
> >         using the existing metaprogramming facilities in R. I put
> together a
> >         prototype package here to demonstrate:
> >
> >         https://github.com/kevinushey/dotty
> >         <https://github.com/kevinushey/dotty>
> >
> >         The package exports an object called `.`, with a special
> >         `[<-.dot` S3
> >         method which enables destructuring assignments. This means you
> can
> >         write code like:
> >
> >              .[nr, nc] <- dim(mtcars)
> >
> >         and that will define 'nr' and 'nc' as you expect.
> >
> >         As for R CMD check warnings, you can suppress those through the
> >         use of
> >         globalVariables(), and that can also be automated within the
> >         package.
> >         The 'dotty' package includes a function 'dotify()' which
> automates
> >         looking for such usages in your package, and calling
> >         globalVariables()
> >         so that R CMD check doesn't warn. In theory, a similar technique
> >         would
> >         be applicable to other packages defining similar operators
> (zeallot,
> >         collapse).
> >
> >         Obviously, globalVariables() is a very heavy hammer to swing for
> >         this
> >         issue, but you might consider the benefits worth the tradeoffs.
> >
> >         Best,
> >         Kevin
> >
> >         On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch
> >         <murdoch.duncan at gmail.com <mailto:murdoch.duncan at gmail.com>>
> wrote:
> >          >
> >          > On 11/03/2023 4:42 p.m., Sebastian Martin Krantz wrote:
> >          > > Thanks Duncan and Ivan for the careful thoughts. I'm not
> >         sure I can
> >          > > follow all aspects you raised, but to give my limited take
> >         on a few:
> >          > >
> >          > >> your proposal violates a very basic property of the
> >         language, i.e. that all statements are expressions and have a
> >         value.  > What's the value of 1 + (A, C = init_matrices()).
> >          > >
> >          > > I'm not sure I see the point here. I evaluated 1 + (d =
> >         dim(mtcars); nr
> >          > > = d[1]; nc = d[2]; rm(d)), which simply gives a syntax
> error,
> >          >
> >          >
> >          >    d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
> >          >
> >          > is not a statement, it is a sequence of 4 statements.
> >          >
> >          > Duncan Murdoch
> >          >
> >          >   as the
> >          > > above expression should. `%=%` assigns to
> >          > > environments, so 1 + (c("A", "C") %=% init_matrices())
> returns
> >          > > numeric(0), with A and C having their values assigned.
> >          > >
> >          > >> suppose f() returns list(A = 1, B = 2) and I do  > B, A <-
> >         f() > Should assignment be by position or by name?
> >          > >
> >          > > In other languages this is by position. The feature is not
> >         meant to
> >          > > replace list2env(), and being able to rename objects in the
> >         assignment
> >          > > is a vital feature of codes
> >          > > using multi input and output functions e.g. in Matlab or
> Julia.
> >          > >
> >          > >> Honestly, given that this is simply syntactic sugar, I
> >         don't think I would support it.
> >          > >
> >          > > You can call it that, but it would be used by almost every
> >         R user almost
> >          > > every day. Simple things like nr, nc = dim(x); values,
> >         vectors =
> >          > > eigen(x) etc. where the creation of intermediate objects
> >          > > is cumbersome and redundant.
> >          > >
> >          > >> I see you've already mentioned it ("JavaScript-like"). I
> >         think it would  fulfil Sebastian's requirements too, as long as
> >         it is considered "true assignment" by the rest of the language.
> >          > >
> >          > > I don't have strong opinions about how the issue is phrased
> or
> >          > > implemented. Something like [t, n] = dim(x) might even be
> >         more clear.
> >          > > It's important though that assignment remains by position,
> >          > > so even if some output gets thrown away that should also be
> >         positional.
> >          > >
> >          > >>  A <- 0  > [A, B = A + 10] <- list(1, A = 2)
> >          > >
> >          > > I also fail to see the use of allowing this. something like
> >         this is an
> >          > > error.
> >          > >
> >          > >> A = 2
> >          > >> (B = A + 1) <- 1
> >          > > Error in (B = A + 1) <- 1 : could not find function "(<-"
> >          > >
> >          > > Regarding the practical implementation, I think
> >         `collapse::%=%` is a
> >          > > good starting point. It could be introduced in R as a
> >         separate function,
> >          > > or `=` could be modified to accommodate its capability. It
> >         should be
> >          > > clear that
> >          > > with more than one LHS variables the assignment is an
> >         environment level
> >          > > operation and the results can only be used in computations
> >         once assigned
> >          > > to the environment, e.g. as in 1 + (c("A", "C") %=%
> >         init_matrices()),
> >          > > A and C are not available for the addition in this
> >         statement. The
> >          > > interpretor then needs to be modified to read something
> >         like nr, nc =
> >          > > dim(x) or [nr, nc] = dim(x). as an environment-level
> >         multiple assignment
> >          > > operation with no
> >          > > immediate value. Appears very feasible to my limited
> >         understanding, but
> >          > > I guess there are other things to consider still.
> >         Definitely appreciate
> >          > > the responses so far though.
> >          > >
> >          > > Best regards,
> >          > >
> >          > > Sebastian
> >          > >
> >          > >
> >          > >
> >          > >
> >          > >
> >          > > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch
> >         <murdoch.duncan at gmail.com <mailto:murdoch.duncan at gmail.com>
> >          > > <mailto:murdoch.duncan at gmail.com
> >         <mailto:murdoch.duncan at gmail.com>>> wrote:
> >          > >
> >          > >     On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> >          > >      > On Sat, 11 Mar 2023 11:11:06 -0500
> >          > >      > Duncan Murdoch <murdoch.duncan at gmail.com
> >         <mailto:murdoch.duncan at gmail.com>
> >          > >     <mailto:murdoch.duncan at gmail.com
> >         <mailto:murdoch.duncan at gmail.com>>> wrote:
> >          > >      >
> >          > >      >> That's clear, but your proposal violates a very
> >         basic property
> >          > >     of the
> >          > >      >> language, i.e. that all statements are expressions
> >         and have a value.
> >          > >      >
> >          > >      > How about reframing this feature request from
> >         multiple assignment
> >          > >      > (which does go contrary to "everything has only one
> >         value, even
> >          > >     if it's
> >          > >      > sometimes invisible(NULL)") to "structured binding"
> >         / "destructuring
> >          > >      > assignment" [*], which takes this single single
> >         value returned by the
> >          > >      > expression and subsets it subject to certain rules?
> >         It may be
> >          > >     easier to
> >          > >      > make a decision on the semantics for destructuring
> >         assignment (e.g.
> >          > >      > languages which have this feature typically allow
> >         throwing unneeded
> >          > >      > parts of the return value away), and it doesn't seem
> >         to break as much
> >          > >      > of the rest of the language if implemented.
> >          > >      >
> >          > >      > I see you've already mentioned it
> >         ("JavaScript-like"). I think it
> >          > >     would
> >          > >      > fulfil Sebastian's requirements too, as long as it
> >         is considered
> >          > >     "true
> >          > >      > assignment" by the rest of the language.
> >          > >      >
> >          > >      > The hard part is to propose the actual grammar of
> >         the new feature (in
> >          > >      > terms of src/main/gram.y, preferably without
> introducing
> >          > >     conflicts) and
> >          > >      > its semantics (including the corner cases, some of
> >         which you have
> >          > >      > already mentioned). I'm not sure I'm up to the task.
> >          > >      >
> >          > >
> >          > >     If I were doing it, here's what I'd propose:
> >          > >
> >          > >         '[' formlist ']' LEFT_ASSIGN expr
> >          > >         '[' formlist ']' EQ_ASSIGN expr
> >          > >         expr RIGHT_ASSIGN  '[' formlist ']'
> >          > >
> >          > >     where `formlist` has the syntax of the formals list for
> >         a function
> >          > >     definition.  This would have the following semantics:
> >          > >
> >          > >          {
> >          > >            *tmp* <- expr
> >          > >
> >          > >            # For arguments with no "default" expression,
> >          > >
> >          > >            argname1 <- *tmp*[[1]]
> >          > >            argname2 <- *tmp*[[2]]
> >          > >            ...
> >          > >
> >          > >            # For arguments with a default listed
> >          > >
> >          > >            argname3 <- with(*tmp*, default3)
> >          > >          }
> >          > >
> >          > >
> >          > >     The value of the whole thing would therefore be
> >         (invisibly) the
> >          > >     value of
> >          > >     the last item in the assignment.
> >          > >
> >          > >     Two examples:
> >          > >
> >          > >         [A, B, C] <- expr   # assign the first three
> >         elements of expr to A,
> >          > >     B, and C
> >          > >
> >          > >         [A, B, C = a + b] <- expr  # assign the first two
> >         elements of expr
> >          > >                                    # to A and B,
> >          > >                                    # assign with(expr, a +
> >         b) to C.
> >          > >
> >          > >     Unfortunately, I don't think this could be done
> entirely by
> >          > >     transforming
> >          > >     the expression (which is the way |> was done), and that
> >         makes it a lot
> >          > >     harder to write and to reason about.  E.g. what does
> >         this do?
> >          > >
> >          > >         A <- 0
> >          > >         [A, B = A + 10] <- list(1, A = 2)
> >          > >
> >          > >     According to the recipe above, I think it sets A to 1
> >         and B to 12, but
> >          > >     maybe a user would expect B to be 10 or 11.  And
> >         according to that
> >          > >     recipe this is an error:
> >          > >
> >          > >         [A, B = A + 10] <- c(1, A = 2)
> >          > >
> >          > >     which probably isn't what a user would expect, given
> >         that this is fine:
> >          > >
> >          > >         [A, B] <- c(1, 2)
> >          > >
> >          > >     Duncan Murdoch
> >          > >
> >          >
> >          > ______________________________________________
> >          > R-devel at r-project.org <mailto:R-devel at r-project.org> mailing
> list
> >          > https://stat.ethz.ch/mailman/listinfo/r-devel
> >         <https://stat.ethz.ch/mailman/listinfo/r-devel>
> >
>
>

	[[alternative HTML version deleted]]


From p@kr|v|t@ky @end|ng |rom un@w@edu@@u  Mon Mar 13 03:36:59 2023
From: p@kr|v|t@ky @end|ng |rom un@w@edu@@u (Pavel Krivitsky)
Date: Mon, 13 Mar 2023 02:36:59 +0000
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxBtYEe9FkMK3QA8PKzar_JX2cVsO1bLNXoZb0GkBPjPQQ@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
 <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>
 <CAOsNuxCLE9j1XiGwRevcAHu_EHYXaA=aBSREbb3SDUXWMiNHyg@mail.gmail.com>
 <05b0cf79-d768-7e6e-6dcf-502a14fcef84@gmail.com>
 <CAOsNuxBtYEe9FkMK3QA8PKzar_JX2cVsO1bLNXoZb0GkBPjPQQ@mail.gmail.com>
Message-ID: <7aedf95ecb2a98531140764db3035449c7bd1147.camel@unsw.edu.au>

Dear All,

As a maintainer of large, complex packages, I can think of many places
in which deconstructing assignment would simplify the code, as well as
facilitate readability by breaking up larger functions into helpers, so
I would be very glad to see this incorporated somehow.

I think the crux of the matter is that while there is a number of ways
to implement deconstructing assignment within R, there is no mechanism
to tell R CMD check about it without also suppressing checks for every
other instance of that variable name. This is particularly problematic
because those variable names are likely to be used elsewhere in the
package.

Workarounds that have been suggested all defeat the conciseness and
clarity of the deconstructing assignment and introduce potential for
subtle bugs.

The check warnings are something that can only be addressed in
'codetools', with a finer API than what utils::globalVariables()
provides.?Perhaps this would have a lower hurdle than modifying R
language itself?

From skimming through the relevant 'codetools' code, one idea for such
an API would be a function, along the lines of

utils::alternativeAssignment(op, assigned)

that sets up a callback assigned = function(op, e) that given the
operator (as string) and the expression it's embedded in, returns a
list of three elements:
 * a character vector containing a list of variables assigned to that
   might not otherwise be detected
 * a character vector containing a list of variables referenced that
   might not otherwise be detected
 * expression e with potentially "offending" elements removed, which
   will then be processed by the rest of the checking code

Then, say, 'zeallot' could implement zeallot::zeallot_assign_detect(),
and a package developer using it could put

utils::alternativeAssignment("%<-%", zeallot::zeallot_assign_detect)

in their .onLoad() function. Similarly, users of 'dotty' could set up
callbacks for all standard assignment operators to inform the code
about the nonstandard assignment.

Best Regards,Pavel

On Sun, 2023-03-12 at 14:05 +0200, Sebastian Martin Krantz wrote:
> Kevins package is very nice as a proof of concept, no doubt about
> that, but
> it is not at the level of performance or convenience that a native R
> implementation would offer. I would probably not use it to translate
> matlab
> routines into R packages placed on CRAN, because it?s an additional
> dependency, I have a performance burden in every iteration, and
> utils::globalVariables() is everything but elegant. From that
> perspective
> it would be more convenient for me right now to stick with
> collapse::%=%,
> which is already written in C, and also call
> utils::globalVariables().
> 
> But again my hope in starting this was that R Core might see that the
> addition of multiple assignment would be a significant enhancement to
> the
> language, of the same order as the base pipe |> in my opinion.
> 
> I think the discussion so far has at least brought forth a way to
> implement
> this in a way that does not violate fundamental principles of the
> language.
> Which could form a basis for thinking about an actual addition to the
> language.
> 
> Best regards,
> 
> Sebastian
> 
> 
> On Sun 12. Mar 2023 at 13:18, Duncan Murdoch
> <murdoch.duncan at gmail.com>
> wrote:
> 
> > On 12/03/2023 6:07 a.m., Sebastian Martin Krantz wrote:
> > > Thinking more about this, and seeing Kevins examples at
> > > https://github.com/kevinushey/dotty
> > > <https://github.com/kevinushey/dotty>, I think this is the most
> > > R-like
> > > way of doing it,
> > > with an additional benefit as it would allow to introduce the
> > > useful
> > > data.table semantics DT[, .(a = b, c, d)] to more general R. So I
> > > would
> > > propose to
> > > introduce a new primitive function . <- function(...)
> > > .Primitive(".") in
> > > R with an assignment method and the following features:
> > 
> > I think that proposal is very unlikely to be accepted.? If it was a
> > primitive function, it could only be maintained by R Core.? They
> > are
> > justifiably very reluctant to take on extra work for themselves.
> > 
> > Kevin's package demonstrates that this can be done entirely in a
> > contributed package, which means there's no need for R Core to be
> > involved.? I don't know if he has plans to turn his prototype into
> > a
> > CRAN package.? If he doesn't, then it will be up to some other
> > interested maintainer to step up and take on the task, or it will
> > just
> > fade away.
> > 
> > I haven't checked whether your proposals below represent changes
> > from
> > the current version of dotty, but if they do, the way to proceed is
> > to
> > fork that project, implement your changes, and offer to contribute
> > them
> > back to the main branch.
> > 
> > Duncan Murdoch
> > 
> > 
> > 
> > > 
> > > ? * Positional assignment e.g. .[nr, nc] <- dim(x), and named
> > > assignment
> > > ??? e.g. .[new = carb] <- mtcars or .[new = log(carb)] <- mtcars.
> > > All
> > > ??? the functionality proposed by Kevin at
> > > ??? https://github.com/kevinushey/dotty
> > > ??? <https://github.com/kevinushey/dotty> is useful, unambiguous
> > > and
> > > ??? feasible.
> > > ? * Silent dropping of RHS values e.g. .[mpg_new, cyl_new] <-
> > > mtcars.
> > > ? * Mixing of positional and named assignment e.g .[mpg_new,
> > > carb_new =
> > > ??? carb, cyl_new] <- mtcars. The inputs not assigned by name are
> > > simply
> > > ??? the elements of RHS in the order they occur, regardless of
> > > whether
> > > ??? they have been used previously e.g. .[mpg_new, cyl_new = cyl,
> > > ??? log_cyl = log(cyl), cyl_new2] <- mtcars is feasible. RHS here
> > > could
> > > ??? be any named vector type.
> > > ? * Conventional use of the function as lazy version of of
> > > list(), as in
> > > ??? data.table: .(A = B, C, D) is the same as list(A = B, C = C,
> > > D = D).
> > > ??? This would also be useful, allowing more parsimonious code,
> > > and
> > > ??? avoid the need to assign names to all return values in a
> > > function
> > > ??? return, e.g. if I already have matrices A, C, Q and R as
> > > internal
> > > ??? objects in my function, I can simply end by return(.(A, C, Q,
> > > R))
> > > ??? instead of return(list(A = A, C = C, Q = Q, R = R)) if I
> > > wanted the
> > > ??? list to be named with the object names.
> > > 
> > > The implementation of this in R and C should be pretty
> > > straightforward.
> > > It would just require a modification to R CMD Check to recognize
> > > .[<- as
> > > assignment.
> > > 
> > > Best regards,
> > > 
> > > Sebastian
> > > -
> > > 2.)
> > > 
> > > On Sun, 12 Mar 2023 at 09:42, Sebastian Martin Krantz
> > > <sebastian.krantz at graduateinstitute.ch
> > > <mailto:sebastian.krantz at graduateinstitute.ch>> wrote:
> > > 
> > > ??? Thanks Gabriel and Kevin for your inputs,
> > > 
> > > ??? regarding your points Gabriel, I think Python and Julia do
> > > allow
> > > ??? multiple sub-assignment, but in-line with my earlier
> > > suggestion in
> > > ??? response to Duncan to make multiple assignment an
> > > environment-level
> > > ??? operation (like collapse::%=% currently works),? this would
> > > not be
> > > ??? possible in R.
> > > 
> > > ??? Regarding the [a] <- coolest_function() syntax, yeah it would
> > > mean
> > > ??? do multiple assignment and set a equal to the first element
> > > dropping
> > > ??? all other elements. Multiple assignment should be positional
> > > loke in
> > > ??? other languages, enabling flexible renaming of objects on the
> > > fly.
> > > ??? So it should be irrelevant whether the function returns a
> > > named or
> > > ??? unnamed list or vector.
> > > 
> > > ??? Thanks also Kevin for this contribution. I think it?s a
> > > remarkable
> > > ??? effort, and I wouldn?t mind such semantics e.g. making it a
> > > function
> > > ??? call to ?.[? or any other one-letter function, as long as
> > > it?s coded
> > > ??? in C and recognized by the interpreter as an assignment
> > > operation.
> > > 
> > > ??? Best regards,
> > > 
> > > ??? Sebastian
> > > 
> > > 
> > > 
> > > 
> > > 
> > > ??? On Sun 12. Mar 2023 at 01:00, Kevin Ushey
> > > <kevinushey at gmail.com
> > > ??? <mailto:kevinushey at gmail.com>> wrote:
> > > 
> > > ??????? FWIW, it's possible to get fairly close to your proposed
> > semantics
> > > ??????? using the existing metaprogramming facilities in R. I put
> > together a
> > > ??????? prototype package here to demonstrate:
> > > 
> > > ??????? https://github.com/kevinushey/dotty
> > > ??????? <https://github.com/kevinushey/dotty>
> > > 
> > > ??????? The package exports an object called `.`, with a special
> > > ??????? `[<-.dot` S3
> > > ??????? method which enables destructuring assignments. This
> > > means you
> > can
> > > ??????? write code like:
> > > 
> > > ???????????? .[nr, nc] <- dim(mtcars)
> > > 
> > > ??????? and that will define 'nr' and 'nc' as you expect.
> > > 
> > > ??????? As for R CMD check warnings, you can suppress those
> > > through the
> > > ??????? use of
> > > ??????? globalVariables(), and that can also be automated within
> > > the
> > > ??????? package.
> > > ??????? The 'dotty' package includes a function 'dotify()' which
> > automates
> > > ??????? looking for such usages in your package, and calling
> > > ??????? globalVariables()
> > > ??????? so that R CMD check doesn't warn. In theory, a similar
> > > technique
> > > ??????? would
> > > ??????? be applicable to other packages defining similar
> > > operators
> > (zeallot,
> > > ??????? collapse).
> > > 
> > > ??????? Obviously, globalVariables() is a very heavy hammer to
> > > swing for
> > > ??????? this
> > > ??????? issue, but you might consider the benefits worth the
> > > tradeoffs.
> > > 
> > > ??????? Best,
> > > ??????? Kevin
> > > 
> > > ??????? On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch
> > > ???????
> > > <murdoch.duncan at gmail.com?<mailto:murdoch.duncan at gmail.com>>
> > wrote:
> > > ???????? >
> > > ???????? > On 11/03/2023 4:42 p.m., Sebastian Martin Krantz
> > > wrote:
> > > ???????? > > Thanks Duncan and Ivan for the careful thoughts. I'm
> > > not
> > > ??????? sure I can
> > > ???????? > > follow all aspects you raised, but to give my
> > > limited take
> > > ??????? on a few:
> > > ???????? > >
> > > ???????? > >> your proposal violates a very basic property of the
> > > ??????? language, i.e. that all statements are expressions and
> > > have a
> > > ??????? value.? > What's the value of 1 + (A, C =
> > > init_matrices()).
> > > ???????? > >
> > > ???????? > > I'm not sure I see the point here. I evaluated 1 +
> > > (d =
> > > ??????? dim(mtcars); nr
> > > ???????? > > = d[1]; nc = d[2]; rm(d)), which simply gives a
> > > syntax
> > error,
> > > ???????? >
> > > ???????? >
> > > ???????? >??? d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
> > > ???????? >
> > > ???????? > is not a statement, it is a sequence of 4 statements.
> > > ???????? >
> > > ???????? > Duncan Murdoch
> > > ???????? >
> > > ???????? >?? as the
> > > ???????? > > above expression should. `%=%` assigns to
> > > ???????? > > environments, so 1 + (c("A", "C") %=%
> > > init_matrices())
> > returns
> > > ???????? > > numeric(0), with A and C having their values
> > > assigned.
> > > ???????? > >
> > > ???????? > >> suppose f() returns list(A = 1, B = 2) and I do? >
> > > B, A <-
> > > ??????? f() > Should assignment be by position or by name?
> > > ???????? > >
> > > ???????? > > In other languages this is by position. The feature
> > > is not
> > > ??????? meant to
> > > ???????? > > replace list2env(), and being able to rename objects
> > > in the
> > > ??????? assignment
> > > ???????? > > is a vital feature of codes
> > > ???????? > > using multi input and output functions e.g. in
> > > Matlab or
> > Julia.
> > > ???????? > >
> > > ???????? > >> Honestly, given that this is simply syntactic
> > > sugar, I
> > > ??????? don't think I would support it.
> > > ???????? > >
> > > ???????? > > You can call it that, but it would be used by almost
> > > every
> > > ??????? R user almost
> > > ???????? > > every day. Simple things like nr, nc = dim(x);
> > > values,
> > > ??????? vectors =
> > > ???????? > > eigen(x) etc. where the creation of intermediate
> > > objects
> > > ???????? > > is cumbersome and redundant.
> > > ???????? > >
> > > ???????? > >> I see you've already mentioned it ("JavaScript-
> > > like"). I
> > > ??????? think it would? fulfil Sebastian's requirements too, as
> > > long as
> > > ??????? it is considered "true assignment" by the rest of the
> > > language.
> > > ???????? > >
> > > ???????? > > I don't have strong opinions about how the issue is
> > > phrased
> > or
> > > ???????? > > implemented. Something like [t, n] = dim(x) might
> > > even be
> > > ??????? more clear.
> > > ???????? > > It's important though that assignment remains by
> > > position,
> > > ???????? > > so even if some output gets thrown away that should
> > > also be
> > > ??????? positional.
> > > ???????? > >
> > > ???????? > >>? A <- 0? > [A, B = A + 10] <- list(1, A = 2)
> > > ???????? > >
> > > ???????? > > I also fail to see the use of allowing this.
> > > something like
> > > ??????? this is an
> > > ???????? > > error.
> > > ???????? > >
> > > ???????? > >> A = 2
> > > ???????? > >> (B = A + 1) <- 1
> > > ???????? > > Error in (B = A + 1) <- 1 : could not find function
> > > "(<-"
> > > ???????? > >
> > > ???????? > > Regarding the practical implementation, I think
> > > ??????? `collapse::%=%` is a
> > > ???????? > > good starting point. It could be introduced in R as
> > > a
> > > ??????? separate function,
> > > ???????? > > or `=` could be modified to accommodate its
> > > capability. It
> > > ??????? should be
> > > ???????? > > clear that
> > > ???????? > > with more than one LHS variables the assignment is
> > > an
> > > ??????? environment level
> > > ???????? > > operation and the results can only be used in
> > > computations
> > > ??????? once assigned
> > > ???????? > > to the environment, e.g. as in 1 + (c("A", "C") %=%
> > > ??????? init_matrices()),
> > > ???????? > > A and C are not available for the addition in this
> > > ??????? statement. The
> > > ???????? > > interpretor then needs to be modified to read
> > > something
> > > ??????? like nr, nc =
> > > ???????? > > dim(x) or [nr, nc] = dim(x). as an environment-level
> > > ??????? multiple assignment
> > > ???????? > > operation with no
> > > ???????? > > immediate value. Appears very feasible to my limited
> > > ??????? understanding, but
> > > ???????? > > I guess there are other things to consider still.
> > > ??????? Definitely appreciate
> > > ???????? > > the responses so far though.
> > > ???????? > >
> > > ???????? > > Best regards,
> > > ???????? > >
> > > ???????? > > Sebastian
> > > ???????? > >
> > > ???????? > >
> > > ???????? > >
> > > ???????? > >
> > > ???????? > >
> > > ???????? > > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch
> > > ???????
> > > <murdoch.duncan at gmail.com?<mailto:murdoch.duncan at gmail.com>
> > > ???????? > > <mailto:murdoch.duncan at gmail.com
> > > ??????? <mailto:murdoch.duncan at gmail.com>>> wrote:
> > > ???????? > >
> > > ???????? > >???? On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
> > > ???????? > >????? > On Sat, 11 Mar 2023 11:11:06 -0500
> > > ???????? > >????? > Duncan Murdoch <murdoch.duncan at gmail.com
> > > ??????? <mailto:murdoch.duncan at gmail.com>
> > > ???????? > >???? <mailto:murdoch.duncan at gmail.com
> > > ??????? <mailto:murdoch.duncan at gmail.com>>> wrote:
> > > ???????? > >????? >
> > > ???????? > >????? >> That's clear, but your proposal violates a
> > > very
> > > ??????? basic property
> > > ???????? > >???? of the
> > > ???????? > >????? >> language, i.e. that all statements are
> > > expressions
> > > ??????? and have a value.
> > > ???????? > >????? >
> > > ???????? > >????? > How about reframing this feature request from
> > > ??????? multiple assignment
> > > ???????? > >????? > (which does go contrary to "everything has
> > > only one
> > > ??????? value, even
> > > ???????? > >???? if it's
> > > ???????? > >????? > sometimes invisible(NULL)") to "structured
> > > binding"
> > > ??????? / "destructuring
> > > ???????? > >????? > assignment" [*], which takes this single
> > > single
> > > ??????? value returned by the
> > > ???????? > >????? > expression and subsets it subject to certain
> > > rules?
> > > ??????? It may be
> > > ???????? > >???? easier to
> > > ???????? > >????? > make a decision on the semantics for
> > > destructuring
> > > ??????? assignment (e.g.
> > > ???????? > >????? > languages which have this feature typically
> > > allow
> > > ??????? throwing unneeded
> > > ???????? > >????? > parts of the return value away), and it
> > > doesn't seem
> > > ??????? to break as much
> > > ???????? > >????? > of the rest of the language if implemented.
> > > ???????? > >????? >
> > > ???????? > >????? > I see you've already mentioned it
> > > ??????? ("JavaScript-like"). I think it
> > > ???????? > >???? would
> > > ???????? > >????? > fulfil Sebastian's requirements too, as long
> > > as it
> > > ??????? is considered
> > > ???????? > >???? "true
> > > ???????? > >????? > assignment" by the rest of the language.
> > > ???????? > >????? >
> > > ???????? > >????? > The hard part is to propose the actual
> > > grammar of
> > > ??????? the new feature (in
> > > ???????? > >????? > terms of src/main/gram.y, preferably without
> > introducing
> > > ???????? > >???? conflicts) and
> > > ???????? > >????? > its semantics (including the corner cases,
> > > some of
> > > ??????? which you have
> > > ???????? > >????? > already mentioned). I'm not sure I'm up to
> > > the task.
> > > ???????? > >????? >
> > > ???????? > >
> > > ???????? > >???? If I were doing it, here's what I'd propose:
> > > ???????? > >
> > > ???????? > >???????? '[' formlist ']' LEFT_ASSIGN expr
> > > ???????? > >???????? '[' formlist ']' EQ_ASSIGN expr
> > > ???????? > >???????? expr RIGHT_ASSIGN? '[' formlist ']'
> > > ???????? > >
> > > ???????? > >???? where `formlist` has the syntax of the formals
> > > list for
> > > ??????? a function
> > > ???????? > >???? definition.? This would have the following
> > > semantics:
> > > ???????? > >
> > > ???????? > >????????? {
> > > ???????? > >??????????? *tmp* <- expr
> > > ???????? > >
> > > ???????? > >??????????? # For arguments with no "default"
> > > expression,
> > > ???????? > >
> > > ???????? > >??????????? argname1 <- *tmp*[[1]]
> > > ???????? > >??????????? argname2 <- *tmp*[[2]]
> > > ???????? > >??????????? ...
> > > ???????? > >
> > > ???????? > >??????????? # For arguments with a default listed
> > > ???????? > >
> > > ???????? > >??????????? argname3 <- with(*tmp*, default3)
> > > ???????? > >????????? }
> > > ???????? > >
> > > ???????? > >
> > > ???????? > >???? The value of the whole thing would therefore be
> > > ??????? (invisibly) the
> > > ???????? > >???? value of
> > > ???????? > >???? the last item in the assignment.
> > > ???????? > >
> > > ???????? > >???? Two examples:
> > > ???????? > >
> > > ???????? > >???????? [A, B, C] <- expr?? # assign the first three
> > > ??????? elements of expr to A,
> > > ???????? > >???? B, and C
> > > ???????? > >
> > > ???????? > >???????? [A, B, C = a + b] <- expr? # assign the
> > > first two
> > > ??????? elements of expr
> > > ???????? > >??????????????????????????????????? # to A and B,
> > > ???????? > >??????????????????????????????????? # assign
> > > with(expr, a +
> > > ??????? b) to C.
> > > ???????? > >
> > > ???????? > >???? Unfortunately, I don't think this could be done
> > entirely by
> > > ???????? > >???? transforming
> > > ???????? > >???? the expression (which is the way |> was done),
> > > and that
> > > ??????? makes it a lot
> > > ???????? > >???? harder to write and to reason about.? E.g. what
> > > does
> > > ??????? this do?
> > > ???????? > >
> > > ???????? > >???????? A <- 0
> > > ???????? > >???????? [A, B = A + 10] <- list(1, A = 2)
> > > ???????? > >
> > > ???????? > >???? According to the recipe above, I think it sets A
> > > to 1
> > > ??????? and B to 12, but
> > > ???????? > >???? maybe a user would expect B to be 10 or 11.? And
> > > ??????? according to that
> > > ???????? > >???? recipe this is an error:
> > > ???????? > >
> > > ???????? > >???????? [A, B = A + 10] <- c(1, A = 2)
> > > ???????? > >
> > > ???????? > >???? which probably isn't what a user would expect,
> > > given
> > > ??????? that this is fine:
> > > ???????? > >
> > > ???????? > >???????? [A, B] <- c(1, 2)
> > > ???????? > >
> > > ???????? > >???? Duncan Murdoch
> > > ???????? > >
> > > ???????? >
> > > ???????? > ______________________________________________
> > > ???????? > R-devel at r-project.org?<mailto:R-devel at r-project.org>
> > > mailing
> > list
> > > ???????? > https://stat.ethz.ch/mailman/listinfo/r-devel
> > > ??????? <https://stat.ethz.ch/mailman/listinfo/r-devel>
> > > 
> > 
> > 
> 
> ????????[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org?mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Mon Mar 13 11:01:07 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Mon, 13 Mar 2023 06:01:07 -0400
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <7aedf95ecb2a98531140764db3035449c7bd1147.camel@unsw.edu.au>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
 <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>
 <CAOsNuxCLE9j1XiGwRevcAHu_EHYXaA=aBSREbb3SDUXWMiNHyg@mail.gmail.com>
 <05b0cf79-d768-7e6e-6dcf-502a14fcef84@gmail.com>
 <CAOsNuxBtYEe9FkMK3QA8PKzar_JX2cVsO1bLNXoZb0GkBPjPQQ@mail.gmail.com>
 <7aedf95ecb2a98531140764db3035449c7bd1147.camel@unsw.edu.au>
Message-ID: <db71f2b8-d7ef-aad5-0369-79bc21fe4213@gmail.com>

Yes, this is really a problem with the checks, not with the language.

A simpler approach than your alternativeAssignment function would be 
simply to allow globalVariables() to be limited to a single function as 
the note in its help page says.

This might be tedious to write by hand, but could be automated using 
methods like "dotify" in dotty.

Duncan Murdoch


On 12/03/2023 10:36 p.m., Pavel Krivitsky wrote:
> Dear All,
> 
> As a maintainer of large, complex packages, I can think of many places
> in which deconstructing assignment would simplify the code, as well as
> facilitate readability by breaking up larger functions into helpers, so
> I would be very glad to see this incorporated somehow.
> 
> I think the crux of the matter is that while there is a number of ways
> to implement deconstructing assignment within R, there is no mechanism
> to tell R CMD check about it without also suppressing checks for every
> other instance of that variable name. This is particularly problematic
> because those variable names are likely to be used elsewhere in the
> package.
> 
> Workarounds that have been suggested all defeat the conciseness and
> clarity of the deconstructing assignment and introduce potential for
> subtle bugs.
> 
> The check warnings are something that can only be addressed in
> 'codetools', with a finer API than what utils::globalVariables()
> provides.?Perhaps this would have a lower hurdle than modifying R
> language itself?
> 
>  From skimming through the relevant 'codetools' code, one idea for such
> an API would be a function, along the lines of
> 
> utils::alternativeAssignment(op, assigned)
> 
> that sets up a callback assigned = function(op, e) that given the
> operator (as string) and the expression it's embedded in, returns a
> list of three elements:
>   * a character vector containing a list of variables assigned to that
>     might not otherwise be detected
>   * a character vector containing a list of variables referenced that
>     might not otherwise be detected
>   * expression e with potentially "offending" elements removed, which
>     will then be processed by the rest of the checking code
> 
> Then, say, 'zeallot' could implement zeallot::zeallot_assign_detect(),
> and a package developer using it could put
> 
> utils::alternativeAssignment("%<-%", zeallot::zeallot_assign_detect)
> 
> in their .onLoad() function. Similarly, users of 'dotty' could set up
> callbacks for all standard assignment operators to inform the code
> about the nonstandard assignment.
> 
> Best Regards,Pavel
> 
> On Sun, 2023-03-12 at 14:05 +0200, Sebastian Martin Krantz wrote:
>> Kevins package is very nice as a proof of concept, no doubt about
>> that, but
>> it is not at the level of performance or convenience that a native R
>> implementation would offer. I would probably not use it to translate
>> matlab
>> routines into R packages placed on CRAN, because it?s an additional
>> dependency, I have a performance burden in every iteration, and
>> utils::globalVariables() is everything but elegant. From that
>> perspective
>> it would be more convenient for me right now to stick with
>> collapse::%=%,
>> which is already written in C, and also call
>> utils::globalVariables().
>>
>> But again my hope in starting this was that R Core might see that the
>> addition of multiple assignment would be a significant enhancement to
>> the
>> language, of the same order as the base pipe |> in my opinion.
>>
>> I think the discussion so far has at least brought forth a way to
>> implement
>> this in a way that does not violate fundamental principles of the
>> language.
>> Which could form a basis for thinking about an actual addition to the
>> language.
>>
>> Best regards,
>>
>> Sebastian
>>
>>
>> On Sun 12. Mar 2023 at 13:18, Duncan Murdoch
>> <murdoch.duncan at gmail.com>
>> wrote:
>>
>>> On 12/03/2023 6:07 a.m., Sebastian Martin Krantz wrote:
>>>> Thinking more about this, and seeing Kevins examples at
>>>> https://github.com/kevinushey/dotty
>>>> <https://github.com/kevinushey/dotty>, I think this is the most
>>>> R-like
>>>> way of doing it,
>>>> with an additional benefit as it would allow to introduce the
>>>> useful
>>>> data.table semantics DT[, .(a = b, c, d)] to more general R. So I
>>>> would
>>>> propose to
>>>> introduce a new primitive function . <- function(...)
>>>> .Primitive(".") in
>>>> R with an assignment method and the following features:
>>>
>>> I think that proposal is very unlikely to be accepted.? If it was a
>>> primitive function, it could only be maintained by R Core.? They
>>> are
>>> justifiably very reluctant to take on extra work for themselves.
>>>
>>> Kevin's package demonstrates that this can be done entirely in a
>>> contributed package, which means there's no need for R Core to be
>>> involved.? I don't know if he has plans to turn his prototype into
>>> a
>>> CRAN package.? If he doesn't, then it will be up to some other
>>> interested maintainer to step up and take on the task, or it will
>>> just
>>> fade away.
>>>
>>> I haven't checked whether your proposals below represent changes
>>> from
>>> the current version of dotty, but if they do, the way to proceed is
>>> to
>>> fork that project, implement your changes, and offer to contribute
>>> them
>>> back to the main branch.
>>>
>>> Duncan Murdoch
>>>
>>>
>>>
>>>>
>>>>  ? * Positional assignment e.g. .[nr, nc] <- dim(x), and named
>>>> assignment
>>>>  ??? e.g. .[new = carb] <- mtcars or .[new = log(carb)] <- mtcars.
>>>> All
>>>>  ??? the functionality proposed by Kevin at
>>>>  ??? https://github.com/kevinushey/dotty
>>>>  ??? <https://github.com/kevinushey/dotty> is useful, unambiguous
>>>> and
>>>>  ??? feasible.
>>>>  ? * Silent dropping of RHS values e.g. .[mpg_new, cyl_new] <-
>>>> mtcars.
>>>>  ? * Mixing of positional and named assignment e.g .[mpg_new,
>>>> carb_new =
>>>>  ??? carb, cyl_new] <- mtcars. The inputs not assigned by name are
>>>> simply
>>>>  ??? the elements of RHS in the order they occur, regardless of
>>>> whether
>>>>  ??? they have been used previously e.g. .[mpg_new, cyl_new = cyl,
>>>>  ??? log_cyl = log(cyl), cyl_new2] <- mtcars is feasible. RHS here
>>>> could
>>>>  ??? be any named vector type.
>>>>  ? * Conventional use of the function as lazy version of of
>>>> list(), as in
>>>>  ??? data.table: .(A = B, C, D) is the same as list(A = B, C = C,
>>>> D = D).
>>>>  ??? This would also be useful, allowing more parsimonious code,
>>>> and
>>>>  ??? avoid the need to assign names to all return values in a
>>>> function
>>>>  ??? return, e.g. if I already have matrices A, C, Q and R as
>>>> internal
>>>>  ??? objects in my function, I can simply end by return(.(A, C, Q,
>>>> R))
>>>>  ??? instead of return(list(A = A, C = C, Q = Q, R = R)) if I
>>>> wanted the
>>>>  ??? list to be named with the object names.
>>>>
>>>> The implementation of this in R and C should be pretty
>>>> straightforward.
>>>> It would just require a modification to R CMD Check to recognize
>>>> .[<- as
>>>> assignment.
>>>>
>>>> Best regards,
>>>>
>>>> Sebastian
>>>> -
>>>> 2.)
>>>>
>>>> On Sun, 12 Mar 2023 at 09:42, Sebastian Martin Krantz
>>>> <sebastian.krantz at graduateinstitute.ch
>>>> <mailto:sebastian.krantz at graduateinstitute.ch>> wrote:
>>>>
>>>>  ??? Thanks Gabriel and Kevin for your inputs,
>>>>
>>>>  ??? regarding your points Gabriel, I think Python and Julia do
>>>> allow
>>>>  ??? multiple sub-assignment, but in-line with my earlier
>>>> suggestion in
>>>>  ??? response to Duncan to make multiple assignment an
>>>> environment-level
>>>>  ??? operation (like collapse::%=% currently works),? this would
>>>> not be
>>>>  ??? possible in R.
>>>>
>>>>  ??? Regarding the [a] <- coolest_function() syntax, yeah it would
>>>> mean
>>>>  ??? do multiple assignment and set a equal to the first element
>>>> dropping
>>>>  ??? all other elements. Multiple assignment should be positional
>>>> loke in
>>>>  ??? other languages, enabling flexible renaming of objects on the
>>>> fly.
>>>>  ??? So it should be irrelevant whether the function returns a
>>>> named or
>>>>  ??? unnamed list or vector.
>>>>
>>>>  ??? Thanks also Kevin for this contribution. I think it?s a
>>>> remarkable
>>>>  ??? effort, and I wouldn?t mind such semantics e.g. making it a
>>>> function
>>>>  ??? call to ?.[? or any other one-letter function, as long as
>>>> it?s coded
>>>>  ??? in C and recognized by the interpreter as an assignment
>>>> operation.
>>>>
>>>>  ??? Best regards,
>>>>
>>>>  ??? Sebastian
>>>>
>>>>
>>>>
>>>>
>>>>
>>>>  ??? On Sun 12. Mar 2023 at 01:00, Kevin Ushey
>>>> <kevinushey at gmail.com
>>>>  ??? <mailto:kevinushey at gmail.com>> wrote:
>>>>
>>>>  ??????? FWIW, it's possible to get fairly close to your proposed
>>> semantics
>>>>  ??????? using the existing metaprogramming facilities in R. I put
>>> together a
>>>>  ??????? prototype package here to demonstrate:
>>>>
>>>>  ??????? https://github.com/kevinushey/dotty
>>>>  ??????? <https://github.com/kevinushey/dotty>
>>>>
>>>>  ??????? The package exports an object called `.`, with a special
>>>>  ??????? `[<-.dot` S3
>>>>  ??????? method which enables destructuring assignments. This
>>>> means you
>>> can
>>>>  ??????? write code like:
>>>>
>>>>  ???????????? .[nr, nc] <- dim(mtcars)
>>>>
>>>>  ??????? and that will define 'nr' and 'nc' as you expect.
>>>>
>>>>  ??????? As for R CMD check warnings, you can suppress those
>>>> through the
>>>>  ??????? use of
>>>>  ??????? globalVariables(), and that can also be automated within
>>>> the
>>>>  ??????? package.
>>>>  ??????? The 'dotty' package includes a function 'dotify()' which
>>> automates
>>>>  ??????? looking for such usages in your package, and calling
>>>>  ??????? globalVariables()
>>>>  ??????? so that R CMD check doesn't warn. In theory, a similar
>>>> technique
>>>>  ??????? would
>>>>  ??????? be applicable to other packages defining similar
>>>> operators
>>> (zeallot,
>>>>  ??????? collapse).
>>>>
>>>>  ??????? Obviously, globalVariables() is a very heavy hammer to
>>>> swing for
>>>>  ??????? this
>>>>  ??????? issue, but you might consider the benefits worth the
>>>> tradeoffs.
>>>>
>>>>  ??????? Best,
>>>>  ??????? Kevin
>>>>
>>>>  ??????? On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch
>>>>         
>>>> <murdoch.duncan at gmail.com?<mailto:murdoch.duncan at gmail.com>>
>>> wrote:
>>>>  ???????? >
>>>>  ???????? > On 11/03/2023 4:42 p.m., Sebastian Martin Krantz
>>>> wrote:
>>>>  ???????? > > Thanks Duncan and Ivan for the careful thoughts. I'm
>>>> not
>>>>  ??????? sure I can
>>>>  ???????? > > follow all aspects you raised, but to give my
>>>> limited take
>>>>  ??????? on a few:
>>>>  ???????? > >
>>>>  ???????? > >> your proposal violates a very basic property of the
>>>>  ??????? language, i.e. that all statements are expressions and
>>>> have a
>>>>  ??????? value.? > What's the value of 1 + (A, C =
>>>> init_matrices()).
>>>>  ???????? > >
>>>>  ???????? > > I'm not sure I see the point here. I evaluated 1 +
>>>> (d =
>>>>  ??????? dim(mtcars); nr
>>>>  ???????? > > = d[1]; nc = d[2]; rm(d)), which simply gives a
>>>> syntax
>>> error,
>>>>  ???????? >
>>>>  ???????? >
>>>>  ???????? >??? d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
>>>>  ???????? >
>>>>  ???????? > is not a statement, it is a sequence of 4 statements.
>>>>  ???????? >
>>>>  ???????? > Duncan Murdoch
>>>>  ???????? >
>>>>  ???????? >?? as the
>>>>  ???????? > > above expression should. `%=%` assigns to
>>>>  ???????? > > environments, so 1 + (c("A", "C") %=%
>>>> init_matrices())
>>> returns
>>>>  ???????? > > numeric(0), with A and C having their values
>>>> assigned.
>>>>  ???????? > >
>>>>  ???????? > >> suppose f() returns list(A = 1, B = 2) and I do? >
>>>> B, A <-
>>>>  ??????? f() > Should assignment be by position or by name?
>>>>  ???????? > >
>>>>  ???????? > > In other languages this is by position. The feature
>>>> is not
>>>>  ??????? meant to
>>>>  ???????? > > replace list2env(), and being able to rename objects
>>>> in the
>>>>  ??????? assignment
>>>>  ???????? > > is a vital feature of codes
>>>>  ???????? > > using multi input and output functions e.g. in
>>>> Matlab or
>>> Julia.
>>>>  ???????? > >
>>>>  ???????? > >> Honestly, given that this is simply syntactic
>>>> sugar, I
>>>>  ??????? don't think I would support it.
>>>>  ???????? > >
>>>>  ???????? > > You can call it that, but it would be used by almost
>>>> every
>>>>  ??????? R user almost
>>>>  ???????? > > every day. Simple things like nr, nc = dim(x);
>>>> values,
>>>>  ??????? vectors =
>>>>  ???????? > > eigen(x) etc. where the creation of intermediate
>>>> objects
>>>>  ???????? > > is cumbersome and redundant.
>>>>  ???????? > >
>>>>  ???????? > >> I see you've already mentioned it ("JavaScript-
>>>> like"). I
>>>>  ??????? think it would? fulfil Sebastian's requirements too, as
>>>> long as
>>>>  ??????? it is considered "true assignment" by the rest of the
>>>> language.
>>>>  ???????? > >
>>>>  ???????? > > I don't have strong opinions about how the issue is
>>>> phrased
>>> or
>>>>  ???????? > > implemented. Something like [t, n] = dim(x) might
>>>> even be
>>>>  ??????? more clear.
>>>>  ???????? > > It's important though that assignment remains by
>>>> position,
>>>>  ???????? > > so even if some output gets thrown away that should
>>>> also be
>>>>  ??????? positional.
>>>>  ???????? > >
>>>>  ???????? > >>? A <- 0? > [A, B = A + 10] <- list(1, A = 2)
>>>>  ???????? > >
>>>>  ???????? > > I also fail to see the use of allowing this.
>>>> something like
>>>>  ??????? this is an
>>>>  ???????? > > error.
>>>>  ???????? > >
>>>>  ???????? > >> A = 2
>>>>  ???????? > >> (B = A + 1) <- 1
>>>>  ???????? > > Error in (B = A + 1) <- 1 : could not find function
>>>> "(<-"
>>>>  ???????? > >
>>>>  ???????? > > Regarding the practical implementation, I think
>>>>  ??????? `collapse::%=%` is a
>>>>  ???????? > > good starting point. It could be introduced in R as
>>>> a
>>>>  ??????? separate function,
>>>>  ???????? > > or `=` could be modified to accommodate its
>>>> capability. It
>>>>  ??????? should be
>>>>  ???????? > > clear that
>>>>  ???????? > > with more than one LHS variables the assignment is
>>>> an
>>>>  ??????? environment level
>>>>  ???????? > > operation and the results can only be used in
>>>> computations
>>>>  ??????? once assigned
>>>>  ???????? > > to the environment, e.g. as in 1 + (c("A", "C") %=%
>>>>  ??????? init_matrices()),
>>>>  ???????? > > A and C are not available for the addition in this
>>>>  ??????? statement. The
>>>>  ???????? > > interpretor then needs to be modified to read
>>>> something
>>>>  ??????? like nr, nc =
>>>>  ???????? > > dim(x) or [nr, nc] = dim(x). as an environment-level
>>>>  ??????? multiple assignment
>>>>  ???????? > > operation with no
>>>>  ???????? > > immediate value. Appears very feasible to my limited
>>>>  ??????? understanding, but
>>>>  ???????? > > I guess there are other things to consider still.
>>>>  ??????? Definitely appreciate
>>>>  ???????? > > the responses so far though.
>>>>  ???????? > >
>>>>  ???????? > > Best regards,
>>>>  ???????? > >
>>>>  ???????? > > Sebastian
>>>>  ???????? > >
>>>>  ???????? > >
>>>>  ???????? > >
>>>>  ???????? > >
>>>>  ???????? > >
>>>>  ???????? > > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch
>>>>         
>>>> <murdoch.duncan at gmail.com?<mailto:murdoch.duncan at gmail.com>
>>>>  ???????? > > <mailto:murdoch.duncan at gmail.com
>>>>  ??????? <mailto:murdoch.duncan at gmail.com>>> wrote:
>>>>  ???????? > >
>>>>  ???????? > >???? On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
>>>>  ???????? > >????? > On Sat, 11 Mar 2023 11:11:06 -0500
>>>>  ???????? > >????? > Duncan Murdoch <murdoch.duncan at gmail.com
>>>>  ??????? <mailto:murdoch.duncan at gmail.com>
>>>>  ???????? > >???? <mailto:murdoch.duncan at gmail.com
>>>>  ??????? <mailto:murdoch.duncan at gmail.com>>> wrote:
>>>>  ???????? > >????? >
>>>>  ???????? > >????? >> That's clear, but your proposal violates a
>>>> very
>>>>  ??????? basic property
>>>>  ???????? > >???? of the
>>>>  ???????? > >????? >> language, i.e. that all statements are
>>>> expressions
>>>>  ??????? and have a value.
>>>>  ???????? > >????? >
>>>>  ???????? > >????? > How about reframing this feature request from
>>>>  ??????? multiple assignment
>>>>  ???????? > >????? > (which does go contrary to "everything has
>>>> only one
>>>>  ??????? value, even
>>>>  ???????? > >???? if it's
>>>>  ???????? > >????? > sometimes invisible(NULL)") to "structured
>>>> binding"
>>>>  ??????? / "destructuring
>>>>  ???????? > >????? > assignment" [*], which takes this single
>>>> single
>>>>  ??????? value returned by the
>>>>  ???????? > >????? > expression and subsets it subject to certain
>>>> rules?
>>>>  ??????? It may be
>>>>  ???????? > >???? easier to
>>>>  ???????? > >????? > make a decision on the semantics for
>>>> destructuring
>>>>  ??????? assignment (e.g.
>>>>  ???????? > >????? > languages which have this feature typically
>>>> allow
>>>>  ??????? throwing unneeded
>>>>  ???????? > >????? > parts of the return value away), and it
>>>> doesn't seem
>>>>  ??????? to break as much
>>>>  ???????? > >????? > of the rest of the language if implemented.
>>>>  ???????? > >????? >
>>>>  ???????? > >????? > I see you've already mentioned it
>>>>  ??????? ("JavaScript-like"). I think it
>>>>  ???????? > >???? would
>>>>  ???????? > >????? > fulfil Sebastian's requirements too, as long
>>>> as it
>>>>  ??????? is considered
>>>>  ???????? > >???? "true
>>>>  ???????? > >????? > assignment" by the rest of the language.
>>>>  ???????? > >????? >
>>>>  ???????? > >????? > The hard part is to propose the actual
>>>> grammar of
>>>>  ??????? the new feature (in
>>>>  ???????? > >????? > terms of src/main/gram.y, preferably without
>>> introducing
>>>>  ???????? > >???? conflicts) and
>>>>  ???????? > >????? > its semantics (including the corner cases,
>>>> some of
>>>>  ??????? which you have
>>>>  ???????? > >????? > already mentioned). I'm not sure I'm up to
>>>> the task.
>>>>  ???????? > >????? >
>>>>  ???????? > >
>>>>  ???????? > >???? If I were doing it, here's what I'd propose:
>>>>  ???????? > >
>>>>  ???????? > >???????? '[' formlist ']' LEFT_ASSIGN expr
>>>>  ???????? > >???????? '[' formlist ']' EQ_ASSIGN expr
>>>>  ???????? > >???????? expr RIGHT_ASSIGN? '[' formlist ']'
>>>>  ???????? > >
>>>>  ???????? > >???? where `formlist` has the syntax of the formals
>>>> list for
>>>>  ??????? a function
>>>>  ???????? > >???? definition.? This would have the following
>>>> semantics:
>>>>  ???????? > >
>>>>  ???????? > >????????? {
>>>>  ???????? > >??????????? *tmp* <- expr
>>>>  ???????? > >
>>>>  ???????? > >??????????? # For arguments with no "default"
>>>> expression,
>>>>  ???????? > >
>>>>  ???????? > >??????????? argname1 <- *tmp*[[1]]
>>>>  ???????? > >??????????? argname2 <- *tmp*[[2]]
>>>>  ???????? > >??????????? ...
>>>>  ???????? > >
>>>>  ???????? > >??????????? # For arguments with a default listed
>>>>  ???????? > >
>>>>  ???????? > >??????????? argname3 <- with(*tmp*, default3)
>>>>  ???????? > >????????? }
>>>>  ???????? > >
>>>>  ???????? > >
>>>>  ???????? > >???? The value of the whole thing would therefore be
>>>>  ??????? (invisibly) the
>>>>  ???????? > >???? value of
>>>>  ???????? > >???? the last item in the assignment.
>>>>  ???????? > >
>>>>  ???????? > >???? Two examples:
>>>>  ???????? > >
>>>>  ???????? > >???????? [A, B, C] <- expr?? # assign the first three
>>>>  ??????? elements of expr to A,
>>>>  ???????? > >???? B, and C
>>>>  ???????? > >
>>>>  ???????? > >???????? [A, B, C = a + b] <- expr? # assign the
>>>> first two
>>>>  ??????? elements of expr
>>>>  ???????? > >??????????????????????????????????? # to A and B,
>>>>  ???????? > >??????????????????????????????????? # assign
>>>> with(expr, a +
>>>>  ??????? b) to C.
>>>>  ???????? > >
>>>>  ???????? > >???? Unfortunately, I don't think this could be done
>>> entirely by
>>>>  ???????? > >???? transforming
>>>>  ???????? > >???? the expression (which is the way |> was done),
>>>> and that
>>>>  ??????? makes it a lot
>>>>  ???????? > >???? harder to write and to reason about.? E.g. what
>>>> does
>>>>  ??????? this do?
>>>>  ???????? > >
>>>>  ???????? > >???????? A <- 0
>>>>  ???????? > >???????? [A, B = A + 10] <- list(1, A = 2)
>>>>  ???????? > >
>>>>  ???????? > >???? According to the recipe above, I think it sets A
>>>> to 1
>>>>  ??????? and B to 12, but
>>>>  ???????? > >???? maybe a user would expect B to be 10 or 11.? And
>>>>  ??????? according to that
>>>>  ???????? > >???? recipe this is an error:
>>>>  ???????? > >
>>>>  ???????? > >???????? [A, B = A + 10] <- c(1, A = 2)
>>>>  ???????? > >
>>>>  ???????? > >???? which probably isn't what a user would expect,
>>>> given
>>>>  ??????? that this is fine:
>>>>  ???????? > >
>>>>  ???????? > >???????? [A, B] <- c(1, 2)
>>>>  ???????? > >
>>>>  ???????? > >???? Duncan Murdoch
>>>>  ???????? > >
>>>>  ???????? >
>>>>  ???????? > ______________________________________________
>>>>  ???????? > R-devel at r-project.org?<mailto:R-devel at r-project.org>
>>>> mailing
>>> list
>>>>  ???????? > https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>  ??????? <https://stat.ethz.ch/mailman/listinfo/r-devel>
>>>>
>>>
>>>
>>
>>  ????????[[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-devel at r-project.org?mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From ggrothend|eck @end|ng |rom gm@||@com  Mon Mar 13 13:29:52 2023
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Mon, 13 Mar 2023 08:29:52 -0400
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
Message-ID: <CAP01uRkDEKhfVsO0XAPdy+DZvtfPX=YKbHUnvReL0Hv5jshQCw@mail.gmail.com>

The gsubfn package can do that.

    library(gsubfn)

    # swap a and b without explicitly creating a temporary
     a <- 1; b <- 2
     list[a,b] <- list(b,a)

     # get eigenvectors and eigenvalues
     list[eval, evec] <- eigen(cbind(1,1:3,3:1))

     # get today's month, day, year
     require(chron)
     list[Month, Day, Year] <- month.day.year(unclass(Sys.Date()))

     # get first two components of linear model ignoring rest
     list[Coef, Resid] <- lm(rnorm(10) ~ seq(10))

     # assign Green and Blue (but not Red) components
     list[,Green,Blue]  <- col2rgb("aquamarine")

     # Assign QR and QRaux but not other components
     list[QR,,QRaux]  <- qr(c(1,1:3,3:1))


On Sat, Mar 11, 2023 at 7:47?AM Sebastian Martin Krantz
<sebastian.krantz at graduateinstitute.ch> wrote:
>
> Dear R Core,
>
> working on my dynamic factor modelling package, which requires several
> subroutines to create and update several system matrices, I come back to
> the issue of being annoyed by R not supporting multiple assignment out of
> the box like Matlab, Python and julia. e.g. something like
>
> A, C, Q, R = init_matrices(X, Y, Z)
>
> would be a great addition to the language. I know there are several
> workarounds such as the %<-% operator in the zeallot package or my own %=%
> operator in collapse, but these don't work well for package development as
> R CMD Check warns about missing global bindings for the created variables,
> e.g. I would have to use
>
> A <- C <- Q <- R <- NULL
> .c(A, C, Q, R) %=% init_matrices(X, Y, Z)
>
> in a package, which is simply annoying. Of course the standard way of
>
> init <- init_matrices(X, Y, Z)
>  A <- init$A; C <- init$C; Q <- init$Q; R <- init$R
> rm(init)
>
> is also super cumbersome compared to Python or Julia. Another reason is of
> course performance, even my %=% operator written in C has a non-negligible
> performance cost for very tight loops, compared to a solution at the
> interpretor level or in a primitive function such as `=`.
>
> So my conclusion at this point is that it is just significantly easier to
> implement such codes in Julia, in addition to the greater performance it
> offers. There are obvious reasons why I am still coding in R and C, thanks
> to the robust API and great ecosystem of packages, but adding this could be
> a presumably low-hanging fruit to make my life a bit easier. Several issues
> for this have been filed on Stackoverflow, the most popular one (
> https://stackoverflow.com/questions/7519790/assign-multiple-new-variables-on-lhs-in-a-single-line)
> has been viewed 77 thousand times.
>
> But maybe this has already been discussed here and already decided against.
> In that case, a way to browse R-devel archives to find out would be nice.
>
> Best regards,
>
> Sebastian
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From ezr@ @end|ng |rom |@ndtucker@com  Mon Mar 13 16:53:56 2023
From: ezr@ @end|ng |rom |@ndtucker@com (Ezra Tucker)
Date: Mon, 13 Mar 2023 11:53:56 -0400
Subject: [Rd] Adding support for S7 to base R
In-Reply-To: <9fea1857-e3fe-e0c4-5d31-702c482f320c@gmail.com>
References: <CALWM=9b2izXXmLOQQOf4Ssg+11E5fdy5DfM4P2NqCPeBpLGSwg@mail.gmail.com>
 <9d257ea4-d757-f88e-e9d0-383f8cc8b45b@gmail.com>
 <9fea1857-e3fe-e0c4-5d31-702c482f320c@gmail.com>
Message-ID: <CAEToJBHfJ2VqdQUk7UgQ8zoCY-nCGrTT6S-GbkyvNcQhkwOD0Q@mail.gmail.com>

I don't know if this is the right forum, but I'd like to ask an open-ended
question about the goals of the S7 OOP system, which is, where do we see
the ultimate future of object-oriented programming in R being? Do we see S7
eventually complementing S3 and S4 in "base" (in quotes because S4 is
provided by the methods package), or do we see (or even wish?) for S7 to
supplant both S3 and S4 eventually within base R?

My own personal experience, I usually use S4 - why, because it's there, and
also, some of my favorite packages (sp and Matrix) use it, and I like my
code to look like the source code for the language. To that end, when I'm
training up engineers or data scientists to use OOP in R, I have them look
at source code-- but then also have to be choosy about source code for what
lest they become confused by the differences between S3 and S4 (not to
mention R6, RC, and whatever else might be out there).

R is the only language I know of that has multiple different object
oriented systems, and that makes it a big barrier to entry for people
learning the language, and I think the language as a whole would benefit
greatly from having a single standard.

-Ezra

On Sat, Feb 18, 2023 at 12:38?PM Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:

> On 18/02/2023 9:51 a.m., Duncan Murdoch wrote:
> > One more comment:
> >
> > The utils::setBreakpoint() function should be updated to be able to set
> > breakpoints in S7 methods, or a substitute function should be added to
> > the S7 package.
> >
> > RStudio 2022.12.0+353 (not sure if that's the latest) also needs to be
> > taught how to do that, since it doesn't seem to use setBreakpoint.
>
> I took a look at updating setBreakpoint().  I can get findLineNum() to
> work, but setBreakpoint() doesn't work because trace() doesn't work.
> debug() doesn't work either:  it looks as though it is trying to treat
> an S7 method as an S4 method.
>
> Will the already proposed changes help with debugging, or is that a
> completely separate issue?
>
> Duncan Murdoch
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From po@@enr|ede @end|ng |rom gm@||@com  Mon Mar 13 17:31:19 2023
From: po@@enr|ede @end|ng |rom gm@||@com (Daniel Possenriede)
Date: Mon, 13 Mar 2023 17:31:19 +0100
Subject: [Rd] Versioning Rtools ARP entries
Message-ID: <CANu2KkPeXi3=0=KyvjfELrE1A_aRO1yrbqmRPavKo-3siJZ_og@mail.gmail.com>

Hi,

If I am not mistaken, all Rtools 4.2 (and 4.3) revisions have the same
ARP [1] entries, i.e. all report version 4.2.0.1 (or 4.3.0.1). This
makes it difficult to determine the installed version (is it possible
to determine the installed revision?) and impossible for tools like
winget [2] to update Rtools to the latest revision, AFAICT.

Would it be possible to track the version in the installer [3] for
future Rtools releases again, like it used to be in Rtools 4.0 [4]?

Thanks!

Daniel

[1] https://github.com/microsoft/winget-pkgs/blob/master/FAQ.md#what-is-an-arp-entry
[2] https://github.com/microsoft/winget-cli
[3] https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/rtools/rtools64.iss
[4] https://github.com/r-windows/rtools-installer/commit/7f23f0d0442d72922014ec4082c8bdd437364cef


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Mon Mar 13 17:57:45 2023
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Mon, 13 Mar 2023 17:57:45 +0100
Subject: [Rd] Versioning Rtools ARP entries
In-Reply-To: <CANu2KkPeXi3=0=KyvjfELrE1A_aRO1yrbqmRPavKo-3siJZ_og@mail.gmail.com>
References: <CANu2KkPeXi3=0=KyvjfELrE1A_aRO1yrbqmRPavKo-3siJZ_og@mail.gmail.com>
Message-ID: <d45cbe35-c093-ff9e-f31d-48f3144f7568@gmail.com>


On 3/13/23 17:31, Daniel Possenriede wrote:
> Hi,
>
> If I am not mistaken, all Rtools 4.2 (and 4.3) revisions have the same
> ARP [1] entries, i.e. all report version 4.2.0.1 (or 4.3.0.1). This
> makes it difficult to determine the installed version (is it possible
> to determine the installed revision?) and impossible for tools like
> winget [2] to update Rtools to the latest revision, AFAICT.
>
> Would it be possible to track the version in the installer [3] for
> future Rtools releases again, like it used to be in Rtools 4.0 [4]?

Well the thing is that once you install Rtools 42/43, you can then 
upgrade it internally (without Windows knowing). You can upgrade the 
Msys2 part, or the MXE part, or both. The MXE part (customized for 
Rtools) does have a single version number, which can be found in the 
installation. The Msys2 part doesn't, afaik.

See e.g. "Upgrading Rtools43" in 
https://cran.r-project.org/bin/windows/base/howto-R-devel.html for how 
to upgrade and how to find out the current version number of the MXE part.

So, right, I could e.g. add a non-decreasing unique version to the build 
of the installer (e.g. based on that from the SVN where it lives and the 
MXE part version originally included), but I doubt how useful that would 
be, given that a particular installation can be upgraded/modified by the 
user. It could actually be misleading.

Note Rtools40 also could be updated by the user internally.

Tomas

>
> Thanks!
>
> Daniel
>
> [1] https://github.com/microsoft/winget-pkgs/blob/master/FAQ.md#what-is-an-arp-entry
> [2] https://github.com/microsoft/winget-cli
> [3] https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/rtools/rtools64.iss
> [4] https://github.com/r-windows/rtools-installer/commit/7f23f0d0442d72922014ec4082c8bdd437364cef
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @uh@rto_@nggono @end|ng |rom y@hoo@com  Mon Mar 13 19:42:06 2023
From: @uh@rto_@nggono @end|ng |rom y@hoo@com (Suharto Anggono Suharto Anggono)
Date: Mon, 13 Mar 2023 18:42:06 +0000 (UTC)
Subject: [Rd] scan(..., skip=1e11): infinite loop; cannot interrupt
References: <1949927453.3306156.1678732926720.ref@mail.yahoo.com>
Message-ID: <1949927453.3306156.1678732926720@mail.yahoo.com>


With

?if?(!j--)?{
?????R_CheckUserInterrupt();
?????j?=?10000;
?}

as?in?current?R?devel?(r83976),?j goes negative (-1) and interrupt is checked every 10001 instead of 10000. I?prefer

?if?(!--j)?{
?????R_CheckUserInterrupt();
?????j?=?10000;
?}

.


In?current?R?devel?(r83976),?if?EOF?is?reached,?the?outer?loop?keeps?going,?i?keeps?incrementing?until?nskip.

The?outer?loop?could?be?made?to?also?stop?on?EOF.

Alternatively,?not?using?nested?loop?is?possible,?like?the?following.

?if?(nskip)?for?(R_xlen_t?i?=?0,?j?=?10000;?;?)?{?/*?MBCS-safe?*/
?c?=?scanchar(FALSE,?&data);
?if?(!j--)?{
?????R_CheckUserInterrupt();
?????j?=?10000;
?}
?if?((c?==?'\n'?&&?++i?==?nskip)?||?c?==?R_EOF)
?????break;
?}


-----------
On?2/11/23?09:33,?Ivan?Krylov?wrote:
>?On?Fri,?10?Feb?2023?23:38:55?-0600
>?Spencer?Graves?<spencer.graves?using?prodsyse.com>?wrote:
>
>>?I?have?a?4.54?GB?file?that?I'm?trying?to?read?in?chunks?using
>>?"scan(...,?skip=__)".??It?works?as?expected?for?small?values?of
>>?"skip"?but?goes?into?an?infinite?loop?for?"skip=1e11"?and?similar
>>?large?values?of?skip:??I?cannot?even?interrupt?it;??I?must?kill?R.
>?Skipping?lines?is?done?by?two?nested?loops.?The?outer?loop?counts?the
>?lines?to?skip;?the?inner?loop?reads?characters?until?it?encounters?a
>?newline?or?end?of?file.?The?outer?loop?doesn't?check?for?EOF?and?keeps
>?asking?for?more?characters?until?the?inner?loop?runs?at?least?once?for
>?every?line?it?wants?to?skip.?The?following?patch?should?avoid?the
>?wait?in?such?cases:
>
>?---?src/main/scan.c?(revision?83797)
>?+++?src/main/scan.c?(working?copy)
>?@@?-835,7?+835,7?@@
>???attribute_hidden?SEXP?do_scan(SEXP?call,?SEXP?op,?SEXP?args,?SEXP?rho)
>???{
>???????SEXP?ans,?file,?sep,?what,?stripwhite,?dec,?quotes,?comstr;
>?-????int?c,?flush,?fill,?blskip,?multiline,?escapes,?skipNul;
>?+????int?c?=?0,?flush,?fill,?blskip,?multiline,?escapes,?skipNul;
>???????R_xlen_t?nmax,?nlines,?nskip;
>???????const?char?*p,?*encoding;
>???????RCNTXT?cntxt;
>?@@?-952,7?+952,7?@@
>????????if(!data.con->canread)
>????error(_("cannot?read?from?this?connection"));
>????}
>?-?for?(R_xlen_t?i?=?0;?i?<?nskip;?i++)?/*?MBCS-safe?*/
>?+?for?(R_xlen_t?i?=?0;?i?<?nskip?&&?c?!=?R_EOF;?i++)?/*?MBCS-safe?*/
>????????while?((c?=?scanchar(FALSE,?&data))?!=?'\n'?&&?c?!=?R_EOF);
>???????}
>
>
>?Making?it?interruptible?is?a?bit?more?work:?we?need?to?ensure?that?a
>?valid?context?is?set?up?and?check?regularly?for?an?interrupt.
>
>?---?src/main/scan.c?(revision?83797)
>?+++?src/main/scan.c?(working?copy)
>?@@?-835,7?+835,7?@@
>???attribute_hidden?SEXP?do_scan(SEXP?call,?SEXP?op,?SEXP?args,?SEXP?rho)
>???{
>???????SEXP?ans,?file,?sep,?what,?stripwhite,?dec,?quotes,?comstr;
>?-????int?c,?flush,?fill,?blskip,?multiline,?escapes,?skipNul;
>?+????int?c?=?0,?flush,?fill,?blskip,?multiline,?escapes,?skipNul;
>???????R_xlen_t?nmax,?nlines,?nskip;
>???????const?char?*p,?*encoding;
>???????RCNTXT?cntxt;
>?@@?-952,8?+952,6?@@
>????????if(!data.con->canread)
>????error(_("cannot?read?from?this?connection"));
>????}
>?-?for?(R_xlen_t?i?=?0;?i?<?nskip;?i++)?/*?MBCS-safe?*/
>?-?????while?((c?=?scanchar(FALSE,?&data))?!=?'\n'?&&?c?!=?R_EOF);
>???????}
>
>???????ans?=?R_NilValue;?/*?-Wall?*/
>?@@?-966,6?+964,10?@@
>???????cntxt.cend?=?&scan_cleanup;
>???????cntxt.cenddata?=?&data;
>
>?+????if?(ii)?for?(R_xlen_t?i?=?0,?j?=?0;?i?<?nskip?&&?c?!=?R_EOF;?i++)?/*?MBCS-safe?*/
>?+?while?((c?=?scanchar(FALSE,?&data))?!=?'\n'?&&?c?!=?R_EOF)
>?+?????if?(j++?%?10000?==?9999)?R_CheckUserInterrupt();
>?+
>???????switch?(TYPEOF(what))?{
>???????case?LGLSXP:
>???????case?INTSXP:
>
>?This?way,?even?if?you?pour?a?Decanter?of?Endless?Lines?(e.g.?mkfifo
>?LINES;?perl?-E'print?"A"x42?while?1;'?>?LINES)?into?scan(),?it?can
>?still?be?interrupted,?even?if?neither?newline?nor?EOF?ever?arrives.

Thanks,?I've?updated?the?implementation?of?scan()?in?R-devel?to?be
interruptible?while?skipping?lines.

I've?done?it?slightly?differently?as?I?found?there?already?was?a?memory
leak,?which?could?be?fixed?by?creating?the?context?a?bit?earlier.

I've?also?avoided?modulo?on?the?fast?path?as?I?saw?13%?performance
overhead?on?my?mailbox?file.?Decrementing?and?checking?against?zero
didn't?have?measurable?overhead.

Best
Tomas

[snip]


From dmedr| @end|ng |rom gm@||@com  Tue Mar 14 09:35:41 2023
From: dmedr| @end|ng |rom gm@||@com (Daniele Medri)
Date: Tue, 14 Mar 2023 09:35:41 +0100
Subject: [Rd] Adding support for S7 to base R
In-Reply-To: <CAEToJBHfJ2VqdQUk7UgQ8zoCY-nCGrTT6S-GbkyvNcQhkwOD0Q@mail.gmail.com>
References: <CALWM=9b2izXXmLOQQOf4Ssg+11E5fdy5DfM4P2NqCPeBpLGSwg@mail.gmail.com>
 <9fea1857-e3fe-e0c4-5d31-702c482f320c@gmail.com>
 <CAEToJBHfJ2VqdQUk7UgQ8zoCY-nCGrTT6S-GbkyvNcQhkwOD0Q@mail.gmail.com>
Message-ID: <7496854.EvYhyI6sBW@mac>

In data luned? 13 marzo 2023 16:53:56 CET, Ezra Tucker ha scritto:
> R is the only language I know of that has multiple different object
> oriented systems, and that makes it a big barrier to entry for people
> learning the language, and I think the language as a whole would benefit
> greatly from having a single standard.

R is more than just a "language," it is well known. It is an environment, an ecosystem of 
packages, many standards and much code written for decades in different programming 
languages that can survive and run under a common roof.

IMHO the question should not be about which versions/systems of R oo to use, but how 
they integrate with each other, what is the cost of an overall upgrade, whether all this is 
really necessary. More than pragmatism, a moral suasion.

hth

-- 
Daniele Medri

	[[alternative HTML version deleted]]


From r|p|ey @end|ng |rom @t@t@@ox@@c@uk  Tue Mar 14 10:56:01 2023
From: r|p|ey @end|ng |rom @t@t@@ox@@c@uk (Prof Brian Ripley)
Date: Tue, 14 Mar 2023 09:56:01 +0000
Subject: [Rd] CRAN package eaf
In-Reply-To: <e1b8a543-6ba1-23de-c6b0-c617f213f0cb@manchester.ac.uk>
References: <E1pXPqZ-0025rO-2m@gannet.stats.ox.ac.uk>
 <e1b8a543-6ba1-23de-c6b0-c617f213f0cb@manchester.ac.uk>
Message-ID: <6f32c746-3f8a-722d-299c-8349ef4ad30d@stats.ox.ac.uk>

On 01/03/2023 18:33, Manuel L?pez-Ib??ez wrote:
> Dear CRAN Team,
> 
> I believe those are false positives. All pointers are updated after 
> realloc. I have verified that this is the case not only at this point 
> but also at every realloc call.
> 
> It may be this compiler bug: 
> https://gcc.gnu.org/bugzilla/show_bug.cgi?id=104215
> 
> I believe this warning may eventually get moved out of -Wall because it 
> has become too noisy in GCC 12: 
> https://gcc.gnu.org/bugzilla/show_bug.cgi?id=Wuse-after-free

Are you aware that eaf still gives a warning with the latest gcc 13 
snapshot?  There are 3 CRAN packages which no longer warn with gcc 13, 
but yours is not one of them.  And none that warn with gcc 13 but not 
gcc 12.

gcc 13 is in final bug-fixing and was expected to be released by now.

We don't have time to study maintainers' C++ code so have to let this 
pass without accepting that it is the compiler and not your fault.  We 
would like you to file a bug report specifically about your code and get 
agreement from the GCC developers that this is their bug.

> 
> Best wishes,
> 
> Manuel.
> 
> 
> 
> 
> 
> On 01/03/2023 17:02, Prof Brian Ripley wrote:
>> Dear maintainer,
>>
>> Please see the problems shown on
>> <https://cran.r-project.org/web/checks/check_results_eaf.html>.
>>
>> Please correct before 2023-03-15 to safely retain your package on CRAN.
>>
>> The CRAN Team

-- 
Brian D. Ripley,                  ripley at stats.ox.ac.uk
Emeritus Professor of Applied Statistics, University of Oxford


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Tue Mar 14 17:29:47 2023
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Tue, 14 Mar 2023 17:29:47 +0100
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
Message-ID: <25616.41211.939172.585741@stat.math.ethz.ch>

>>>>> Sebastian Martin Krantz 
>>>>>     on Sat, 11 Mar 2023 11:04:54 +0200 writes:

[............]

    > But maybe this has already been discussed here and already
    > decided against.  In that case, a way to browse R-devel
    > archives to find out would be nice.

    > Best regards,
    > Sebastian

    ....

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel

As every mailing list message contains a footer like this,
and if you know about 'site:' in Google or say, https://duckduckgo.com/
you can use search terms such as

     site:stat.ethz.ch '[R-devel]' "Multiple Assignment"
or   site:stat.ethz.ch/pipermail '[R-devel]' "Multiple Assignment"
or   site:stat.ethz.ch/pipermail/r-devel  'Multiple Assignment'

giving results (but for me, currently,
much much better ones  on duckduckgo.com than Google.com).
"Search" from the sidebar of www.r-project.org
is https://www.r-project.org/search.html

which mentions 
- https://search.r-project.org/  
- Rseek

where Rseek is very widely searching, and (the R foundation's)
 search.r-project.org  is mainly searching on CRAN

and both give interesting hits on  'multiple assignment'

Martin


From murdoch@dunc@n @end|ng |rom gm@||@com  Tue Mar 14 23:57:38 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Tue, 14 Mar 2023 18:57:38 -0400
Subject: [Rd] Multiple Assignment built into the R Interpreter?
In-Reply-To: <db71f2b8-d7ef-aad5-0369-79bc21fe4213@gmail.com>
References: <CAOsNuxBZX87P3-CSv7aX9ZzV_0TDDmX_rwz5RVg2Jv1a1Df9EA@mail.gmail.com>
 <015b3842-3ef4-7395-402c-6469295685d4@gmail.com>
 <CAOsNuxDVT9OSLBJfmjFDZAeu7pDbiNzm3yEw4ChcEQMfrya_Ww@mail.gmail.com>
 <aa8acb6b-06ae-d143-d09a-0672d9d5bbbc@gmail.com>
 <20230311195708.794032e8@Tarkus>
 <8faf3d49-7fdd-4396-33ac-454e5ec0d3be@gmail.com>
 <CAOsNuxCrkRpFeArm6VcS16_g0o3U0jHLN6dVtr2UMGJuW-cDXw@mail.gmail.com>
 <24d79a98-af75-27ef-91af-9734ee90e9b2@gmail.com>
 <CAJXgQP2AJPt2V4O4b1_VC=gmyEH2NG1S=dqzro3nNwRGUrmViQ@mail.gmail.com>
 <CAOsNuxBWFN7WsHy4N7YhN5tuGF-wfg8+4A_4jXHe+fjyUBtWCA@mail.gmail.com>
 <CAOsNuxCLE9j1XiGwRevcAHu_EHYXaA=aBSREbb3SDUXWMiNHyg@mail.gmail.com>
 <05b0cf79-d768-7e6e-6dcf-502a14fcef84@gmail.com>
 <CAOsNuxBtYEe9FkMK3QA8PKzar_JX2cVsO1bLNXoZb0GkBPjPQQ@mail.gmail.com>
 <7aedf95ecb2a98531140764db3035449c7bd1147.camel@unsw.edu.au>
 <db71f2b8-d7ef-aad5-0369-79bc21fe4213@gmail.com>
Message-ID: <525d8561-e12a-853a-e184-449a8d2fbeb4@gmail.com>

On 13/03/2023 6:01 a.m., Duncan Murdoch wrote:
> Yes, this is really a problem with the checks, not with the language.
> 
> A simpler approach than your alternativeAssignment function would be
> simply to allow globalVariables() to be limited to a single function as
> the note in its help page says.

I just took a look, and this would be quite easy to do.  It would 
require changes to codetools and to utils, but probably just a few dozen 
lines.

Duncan Murdoch

> 
> This might be tedious to write by hand, but could be automated using
> methods like "dotify" in dotty.
> 
> Duncan Murdoch
> 
> 
> On 12/03/2023 10:36 p.m., Pavel Krivitsky wrote:
>> Dear All,
>>
>> As a maintainer of large, complex packages, I can think of many places
>> in which deconstructing assignment would simplify the code, as well as
>> facilitate readability by breaking up larger functions into helpers, so
>> I would be very glad to see this incorporated somehow.
>>
>> I think the crux of the matter is that while there is a number of ways
>> to implement deconstructing assignment within R, there is no mechanism
>> to tell R CMD check about it without also suppressing checks for every
>> other instance of that variable name. This is particularly problematic
>> because those variable names are likely to be used elsewhere in the
>> package.
>>
>> Workarounds that have been suggested all defeat the conciseness and
>> clarity of the deconstructing assignment and introduce potential for
>> subtle bugs.
>>
>> The check warnings are something that can only be addressed in
>> 'codetools', with a finer API than what utils::globalVariables()
>> provides.?Perhaps this would have a lower hurdle than modifying R
>> language itself?
>>
>>   From skimming through the relevant 'codetools' code, one idea for such
>> an API would be a function, along the lines of
>>
>> utils::alternativeAssignment(op, assigned)
>>
>> that sets up a callback assigned = function(op, e) that given the
>> operator (as string) and the expression it's embedded in, returns a
>> list of three elements:
>>    * a character vector containing a list of variables assigned to that
>>      might not otherwise be detected
>>    * a character vector containing a list of variables referenced that
>>      might not otherwise be detected
>>    * expression e with potentially "offending" elements removed, which
>>      will then be processed by the rest of the checking code
>>
>> Then, say, 'zeallot' could implement zeallot::zeallot_assign_detect(),
>> and a package developer using it could put
>>
>> utils::alternativeAssignment("%<-%", zeallot::zeallot_assign_detect)
>>
>> in their .onLoad() function. Similarly, users of 'dotty' could set up
>> callbacks for all standard assignment operators to inform the code
>> about the nonstandard assignment.
>>
>> Best Regards,Pavel
>>
>> On Sun, 2023-03-12 at 14:05 +0200, Sebastian Martin Krantz wrote:
>>> Kevins package is very nice as a proof of concept, no doubt about
>>> that, but
>>> it is not at the level of performance or convenience that a native R
>>> implementation would offer. I would probably not use it to translate
>>> matlab
>>> routines into R packages placed on CRAN, because it?s an additional
>>> dependency, I have a performance burden in every iteration, and
>>> utils::globalVariables() is everything but elegant. From that
>>> perspective
>>> it would be more convenient for me right now to stick with
>>> collapse::%=%,
>>> which is already written in C, and also call
>>> utils::globalVariables().
>>>
>>> But again my hope in starting this was that R Core might see that the
>>> addition of multiple assignment would be a significant enhancement to
>>> the
>>> language, of the same order as the base pipe |> in my opinion.
>>>
>>> I think the discussion so far has at least brought forth a way to
>>> implement
>>> this in a way that does not violate fundamental principles of the
>>> language.
>>> Which could form a basis for thinking about an actual addition to the
>>> language.
>>>
>>> Best regards,
>>>
>>> Sebastian
>>>
>>>
>>> On Sun 12. Mar 2023 at 13:18, Duncan Murdoch
>>> <murdoch.duncan at gmail.com>
>>> wrote:
>>>
>>>> On 12/03/2023 6:07 a.m., Sebastian Martin Krantz wrote:
>>>>> Thinking more about this, and seeing Kevins examples at
>>>>> https://github.com/kevinushey/dotty
>>>>> <https://github.com/kevinushey/dotty>, I think this is the most
>>>>> R-like
>>>>> way of doing it,
>>>>> with an additional benefit as it would allow to introduce the
>>>>> useful
>>>>> data.table semantics DT[, .(a = b, c, d)] to more general R. So I
>>>>> would
>>>>> propose to
>>>>> introduce a new primitive function . <- function(...)
>>>>> .Primitive(".") in
>>>>> R with an assignment method and the following features:
>>>>
>>>> I think that proposal is very unlikely to be accepted.? If it was a
>>>> primitive function, it could only be maintained by R Core.? They
>>>> are
>>>> justifiably very reluctant to take on extra work for themselves.
>>>>
>>>> Kevin's package demonstrates that this can be done entirely in a
>>>> contributed package, which means there's no need for R Core to be
>>>> involved.? I don't know if he has plans to turn his prototype into
>>>> a
>>>> CRAN package.? If he doesn't, then it will be up to some other
>>>> interested maintainer to step up and take on the task, or it will
>>>> just
>>>> fade away.
>>>>
>>>> I haven't checked whether your proposals below represent changes
>>>> from
>>>> the current version of dotty, but if they do, the way to proceed is
>>>> to
>>>> fork that project, implement your changes, and offer to contribute
>>>> them
>>>> back to the main branch.
>>>>
>>>> Duncan Murdoch
>>>>
>>>>
>>>>
>>>>>
>>>>>   ? * Positional assignment e.g. .[nr, nc] <- dim(x), and named
>>>>> assignment
>>>>>   ??? e.g. .[new = carb] <- mtcars or .[new = log(carb)] <- mtcars.
>>>>> All
>>>>>   ??? the functionality proposed by Kevin at
>>>>>   ??? https://github.com/kevinushey/dotty
>>>>>   ??? <https://github.com/kevinushey/dotty> is useful, unambiguous
>>>>> and
>>>>>   ??? feasible.
>>>>>   ? * Silent dropping of RHS values e.g. .[mpg_new, cyl_new] <-
>>>>> mtcars.
>>>>>   ? * Mixing of positional and named assignment e.g .[mpg_new,
>>>>> carb_new =
>>>>>   ??? carb, cyl_new] <- mtcars. The inputs not assigned by name are
>>>>> simply
>>>>>   ??? the elements of RHS in the order they occur, regardless of
>>>>> whether
>>>>>   ??? they have been used previously e.g. .[mpg_new, cyl_new = cyl,
>>>>>   ??? log_cyl = log(cyl), cyl_new2] <- mtcars is feasible. RHS here
>>>>> could
>>>>>   ??? be any named vector type.
>>>>>   ? * Conventional use of the function as lazy version of of
>>>>> list(), as in
>>>>>   ??? data.table: .(A = B, C, D) is the same as list(A = B, C = C,
>>>>> D = D).
>>>>>   ??? This would also be useful, allowing more parsimonious code,
>>>>> and
>>>>>   ??? avoid the need to assign names to all return values in a
>>>>> function
>>>>>   ??? return, e.g. if I already have matrices A, C, Q and R as
>>>>> internal
>>>>>   ??? objects in my function, I can simply end by return(.(A, C, Q,
>>>>> R))
>>>>>   ??? instead of return(list(A = A, C = C, Q = Q, R = R)) if I
>>>>> wanted the
>>>>>   ??? list to be named with the object names.
>>>>>
>>>>> The implementation of this in R and C should be pretty
>>>>> straightforward.
>>>>> It would just require a modification to R CMD Check to recognize
>>>>> .[<- as
>>>>> assignment.
>>>>>
>>>>> Best regards,
>>>>>
>>>>> Sebastian
>>>>> -
>>>>> 2.)
>>>>>
>>>>> On Sun, 12 Mar 2023 at 09:42, Sebastian Martin Krantz
>>>>> <sebastian.krantz at graduateinstitute.ch
>>>>> <mailto:sebastian.krantz at graduateinstitute.ch>> wrote:
>>>>>
>>>>>   ??? Thanks Gabriel and Kevin for your inputs,
>>>>>
>>>>>   ??? regarding your points Gabriel, I think Python and Julia do
>>>>> allow
>>>>>   ??? multiple sub-assignment, but in-line with my earlier
>>>>> suggestion in
>>>>>   ??? response to Duncan to make multiple assignment an
>>>>> environment-level
>>>>>   ??? operation (like collapse::%=% currently works),? this would
>>>>> not be
>>>>>   ??? possible in R.
>>>>>
>>>>>   ??? Regarding the [a] <- coolest_function() syntax, yeah it would
>>>>> mean
>>>>>   ??? do multiple assignment and set a equal to the first element
>>>>> dropping
>>>>>   ??? all other elements. Multiple assignment should be positional
>>>>> loke in
>>>>>   ??? other languages, enabling flexible renaming of objects on the
>>>>> fly.
>>>>>   ??? So it should be irrelevant whether the function returns a
>>>>> named or
>>>>>   ??? unnamed list or vector.
>>>>>
>>>>>   ??? Thanks also Kevin for this contribution. I think it?s a
>>>>> remarkable
>>>>>   ??? effort, and I wouldn?t mind such semantics e.g. making it a
>>>>> function
>>>>>   ??? call to ?.[? or any other one-letter function, as long as
>>>>> it?s coded
>>>>>   ??? in C and recognized by the interpreter as an assignment
>>>>> operation.
>>>>>
>>>>>   ??? Best regards,
>>>>>
>>>>>   ??? Sebastian
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>   ??? On Sun 12. Mar 2023 at 01:00, Kevin Ushey
>>>>> <kevinushey at gmail.com
>>>>>   ??? <mailto:kevinushey at gmail.com>> wrote:
>>>>>
>>>>>   ??????? FWIW, it's possible to get fairly close to your proposed
>>>> semantics
>>>>>   ??????? using the existing metaprogramming facilities in R. I put
>>>> together a
>>>>>   ??????? prototype package here to demonstrate:
>>>>>
>>>>>   ??????? https://github.com/kevinushey/dotty
>>>>>   ??????? <https://github.com/kevinushey/dotty>
>>>>>
>>>>>   ??????? The package exports an object called `.`, with a special
>>>>>   ??????? `[<-.dot` S3
>>>>>   ??????? method which enables destructuring assignments. This
>>>>> means you
>>>> can
>>>>>   ??????? write code like:
>>>>>
>>>>>   ???????????? .[nr, nc] <- dim(mtcars)
>>>>>
>>>>>   ??????? and that will define 'nr' and 'nc' as you expect.
>>>>>
>>>>>   ??????? As for R CMD check warnings, you can suppress those
>>>>> through the
>>>>>   ??????? use of
>>>>>   ??????? globalVariables(), and that can also be automated within
>>>>> the
>>>>>   ??????? package.
>>>>>   ??????? The 'dotty' package includes a function 'dotify()' which
>>>> automates
>>>>>   ??????? looking for such usages in your package, and calling
>>>>>   ??????? globalVariables()
>>>>>   ??????? so that R CMD check doesn't warn. In theory, a similar
>>>>> technique
>>>>>   ??????? would
>>>>>   ??????? be applicable to other packages defining similar
>>>>> operators
>>>> (zeallot,
>>>>>   ??????? collapse).
>>>>>
>>>>>   ??????? Obviously, globalVariables() is a very heavy hammer to
>>>>> swing for
>>>>>   ??????? this
>>>>>   ??????? issue, but you might consider the benefits worth the
>>>>> tradeoffs.
>>>>>
>>>>>   ??????? Best,
>>>>>   ??????? Kevin
>>>>>
>>>>>   ??????? On Sat, Mar 11, 2023 at 2:53?PM Duncan Murdoch
>>>>>          
>>>>> <murdoch.duncan at gmail.com?<mailto:murdoch.duncan at gmail.com>>
>>>> wrote:
>>>>>   ???????? >
>>>>>   ???????? > On 11/03/2023 4:42 p.m., Sebastian Martin Krantz
>>>>> wrote:
>>>>>   ???????? > > Thanks Duncan and Ivan for the careful thoughts. I'm
>>>>> not
>>>>>   ??????? sure I can
>>>>>   ???????? > > follow all aspects you raised, but to give my
>>>>> limited take
>>>>>   ??????? on a few:
>>>>>   ???????? > >
>>>>>   ???????? > >> your proposal violates a very basic property of the
>>>>>   ??????? language, i.e. that all statements are expressions and
>>>>> have a
>>>>>   ??????? value.? > What's the value of 1 + (A, C =
>>>>> init_matrices()).
>>>>>   ???????? > >
>>>>>   ???????? > > I'm not sure I see the point here. I evaluated 1 +
>>>>> (d =
>>>>>   ??????? dim(mtcars); nr
>>>>>   ???????? > > = d[1]; nc = d[2]; rm(d)), which simply gives a
>>>>> syntax
>>>> error,
>>>>>   ???????? >
>>>>>   ???????? >
>>>>>   ???????? >??? d = dim(mtcars); nr = d[1]; nc = d[2]; rm(d)
>>>>>   ???????? >
>>>>>   ???????? > is not a statement, it is a sequence of 4 statements.
>>>>>   ???????? >
>>>>>   ???????? > Duncan Murdoch
>>>>>   ???????? >
>>>>>   ???????? >?? as the
>>>>>   ???????? > > above expression should. `%=%` assigns to
>>>>>   ???????? > > environments, so 1 + (c("A", "C") %=%
>>>>> init_matrices())
>>>> returns
>>>>>   ???????? > > numeric(0), with A and C having their values
>>>>> assigned.
>>>>>   ???????? > >
>>>>>   ???????? > >> suppose f() returns list(A = 1, B = 2) and I do? >
>>>>> B, A <-
>>>>>   ??????? f() > Should assignment be by position or by name?
>>>>>   ???????? > >
>>>>>   ???????? > > In other languages this is by position. The feature
>>>>> is not
>>>>>   ??????? meant to
>>>>>   ???????? > > replace list2env(), and being able to rename objects
>>>>> in the
>>>>>   ??????? assignment
>>>>>   ???????? > > is a vital feature of codes
>>>>>   ???????? > > using multi input and output functions e.g. in
>>>>> Matlab or
>>>> Julia.
>>>>>   ???????? > >
>>>>>   ???????? > >> Honestly, given that this is simply syntactic
>>>>> sugar, I
>>>>>   ??????? don't think I would support it.
>>>>>   ???????? > >
>>>>>   ???????? > > You can call it that, but it would be used by almost
>>>>> every
>>>>>   ??????? R user almost
>>>>>   ???????? > > every day. Simple things like nr, nc = dim(x);
>>>>> values,
>>>>>   ??????? vectors =
>>>>>   ???????? > > eigen(x) etc. where the creation of intermediate
>>>>> objects
>>>>>   ???????? > > is cumbersome and redundant.
>>>>>   ???????? > >
>>>>>   ???????? > >> I see you've already mentioned it ("JavaScript-
>>>>> like"). I
>>>>>   ??????? think it would? fulfil Sebastian's requirements too, as
>>>>> long as
>>>>>   ??????? it is considered "true assignment" by the rest of the
>>>>> language.
>>>>>   ???????? > >
>>>>>   ???????? > > I don't have strong opinions about how the issue is
>>>>> phrased
>>>> or
>>>>>   ???????? > > implemented. Something like [t, n] = dim(x) might
>>>>> even be
>>>>>   ??????? more clear.
>>>>>   ???????? > > It's important though that assignment remains by
>>>>> position,
>>>>>   ???????? > > so even if some output gets thrown away that should
>>>>> also be
>>>>>   ??????? positional.
>>>>>   ???????? > >
>>>>>   ???????? > >>? A <- 0? > [A, B = A + 10] <- list(1, A = 2)
>>>>>   ???????? > >
>>>>>   ???????? > > I also fail to see the use of allowing this.
>>>>> something like
>>>>>   ??????? this is an
>>>>>   ???????? > > error.
>>>>>   ???????? > >
>>>>>   ???????? > >> A = 2
>>>>>   ???????? > >> (B = A + 1) <- 1
>>>>>   ???????? > > Error in (B = A + 1) <- 1 : could not find function
>>>>> "(<-"
>>>>>   ???????? > >
>>>>>   ???????? > > Regarding the practical implementation, I think
>>>>>   ??????? `collapse::%=%` is a
>>>>>   ???????? > > good starting point. It could be introduced in R as
>>>>> a
>>>>>   ??????? separate function,
>>>>>   ???????? > > or `=` could be modified to accommodate its
>>>>> capability. It
>>>>>   ??????? should be
>>>>>   ???????? > > clear that
>>>>>   ???????? > > with more than one LHS variables the assignment is
>>>>> an
>>>>>   ??????? environment level
>>>>>   ???????? > > operation and the results can only be used in
>>>>> computations
>>>>>   ??????? once assigned
>>>>>   ???????? > > to the environment, e.g. as in 1 + (c("A", "C") %=%
>>>>>   ??????? init_matrices()),
>>>>>   ???????? > > A and C are not available for the addition in this
>>>>>   ??????? statement. The
>>>>>   ???????? > > interpretor then needs to be modified to read
>>>>> something
>>>>>   ??????? like nr, nc =
>>>>>   ???????? > > dim(x) or [nr, nc] = dim(x). as an environment-level
>>>>>   ??????? multiple assignment
>>>>>   ???????? > > operation with no
>>>>>   ???????? > > immediate value. Appears very feasible to my limited
>>>>>   ??????? understanding, but
>>>>>   ???????? > > I guess there are other things to consider still.
>>>>>   ??????? Definitely appreciate
>>>>>   ???????? > > the responses so far though.
>>>>>   ???????? > >
>>>>>   ???????? > > Best regards,
>>>>>   ???????? > >
>>>>>   ???????? > > Sebastian
>>>>>   ???????? > >
>>>>>   ???????? > >
>>>>>   ???????? > >
>>>>>   ???????? > >
>>>>>   ???????? > >
>>>>>   ???????? > > On Sat, 11 Mar 2023 at 20:38, Duncan Murdoch
>>>>>          
>>>>> <murdoch.duncan at gmail.com?<mailto:murdoch.duncan at gmail.com>
>>>>>   ???????? > > <mailto:murdoch.duncan at gmail.com
>>>>>   ??????? <mailto:murdoch.duncan at gmail.com>>> wrote:
>>>>>   ???????? > >
>>>>>   ???????? > >???? On 11/03/2023 11:57 a.m., Ivan Krylov wrote:
>>>>>   ???????? > >????? > On Sat, 11 Mar 2023 11:11:06 -0500
>>>>>   ???????? > >????? > Duncan Murdoch <murdoch.duncan at gmail.com
>>>>>   ??????? <mailto:murdoch.duncan at gmail.com>
>>>>>   ???????? > >???? <mailto:murdoch.duncan at gmail.com
>>>>>   ??????? <mailto:murdoch.duncan at gmail.com>>> wrote:
>>>>>   ???????? > >????? >
>>>>>   ???????? > >????? >> That's clear, but your proposal violates a
>>>>> very
>>>>>   ??????? basic property
>>>>>   ???????? > >???? of the
>>>>>   ???????? > >????? >> language, i.e. that all statements are
>>>>> expressions
>>>>>   ??????? and have a value.
>>>>>   ???????? > >????? >
>>>>>   ???????? > >????? > How about reframing this feature request from
>>>>>   ??????? multiple assignment
>>>>>   ???????? > >????? > (which does go contrary to "everything has
>>>>> only one
>>>>>   ??????? value, even
>>>>>   ???????? > >???? if it's
>>>>>   ???????? > >????? > sometimes invisible(NULL)") to "structured
>>>>> binding"
>>>>>   ??????? / "destructuring
>>>>>   ???????? > >????? > assignment" [*], which takes this single
>>>>> single
>>>>>   ??????? value returned by the
>>>>>   ???????? > >????? > expression and subsets it subject to certain
>>>>> rules?
>>>>>   ??????? It may be
>>>>>   ???????? > >???? easier to
>>>>>   ???????? > >????? > make a decision on the semantics for
>>>>> destructuring
>>>>>   ??????? assignment (e.g.
>>>>>   ???????? > >????? > languages which have this feature typically
>>>>> allow
>>>>>   ??????? throwing unneeded
>>>>>   ???????? > >????? > parts of the return value away), and it
>>>>> doesn't seem
>>>>>   ??????? to break as much
>>>>>   ???????? > >????? > of the rest of the language if implemented.
>>>>>   ???????? > >????? >
>>>>>   ???????? > >????? > I see you've already mentioned it
>>>>>   ??????? ("JavaScript-like"). I think it
>>>>>   ???????? > >???? would
>>>>>   ???????? > >????? > fulfil Sebastian's requirements too, as long
>>>>> as it
>>>>>   ??????? is considered
>>>>>   ???????? > >???? "true
>>>>>   ???????? > >????? > assignment" by the rest of the language.
>>>>>   ???????? > >????? >
>>>>>   ???????? > >????? > The hard part is to propose the actual
>>>>> grammar of
>>>>>   ??????? the new feature (in
>>>>>   ???????? > >????? > terms of src/main/gram.y, preferably without
>>>> introducing
>>>>>   ???????? > >???? conflicts) and
>>>>>   ???????? > >????? > its semantics (including the corner cases,
>>>>> some of
>>>>>   ??????? which you have
>>>>>   ???????? > >????? > already mentioned). I'm not sure I'm up to
>>>>> the task.
>>>>>   ???????? > >????? >
>>>>>   ???????? > >
>>>>>   ???????? > >???? If I were doing it, here's what I'd propose:
>>>>>   ???????? > >
>>>>>   ???????? > >???????? '[' formlist ']' LEFT_ASSIGN expr
>>>>>   ???????? > >???????? '[' formlist ']' EQ_ASSIGN expr
>>>>>   ???????? > >???????? expr RIGHT_ASSIGN? '[' formlist ']'
>>>>>   ???????? > >
>>>>>   ???????? > >???? where `formlist` has the syntax of the formals
>>>>> list for
>>>>>   ??????? a function
>>>>>   ???????? > >???? definition.? This would have the following
>>>>> semantics:
>>>>>   ???????? > >
>>>>>   ???????? > >????????? {
>>>>>   ???????? > >??????????? *tmp* <- expr
>>>>>   ???????? > >
>>>>>   ???????? > >??????????? # For arguments with no "default"
>>>>> expression,
>>>>>   ???????? > >
>>>>>   ???????? > >??????????? argname1 <- *tmp*[[1]]
>>>>>   ???????? > >??????????? argname2 <- *tmp*[[2]]
>>>>>   ???????? > >??????????? ...
>>>>>   ???????? > >
>>>>>   ???????? > >??????????? # For arguments with a default listed
>>>>>   ???????? > >
>>>>>   ???????? > >??????????? argname3 <- with(*tmp*, default3)
>>>>>   ???????? > >????????? }
>>>>>   ???????? > >
>>>>>   ???????? > >
>>>>>   ???????? > >???? The value of the whole thing would therefore be
>>>>>   ??????? (invisibly) the
>>>>>   ???????? > >???? value of
>>>>>   ???????? > >???? the last item in the assignment.
>>>>>   ???????? > >
>>>>>   ???????? > >???? Two examples:
>>>>>   ???????? > >
>>>>>   ???????? > >???????? [A, B, C] <- expr?? # assign the first three
>>>>>   ??????? elements of expr to A,
>>>>>   ???????? > >???? B, and C
>>>>>   ???????? > >
>>>>>   ???????? > >???????? [A, B, C = a + b] <- expr? # assign the
>>>>> first two
>>>>>   ??????? elements of expr
>>>>>   ???????? > >??????????????????????????????????? # to A and B,
>>>>>   ???????? > >??????????????????????????????????? # assign
>>>>> with(expr, a +
>>>>>   ??????? b) to C.
>>>>>   ???????? > >
>>>>>   ???????? > >???? Unfortunately, I don't think this could be done
>>>> entirely by
>>>>>   ???????? > >???? transforming
>>>>>   ???????? > >???? the expression (which is the way |> was done),
>>>>> and that
>>>>>   ??????? makes it a lot
>>>>>   ???????? > >???? harder to write and to reason about.? E.g. what
>>>>> does
>>>>>   ??????? this do?
>>>>>   ???????? > >
>>>>>   ???????? > >???????? A <- 0
>>>>>   ???????? > >???????? [A, B = A + 10] <- list(1, A = 2)
>>>>>   ???????? > >
>>>>>   ???????? > >???? According to the recipe above, I think it sets A
>>>>> to 1
>>>>>   ??????? and B to 12, but
>>>>>   ???????? > >???? maybe a user would expect B to be 10 or 11.? And
>>>>>   ??????? according to that
>>>>>   ???????? > >???? recipe this is an error:
>>>>>   ???????? > >
>>>>>   ???????? > >???????? [A, B = A + 10] <- c(1, A = 2)
>>>>>   ???????? > >
>>>>>   ???????? > >???? which probably isn't what a user would expect,
>>>>> given
>>>>>   ??????? that this is fine:
>>>>>   ???????? > >
>>>>>   ???????? > >???????? [A, B] <- c(1, 2)
>>>>>   ???????? > >
>>>>>   ???????? > >???? Duncan Murdoch
>>>>>   ???????? > >
>>>>>   ???????? >
>>>>>   ???????? > ______________________________________________
>>>>>   ???????? > R-devel at r-project.org?<mailto:R-devel at r-project.org>
>>>>> mailing
>>>> list
>>>>>   ???????? > https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>   ??????? <https://stat.ethz.ch/mailman/listinfo/r-devel>
>>>>>
>>>>
>>>>
>>>
>>>   ????????[[alternative HTML version deleted]]
>>>
>>> ______________________________________________
>>> R-devel at r-project.org?mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From pd@|gd @end|ng |rom gm@||@com  Wed Mar 15 11:06:11 2023
From: pd@|gd @end|ng |rom gm@||@com (peter dalgaard)
Date: Wed, 15 Mar 2023 11:06:11 +0100
Subject: [Rd] R 4.2.3 is released
Message-ID: <242BFA0D-71C0-4C6D-97AE-62F571774E4C@gmail.com>

The build system rolled up R-4.2.3.tar.gz (codename "Shortstop Beagle") this morning.

The list below details the changes in this release. 

You can get the source code from

https://cran.r-project.org/src/base/R-4/R-4.2.3.tar.gz

or wait for it to be mirrored at a CRAN site nearer to you.

Binaries for various platforms will appear in due course.


For the R Core Team,

Peter Dalgaard


These are the checksums (md5 and SHA-256) for the freshly created files, in case you wish
to check that they are uncorrupted:

MD5 (AUTHORS) = 320967884b547734d6279dedbc739dd4
MD5 (COPYING) = eb723b61539feef013de476e68b5c50a
MD5 (COPYING.LIB) = a6f89e2100d9b6cdffcea4f398e37343
MD5 (FAQ) = 3f5d6539d3c4878cbbb74dcbee74447f
MD5 (INSTALL) = 7893f754308ca31f1ccf62055090ad7b
MD5 (NEWS) = 4a300bf9bd24e704614f036452355d23
MD5 (NEWS.0) = bfcd7c147251b5474d96848c6f57e5a8
MD5 (NEWS.1) = 4108ab429e768e29b1c3b418c224246e
MD5 (NEWS.2) = b38d94569700664205a76a7de836ba83
MD5 (NEWS.3) = e55ed2c8a547b827b46e08eb7137ba23
MD5 (R-latest.tar.gz) = ebfc90b1552581f2b7c9a50f934e6bb0
MD5 (README) = f468f281c919665e276a1b691decbbe6
MD5 (RESOURCES) = a79b9b338cab09bd665f6b62ac6f455b
MD5 (THANKS) = 45b6d2e88a6ecb5b24fa33a781351cd5
MD5 (VERSION-INFO.dcf) = d08f0c8f65c2a021be36324081440dd9
MD5 (R-4/R-4.2.3.tar.gz) = ebfc90b1552581f2b7c9a50f934e6bb0

60a0d150e6fc1f424be76ad7b645d236b56e747692a4679f81ce6536c550e949  AUTHORS
e6d6a009505e345fe949e1310334fcb0747f28dae2856759de102ab66b722cb4  COPYING
6095e9ffa777dd22839f7801aa845b31c9ed07f3d6bf8a26dc5d2dec8ccc0ef3  COPYING.LIB
8c396b0db6b1b072e66ea78deab8c89f71150744420ad9f74de6505aacee9a80  FAQ
f87461be6cbaecc4dce44ac58e5bd52364b0491ccdadaf846cb9b452e9550f31  INSTALL
be3cd8a6d7220726d2cbdf1b929e6b75c09101214b1b006e29ce97dab4450553  NEWS
4e21b62f515b749f80997063fceab626d7258c7d650e81a662ba8e0640f12f62  NEWS.0
5de7657c5e58e481403c0dd1a74a5c090b3ef481ce75a91dfe05d4b03f63163f  NEWS.1
cde079b6beab7d700d3d4ecda494e2681ad3b7f8fab13b68be090f949393ec62  NEWS.2
1910a2405300b9bc7c76beeb0753a5249cf799afe175ce28f8d782fab723e012  NEWS.3
55e4a9a6d43be314e2c03d0266a6fa5444afdce50b303bfc3b82b3979516e074  R-latest.tar.gz
2fdd3e90f23f32692d4b3a0c0452f2c219a10882033d1774f8cadf25886c3ddc  README
8b7d3856100220f4555d4d57140829f2e81c27eccec5b441f5dce616e9ec9061  RESOURCES
8319c5415de58ee10d4bc058d79c370fd8e6b2ad09e25d7a1e04b74ca5f380a6  THANKS
4701c6802bf3f31e6f8ad66d47909eef0985f8af97b0a28fd391c68a7d3ffc18  VERSION-INFO.dcf
55e4a9a6d43be314e2c03d0266a6fa5444afdce50b303bfc3b82b3979516e074  R-4/R-4.2.3.tar.gz

This is the relevant part of the NEWS file

CHANGES IN R 4.2.3:

  C-LEVEL FACILITIES:

    * The definition of DL_FUNC in R_ext/Rdynload.h has been changed to
      be fully C-compliant.  This means that functions loaded _via_ for
      example R_GetCCallable need to be cast to an appropriate type if
      they have any arguments.

    * .Machine has a new element sizeof.time_t to identify old systems
      with a 32-bit type and hence a limited range of date-times (and
      limited support for dates millions of years from present).

  PACKAGE INSTALLATION:

    * (Windows) The default C++ standard had accidentally been left at
      C++11 when it was changed to C++14 on Unix.

  BUG FIXES:

    * As "POSIXlt" objects may be "partially filled" and their list
      components meant to be recycled, length() now is the length of
      the longest component.

    * as.POSIXlt.Date() could underflow for dates in the far past (more
      than half a million years BCE).

    * as.Date.POSIXlt(x) would return "1970-01-01" instead of NA in R
      4.2.2, e.g., for

              x <- as.POSIXlt(c("2019-01-30","2001-1-1"))
              x$mon <- c(0L, NA); as.Date(x)
      
    * R CMD check failed to apply enabled _R_CHECK_SUGGESTS_ONLY_ to
      examples and vignettes (regression in R 4.2.0).

    * R CMD check did not re-build vignettes in separate processes by
      default (regression in R 4.2.0).

    * Running examples from HTML documentation now restores previous
      knitr settings and options (PR#18420).

    * Quartz: fonts are now located using Core Graphics API instead of
      deprecated ATS which is no longer supported in the macOS 13 SDK
      (PR#18426).  This also addresses an issue where the currently
      used font in the Quartz device context was not correctly
      retained.

    * (Windows) Math symbols in text drawing functions are again
      rendered correctly (PR#18440).  This fixes a regression in R
      4.2.1 caused by a fix in PR#18382 which uncovered an issue in
      GraphApp due to which the symbol charset was not used with TT
      Symbol font face.

    * (Windows) Installing a package with a src/Makefile.{win,ucrt}
      file includes ~/.R/Makevars.win64 in the search for user
      makevars, as documented in "R Installation and Administration"
      and done for packages with a src/Makevars.{win,ucrt} file.

    * format(<POSIXlt_w/_unbalanced_sec>, "....%OS<n>") with n > 0 no
      longer accidentally uses the unbalanced seconds, thanks to
      Suharto Anggono's report (including patch) in PR#18448.

    * solve.default(a, b) works around issues with some versions of
      LAPACK when a contains NA or NaN values.

    * When UseMethod() cannot dispatch, it no longer segfaults
      producing the error message in case of a long class(), thanks to
      Joris Vankerschaver's report (including patch) in PR#18447.

    * When example(foo, ..) produces graphics on an interactive device
      it needs to open itself, it now leaves devAskNewPage() unchanged
      even when it was FALSE, thus fixing a 14 years old '<FIXME>'.

    * packageDescription() again catches errors from encoding
      conversions. This also fixes broken packageVersion() in C locale
      on systems where iconv does not support transliteration.

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From ||one| @end|ng |rom po@|t@co  Thu Mar 16 18:45:24 2023
From: ||one| @end|ng |rom po@|t@co (Lionel Henry)
Date: Thu, 16 Mar 2023 18:45:24 +0100
Subject: [Rd] Making headers self-contained for static analysis
Message-ID: <CAJf4E3o1ZndpVV=b+RaFXZq1tKGXa5+WOemD0s62WpwNJRi8wA@mail.gmail.com>

Hello,

I started using clangd to get better static analysis and code
refactoring tooling with the R sources (using eglot-mode in Emacs, it
just works once you've generated a `compile_commands.json` file with
`bear make all`). I noticed that the static analyser can't understand
several header files because these are not self-contained. So I went
through all .h files and inserted the missing includes, cf the
attached patch.

Making the headers self-contained has consequences for the .c or .cpp
files that include them. In the case of C files, the only downside I
see is that it might cause users to accidentally rely on indirect
inclusion of standard headers, instead of directly including the
header to make the dependency explicit as would be good practice.
This doesn't seem like a big deal compared to the benefits of enabling
static analysis.

However in the case of C++ that's more problematic. We don't want to
include the C headers because that would pollute the global namespace
and users might prefer to import the missing symbols (`size_t` and
`FILE`) selectively. Also that wouldn't help static analysis within
the header files since the analysers use the C path. So I have guarded
inclusion of standard C headers behing a `__cplusplus` check.

If that makes sense, would R core consider applying the attached patch
to the R sources?

Best,
Lionel

From ||one| @end|ng |rom po@|t@co  Thu Mar 16 18:49:55 2023
From: ||one| @end|ng |rom po@|t@co (Lionel Henry)
Date: Thu, 16 Mar 2023 18:49:55 +0100
Subject: [Rd] isNamespaceLoaded() while the namespace is loading
In-Reply-To: <CABtg=Kn8zaF+ebw8qd-PeG2DnzT6xa-r3tMct9raDLUPFz=X0A@mail.gmail.com>
References: <CABtg=Kn8zaF+ebw8qd-PeG2DnzT6xa-r3tMct9raDLUPFz=X0A@mail.gmail.com>
Message-ID: <CAJf4E3q4dJu5=jNTUBZcJQracbc_MaHrHUzc6rnLfoMSQS1HtA@mail.gmail.com>

Hello,

We've run into this issue multiple times and it's often a head
scratcher when it happens. We are using workarounds but it would be
great to fix this for R 4.3. Would an R core member have time to
review the patch that we supplied in
https://bugs.r-project.org/show_bug.cgi?id=18489 ?

Best,
Lionel


On 1/21/22, G?bor Cs?rdi <csardi.gabor at gmail.com> wrote:
> We ran into a bug in our package that seems to boil down to
> isNamespaceLoaded() returning TRUE for namespaces that R is currently
> loading.
>
> We had something like this in an .onLoad function:
>
> if (isNamespaceLoaded("upstream")) {
>   upstream::upstream_function()
> }
>
> Which seems OK, unless upstream (recursively) imports the package
> having this code. Should that happen, the loading of upstream triggers
> the loading of this package as well and isNamespaceLoaded() seems to
> return TRUE, even though the namespace of upstream is not fully loaded
> yet, and we get an error that looks like this:
>
> Error : .onLoad failed in loadNamespace() for 'foo', details:
>      call: NULL
>      error: 'upstream_function' is not an exported object from
> 'namespace:upstream'
>
> I wonder if isNamespaceLoaded() returning TRUE is correct in this
> case, or returning FALSE would be better. Or maybe it would make sense
> to have a way to query the packages that are being loaded currently?
>
> AFAICT this works, but it does use some implementation details from
> loadNamespace(), so it does not seem like a proper solution:
>
> dynGet("__NameSpacesLoading__", NULL)
>
> Another workaround is something like this:
>
>   is_loaded <- function(pkg) {
>     if (!isNamespaceLoaded(pkg)) return(FALSE)
>     tryCatch({
>       loadNamespace(pkg)
>       TRUE
>     }, error = function(err) FALSE)
>   }
>
> which forces an error for currently loading namespaces by triggering a
> (fake) recursive dependency.
>
> Thanks,
> Gabor
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From kry|ov@r00t @end|ng |rom gm@||@com  Thu Mar 16 19:05:54 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Thu, 16 Mar 2023 21:05:54 +0300
Subject: [Rd] Making headers self-contained for static analysis
In-Reply-To: <CAJf4E3o1ZndpVV=b+RaFXZq1tKGXa5+WOemD0s62WpwNJRi8wA@mail.gmail.com>
References: <CAJf4E3o1ZndpVV=b+RaFXZq1tKGXa5+WOemD0s62WpwNJRi8wA@mail.gmail.com>
Message-ID: <20230316210402.7cb38406@Tarkus>

Hello Lionel,

Just letting you know off-list that the patch didn't make it through.
Unfortunately, I don't remember the exact rules regarding attachments
(does text/plain work?), but an external link is always an option,
especially for large patches.

-- 
Best regards,
Ivan


From ||one| @end|ng |rom po@|t@co  Thu Mar 16 19:32:39 2023
From: ||one| @end|ng |rom po@|t@co (Lionel Henry)
Date: Thu, 16 Mar 2023 19:32:39 +0100
Subject: [Rd] Making headers self-contained for static analysis
In-Reply-To: <CAJf4E3o1ZndpVV=b+RaFXZq1tKGXa5+WOemD0s62WpwNJRi8wA@mail.gmail.com>
References: <CAJf4E3o1ZndpVV=b+RaFXZq1tKGXa5+WOemD0s62WpwNJRi8wA@mail.gmail.com>
Message-ID: <CAJf4E3pubgvmTfdqK8GM39oyPN=AOSbKkyLN3wj3KB24T351Gg@mail.gmail.com>

People have let me know that the attachment didn't make it through.
Do patches get filtered out?

Please find it there:
https://github.com/lionel-/r-svn/commit/e3de56798b1321a3fa8688a42bbb73d763b78024.patch

I'm also happy to post it on the bugzilla if that makes sense.

Best,
Lionel

On 3/16/23, Lionel Henry <lionel at posit.co> wrote:
> Hello,
>
> I started using clangd to get better static analysis and code
> refactoring tooling with the R sources (using eglot-mode in Emacs, it
> just works once you've generated a `compile_commands.json` file with
> `bear make all`). I noticed that the static analyser can't understand
> several header files because these are not self-contained. So I went
> through all .h files and inserted the missing includes, cf the
> attached patch.
>
> Making the headers self-contained has consequences for the .c or .cpp
> files that include them. In the case of C files, the only downside I
> see is that it might cause users to accidentally rely on indirect
> inclusion of standard headers, instead of directly including the
> header to make the dependency explicit as would be good practice.
> This doesn't seem like a big deal compared to the benefits of enabling
> static analysis.
>
> However in the case of C++ that's more problematic. We don't want to
> include the C headers because that would pollute the global namespace
> and users might prefer to import the missing symbols (`size_t` and
> `FILE`) selectively. Also that wouldn't help static analysis within
> the header files since the analysers use the C path. So I have guarded
> inclusion of standard C headers behing a `__cplusplus` check.
>
> If that makes sense, would R core consider applying the attached patch
> to the R sources?
>
> Best,
> Lionel
>


From m@rc_@chw@rtz @end|ng |rom me@com  Thu Mar 16 19:54:05 2023
From: m@rc_@chw@rtz @end|ng |rom me@com (Marc Schwartz)
Date: Thu, 16 Mar 2023 14:54:05 -0400
Subject: [Rd] Making headers self-contained for static analysis
In-Reply-To: <CAJf4E3pubgvmTfdqK8GM39oyPN=AOSbKkyLN3wj3KB24T351Gg@mail.gmail.com>
References: <CAJf4E3o1ZndpVV=b+RaFXZq1tKGXa5+WOemD0s62WpwNJRi8wA@mail.gmail.com>
 <CAJf4E3pubgvmTfdqK8GM39oyPN=AOSbKkyLN3wj3KB24T351Gg@mail.gmail.com>
Message-ID: <etPan.641365cd.617551a8.410@me.com>

Hi,

There are a limited number of MIME file types that are accepted through the list server, with plain text being one. Even though a patch file should be plain text, it is possible that your mail client may not have set the correct MIME type for your patch file attachment. If so, that would explain why it was filtered from the list.

For future reference, if you change the file extension to ".txt" and then attach it, that should get picked up as plain text and get through the list server filters.

Regards,

Marc Schwartz
R-Devel Co-Admin


On March 16, 2023 at 2:32:39 PM, Lionel Henry via R-devel (r-devel at r-project.org (mailto:r-devel at r-project.org)) wrote:

> People have let me know that the attachment didn't make it through.
> Do patches get filtered out?
>
> Please find it there:
> https://github.com/lionel-/r-svn/commit/e3de56798b1321a3fa8688a42bbb73d763b78024.patch
>
> I'm also happy to post it on the bugzilla if that makes sense.
>
> Best,
> Lionel
>
> On 3/16/23, Lionel Henry wrote:
> > Hello,
> >
> > I started using clangd to get better static analysis and code
> > refactoring tooling with the R sources (using eglot-mode in Emacs, it
> > just works once you've generated a `compile_commands.json` file with
> > `bear make all`). I noticed that the static analyser can't understand
> > several header files because these are not self-contained. So I went
> > through all .h files and inserted the missing includes, cf the
> > attached patch.
> >
> > Making the headers self-contained has consequences for the .c or .cpp
> > files that include them. In the case of C files, the only downside I
> > see is that it might cause users to accidentally rely on indirect
> > inclusion of standard headers, instead of directly including the
> > header to make the dependency explicit as would be good practice.
> > This doesn't seem like a big deal compared to the benefits of enabling
> > static analysis.
> >
> > However in the case of C++ that's more problematic. We don't want to
> > include the C headers because that would pollute the global namespace
> > and users might prefer to import the missing symbols (`size_t` and
> > `FILE`) selectively. Also that wouldn't help static analysis within
> > the header files since the analysers use the C path. So I have guarded
> > inclusion of standard C headers behing a `__cplusplus` check.
> >
> > If that makes sense, would R core consider applying the attached patch
> > to the R sources?
> >
> > Best,
> > Lionel
> >
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From |e||pe@contrer@@ @end|ng |rom gm@||@com  Thu Mar 16 20:39:40 2023
From: |e||pe@contrer@@ @end|ng |rom gm@||@com (Felipe Contreras)
Date: Thu, 16 Mar 2023 13:39:40 -0600
Subject: [Rd] Request: better default R_LIBS_USER
Message-ID: <CAMP44s2zzqo6iG2ujvhBGL4UsxsOt7e11p81xwWLCEf5Ggperw@mail.gmail.com>

Hi,

I see R by default installs packages in ~/R. I know I can change the
default directory with R_LIBS_USER, but software shouldn't be
polluting the home directory.

For example both python and node install packages to ~/.local/lib,
ruby to ~/.local/share. They don't install to for example ~/node.

R should do the same: it should install packages to somewhere inside
~/.local by default.

Cheers.

-- 
Felipe Contreras


From edd @end|ng |rom deb|@n@org  Thu Mar 16 23:08:41 2023
From: edd @end|ng |rom deb|@n@org (Dirk Eddelbuettel)
Date: Thu, 16 Mar 2023 17:08:41 -0500
Subject: [Rd] Request: better default R_LIBS_USER
In-Reply-To: <CAMP44s2zzqo6iG2ujvhBGL4UsxsOt7e11p81xwWLCEf5Ggperw@mail.gmail.com>
References: <CAMP44s2zzqo6iG2ujvhBGL4UsxsOt7e11p81xwWLCEf5Ggperw@mail.gmail.com>
Message-ID: <25619.37737.873897.49177@rob.eddelbuettel.com>


On 16 March 2023 at 13:39, Felipe Contreras wrote:
| I see R by default installs packages in ~/R. I know I can change the
| default directory with R_LIBS_USER, but software shouldn't be
| polluting the home directory.
| 
| For example both python and node install packages to ~/.local/lib,
| ruby to ~/.local/share. They don't install to for example ~/node.
| 
| R should do the same: it should install packages to somewhere inside
| ~/.local by default.

Use of ~/.local is a fairly recent convention (relative to the time R has
been around, which is now decades) and one which R supports already eg in the
(rather useful) portable config directories:

   > tools::R_user_dir("r2u")
   [1] "/home/edd/.local/share/R/r2u"
   > 

Your best bet really to govern your .libPaths from your Rprofile.site and
Renviron.site rather than asking a few million R users to adjust from past
practice.

Also: personal preferences differ. I think of Linux as multi-tenant and
expect other (even system) users to have access to packages I install. So I
am happy with this default --- which goes after all back to fruitful
discussion in a bar in Vienna with Kurt and Fritz some 20 years ago:

   > .libPaths()
   [1] "/usr/local/lib/R/site-library" "/usr/lib/R/site-library"
   [3] "/usr/lib/R/library"           
   > 

Dirk

-- 
dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org


From henr|k@bengt@@on @end|ng |rom gm@||@com  Fri Mar 17 01:15:09 2023
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Thu, 16 Mar 2023 17:15:09 -0700
Subject: [Rd] Request: better default R_LIBS_USER
In-Reply-To: <25619.37737.873897.49177@rob.eddelbuettel.com>
References: <CAMP44s2zzqo6iG2ujvhBGL4UsxsOt7e11p81xwWLCEf5Ggperw@mail.gmail.com>
 <25619.37737.873897.49177@rob.eddelbuettel.com>
Message-ID: <CAFDcVCQz0VfD-BKoy8swP4iCXx-Q-unH=nk7N0P_-QM=GbfMXw@mail.gmail.com>

> Your best bet really to govern your .libPaths from your Rprofile.site and
Renviron.site ...

To do this for any version of R, one can add:

R_LIBS_USER=~/.local/share/R/%p-library/%v

to ~/.Renviron or the Renviron.site file. This automatically expands
to the platform and R x.y version early on when R starts up, e.g.
~/.local/share/R/x86_64-pc-linux-gnu-library/4.2.

> rather than asking a few million R users to adjust from past practice.

We're all starting out with a fresh R_LIBS_USER once a year when a new
minor version of R is released, so changing the default should be
doable without major troubles. On MS Windows, this move has already
been made. When R 4.2.0 was released, the default R_LIBS_USER location
on MS Windows was changed, similarly, to the Local Application Data
directory in R (>= 4.2.0), e.g.
C:\Users\alice\AppData\Local\R\win-library\4.2.

/Henrik

On Thu, Mar 16, 2023 at 3:09?PM Dirk Eddelbuettel <edd at debian.org> wrote:
>
>
> On 16 March 2023 at 13:39, Felipe Contreras wrote:
> | I see R by default installs packages in ~/R. I know I can change the
> | default directory with R_LIBS_USER, but software shouldn't be
> | polluting the home directory.
> |
> | For example both python and node install packages to ~/.local/lib,
> | ruby to ~/.local/share. They don't install to for example ~/node.
> |
> | R should do the same: it should install packages to somewhere inside
> | ~/.local by default.
>
> Use of ~/.local is a fairly recent convention (relative to the time R has
> been around, which is now decades) and one which R supports already eg in the
> (rather useful) portable config directories:
>
>    > tools::R_user_dir("r2u")
>    [1] "/home/edd/.local/share/R/r2u"
>    >
>
> Your best bet really to govern your .libPaths from your Rprofile.site and
> Renviron.site rather than asking a few million R users to adjust from past
> practice.
>
> Also: personal preferences differ. I think of Linux as multi-tenant and
> expect other (even system) users to have access to packages I install. So I
> am happy with this default --- which goes after all back to fruitful
> discussion in a bar in Vienna with Kurt and Fritz some 20 years ago:
>
>    > .libPaths()
>    [1] "/usr/local/lib/R/site-library" "/usr/lib/R/site-library"
>    [3] "/usr/lib/R/library"
>    >
>
> Dirk
>
> --
> dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From edd @end|ng |rom deb|@n@org  Fri Mar 17 01:39:16 2023
From: edd @end|ng |rom deb|@n@org (Dirk Eddelbuettel)
Date: Thu, 16 Mar 2023 19:39:16 -0500
Subject: [Rd] Request: better default R_LIBS_USER
In-Reply-To: <CAFDcVCQz0VfD-BKoy8swP4iCXx-Q-unH=nk7N0P_-QM=GbfMXw@mail.gmail.com>
References: <CAMP44s2zzqo6iG2ujvhBGL4UsxsOt7e11p81xwWLCEf5Ggperw@mail.gmail.com>
 <25619.37737.873897.49177@rob.eddelbuettel.com>
 <CAFDcVCQz0VfD-BKoy8swP4iCXx-Q-unH=nk7N0P_-QM=GbfMXw@mail.gmail.com>
Message-ID: <25619.46772.139003.258344@rob.eddelbuettel.com>


On 16 March 2023 at 17:15, Henrik Bengtsson wrote:
| We're all starting out with a fresh R_LIBS_USER once a year when a new
| minor version of R is released,

Maybe not "we all". I don't, and I know other Linux users who don't force a
rebuild unless needed (as with R 3.6.* -> R 4.0.0).

R signals clearly when a rebuild is needed at a major version change, and we
had this (if I recall correctly) about twice in the six or so years.  I carry
my directories over with ease from most (major) release to the next: By doing
nothing as my .libPaths has no version number in.

[ In fairness the last few upgrades were semi-dirtied because package needing
a graphics device needed a rebuild as the tireless Paul Murrell extends
capabilities and hence API interfaces. But that affects usually half a dozen
out of maybe hundreds of installed packages. ]

[ But your post was helpful in adding how to define a version, or arch, or
... handle for which `help(".Library")` has all the relevant details. ]

Dirk

-- 
dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org


From |e||pe@contrer@@ @end|ng |rom gm@||@com  Fri Mar 17 02:17:12 2023
From: |e||pe@contrer@@ @end|ng |rom gm@||@com (Felipe Contreras)
Date: Thu, 16 Mar 2023 19:17:12 -0600
Subject: [Rd] Request: better default R_LIBS_USER
In-Reply-To: <25619.37737.873897.49177@rob.eddelbuettel.com>
References: <CAMP44s2zzqo6iG2ujvhBGL4UsxsOt7e11p81xwWLCEf5Ggperw@mail.gmail.com>
 <25619.37737.873897.49177@rob.eddelbuettel.com>
Message-ID: <CAMP44s2NFqiOP1hYcXvk0MvDDnQ9ZmoQvEk37cRyUW2T_0pqRQ@mail.gmail.com>

On Thu, Mar 16, 2023 at 4:08?PM Dirk Eddelbuettel <edd at debian.org> wrote:
>
>
> On 16 March 2023 at 13:39, Felipe Contreras wrote:
> | I see R by default installs packages in ~/R. I know I can change the
> | default directory with R_LIBS_USER, but software shouldn't be
> | polluting the home directory.
> |
> | For example both python and node install packages to ~/.local/lib,
> | ruby to ~/.local/share. They don't install to for example ~/node.
> |
> | R should do the same: it should install packages to somewhere inside
> | ~/.local by default.
>
> Use of ~/.local is a fairly recent convention (relative to the time R has
> been around, which is now decades) and one which R supports already eg in the
> (rather useful) portable config directories:
>
>    > tools::R_user_dir("r2u")
>    [1] "/home/edd/.local/share/R/r2u"
>    >
>
> Your best bet really to govern your .libPaths from your Rprofile.site and
> Renviron.site

I already have fixed it for myself, my request was about the default,
so most users don't have to fix it for themselves too.

> rather than asking a few million R users to adjust from past
> practice.

Why would they have to adjust anything?

Just expand %U to both:

            paste(c(
            file.path(home, ".local", "lib", "r", x.y),
            file.path(home, "R", paste0(R.version$platform, "-library"), x.y)
            ), collapse = ":")

Then R would install packages to the new location in new installations
by default, but still use packages from the old location if present.

Moreover, this location is going to change the next time the minor
version is bumped anyway.

Cheers.

-- 
Felipe Contreras


From j@g@nmn2 @end|ng |rom gm@||@com  Fri Mar 17 02:22:00 2023
From: j@g@nmn2 @end|ng |rom gm@||@com (Mikael Jagan)
Date: Thu, 16 Mar 2023 21:22:00 -0400
Subject: [Rd] det(diag(c(NaN, 1))) should be NaN, not 0
In-Reply-To: <4d6116fe-ecf0-19c8-d572-4eb1a3631d4c@gmail.com>
References: <4d6116fe-ecf0-19c8-d572-4eb1a3631d4c@gmail.com>
Message-ID: <35b2c677-1cae-0327-f626-20a75f566efe@gmail.com>

Hmm ... I can no longer reproduce this under r83996 when configuring
--without-lapack and --without-blas {the default}.  Now det(A), det(B),
det(C), and det(D) are all NaN.

I assume that the reason is the recent update to use LAPACK 3.11.0?
But I don't see any related NEWS here:

     https://netlib.org/lapack/lapack-3.11.0.html

It is possible that the underlying issue in DGETRF (INFO>0 due to NaN
pivots rather than 0 pivots {=> singular}) still exists for matrices
less trivial than my 2-by-2 examples.  Will have to experiment ...

Mikael

On 2022-11-09 3:58 pm, Mikael Jagan wrote:
> Hello,
> 
> Currently, determinant(A) calculates the determinant of 'A' by factorizing
> A=LU and computing prod(diag(U)) [or the logarithm of the absolute value].
> The factorization is done by LAPACK routine DGETRF, which gives a status
> code INFO, documented [1] as follows:
> 
> *>          INFO is INTEGER
> *>          = 0:  successful exit
> *>          < 0:  if INFO = -i, the i-th argument had an illegal value
> *>          > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
> *>                has been completed, but the factor U is exactly
> *>                singular, and division by zero will occur if it is used
> *>                to solve a system of equations.
> 
> Accordingly, when INF0>0, determinant(A) behaves as det(A)=0, _not_ computing
> prod(diag(U)).  The problem here is that DGETRF can _also_ give positive
> INFO for matrices containing NaN, which may very well not be singular for some
> finite value of NaN.
> 
> I claim that, when INFO>0, determinant(A) should _not_ behave as det(A)=0
> unconditionally, but rather sometimes (depending on some test) give NaN.
> Here is one case where 0 is really "wrong":
> 
>   > (A <- diag(c(NaN, 1)))
>        [,1] [,2]
> [1,]  NaN    0
> [2,]    0    1
>   > det(A)
> [1] 0
> 
> R isn't consistent, either:
> 
>   > (B <- diag(c(1, NaN)))
>        [,1] [,2]
> [1,]    1    0
> [2,]    0  NaN
>   > det(B)
> [1] NaN
> 
> Here, DGETRF _does_ succeed, because it does not "see" the trailing NaN in 'B'.
> 
> So: Should R change to better handle the INFO>0 case?  If so, how?
> 
> Ideally (I think), the proposed change would give NaN for 'A' and 'B'
> above and 0 for 'C' and 'D' below (both of which really _are_ singular):
> 
>   > (C <- matrix(c(NaN, NaN, 0, 0), 2L, 2L))
>        [,1] [,2]
> [1,]  NaN    0
> [2,]  NaN    0
>   > det(C)
> [1] NaN
>   > (D <- t(C))
>        [,1] [,2]
> [1,]  NaN  NaN
> [2,]    0    0
>   > det(D)
> [1] 0
> 
> Furthermore, the proposed change should _not_ decrease the performance
> of determinant(A) for nonsingular 'A' ...
> 
> For those looking, the relevant C-level function is det_ge_real(),
> defined in R-devel/src/modules/lapack/Lapack.c (at line 1260 in r83320).
> 
> Mikael
> 
> [1] https://github.com/Reference-LAPACK/lapack/blob/master/SRC/dgetrf.f


From |e||pe@contrer@@ @end|ng |rom gm@||@com  Fri Mar 17 02:22:42 2023
From: |e||pe@contrer@@ @end|ng |rom gm@||@com (Felipe Contreras)
Date: Thu, 16 Mar 2023 19:22:42 -0600
Subject: [Rd] Request: better default R_LIBS_USER
In-Reply-To: <25619.46772.139003.258344@rob.eddelbuettel.com>
References: <CAMP44s2zzqo6iG2ujvhBGL4UsxsOt7e11p81xwWLCEf5Ggperw@mail.gmail.com>
 <25619.37737.873897.49177@rob.eddelbuettel.com>
 <CAFDcVCQz0VfD-BKoy8swP4iCXx-Q-unH=nk7N0P_-QM=GbfMXw@mail.gmail.com>
 <25619.46772.139003.258344@rob.eddelbuettel.com>
Message-ID: <CAMP44s0hZ6MR6Hx4YfnfVRCqFXK5EvHcmDLKY2AcMXi+9jQUNQ@mail.gmail.com>

On Thu, Mar 16, 2023 at 6:39?PM Dirk Eddelbuettel <edd at debian.org> wrote:
>
>
> On 16 March 2023 at 17:15, Henrik Bengtsson wrote:
> | We're all starting out with a fresh R_LIBS_USER once a year when a new
> | minor version of R is released,
>
> Maybe not "we all". I don't, and I know other Linux users who don't force a
> rebuild unless needed (as with R 3.6.* -> R 4.0.0).

Then you are not using the default.

And BTW, that's why the default location probably should be in a "4"
directory, not "4.2". And since it's even more unlikely that the
platform is going to change from one version to the next:

    ~/.local/share/R/4

Or something like that.

-- 
Felipe Contreras


From c@@rd|@g@bor @end|ng |rom gm@||@com  Fri Mar 17 11:53:02 2023
From: c@@rd|@g@bor @end|ng |rom gm@||@com (=?UTF-8?B?R8OhYm9yIENzw6FyZGk=?=)
Date: Fri, 17 Mar 2023 11:53:02 +0100
Subject: [Rd] La_library() always returns "" on R-devel?
Message-ID: <CABtg=Kkr3MsFndd5MSXBHbfOvgwcuOuZioVr13wNQm-UN61Sbw@mail.gmail.com>

Seems like this in 83986 [1] needs a fix in Lapack.c:

        if (dladdr((void *) F77_NAME(ilaver), &dl_info)) {
            char buf[PATH_MAX+1];
            char *res = realpath(dl_info.dli_fname, buf);
            if (res) {
                SEXP nfo = R_NilValue;
                if (strstr(res, "flexiblas"))
                    nfo = R_flexiblas_info();
                if (isNull(nfo))
                    nfo = mkChar("");
                ans = ScalarString(nfo);
                break;
            }
        }

It will always return an empty string except for flexiblas. I assume
this is not intentional.

Gabor

[1] https://github.com/wch/r-source/commit/77b1f5a75f8691d3e77ef07ece53f0bb6c149020#diff-b6e85dec8d7194fae29b1a1768e3f6608fa184e57f0828f48c05ebd29ef653c8R1416


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Fri Mar 17 12:01:31 2023
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Fri, 17 Mar 2023 12:01:31 +0100
Subject: [Rd] La_library() always returns "" on R-devel?
In-Reply-To: <CABtg=Kkr3MsFndd5MSXBHbfOvgwcuOuZioVr13wNQm-UN61Sbw@mail.gmail.com>
References: <CABtg=Kkr3MsFndd5MSXBHbfOvgwcuOuZioVr13wNQm-UN61Sbw@mail.gmail.com>
Message-ID: <33900d0c-003a-fb11-c22c-e7954990aa49@gmail.com>


On 3/17/23 11:53, G?bor Cs?rdi wrote:
> Seems like this in 83986 [1] needs a fix in Lapack.c:
>
>          if (dladdr((void *) F77_NAME(ilaver), &dl_info)) {
>              char buf[PATH_MAX+1];
>              char *res = realpath(dl_info.dli_fname, buf);
>              if (res) {
>                  SEXP nfo = R_NilValue;
>                  if (strstr(res, "flexiblas"))
>                      nfo = R_flexiblas_info();
>                  if (isNull(nfo))
>                      nfo = mkChar("");
>                  ans = ScalarString(nfo);
>                  break;
>              }
>          }
>
> It will always return an empty string except for flexiblas. I assume
> this is not intentional.

Thanks, fixed now.

Tomas

>
> Gabor
>
> [1] https://github.com/wch/r-source/commit/77b1f5a75f8691d3e77ef07ece53f0bb6c149020#diff-b6e85dec8d7194fae29b1a1768e3f6608fa184e57f0828f48c05ebd29ef653c8R1416
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From bbo|ker @end|ng |rom gm@||@com  Fri Mar 17 23:16:49 2023
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Fri, 17 Mar 2023 18:16:49 -0400
Subject: [Rd] use Ctrl-W to close View() window?
Message-ID: <49134429-268f-5632-c6f3-08b995aa8fa4@gmail.com>

 ? I might be the last person in the world who's using View() outside of 
RStudio, but does anyone have a sense of how hard it would be to enable 
closing such a window (when in focus) with a standard keyboard shortcut 
(e.g. Ctrl-W on Linux) ... ?? Where would I start looking in the code base?

 ? Or maybe this can already be enabled somehow?

 ? cheers

 ?? Ben Bolker


From joh@nne@@r@nke @end|ng |rom jrwb@de  Fri Mar 17 23:25:36 2023
From: joh@nne@@r@nke @end|ng |rom jrwb@de (Johannes Ranke)
Date: Fri, 17 Mar 2023 23:25:36 +0100
Subject: [Rd] use Ctrl-W to close View() window?
In-Reply-To: <49134429-268f-5632-c6f3-08b995aa8fa4@gmail.com>
References: <49134429-268f-5632-c6f3-08b995aa8fa4@gmail.com>
Message-ID: <3404502.RL5eaSpR8r@ryz>

Hi,

am I missing something or could you just use Alt-F4? This is pretty standard 
for closing focussed windows on Windows and Linux at least. It just closed a 
Window opened with View() on Debian Linux FWIW.

Cheers, Johannes

Am Freitag, 17. M?rz 2023, 23:16:49 CET schrieb Ben Bolker:
>    I might be the last person in the world who's using View() outside of
> RStudio, but does anyone have a sense of how hard it would be to enable
> closing such a window (when in focus) with a standard keyboard shortcut
> (e.g. Ctrl-W on Linux) ... ?  Where would I start looking in the code base?
> 
>    Or maybe this can already be enabled somehow?
> 
>    cheers
> 
>     Ben Bolker
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From bbo|ker @end|ng |rom gm@||@com  Sat Mar 18 00:15:15 2023
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Fri, 17 Mar 2023 19:15:15 -0400
Subject: [Rd] use Ctrl-W to close View() window?
In-Reply-To: <3404502.RL5eaSpR8r@ryz>
References: <49134429-268f-5632-c6f3-08b995aa8fa4@gmail.com>
 <3404502.RL5eaSpR8r@ryz>
Message-ID: <82622d04-37f2-9ed0-6284-dcb9f34ac266@gmail.com>

 ? It does work, although it's very awkward with my current keyboard 
setup (I need to use Alt-Fn-F4).? However, knowing that there was *a* 
keyboard shortcut for it led me to figuring out how to add Ctrl-W as a 
synonym.? Thanks!? ("Super"-Q is also a synonym, where "Super" is the 
same as the Windows/MacOS command/system key ...)

On 2023-03-17 6:25 p.m., Johannes Ranke wrote:

> Hi,
>
> am I missing something or could you just use Alt-F4? This is pretty standard
> for closing focussed windows on Windows and Linux at least. It just closed a
> Window opened with View() on Debian Linux FWIW.
>
> Cheers, Johannes
>
> Am Freitag, 17. M?rz 2023, 23:16:49 CET schrieb Ben Bolker:
>>     I might be the last person in the world who's using View() outside of
>> RStudio, but does anyone have a sense of how hard it would be to enable
>> closing such a window (when in focus) with a standard keyboard shortcut
>> (e.g. Ctrl-W on Linux) ... ?  Where would I start looking in the code base?
>>
>>     Or maybe this can already be enabled somehow?
>>
>>     cheers
>>
>>      Ben Bolker
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From p@kr|v|t@ky @end|ng |rom un@w@edu@@u  Sun Mar 19 07:33:38 2023
From: p@kr|v|t@ky @end|ng |rom un@w@edu@@u (Pavel Krivitsky)
Date: Sun, 19 Mar 2023 06:33:38 +0000
Subject: [Rd] 
 [WARNING: POTENTIAL FORGED EMAIL] Augment base::replace(x, list,
 value) to allow list= to be a predicate?
In-Reply-To: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
References: <c450f50c118c8e4ca10acaf7b1fc40e7b205be57.camel@unsw.edu.au>
Message-ID: <510b9ed9647460c12819d3cd2d61ea2ad1e482f1.camel@unsw.edu.au>

Dear All,

Following up on this, I was wondering whether it might be possible to
get a disposition from R developers.

I did find a way to produce a similar effect reasonably concisely using
call alchemy and lazy evaluation. The following function grabs the
specified arguments in the function whose argument it is, applies the
specified function to them, and returns the result. I am not sure if it
correctly handles all possible cases, particularly when nonstandard
evaluation and functions with side-effects are involved.

.af. <- function(...){
  if(is.numeric(arg1 <- ...elt(1)) || is.character(arg1)){ # By position or name
    i <- arg1
    f <- ...elt(2L)
    g <- \(x, dummy1, dummy2, ...) f(x, ...) # Eat 2 arguments in ... .
  }else{ # First argument (the default)
    i <- 1L
    f <- arg1
    g <- \(x, dummy, ...) f(x, ...) # Eat 1 argument in ... .
  }

  sys.function(1L) |> formals() |> names() |>
    setNames(nm=_) |> (`[`)(i) |> get(sys.frame(1L)) |>
    g(...)
}

# Examples:

c(1,2,NA,3) |> replace(.af.(is.na), 0) # First argument

1:5 |> replace(.af.(`>`, 3), 0) # Function of multiple arguments

1:5 |> ifelse(.af.(2, `>`, 3), yes=_, 0) # Specify position of referenced argument

1:5 |> ifelse(.af.("yes", `>`, 3), yes=_, 0) # Specify name of referenced argument

It may also make sense to have hard-coded versions of this for common cases, e.g.,

.a2f. <- function(...) .af.(2L, ...)

I am not sure how readable or concise this is in practice, and I don't
think this should go into R proper, but would anyone else use it if I
put something like this in a package?

				Best Regards,
				Pavel

On Sat, 2023-03-04 at 00:21 +0000, r-devel-bounces at r-project.org wrote:
> Dear All,
> 
> Currently, list= in base::replace(x, list, value) has to be an index
> vector. For me, at least, the most common use case is for list= to be
> some simple property of elements of x, e.g.,
> 
> x <- c(1,2,NA,3)
> replace(x, is.na(x), 0)
> 
> Particularly when using R pipes, which don't allow multiple
> substitutions, it would simplify many of such cases if list= could be
> a
> function that returns an index, e.g.,
> 
> replace <- function (x, list, values, ...) {
> ? # Here, list() refers to the argument, not the built-in.
> ? if(is.function(list)) list <- list(x, ...)
> ? x[list] <- values
> ? x
> }
> 
> Then, the following is possible:
> 
> c(1,2,NA,3) |> replace(is.na, 0)
> 
> ????????????????????????Any thoughts?
> ????????????????????????Pavel
> ______________________________________________
> R-devel at r-project.org?mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From henr|k@bengt@@on @end|ng |rom gm@||@com  Sun Mar 19 17:08:20 2023
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Sun, 19 Mar 2023 09:08:20 -0700
Subject: [Rd] WISH: Optional mechanism preventing var <<- value from
 assigning non-existing variable
Message-ID: <CAFDcVCRFvDFP1fszvn8=UbgArtAyU5P97r=X7QdnGbUQCkaOcw@mail.gmail.com>

I'd like to be able to prevent the <<- assignment operator ("super
assignment") from assigning to the global environment unless the
variable already exists and is not locked.  If it does not exist or is
locked, I'd like an error to be produced.  This would allow me to
evaluate expressions with this temporarily set to protect against
mistakes.

For example, I'd like to do something like:

$ R --vanilla
> exists("a")
[1] FALSE

> options(check.superassignment = TRUE)
> local({ a <<- 1 })
Error: object 'a' not found

> a <- 0
> local({ a <<- 1 })
> a
[1] 1

> rm("a")
> options(check.superassignment = FALSE)
> local({ a <<- 1 })
> exists("a")
[1] TRUE


BACKGROUND:

>From help("<<-") we have:

"The operators <<- and ->> are normally only used in functions, and
cause a search to be made through parent environments for an existing
definition of the variable being assigned. If such a variable is found
(and its binding is not locked) then its value is redefined, otherwise
assignment takes place in the global environment."

I argue that it's unfortunate that <<- fallbacks back to assigning to
the global environment if the variable does not already exist.
Unfortunately, it has become a "go to" solution for many to use it
that way.  Sometimes it is intended, sometimes it's a mistake.  We
find it also in R packages on CRAN, even if 'R CMD check' tries to
detect when it happens (but it's limited to do so from run-time
examples and tests).

It's probably too widely used for us to change to a more strict
behavior permanent.  The proposed R option allows me, as a developer,
to evaluate an R expression with the strict behavior, especially if I
don't trust the code.

With 'check.superassignment = TRUE' set, a developer would have to
first declare the variable in the global environment for <<- to assign
there.  This would remove the fallback "If such a variable is found
(and its binding is not locked) then its value is redefined, otherwise
assignment takes place in the global environment" in the current
design.  For those who truly intends to assign to the global, could
use assign(var, value, envir = globalenv()) or globalenv()[[var]] <-
value.

'R CMD check' could temporarily set 'check.superassignment = TRUE'
during checks.  If we let environment variable
'R_CHECK_SUPERASSIGNMENT' set the default value of option
'check.superassignment' on R startup, it would be possible to check
packages optionally this way, but also to run any "non-trusted" R
script in the "strict" mode.


TEASER:

Here's an example why using <<- for assigning to the global
environment is a bad idea:

This works:

$ R --vanilla
> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
> keep
> [1] 3


This doesn't work:

$ R --vanilla
> library(purrr)
> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
Error in keep <<- x : cannot change value of locked binding for 'keep'


But, if we "declare" the variable first, it works:

$ R --vanilla
> library(purrr)
> keep <- 0
> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
> keep
> [1] 3

/Henrik

PS. Does the <<- operator have an official name? Hadley calls it
"super assignment" in 'Advanced R'
(https://adv-r.hadley.nz/environments.html), which is where I got it
from.


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Mar 19 18:53:57 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sun, 19 Mar 2023 13:53:57 -0400
Subject: [Rd] WISH: Optional mechanism preventing var <<- value from
 assigning non-existing variable
In-Reply-To: <CAFDcVCRFvDFP1fszvn8=UbgArtAyU5P97r=X7QdnGbUQCkaOcw@mail.gmail.com>
References: <CAFDcVCRFvDFP1fszvn8=UbgArtAyU5P97r=X7QdnGbUQCkaOcw@mail.gmail.com>
Message-ID: <2c1fefc8-a554-3876-91ed-27e2d77d6f12@gmail.com>

I think that should be the default behaviour. It's pretty late to get 
that into R 4.3.0, but I think your proposal (with check.superassignment 
= FALSE being the default) could make it in, and 4.4.0 could change the 
default to TRUE.

Duncan



On 19/03/2023 12:08 p.m., Henrik Bengtsson wrote:
> I'd like to be able to prevent the <<- assignment operator ("super
> assignment") from assigning to the global environment unless the
> variable already exists and is not locked.  If it does not exist or is
> locked, I'd like an error to be produced.  This would allow me to
> evaluate expressions with this temporarily set to protect against
> mistakes.
> 
> For example, I'd like to do something like:
> 
> $ R --vanilla
>> exists("a")
> [1] FALSE
> 
>> options(check.superassignment = TRUE)
>> local({ a <<- 1 })
> Error: object 'a' not found
> 
>> a <- 0
>> local({ a <<- 1 })
>> a
> [1] 1
> 
>> rm("a")
>> options(check.superassignment = FALSE)
>> local({ a <<- 1 })
>> exists("a")
> [1] TRUE
> 
> 
> BACKGROUND:
> 
>  From help("<<-") we have:
> 
> "The operators <<- and ->> are normally only used in functions, and
> cause a search to be made through parent environments for an existing
> definition of the variable being assigned. If such a variable is found
> (and its binding is not locked) then its value is redefined, otherwise
> assignment takes place in the global environment."
> 
> I argue that it's unfortunate that <<- fallbacks back to assigning to
> the global environment if the variable does not already exist.
> Unfortunately, it has become a "go to" solution for many to use it
> that way.  Sometimes it is intended, sometimes it's a mistake.  We
> find it also in R packages on CRAN, even if 'R CMD check' tries to
> detect when it happens (but it's limited to do so from run-time
> examples and tests).
> 
> It's probably too widely used for us to change to a more strict
> behavior permanent.  The proposed R option allows me, as a developer,
> to evaluate an R expression with the strict behavior, especially if I
> don't trust the code.
> 
> With 'check.superassignment = TRUE' set, a developer would have to
> first declare the variable in the global environment for <<- to assign
> there.  This would remove the fallback "If such a variable is found
> (and its binding is not locked) then its value is redefined, otherwise
> assignment takes place in the global environment" in the current
> design.  For those who truly intends to assign to the global, could
> use assign(var, value, envir = globalenv()) or globalenv()[[var]] <-
> value.
> 
> 'R CMD check' could temporarily set 'check.superassignment = TRUE'
> during checks.  If we let environment variable
> 'R_CHECK_SUPERASSIGNMENT' set the default value of option
> 'check.superassignment' on R startup, it would be possible to check
> packages optionally this way, but also to run any "non-trusted" R
> script in the "strict" mode.
> 
> 
> TEASER:
> 
> Here's an example why using <<- for assigning to the global
> environment is a bad idea:
> 
> This works:
> 
> $ R --vanilla
>> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
>> keep
>> [1] 3
> 
> 
> This doesn't work:
> 
> $ R --vanilla
>> library(purrr)
>> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
> Error in keep <<- x : cannot change value of locked binding for 'keep'
> 
> 
> But, if we "declare" the variable first, it works:
> 
> $ R --vanilla
>> library(purrr)
>> keep <- 0
>> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
>> keep
>> [1] 3
> 
> /Henrik
> 
> PS. Does the <<- operator have an official name? Hadley calls it
> "super assignment" in 'Advanced R'
> (https://adv-r.hadley.nz/environments.html), which is where I got it
> from.
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From w||||@mwdun|@p @end|ng |rom gm@||@com  Sun Mar 19 19:15:38 2023
From: w||||@mwdun|@p @end|ng |rom gm@||@com (Bill Dunlap)
Date: Sun, 19 Mar 2023 11:15:38 -0700
Subject: [Rd] WISH: Optional mechanism preventing var <<- value from
 assigning non-existing variable
In-Reply-To: <2c1fefc8-a554-3876-91ed-27e2d77d6f12@gmail.com>
References: <CAFDcVCRFvDFP1fszvn8=UbgArtAyU5P97r=X7QdnGbUQCkaOcw@mail.gmail.com>
 <2c1fefc8-a554-3876-91ed-27e2d77d6f12@gmail.com>
Message-ID: <CAHqSRuR=VLGtatNfty7sHA4aBNPxU-y0PfJiyN-gAR65V5hkGw@mail.gmail.com>

Why should it make an exception for cases where the about-to-be-assigned-to
name is present in the global environment?  I think it should warn or give
an error if the altered variable is in any environment on the search list.

-Bill

On Sun, Mar 19, 2023 at 10:54?AM Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:

> I think that should be the default behaviour. It's pretty late to get
> that into R 4.3.0, but I think your proposal (with check.superassignment
> = FALSE being the default) could make it in, and 4.4.0 could change the
> default to TRUE.
>
> Duncan
>
>
>
> On 19/03/2023 12:08 p.m., Henrik Bengtsson wrote:
> > I'd like to be able to prevent the <<- assignment operator ("super
> > assignment") from assigning to the global environment unless the
> > variable already exists and is not locked.  If it does not exist or is
> > locked, I'd like an error to be produced.  This would allow me to
> > evaluate expressions with this temporarily set to protect against
> > mistakes.
> >
> > For example, I'd like to do something like:
> >
> > $ R --vanilla
> >> exists("a")
> > [1] FALSE
> >
> >> options(check.superassignment = TRUE)
> >> local({ a <<- 1 })
> > Error: object 'a' not found
> >
> >> a <- 0
> >> local({ a <<- 1 })
> >> a
> > [1] 1
> >
> >> rm("a")
> >> options(check.superassignment = FALSE)
> >> local({ a <<- 1 })
> >> exists("a")
> > [1] TRUE
> >
> >
> > BACKGROUND:
> >
> >  From help("<<-") we have:
> >
> > "The operators <<- and ->> are normally only used in functions, and
> > cause a search to be made through parent environments for an existing
> > definition of the variable being assigned. If such a variable is found
> > (and its binding is not locked) then its value is redefined, otherwise
> > assignment takes place in the global environment."
> >
> > I argue that it's unfortunate that <<- fallbacks back to assigning to
> > the global environment if the variable does not already exist.
> > Unfortunately, it has become a "go to" solution for many to use it
> > that way.  Sometimes it is intended, sometimes it's a mistake.  We
> > find it also in R packages on CRAN, even if 'R CMD check' tries to
> > detect when it happens (but it's limited to do so from run-time
> > examples and tests).
> >
> > It's probably too widely used for us to change to a more strict
> > behavior permanent.  The proposed R option allows me, as a developer,
> > to evaluate an R expression with the strict behavior, especially if I
> > don't trust the code.
> >
> > With 'check.superassignment = TRUE' set, a developer would have to
> > first declare the variable in the global environment for <<- to assign
> > there.  This would remove the fallback "If such a variable is found
> > (and its binding is not locked) then its value is redefined, otherwise
> > assignment takes place in the global environment" in the current
> > design.  For those who truly intends to assign to the global, could
> > use assign(var, value, envir = globalenv()) or globalenv()[[var]] <-
> > value.
> >
> > 'R CMD check' could temporarily set 'check.superassignment = TRUE'
> > during checks.  If we let environment variable
> > 'R_CHECK_SUPERASSIGNMENT' set the default value of option
> > 'check.superassignment' on R startup, it would be possible to check
> > packages optionally this way, but also to run any "non-trusted" R
> > script in the "strict" mode.
> >
> >
> > TEASER:
> >
> > Here's an example why using <<- for assigning to the global
> > environment is a bad idea:
> >
> > This works:
> >
> > $ R --vanilla
> >> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
> >> keep
> >> [1] 3
> >
> >
> > This doesn't work:
> >
> > $ R --vanilla
> >> library(purrr)
> >> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
> > Error in keep <<- x : cannot change value of locked binding for 'keep'
> >
> >
> > But, if we "declare" the variable first, it works:
> >
> > $ R --vanilla
> >> library(purrr)
> >> keep <- 0
> >> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
> >> keep
> >> [1] 3
> >
> > /Henrik
> >
> > PS. Does the <<- operator have an official name? Hadley calls it
> > "super assignment" in 'Advanced R'
> > (https://adv-r.hadley.nz/environments.html), which is where I got it
> > from.
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From henr|k@bengt@@on @end|ng |rom gm@||@com  Sun Mar 19 19:20:56 2023
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Sun, 19 Mar 2023 11:20:56 -0700
Subject: [Rd] CRAN 'R Sources' page: Provide link to
 https://svn.r-project.org/R/
Message-ID: <CAFDcVCSCu=P464E8-N_VcCizAnY0PsTfcHOBnJuBGKy=HVeUcQ@mail.gmail.com>

Not sure who is the webadmin for
https://cran.r-project.org/sources.html, so posting it here:

I just noticed it's not straightforward to find the Subversion URL for
the R source code.  A natural search would be to go to
https://cran.r-project.org/, then click 'Source code' to get to
https://cran.r-project.org/sources.html.  That page does mention
"Subversion tree", but it gives not URL for it.  I'd like to suggest
adding it in parentheses, as in:

"The above archives are created automatically from the Subversion tree
(https://svn.r-project.org/R/), hence might not even compile on your
platform and can contain any number of bugs. They will probably work,
but maybe not. Use them to verify whether a bug you're tracking has
been fixed or a new feature you always wanted has already been
implemented."

Thanks,

Henrik


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Mar 19 19:33:31 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sun, 19 Mar 2023 14:33:31 -0400
Subject: [Rd] WISH: Optional mechanism preventing var <<- value from
 assigning non-existing variable
In-Reply-To: <CAHqSRuR=VLGtatNfty7sHA4aBNPxU-y0PfJiyN-gAR65V5hkGw@mail.gmail.com>
References: <CAFDcVCRFvDFP1fszvn8=UbgArtAyU5P97r=X7QdnGbUQCkaOcw@mail.gmail.com>
 <2c1fefc8-a554-3876-91ed-27e2d77d6f12@gmail.com>
 <CAHqSRuR=VLGtatNfty7sHA4aBNPxU-y0PfJiyN-gAR65V5hkGw@mail.gmail.com>
Message-ID: <c7892263-98b1-99d0-f22b-225a1e0b81a6@gmail.com>

On 19/03/2023 2:15 p.m., Bill Dunlap wrote:
> Why should it make an exception for cases where the 
> about-to-be-assigned-to name is present in the global environment?? I 
> think it should warn or give an error if the altered variable is in any 
> environment on the search list.

I'd say code like this should work:

   x <- NULL
   f <- function() x <<- 123
   f()

and then x should be changed to 123 unless the binding to x is locked. 
I don't see why it should matter if this code is in local() or in a 
function, or if it is run at the top level.

For most things on the search list, the binding would be locked, but we 
do allow people to attach environments, and then they'd be on the search 
list, so this code should work too:

   g <- function() {

     attach(environment())

     x <- NULL
     f <- function() x <<- 123
     f()

   }

What shouldn't work would be something like

   mean <<- 3

but it already doesn't work (contrary to the documentation), giving

   Error: cannot change value of locked binding for 'mean'

(which makes sense; what if I locked a binding in the global 
environment?  Then we'd go to the fallback, but the fallback can't work, 
because the binding is already there but locked...)

Duncan Murdoch

> 
> -Bill
> 
> On Sun, Mar 19, 2023 at 10:54?AM Duncan Murdoch 
> <murdoch.duncan at gmail.com <mailto:murdoch.duncan at gmail.com>> wrote:
> 
>     I think that should be the default behaviour. It's pretty late to get
>     that into R 4.3.0, but I think your proposal (with
>     check.superassignment
>     = FALSE being the default) could make it in, and 4.4.0 could change the
>     default to TRUE.
> 
>     Duncan
> 
> 
> 
>     On 19/03/2023 12:08 p.m., Henrik Bengtsson wrote:
>      > I'd like to be able to prevent the <<- assignment operator ("super
>      > assignment") from assigning to the global environment unless the
>      > variable already exists and is not locked.? If it does not exist
>     or is
>      > locked, I'd like an error to be produced.? This would allow me to
>      > evaluate expressions with this temporarily set to protect against
>      > mistakes.
>      >
>      > For example, I'd like to do something like:
>      >
>      > $ R --vanilla
>      >> exists("a")
>      > [1] FALSE
>      >
>      >> options(check.superassignment = TRUE)
>      >> local({ a <<- 1 })
>      > Error: object 'a' not found
>      >
>      >> a <- 0
>      >> local({ a <<- 1 })
>      >> a
>      > [1] 1
>      >
>      >> rm("a")
>      >> options(check.superassignment = FALSE)
>      >> local({ a <<- 1 })
>      >> exists("a")
>      > [1] TRUE
>      >
>      >
>      > BACKGROUND:
>      >
>      >? From help("<<-") we have:
>      >
>      > "The operators <<- and ->> are normally only used in functions, and
>      > cause a search to be made through parent environments for an existing
>      > definition of the variable being assigned. If such a variable is
>     found
>      > (and its binding is not locked) then its value is redefined,
>     otherwise
>      > assignment takes place in the global environment."
>      >
>      > I argue that it's unfortunate that <<- fallbacks back to assigning to
>      > the global environment if the variable does not already exist.
>      > Unfortunately, it has become a "go to" solution for many to use it
>      > that way.? Sometimes it is intended, sometimes it's a mistake.? We
>      > find it also in R packages on CRAN, even if 'R CMD check' tries to
>      > detect when it happens (but it's limited to do so from run-time
>      > examples and tests).
>      >
>      > It's probably too widely used for us to change to a more strict
>      > behavior permanent.? The proposed R option allows me, as a developer,
>      > to evaluate an R expression with the strict behavior, especially if I
>      > don't trust the code.
>      >
>      > With 'check.superassignment = TRUE' set, a developer would have to
>      > first declare the variable in the global environment for <<- to
>     assign
>      > there.? This would remove the fallback "If such a variable is found
>      > (and its binding is not locked) then its value is redefined,
>     otherwise
>      > assignment takes place in the global environment" in the current
>      > design.? For those who truly intends to assign to the global, could
>      > use assign(var, value, envir = globalenv()) or globalenv()[[var]] <-
>      > value.
>      >
>      > 'R CMD check' could temporarily set 'check.superassignment = TRUE'
>      > during checks.? If we let environment variable
>      > 'R_CHECK_SUPERASSIGNMENT' set the default value of option
>      > 'check.superassignment' on R startup, it would be possible to check
>      > packages optionally this way, but also to run any "non-trusted" R
>      > script in the "strict" mode.
>      >
>      >
>      > TEASER:
>      >
>      > Here's an example why using <<- for assigning to the global
>      > environment is a bad idea:
>      >
>      > This works:
>      >
>      > $ R --vanilla
>      >> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
>      >> keep
>      >> [1] 3
>      >
>      >
>      > This doesn't work:
>      >
>      > $ R --vanilla
>      >> library(purrr)
>      >> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
>      > Error in keep <<- x : cannot change value of locked binding for
>     'keep'
>      >
>      >
>      > But, if we "declare" the variable first, it works:
>      >
>      > $ R --vanilla
>      >> library(purrr)
>      >> keep <- 0
>      >> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
>      >> keep
>      >> [1] 3
>      >
>      > /Henrik
>      >
>      > PS. Does the <<- operator have an official name? Hadley calls it
>      > "super assignment" in 'Advanced R'
>      > (https://adv-r.hadley.nz/environments.html
>     <https://adv-r.hadley.nz/environments.html>), which is where I got it
>      > from.
>      >
>      > ______________________________________________
>      > R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>      > https://stat.ethz.ch/mailman/listinfo/r-devel
>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
> 
>     ______________________________________________
>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>     https://stat.ethz.ch/mailman/listinfo/r-devel
>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>


From g@bembecker @end|ng |rom gm@||@com  Sun Mar 19 19:43:58 2023
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Sun, 19 Mar 2023 11:43:58 -0700
Subject: [Rd] WISH: Optional mechanism preventing var <<- value from
 assigning non-existing variable
In-Reply-To: <CAHqSRuR=VLGtatNfty7sHA4aBNPxU-y0PfJiyN-gAR65V5hkGw@mail.gmail.com>
References: <CAFDcVCRFvDFP1fszvn8=UbgArtAyU5P97r=X7QdnGbUQCkaOcw@mail.gmail.com>
 <2c1fefc8-a554-3876-91ed-27e2d77d6f12@gmail.com>
 <CAHqSRuR=VLGtatNfty7sHA4aBNPxU-y0PfJiyN-gAR65V5hkGw@mail.gmail.com>
Message-ID: <CAD4oTHF2sMYQseEgs-cr7hoggGgjFrVdxHyWTEtMLmxbESLyHA@mail.gmail.com>

I have to say <<- is a core debugging tool when assigning into the global
environment. I suppose I could use assign but that would be somewhat
annoying.

That said I'm still for this change, the vast overwhelming number of times
that <<- is in my package code - already rare but it does happen - it would
absolutely be a bug (typo most likely) for it to get to the global
environment and assign into it. Assigning into thr global environment from
package code is a serious anti pattern anyway.

To be honest from the developer perspective what id personally actually
want is an assigner that was willing to go up exactly one frame from the
current one to find its binding. That is how I essentially always am using
<<- myself.

~G

On Sun, Mar 19, 2023, 11:16 AM Bill Dunlap <williamwdunlap at gmail.com> wrote:

> Why should it make an exception for cases where the about-to-be-assigned-to
> name is present in the global environment?  I think it should warn or give
> an error if the altered variable is in any environment on the search list.
>
> -Bill
>
> On Sun, Mar 19, 2023 at 10:54?AM Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
>
> > I think that should be the default behaviour. It's pretty late to get
> > that into R 4.3.0, but I think your proposal (with check.superassignment
> > = FALSE being the default) could make it in, and 4.4.0 could change the
> > default to TRUE.
> >
> > Duncan
> >
> >
> >
> > On 19/03/2023 12:08 p.m., Henrik Bengtsson wrote:
> > > I'd like to be able to prevent the <<- assignment operator ("super
> > > assignment") from assigning to the global environment unless the
> > > variable already exists and is not locked.  If it does not exist or is
> > > locked, I'd like an error to be produced.  This would allow me to
> > > evaluate expressions with this temporarily set to protect against
> > > mistakes.
> > >
> > > For example, I'd like to do something like:
> > >
> > > $ R --vanilla
> > >> exists("a")
> > > [1] FALSE
> > >
> > >> options(check.superassignment = TRUE)
> > >> local({ a <<- 1 })
> > > Error: object 'a' not found
> > >
> > >> a <- 0
> > >> local({ a <<- 1 })
> > >> a
> > > [1] 1
> > >
> > >> rm("a")
> > >> options(check.superassignment = FALSE)
> > >> local({ a <<- 1 })
> > >> exists("a")
> > > [1] TRUE
> > >
> > >
> > > BACKGROUND:
> > >
> > >  From help("<<-") we have:
> > >
> > > "The operators <<- and ->> are normally only used in functions, and
> > > cause a search to be made through parent environments for an existing
> > > definition of the variable being assigned. If such a variable is found
> > > (and its binding is not locked) then its value is redefined, otherwise
> > > assignment takes place in the global environment."
> > >
> > > I argue that it's unfortunate that <<- fallbacks back to assigning to
> > > the global environment if the variable does not already exist.
> > > Unfortunately, it has become a "go to" solution for many to use it
> > > that way.  Sometimes it is intended, sometimes it's a mistake.  We
> > > find it also in R packages on CRAN, even if 'R CMD check' tries to
> > > detect when it happens (but it's limited to do so from run-time
> > > examples and tests).
> > >
> > > It's probably too widely used for us to change to a more strict
> > > behavior permanent.  The proposed R option allows me, as a developer,
> > > to evaluate an R expression with the strict behavior, especially if I
> > > don't trust the code.
> > >
> > > With 'check.superassignment = TRUE' set, a developer would have to
> > > first declare the variable in the global environment for <<- to assign
> > > there.  This would remove the fallback "If such a variable is found
> > > (and its binding is not locked) then its value is redefined, otherwise
> > > assignment takes place in the global environment" in the current
> > > design.  For those who truly intends to assign to the global, could
> > > use assign(var, value, envir = globalenv()) or globalenv()[[var]] <-
> > > value.
> > >
> > > 'R CMD check' could temporarily set 'check.superassignment = TRUE'
> > > during checks.  If we let environment variable
> > > 'R_CHECK_SUPERASSIGNMENT' set the default value of option
> > > 'check.superassignment' on R startup, it would be possible to check
> > > packages optionally this way, but also to run any "non-trusted" R
> > > script in the "strict" mode.
> > >
> > >
> > > TEASER:
> > >
> > > Here's an example why using <<- for assigning to the global
> > > environment is a bad idea:
> > >
> > > This works:
> > >
> > > $ R --vanilla
> > >> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
> > >> keep
> > >> [1] 3
> > >
> > >
> > > This doesn't work:
> > >
> > > $ R --vanilla
> > >> library(purrr)
> > >> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
> > > Error in keep <<- x : cannot change value of locked binding for 'keep'
> > >
> > >
> > > But, if we "declare" the variable first, it works:
> > >
> > > $ R --vanilla
> > >> library(purrr)
> > >> keep <- 0
> > >> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
> > >> keep
> > >> [1] 3
> > >
> > > /Henrik
> > >
> > > PS. Does the <<- operator have an official name? Hadley calls it
> > > "super assignment" in 'Advanced R'
> > > (https://adv-r.hadley.nz/environments.html), which is where I got it
> > > from.
> > >
> > > ______________________________________________
> > > R-devel at r-project.org mailing list
> > > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Mar 19 20:39:41 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sun, 19 Mar 2023 15:39:41 -0400
Subject: [Rd] WISH: Optional mechanism preventing var <<- value from
 assigning non-existing variable
In-Reply-To: <CAD4oTHF2sMYQseEgs-cr7hoggGgjFrVdxHyWTEtMLmxbESLyHA@mail.gmail.com>
References: <CAFDcVCRFvDFP1fszvn8=UbgArtAyU5P97r=X7QdnGbUQCkaOcw@mail.gmail.com>
 <2c1fefc8-a554-3876-91ed-27e2d77d6f12@gmail.com>
 <CAHqSRuR=VLGtatNfty7sHA4aBNPxU-y0PfJiyN-gAR65V5hkGw@mail.gmail.com>
 <CAD4oTHF2sMYQseEgs-cr7hoggGgjFrVdxHyWTEtMLmxbESLyHA@mail.gmail.com>
Message-ID: <2a9cbd8f-7e5a-30a2-3f60-f5b1ac4e0095@gmail.com>

On 19/03/2023 2:43 p.m., Gabriel Becker wrote:
> I have to say <<- is a core debugging tool when assigning into the 
> global environment. I suppose I could use assign but that would be 
> somewhat annoying.
> 
> That said I'm still for this change, the vast overwhelming number of 
> times that <<- is in my package code - already rare but it does happen - 
> it would absolutely be a bug (typo most likely) for it to get to the 
> global environment and assign into it. Assigning into thr global 
> environment from package code is a serious anti pattern anyway.
> 
> To be honest from the developer perspective what id personally actually 
> want is an assigner that was willing to go up exactly one frame from the 
> current one to find its binding. That is how I essentially always am 
> using <<- myself.

This sounds like a linter would be appropriate:  any time you make an 
assignment that goes more than one level up, it warns you about it.

Other linter rules could limit the destination in other ways, e.g. 
assigning to globalenv() or things in the search list could be disallowed.

Another error I've made a few times is to use "<-" by mistake when "<<-" 
was intended.  A linter could detect this by seeing both `x <- value1` 
and `x <<- value2` in the same context.  That's legal, but (for me at 
least) it usually indicates that one of them is a typo.

Duncan Murdoch

> 
> ~G
> 
> On Sun, Mar 19, 2023, 11:16 AM Bill Dunlap <williamwdunlap at gmail.com 
> <mailto:williamwdunlap at gmail.com>> wrote:
> 
>     Why should it make an exception for cases where the
>     about-to-be-assigned-to
>     name is present in the global environment?? I think it should warn
>     or give
>     an error if the altered variable is in any environment on the search
>     list.
> 
>     -Bill
> 
>     On Sun, Mar 19, 2023 at 10:54?AM Duncan Murdoch
>     <murdoch.duncan at gmail.com <mailto:murdoch.duncan at gmail.com>>
>     wrote:
> 
>      > I think that should be the default behaviour. It's pretty late to get
>      > that into R 4.3.0, but I think your proposal (with
>     check.superassignment
>      > = FALSE being the default) could make it in, and 4.4.0 could
>     change the
>      > default to TRUE.
>      >
>      > Duncan
>      >
>      >
>      >
>      > On 19/03/2023 12:08 p.m., Henrik Bengtsson wrote:
>      > > I'd like to be able to prevent the <<- assignment operator ("super
>      > > assignment") from assigning to the global environment unless the
>      > > variable already exists and is not locked.? If it does not
>     exist or is
>      > > locked, I'd like an error to be produced.? This would allow me to
>      > > evaluate expressions with this temporarily set to protect against
>      > > mistakes.
>      > >
>      > > For example, I'd like to do something like:
>      > >
>      > > $ R --vanilla
>      > >> exists("a")
>      > > [1] FALSE
>      > >
>      > >> options(check.superassignment = TRUE)
>      > >> local({ a <<- 1 })
>      > > Error: object 'a' not found
>      > >
>      > >> a <- 0
>      > >> local({ a <<- 1 })
>      > >> a
>      > > [1] 1
>      > >
>      > >> rm("a")
>      > >> options(check.superassignment = FALSE)
>      > >> local({ a <<- 1 })
>      > >> exists("a")
>      > > [1] TRUE
>      > >
>      > >
>      > > BACKGROUND:
>      > >
>      > >? From help("<<-") we have:
>      > >
>      > > "The operators <<- and ->> are normally only used in functions, and
>      > > cause a search to be made through parent environments for an
>     existing
>      > > definition of the variable being assigned. If such a variable
>     is found
>      > > (and its binding is not locked) then its value is redefined,
>     otherwise
>      > > assignment takes place in the global environment."
>      > >
>      > > I argue that it's unfortunate that <<- fallbacks back to
>     assigning to
>      > > the global environment if the variable does not already exist.
>      > > Unfortunately, it has become a "go to" solution for many to use it
>      > > that way.? Sometimes it is intended, sometimes it's a mistake.? We
>      > > find it also in R packages on CRAN, even if 'R CMD check' tries to
>      > > detect when it happens (but it's limited to do so from run-time
>      > > examples and tests).
>      > >
>      > > It's probably too widely used for us to change to a more strict
>      > > behavior permanent.? The proposed R option allows me, as a
>     developer,
>      > > to evaluate an R expression with the strict behavior,
>     especially if I
>      > > don't trust the code.
>      > >
>      > > With 'check.superassignment = TRUE' set, a developer would have to
>      > > first declare the variable in the global environment for <<- to
>     assign
>      > > there.? This would remove the fallback "If such a variable is found
>      > > (and its binding is not locked) then its value is redefined,
>     otherwise
>      > > assignment takes place in the global environment" in the current
>      > > design.? For those who truly intends to assign to the global, could
>      > > use assign(var, value, envir = globalenv()) or
>     globalenv()[[var]] <-
>      > > value.
>      > >
>      > > 'R CMD check' could temporarily set 'check.superassignment = TRUE'
>      > > during checks.? If we let environment variable
>      > > 'R_CHECK_SUPERASSIGNMENT' set the default value of option
>      > > 'check.superassignment' on R startup, it would be possible to check
>      > > packages optionally this way, but also to run any "non-trusted" R
>      > > script in the "strict" mode.
>      > >
>      > >
>      > > TEASER:
>      > >
>      > > Here's an example why using <<- for assigning to the global
>      > > environment is a bad idea:
>      > >
>      > > This works:
>      > >
>      > > $ R --vanilla
>      > >> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
>      > >> keep
>      > >> [1] 3
>      > >
>      > >
>      > > This doesn't work:
>      > >
>      > > $ R --vanilla
>      > >> library(purrr)
>      > >> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
>      > > Error in keep <<- x : cannot change value of locked binding for
>     'keep'
>      > >
>      > >
>      > > But, if we "declare" the variable first, it works:
>      > >
>      > > $ R --vanilla
>      > >> library(purrr)
>      > >> keep <- 0
>      > >> y <- lapply(1:3, function(x) { if (x > 2) keep <<- x; x^2 })
>      > >> keep
>      > >> [1] 3
>      > >
>      > > /Henrik
>      > >
>      > > PS. Does the <<- operator have an official name? Hadley calls it
>      > > "super assignment" in 'Advanced R'
>      > > (https://adv-r.hadley.nz/environments.html
>     <https://adv-r.hadley.nz/environments.html>), which is where I got it
>      > > from.
>      > >
>      > > ______________________________________________
>      > > R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>      > > https://stat.ethz.ch/mailman/listinfo/r-devel
>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>      >
>      > ______________________________________________
>      > R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>      > https://stat.ethz.ch/mailman/listinfo/r-devel
>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>      >
> 
>      ? ? ? ? [[alternative HTML version deleted]]
> 
>     ______________________________________________
>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>     https://stat.ethz.ch/mailman/listinfo/r-devel
>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>


From pd@|gd @end|ng |rom gm@||@com  Tue Mar 21 10:46:41 2023
From: pd@|gd @end|ng |rom gm@||@com (peter dalgaard)
Date: Tue, 21 Mar 2023 10:46:41 +0100
Subject: [Rd] R 4.3.0 scheduled for April 21
Message-ID: <FD365656-05E1-4962-8238-2A850FF7D972@gmail.com>

Full schedule is available on developer.r-project.org (pending update from SVN).

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From @ndre|@ko@tyrk@ @end|ng |rom gm@||@com  Tue Mar 21 01:59:38 2023
From: @ndre|@ko@tyrk@ @end|ng |rom gm@||@com (=?UTF-8?Q?Andre=C3=AF_V=2E_Kostyrka?=)
Date: Tue, 21 Mar 2023 01:59:38 +0100
Subject: [Rd] Floating-point-related surprising behaviour in
 boot:::norm.inter
Message-ID: <CAFnf=nqhRfHdQM3Tz5QccHy9NU8M5NJp11Y_D-8fk+YeucUFoQ@mail.gmail.com>

Dear all,

I have been implementing some bootstrap-related methods, and came across
this theoretically undesirable behaviour in the computation of bootstrap
quantiles. The manual says:

?Interpolation on the normal quantile scale is used when a non-integer
order statistic is required.?

Theoretically, when R=999 and (R+1)*alpha is integer, then, the
calculations of the 95% CI should never contain non-integer order
statistics, right?

No ? due to the fractional nature of the probabilities. Consider R=999 and
conf=0.95; then, the second argument to boot:::norm.inter is

alpha <- (1 + c(conf, -conf))/2
print(alpha, 20) # c(0.974999999999999977796, 0.025000000000000022204)
# print(0.025, 20) yields 0.025000000000000001388

Looks like both numbers times (B+1) should not be integers, right?.. Oddly
enough, one of them is integer, and one of them isn?t:

R <- 999
rk <- (R + 1) * alpha
k <- trunc(rk)
ints <- (k == rk) # TRUE FALSE

k - rk # 0.000000e+00 -2.131628e-14

This is why the subsequent variable `temp` (containing the indices of
non-integer order statistics) becomes equal to 2.

Yes, the amount of correction due to interpolation is minuscule (around
1e-16), but this code should not have been invoked in the first place. This
kind of unintended behaviour can be prevented through a more relaxed check:

ints <- abs(k - rk) < R * .Machine$double.eps

The FP-related error is proportional to R, e.g. if R=99999, then, abs(k -
rk) = 0.000000e+00 2.273737e-12). Therefore, I believe that fuzzy
comparison (with tolerance proportional to R) should replace the faulty
strict-equality-based one. Then, a check can be carried out based on `if
(any(!ints))` to invoke the interpolation only if the order statistics are
really non-integer.

Yours sincerely,
Andre? V. Kostyrka

	[[alternative HTML version deleted]]


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Wed Mar 22 17:00:30 2023
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Wed, 22 Mar 2023 17:00:30 +0100
Subject: [Rd] Versioning Rtools ARP entries
In-Reply-To: <d45cbe35-c093-ff9e-f31d-48f3144f7568@gmail.com>
References: <CANu2KkPeXi3=0=KyvjfELrE1A_aRO1yrbqmRPavKo-3siJZ_og@mail.gmail.com>
 <d45cbe35-c093-ff9e-f31d-48f3144f7568@gmail.com>
Message-ID: <f426b0b8-eeed-24b7-993f-643946bda953@gmail.com>


On 3/13/23 17:57, Tomas Kalibera wrote:
>
> On 3/13/23 17:31, Daniel Possenriede wrote:
>> Hi,
>>
>> If I am not mistaken, all Rtools 4.2 (and 4.3) revisions have the same
>> ARP [1] entries, i.e. all report version 4.2.0.1 (or 4.3.0.1). This
>> makes it difficult to determine the installed version (is it possible
>> to determine the installed revision?) and impossible for tools like
>> winget [2] to update Rtools to the latest revision, AFAICT.
>>
>> Would it be possible to track the version in the installer [3] for
>> future Rtools releases again, like it used to be in Rtools 4.0 [4]?
>
> Well the thing is that once you install Rtools 42/43, you can then 
> upgrade it internally (without Windows knowing). You can upgrade the 
> Msys2 part, or the MXE part, or both. The MXE part (customized for 
> Rtools) does have a single version number, which can be found in the 
> installation. The Msys2 part doesn't, afaik.
>
> See e.g. "Upgrading Rtools43" in 
> https://cran.r-project.org/bin/windows/base/howto-R-devel.html for how 
> to upgrade and how to find out the current version number of the MXE 
> part.
>
> So, right, I could e.g. add a non-decreasing unique version to the 
> build of the installer (e.g. based on that from the SVN where it lives 
> and the MXE part version originally included), but I doubt how useful 
> that would be, given that a particular installation can be 
> upgraded/modified by the user. It could actually be misleading.
>
> Note Rtools40 also could be updated by the user internally.

Hi Daniel,

I've extended the version information in a testing version of an update 
of Rtools43, more below, but first with some explanation of how the 
versioning works.

A version of an installed program in Windows is stored in the registry 
as "Display version": this is shown, together with "Display name" in the 
"Add/Remove programs menu" and it is used by tools such as winget to 
determine the version of an installed application (so e.g. also in 
"winget list").

An installer in Windows has in its meta-data has a "Product version" and 
a "File version" - one can see them in the Windows explorer via 
"Properties/Details". This can be set also for other files, not only for 
.EXEs of installers.? The distinction for general files is that "File 
version" refers to the individual file and "Product version" (shared for 
many files) to the application. The distinction for installers is 
usually that "File version" refers to the installer, but "Product 
version" to the application.

A Windows installer may set the display version and display name for the 
application it is installing, usually at the end. Many installers, 
including that of Rtools, don't do that explicitly, and a "Product 
version" from the installer meta-data is used, instead, for the display 
version. A "Product name" is used for the display name. In Inno Setup, 
used by R and Rtools, "Product version" is given by "AppVersion", "File 
version" by "VersionInfoVersion", and "Product name" by 
"UninstallDisplayName" (there are also some rules to take these values 
from other entries when not specified, more in Inno Setup documentation).

Historically, Rtools installer used two-component product version, e.g. 
"4.2" or "4.0". Therefore, winget could offer an upgrade from say 
Rtools40 Rtools42, but not between individual version of Rtools40 or 
Rtool42. The changes in file version you referred to in [4] didn't make 
a difference, because the "product version" stayed the same.

In the testing version of Rtools43, I've added one more component to the 
product version, which is the version of the toolchain+libraries (e.g. 
4.3.5548). So, one can now see the version of the toolchain+libraries in 
the "Add/Remove programs" list, and winget could (be made to) support 
upgrades within say Rtools43. Winget registry is maintained 
independently of R/Rtools, so it is up to those maintainer if they do 
that or not, but it should now be easy since product version has the 
information.

I've also extended the file version to have four components, e.g. 
4.3.5550.5548, where the last component is the version of the scripts to 
build the installer. This corresponds to version in the file name, e.g. 
rtools43-5550-5548.exe. The original file name is now also part of the 
meta-data.

When one manually upgrades the toolchain+libraries in an existing 
Rtools43 installation, the version information stored in the registry 
should be updated and the documentation will say how to do that (how to 
change the registry accordingly).

Best
Tomas

>
> Tomas
>
>>
>> Thanks!
>>
>> Daniel
>>
>> [1] 
>> https://github.com/microsoft/winget-pkgs/blob/master/FAQ.md#what-is-an-arp-entry
>> [2] https://github.com/microsoft/winget-cli
>> [3] 
>> https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/rtools/rtools64.iss
>> [4] 
>> https://github.com/r-windows/rtools-installer/commit/7f23f0d0442d72922014ec4082c8bdd437364cef
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel


From |uc@r @end|ng |rom |edor@project@org  Thu Mar 23 11:00:44 2023
From: |uc@r @end|ng |rom |edor@project@org (=?UTF-8?Q?I=C3=B1aki_Ucar?=)
Date: Thu, 23 Mar 2023 11:00:44 +0100
Subject: [Rd] Enable curl 8
Message-ID: <CALEXWq2a_ZodJOa+wtQnyaVby+=d=1_YLOyYVatA+io4+zh+hQ@mail.gmail.com>

Hi,

Just a heads-up that curl 8 landed in Fedora Rawhide a couple of days
ago. Note that R does **not** compile without a small fix [1] that
allows the configuration to continue if the major version is > 7.

[1] https://src.fedoraproject.org/rpms/R/blob/rawhide/f/R-4.2.3-curl-v8.patch

Best,
-- 
I?aki ?car


From kry|ov@r00t @end|ng |rom gm@||@com  Thu Mar 23 11:05:37 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Thu, 23 Mar 2023 13:05:37 +0300
Subject: [Rd] `dendrapply` Enhancements
In-Reply-To: <BL0PR04MB4706C5E54A0C323647098D76D9B29@BL0PR04MB4706.namprd04.prod.outlook.com>
References: <BL0PR04MB47068D544F5A49315EF1D042D9AB9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <CALK03d1PWiA4tfbRkxMBU6tckhfB2JRGUmnuqh5ygLcCLHDXNw@mail.gmail.com>
 <BL0PR04MB4706A66884728B9419CEAE00D9A89@BL0PR04MB4706.namprd04.prod.outlook.com>
 <BL0PR04MB4706B185A345A98AB4AB829AD9AC9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <20230302174750.19c3b247@arachnoid>
 <BL0PR04MB47069CCBD8C6EB57BB22533ED9B29@BL0PR04MB4706.namprd04.prod.outlook.com>
 <BL0PR04MB4706F5BC72B6331815DC1DFDD9B29@BL0PR04MB4706.namprd04.prod.outlook.com>
 <BL0PR04MB4706C5E54A0C323647098D76D9B29@BL0PR04MB4706.namprd04.prod.outlook.com>
Message-ID: <20230323130537.65f1c69e@arachnoid>

Hello Aidan,

Sorry for dropping this for a while.

? Thu, 2 Mar 2023 21:03:59 +0000
"Lakshman, Aidan H" <AHL27 at pitt.edu> ?????:

> //after
> curnode = eval(lang3(R_Bracket2Symbol, parent->node, DEND_IND), env);

lang3() always constructs a new language object. If you do end up using
eval(), it may make sense to move lang3() out of the loop and reuse the
existing object by referring to the DEND_IND variable using its symbol,
like it's done in the lapply() implementation.

> The problem is, it seems like the returned value from `eval` is not
> protected, whereas the value from VECTOR_ELT is (if the source list
> is protected). My understanding is that this happens because
> VECTOR_ELT just copies the pointer, whereas eval(?) calls R code,
> which returns a copy of the object.

That's right, `[[.dendrogram` returns a new object which is not
protected, unlike the raw elements of node that you're keeping a
protected pointer to.

> This ends up being problematic, since it isn?t feasible to protect
> all the nodes until we?re done with them.

I see. It's not easy in R to unprotect arbitrary previously-allocated
objects in a safe way. Have you considered "precious multi-sets"
<https://blog.r-project.org/2018/12/10/unprotecting-by-value/index.html>?
They have R_ReleaseFromMSet(), making it possible to free arbitrary
objects from the set, and they automatically unprotect everything they
contain on destruction.

> It?s also possible to use eval(?) to get the node, apply the function
> to it, save its class in the linked list, and then save the object
> using VECTOR_ELT. This way we get the benefits of `[[` dispatch,
> class preservation, and constant stack space. However, this ends up
> hurting performance significantly (about 4x slower than the current
> new version, making it around half the speed of the version in stats).

That's a clever solution! Can you profile the code to see if there are
visible sources of slowdown? Maybe this can be salvaged.

-- 
Best regards,
Ivan


From c@@rd|@g@bor @end|ng |rom gm@||@com  Thu Mar 23 12:01:24 2023
From: c@@rd|@g@bor @end|ng |rom gm@||@com (=?UTF-8?B?R8OhYm9yIENzw6FyZGk=?=)
Date: Thu, 23 Mar 2023 12:01:24 +0100
Subject: [Rd] Edge case in rm() now failing in R-devel
Message-ID: <CABtg=KkLjFaUqgUy63OEwvB7Tje4g+HgcWGVrErLou72vATPaw@mail.gmail.com>

This is new in R-devel:

> rm(list = NULL)
Error in rm(list = NULL) : invalid first argument

It still works in r84020, but does not in r84023, possibly because of
r84022 [1].

Gabor

[1] https://github.com/wch/r-source/commit/4dc057f5d49d3c0590488100e418e39b68682c95


From AHL27 @end|ng |rom p|tt@edu  Thu Mar 23 12:27:42 2023
From: AHL27 @end|ng |rom p|tt@edu (Lakshman, Aidan H)
Date: Thu, 23 Mar 2023 11:27:42 +0000
Subject: [Rd] `dendrapply` Enhancements
In-Reply-To: <20230323130537.65f1c69e@arachnoid>
References: <BL0PR04MB47068D544F5A49315EF1D042D9AB9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <CALK03d1PWiA4tfbRkxMBU6tckhfB2JRGUmnuqh5ygLcCLHDXNw@mail.gmail.com>
 <BL0PR04MB4706A66884728B9419CEAE00D9A89@BL0PR04MB4706.namprd04.prod.outlook.com>
 <BL0PR04MB4706B185A345A98AB4AB829AD9AC9@BL0PR04MB4706.namprd04.prod.outlook.com>
 <20230302174750.19c3b247@arachnoid>
 <BL0PR04MB47069CCBD8C6EB57BB22533ED9B29@BL0PR04MB4706.namprd04.prod.outlook.com>
 <BL0PR04MB4706F5BC72B6331815DC1DFDD9B29@BL0PR04MB4706.namprd04.prod.outlook.com>
 <BL0PR04MB4706C5E54A0C323647098D76D9B29@BL0PR04MB4706.namprd04.prod.outlook.com>
 <20230323130537.65f1c69e@arachnoid>
Message-ID: <BL0PR04MB47062E263CB43FD6DA6E8C7CD9879@BL0PR04MB4706.namprd04.prod.outlook.com>

No problem! I know it?s a lot of code and also not super high priority haha; I appreciate the feedback and comments.

I had looked at precious multi sets, but I wasn?t quite sure how to implement them?the docs mentioned they were mainly intended for the interpreter, and I couldn?t find a ton of code examples to work off of.

Another idea I had was to make use of R-level dendrogram indexing. I recently learned dendrograms support vector indexing, so like dend[[c(1,1)]] == dend[[1]][[1]]. It could theoretically be possible to make the linked list just store the access vectors, and then have the R function execute by taking the root and the vector as input. Theoretically would solve a lot of these issues, but there?s a lot of quirks I can see causing issues.

> That's a clever solution! Can you profile the code to see if there are
> visible sources of slowdown? Maybe this can be salvaged.

Yep, I'll add that to my list. Salvaging the existing solution would definitely be a lot simpler for me than the other options mentioned here :D

When I get back to dendrapply (hopefully later today) I'll look at precious MSets, seeing if a simplification with vector indexing is possible, and profiling the existing code.

Thanks again for taking a look! I really appreciate it.

-Aidan

-----------------------

Aidan Lakshman (he/him)<https://www.ahl27.com/>

Doctoral Candidate, Wright Lab<https://www.wrightlabscience.com/>

University of Pittsburgh School of Medicine

Department of Biomedical Informatics

ahl27 at pitt.edu

(724) 612-9940



________________________________
From: Ivan Krylov <krylov.r00t at gmail.com>
Sent: Thursday, March 23, 2023 6:05:37 AM
To: Lakshman, Aidan H <AHL27 at pitt.edu>
Cc: R-devel at r-project.org <R-devel at r-project.org>
Subject: Re: [Rd] `dendrapply` Enhancements

Hello Aidan,

Sorry for dropping this for a while.

? Thu, 2 Mar 2023 21:03:59 +0000
"Lakshman, Aidan H" <AHL27 at pitt.edu> ?????:

> //after
> curnode = eval(lang3(R_Bracket2Symbol, parent->node, DEND_IND), env);

lang3() always constructs a new language object. If you do end up using
eval(), it may make sense to move lang3() out of the loop and reuse the
existing object by referring to the DEND_IND variable using its symbol,
like it's done in the lapply() implementation.

> The problem is, it seems like the returned value from `eval` is not
> protected, whereas the value from VECTOR_ELT is (if the source list
> is protected). My understanding is that this happens because
> VECTOR_ELT just copies the pointer, whereas eval(?) calls R code,
> which returns a copy of the object.

That's right, `[[.dendrogram` returns a new object which is not
protected, unlike the raw elements of node that you're keeping a
protected pointer to.

> This ends up being problematic, since it isn?t feasible to protect
> all the nodes until we?re done with them.

I see. It's not easy in R to unprotect arbitrary previously-allocated
objects in a safe way. Have you considered "precious multi-sets"
<https://nam12.safelinks.protection.outlook.com/?url=https%3A%2F%2Fblog.r-project.org%2F2018%2F12%2F10%2Funprotecting-by-value%2Findex.html&data=05%7C01%7CAHL27%40pitt.edu%7Ce05bb9d748bf45bd4d0308db2b862883%7C9ef9f489e0a04eeb87cc3a526112fd0d%7C1%7C0%7C638151627427438911%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=3A447zpoQaI1%2BOptiBE8Ix4gXr72VrOdaByvUrHRBbA%3D&reserved=0>?
They have R_ReleaseFromMSet(), making it possible to free arbitrary
objects from the set, and they automatically unprotect everything they
contain on destruction.

> It?s also possible to use eval(?) to get the node, apply the function
> to it, save its class in the linked list, and then save the object
> using VECTOR_ELT. This way we get the benefits of `[[` dispatch,
> class preservation, and constant stack space. However, this ends up
> hurting performance significantly (about 4x slower than the current
> new version, making it around half the speed of the version in stats).

That's a clever solution! Can you profile the code to see if there are
visible sources of slowdown? Maybe this can be salvaged.

--
Best regards,
Ivan

	[[alternative HTML version deleted]]


From |e||pe@contrer@@ @end|ng |rom gm@||@com  Thu Mar 23 20:48:40 2023
From: |e||pe@contrer@@ @end|ng |rom gm@||@com (Felipe Contreras)
Date: Thu, 23 Mar 2023 13:48:40 -0600
Subject: [Rd] Request: better default R_LIBS_USER
In-Reply-To: <CAMP44s2NFqiOP1hYcXvk0MvDDnQ9ZmoQvEk37cRyUW2T_0pqRQ@mail.gmail.com>
References: <CAMP44s2zzqo6iG2ujvhBGL4UsxsOt7e11p81xwWLCEf5Ggperw@mail.gmail.com>
 <25619.37737.873897.49177@rob.eddelbuettel.com>
 <CAMP44s2NFqiOP1hYcXvk0MvDDnQ9ZmoQvEk37cRyUW2T_0pqRQ@mail.gmail.com>
Message-ID: <CAMP44s2JwdYn8ct6Lg3onjGfOwzEpr6e995vRqQhQMs4HS_Apg@mail.gmail.com>

Hi,

Pinging.

On Thu, Mar 16, 2023 at 7:17?PM Felipe Contreras
<felipe.contreras at gmail.com> wrote:
> On Thu, Mar 16, 2023 at 4:08?PM Dirk Eddelbuettel <edd at debian.org> wrote:
> > On 16 March 2023 at 13:39, Felipe Contreras wrote:

> > | R should do the same: it should install packages to somewhere inside
> > | ~/.local by default.

> > rather than asking a few million R users to adjust from past
> > practice.
>
> Why would they have to adjust anything?
>
> Just expand %U to both:
>
>             paste(c(
>             file.path(home, ".local", "lib", "r", x.y),
>             file.path(home, "R", paste0(R.version$platform, "-library"), x.y)
>             ), collapse = ":")
>
> Then R would install packages to the new location in new installations
> by default, but still use packages from the old location if present.

This would work, would it not?

> Moreover, this location is going to change the next time the minor
> version is bumped anyway.

Or just change it for the next version of R.

Cheers.

-- 
Felipe Contreras


From g@bembecker @end|ng |rom gm@||@com  Thu Mar 23 23:57:21 2023
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Thu, 23 Mar 2023 15:57:21 -0700
Subject: [Rd] Request: better default R_LIBS_USER
In-Reply-To: <CAMP44s2JwdYn8ct6Lg3onjGfOwzEpr6e995vRqQhQMs4HS_Apg@mail.gmail.com>
References: <CAMP44s2zzqo6iG2ujvhBGL4UsxsOt7e11p81xwWLCEf5Ggperw@mail.gmail.com>
 <25619.37737.873897.49177@rob.eddelbuettel.com>
 <CAMP44s2NFqiOP1hYcXvk0MvDDnQ9ZmoQvEk37cRyUW2T_0pqRQ@mail.gmail.com>
 <CAMP44s2JwdYn8ct6Lg3onjGfOwzEpr6e995vRqQhQMs4HS_Apg@mail.gmail.com>
Message-ID: <CAD4oTHGLUpap62_1dVoumt9BnLn+UffLmD5d+ZWcre9X7LayDA@mail.gmail.com>

Felipe,

Thanks for being interested in making R better. Its great to see engagement
from a new "virtual face", so to speak. That said, without speaking for
R-core, my experience is that the R-project and R-core team place a very
high premium on backwards compatibility. They will make breaking changes,
on occasion, but its rare and extreme for them to do so. I personally
don't think the amount of convenience/modern conceptual best practices
adherence we're talking about here rises to the level of justifying a
breaking change put in quickly.

As for why I'm calling this a breaking change, see inline:

>

On Thu, Mar 23, 2023 at 12:49?PM Felipe Contreras <
felipe.contreras at gmail.com> wrote:

> > Just expand %U to both:
> >
> >             paste(c(
> >             file.path(home, ".local", "lib", "r", x.y),
> >             file.path(home, "R", paste0(R.version$platform, "-library"),
> x.y)
> >             ), collapse = ":")
> >
> > Then R would install packages to the new location in new installations
> > by default, but still use packages from the old location if present.
>
> This would work, would it not?
>

So off the top of my head, this would mean that people who have versions of
R from before and after that change installed simultaneously would, *by
default* have package libraries that live in completely different places on
the drive.

Does that preclude a change like this from ever being made? No, but it does
seem more like a major version change than a minor version change to me.

For an example of why this could be a breaking change, i'd be willing to
bet there are shell scripts out there which assume the user directories
live at ~user/R/<os>/<version> and detect them as such. Do I think its
common? No. Do I think its the right way to do whatever that shell script
is doing? No, but I'd be surprised if there wasn't code that does it
somewhere. And that code will/would break under your proposed change.


> Moreover, this location is going to change the next time the minor
> > version is bumped anyway.
>
> Or just change it for the next version of R.
>

All of the above said, I do actually agree that it would be nice to change
the default in the long term (including for mac builds from source).
Perhaps this could be put on the list of possible changes for R 5.0, to be
bundled with other as-yet undecided breaking changes, members of R-core
feel the same way.

Best,
~G


> Cheers.
>
> --
> Felipe Contreras
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From g@bembecker @end|ng |rom gm@||@com  Fri Mar 24 01:50:53 2023
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Thu, 23 Mar 2023 17:50:53 -0700
Subject: [Rd] Request: better default R_LIBS_USER
In-Reply-To: <CAD4oTHGLUpap62_1dVoumt9BnLn+UffLmD5d+ZWcre9X7LayDA@mail.gmail.com>
References: <CAMP44s2zzqo6iG2ujvhBGL4UsxsOt7e11p81xwWLCEf5Ggperw@mail.gmail.com>
 <25619.37737.873897.49177@rob.eddelbuettel.com>
 <CAMP44s2NFqiOP1hYcXvk0MvDDnQ9ZmoQvEk37cRyUW2T_0pqRQ@mail.gmail.com>
 <CAMP44s2JwdYn8ct6Lg3onjGfOwzEpr6e995vRqQhQMs4HS_Apg@mail.gmail.com>
 <CAD4oTHGLUpap62_1dVoumt9BnLn+UffLmD5d+ZWcre9X7LayDA@mail.gmail.com>
Message-ID: <CAD4oTHHyBt3g0+1jpi7OSRCHLUpEEwwenUam09MeSfsKxzDZbw@mail.gmail.com>

Small but crucial typo correction:

 Perhaps this could be put on the list of possible changes for R 5.0, to be
> bundled with other as-yet undecided breaking changes, members of R-core
> feel the same way.
>

 *if* members of R-core feel the same way.

~G

>
> Best,
> ~G
>
>
>> Cheers.
>>
>> --
>> Felipe Contreras
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>

	[[alternative HTML version deleted]]


From d|pter|x@w@ng @end|ng |rom gm@||@com  Fri Mar 24 06:12:29 2023
From: d|pter|x@w@ng @end|ng |rom gm@||@com (Dipterix Wang)
Date: Fri, 24 Mar 2023 01:12:29 -0400
Subject: [Rd] make file.rename return invisible
Message-ID: <AD74A984-21C5-4055-A426-505BDBFC6196@gmail.com>

Dear R Core devs,

I wonder if it makes sense to make function file.rename return invisible? This is not a big issue, but when running in RMarkdown or knitr, this function will print results. I have to manually call invisible to hide the output from showing in the final document:

```r
invisible(file.rename(...))
```

Otherwise knitr will print:

```
file.rename(...)
#> TRUE
```

If this function is designed for debug/interactive use, and the return is designed to be visible so users don't have to manually print, would it be possible to add an option to suppress the printing? 

Best,
- D
	[[alternative HTML version deleted]]


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Fri Mar 24 11:20:09 2023
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Fri, 24 Mar 2023 11:20:09 +0100
Subject: [Rd] make file.rename return invisible
In-Reply-To: <AD74A984-21C5-4055-A426-505BDBFC6196@gmail.com>
References: <AD74A984-21C5-4055-A426-505BDBFC6196@gmail.com>
Message-ID: <25629.31065.69388.216702@stat.math.ethz.ch>

>>>>> Dipterix Wang 
>>>>>     on Fri, 24 Mar 2023 01:12:29 -0400 writes:

    > Dear R Core devs,

    > I wonder if it makes sense to make function file.rename return invisible? This is not a big issue, but when running in RMarkdown or knitr, this function will print results. I have to manually call invisible to hide the output from showing in the final document:

    > ```r
    > invisible(file.rename(...))
    > ```

    > Otherwise knitr will print:

    > ```
    > file.rename(...)
    > #> TRUE
    > ```

    > If this function is designed for debug/interactive use, and the return is designed to be visible so users don't have to manually print, would it be possible to add an option to suppress the printing? 

Well, all (or just most?) of these  file.*() file manipulation
functions have been designed to return logicals ... and making a
return value invisible is rather the exception than typical in R.

And, why should (your own solution)

    invisible(file.rename(from, to))

not be sufficient?  I think it's much more expressive than e.g.,

    file.rename(from, to, invisible=TRUE))


Note that very safe use (in scripts run automatically, ..) should
happen inside

    if (!file.rename(a,b))
       stop("Could not successfully rename ", a, " to ", b)

anyway... and indeed it's much much less confusing for people
debugging such code that functions behave normally, i.e., the
user / programmer / debugger sees  TRUE or FALSE when evaluating
the function call.

Martin Maechler
ETH Zurich  and   R Core team


From |e||pe@contrer@@ @end|ng |rom gm@||@com  Sun Mar 26 08:09:56 2023
From: |e||pe@contrer@@ @end|ng |rom gm@||@com (Felipe Contreras)
Date: Sun, 26 Mar 2023 00:09:56 -0600
Subject: [Rd] Request: better default R_LIBS_USER
In-Reply-To: <CAD4oTHGLUpap62_1dVoumt9BnLn+UffLmD5d+ZWcre9X7LayDA@mail.gmail.com>
References: <CAMP44s2zzqo6iG2ujvhBGL4UsxsOt7e11p81xwWLCEf5Ggperw@mail.gmail.com>
 <25619.37737.873897.49177@rob.eddelbuettel.com>
 <CAMP44s2NFqiOP1hYcXvk0MvDDnQ9ZmoQvEk37cRyUW2T_0pqRQ@mail.gmail.com>
 <CAMP44s2JwdYn8ct6Lg3onjGfOwzEpr6e995vRqQhQMs4HS_Apg@mail.gmail.com>
 <CAD4oTHGLUpap62_1dVoumt9BnLn+UffLmD5d+ZWcre9X7LayDA@mail.gmail.com>
Message-ID: <CAMP44s3NZZXp7BKhxZeZ400s_9myghT8XM6Kq=_AOA+aXiUYqQ@mail.gmail.com>

On Thu, Mar 23, 2023 at 4:57?PM Gabriel Becker <gabembecker at gmail.com> wrote:
> Thanks for being interested in making R better. Its great to see engagement from a new "virtual face", so to speak. That said, without speaking for R-core, my experience is that the R-project and R-core team place a very high premium on backwards compatibility.

Yes, this is something I value in the software I use: backwards
compatibility should be of utmost importance.

However, there's a difference between being extremely dutiful with
backwards-incompatible changes, and making them taboo. There's such a
thing as too much inflexibleness. And you must make
backwards-incompatible changes at some point. Otherwise your software
eventually becomes stale and obsolete.

> They will make breaking changes, on occasion, but its rare and extreme for them to do so.

As it should be. But rare doesn't mean non-existent.

> I personally  don't think the amount of convenience/modern conceptual best practices adherence we're talking about here rises to the level of justifying a breaking change put in quickly.

Let me put it this way: I work with several dozens of projects on my
Linux system, and R is the *only* one that creates a directory
directly on top of my home directory, it has been the only one doing
so for at least the past 10 years, if not *ever*.

Most projects with poor considerations towards the user's home
directory at least have the decency to start the name of the directory
with a dot: e.g. ~/.R (as opposed to ~/R).

But I'm a programmer, R is just one of the many projects I dabble
with. If on the other hand R is the main project *you* work with (if
not the only one), then I can imagine how *you* don't see a problem.
But that doesn't mean there isn't one.

I bet many casual users of R are annoyed by precisely the same thing,
but they aren't going to bother investigating and contacting you like
I did.

> As for why I'm calling this a breaking change, see inline:
>
> On Thu, Mar 23, 2023 at 12:49?PM Felipe Contreras <felipe.contreras at gmail.com> wrote:
>>
>> > Just expand %U to both:
>> >
>> >             paste(c(
>> >             file.path(home, ".local", "lib", "r", x.y),
>> >             file.path(home, "R", paste0(R.version$platform, "-library"), x.y)
>> >             ), collapse = ":")
>> >
>> > Then R would install packages to the new location in new installations
>> > by default, but still use packages from the old location if present.
>>
>> This would work, would it not?
>
>
> So off the top of my head, this would mean that people who have versions of R from before and after that change installed simultaneously would, by default have package libraries that live in completely different places on the drive.
>
> Does that preclude a change like this from ever being made? No, but it does seem more like a major version change than a minor version change to me.
>
> For an example of why this could be a breaking change, i'd be willing to bet there are shell scripts out there which assume the user directories live at ~user/R/<os>/<version> and detect them as such. Do I think its common? No. Do I think its the right way to do whatever that shell script is doing? No, but I'd be surprised if there wasn't code that does it somewhere. And that code will/would break under your proposed change.

Yes, bad code breaks. That is the nature of using bad code.

But that's why good software doesn't rely on hard-coded paths, and
instead relies on methods to fetch them automatically. If I wrote a
software that somehow needed a path to check for Ruby gems, I wouldn't
use a hardcoded path such as `$HOME/.local/share/gem/ruby/3.0.0`, I
would use the output of `ruby -e 'puts Gem.user_dir'`.

Instead of hardcoding a path, why don't you provide a functionality
similar to `ruby -e 'puts Gem.user_dir'` so that scripts can use that
instead?

That being said, I don't even buy this hypothetical scenario, because
the location where R packages are installed isn't even
`~user/R/<os>/<version>`, the <os> is always the same, what is
different is the *platform*, and it's not even <version>, it's
`major.minor`.

How is this hypothetical shell script supposed to figure out this
directory in reality? What is the actual command?

* Ruby: find $(ruby -e 'puts Gem.user_dir')
* R: find $(????)

>> > Moreover, this location is going to change the next time the minor
>> > version is bumped anyway.
>>
>> Or just change it for the next version of R.
>
>
> All of the above said, I do actually agree that it would be nice to change the default in the long term (including for mac builds from source). Perhaps this could be put on the list of possible changes for R 5.0, to be bundled with other as-yet undecided breaking changes, members of R-core feel the same way.

I'm perfectly fine with this change being part of the next major
release (as long as it actually happens at some point), but wasn't
this *already* changed?

Here's a link to a git mirror (because the last time I used svn was in 2005):

https://github.com/wch/r-source/commit/9196047eea

Isn't this a change for the default location? Not in 4.0, not in 5.0,
but in 4.2. So there's nothing that should prevent this from happening
for Linux in 4.3. Is there?

Cheers.

-- 
Felipe Contreras


From pro|jcn@@h @end|ng |rom gm@||@com  Sun Mar 26 17:54:36 2023
From: pro|jcn@@h @end|ng |rom gm@||@com (J C Nash)
Date: Sun, 26 Mar 2023 11:54:36 -0400
Subject: [Rd] Query: Could documentation include modernized references?
Message-ID: <11c89c31-8e67-7947-00eb-717cc5d65557@gmail.com>

A tangential email discussion with Simon U. has highlighted a long-standing
matter that some tools in the base R distribution are outdated, but that
so many examples and other tools may use them that they cannot be deprecated.

The examples that I am most familiar with concern optimization and nonlinear
least squares, but other workers will surely be able to suggest cases elsewhere.
I was the source (in Pascal) of Nelder-Mead, BFGS and CG algorithms in optim().
BFGS is still mostly competitive, and Nelder-Mead is useful for initial exploration
of an optimization problem, but CG was never very good, right from the mid-1970s
well before it was interfaced to R. By contrast Rcgmin works rather well
considering how similar it is in nature to CG. Yet I continue to see use and
even recommendations of these tools in inappropriate circumstances.

Given that it would break too many other packages and examples to drop the
existing tools, should we at least add short notes in the man (.Rd) pages?
I'm thinking of something like

    optim() has methods that are dated. Users are urged to consider suggestions
    from ...

and point to references and/or an appropriate Task View, which could, of course,
be in the references.

I have no idea what steps are needed to make such edits to the man pages. Would
R-core need to be directly involved, or could one or two trusted R developers
be given privileges to seek advice on and implement such modest documentation
additions?  FWIW, I'm willing to participate in such an effort, which I believe
would help users to use appropriate and up-to-date tools.

John Nash


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Mar 26 18:41:03 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sun, 26 Mar 2023 12:41:03 -0400
Subject: [Rd] Query: Could documentation include modernized references?
In-Reply-To: <11c89c31-8e67-7947-00eb-717cc5d65557@gmail.com>
References: <11c89c31-8e67-7947-00eb-717cc5d65557@gmail.com>
Message-ID: <9f202099-a869-b325-057a-a5e21e286ab2@gmail.com>

On 26/03/2023 11:54 a.m., J C Nash wrote:
> A tangential email discussion with Simon U. has highlighted a long-standing
> matter that some tools in the base R distribution are outdated, but that
> so many examples and other tools may use them that they cannot be deprecated.
> 
> The examples that I am most familiar with concern optimization and nonlinear
> least squares, but other workers will surely be able to suggest cases elsewhere.
> I was the source (in Pascal) of Nelder-Mead, BFGS and CG algorithms in optim().
> BFGS is still mostly competitive, and Nelder-Mead is useful for initial exploration
> of an optimization problem, but CG was never very good, right from the mid-1970s
> well before it was interfaced to R. By contrast Rcgmin works rather well
> considering how similar it is in nature to CG. Yet I continue to see use and
> even recommendations of these tools in inappropriate circumstances.
> 
> Given that it would break too many other packages and examples to drop the
> existing tools, should we at least add short notes in the man (.Rd) pages?
> I'm thinking of something like
> 
>      optim() has methods that are dated. Users are urged to consider suggestions
>      from ...
> 
> and point to references and/or an appropriate Task View, which could, of course,
> be in the references.
> 
> I have no idea what steps are needed to make such edits to the man pages. Would
> R-core need to be directly involved, or could one or two trusted R developers
> be given privileges to seek advice on and implement such modest documentation
> additions?  FWIW, I'm willing to participate in such an effort, which I believe
> would help users to use appropriate and up-to-date tools.

I can answer your final paragraph:

Currently R-core would need to be directly involved, in that they are 
the only ones with write permission on the R sources.

However, they don't need to do the work, they just need to approve of it 
and commit it.  So I would suggest one way forward is the following:

- You fork one of the mirrors of the R sources from Github, and (perhaps 
with help from others) edit one or two of the pages in the way you're 
describing.  Once you think they are ready, make them available online 
for others to review (Github or Gitlab would help doing this), and then 
submit the changes as a patch against the svn sources on the R Bugzilla 
site.

- Another way could be that you copy the help page sources to a dummy 
package, instead of checking out the whole of the R sources.  You'll 
need to be careful not to miss other changes to the originals between 
the time you make your copy and the time you submit the patches.

Don't do too many pages, because you're probably going to have to work 
out the details of the workflow as you go, and earn R Core's trust by 
submitting good changes and responding to their requests.  And maybe 
don't do any until you hear from a member of R Core that they're willing 
to participate in this, because they certainly don't accept all suggestions.

Duncan Murdoch


From bbo|ker @end|ng |rom gm@||@com  Sun Mar 26 20:57:19 2023
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Sun, 26 Mar 2023 14:57:19 -0400
Subject: [Rd] Query: Could documentation include modernized references?
In-Reply-To: <9f202099-a869-b325-057a-a5e21e286ab2@gmail.com>
References: <11c89c31-8e67-7947-00eb-717cc5d65557@gmail.com>
 <9f202099-a869-b325-057a-a5e21e286ab2@gmail.com>
Message-ID: <c77d7a36-2b98-8271-ad32-5d9e4ddec78f@gmail.com>

   For one point of evidence about how much people pay attention to the 
documentation about what's outdated: Brian Ripley added a comment to 
nlminb.Rd in 2013 saying that the function was "for historical 
compatibility" 
<https://github.com/wch/r-source/commit/fd50cf2047b636e496551bcefd6bfa505f93f168> 
but it's still widely used in new code ...

  But I agree that adding appropriate warnings/links to the 
documentation couldn't hurt.

   cheers
    Ben

On 2023-03-26 12:41 p.m., Duncan Murdoch wrote:
> On 26/03/2023 11:54 a.m., J C Nash wrote:
>> A tangential email discussion with Simon U. has highlighted a 
>> long-standing
>> matter that some tools in the base R distribution are outdated, but that
>> so many examples and other tools may use them that they cannot be 
>> deprecated.
>>
>> The examples that I am most familiar with concern optimization and 
>> nonlinear
>> least squares, but other workers will surely be able to suggest cases 
>> elsewhere.
>> I was the source (in Pascal) of Nelder-Mead, BFGS and CG algorithms in 
>> optim().
>> BFGS is still mostly competitive, and Nelder-Mead is useful for 
>> initial exploration
>> of an optimization problem, but CG was never very good, right from the 
>> mid-1970s
>> well before it was interfaced to R. By contrast Rcgmin works rather well
>> considering how similar it is in nature to CG. Yet I continue to see 
>> use and
>> even recommendations of these tools in inappropriate circumstances.
>>
>> Given that it would break too many other packages and examples to drop 
>> the
>> existing tools, should we at least add short notes in the man (.Rd) 
>> pages?
>> I'm thinking of something like
>>
>> ???? optim() has methods that are dated. Users are urged to consider 
>> suggestions
>> ???? from ...
>>
>> and point to references and/or an appropriate Task View, which could, 
>> of course,
>> be in the references.
>>
>> I have no idea what steps are needed to make such edits to the man 
>> pages. Would
>> R-core need to be directly involved, or could one or two trusted R 
>> developers
>> be given privileges to seek advice on and implement such modest 
>> documentation
>> additions?? FWIW, I'm willing to participate in such an effort, which 
>> I believe
>> would help users to use appropriate and up-to-date tools.
> 
> I can answer your final paragraph:
> 
> Currently R-core would need to be directly involved, in that they are 
> the only ones with write permission on the R sources.
> 
> However, they don't need to do the work, they just need to approve of it 
> and commit it.? So I would suggest one way forward is the following:
> 
> - You fork one of the mirrors of the R sources from Github, and (perhaps 
> with help from others) edit one or two of the pages in the way you're 
> describing.? Once you think they are ready, make them available online 
> for others to review (Github or Gitlab would help doing this), and then 
> submit the changes as a patch against the svn sources on the R Bugzilla 
> site.
> 
> - Another way could be that you copy the help page sources to a dummy 
> package, instead of checking out the whole of the R sources.? You'll 
> need to be careful not to miss other changes to the originals between 
> the time you make your copy and the time you submit the patches.
> 
> Don't do too many pages, because you're probably going to have to work 
> out the details of the workflow as you go, and earn R Core's trust by 
> submitting good changes and responding to their requests.? And maybe 
> don't do any until you hear from a member of R Core that they're willing 
> to participate in this, because they certainly don't accept all 
> suggestions.
> 
> Duncan Murdoch
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Dr. Benjamin Bolker
Professor, Mathematics & Statistics and Biology, McMaster University
Director, School of Computational Science and Engineering
(Acting) Graduate chair, Mathematics & Statistics
 > E-mail is sent at my convenience; I don't expect replies outside of 
working hours.


From p@u| @end|ng |rom @t@t@@uck|@nd@@c@nz  Sun Mar 26 22:00:00 2023
From: p@u| @end|ng |rom @t@t@@uck|@nd@@c@nz (Paul Murrell)
Date: Mon, 27 Mar 2023 09:00:00 +1300
Subject: [Rd] Inconsistency in grid::grid.polyline
In-Reply-To: <CABtA9mH=PjDv2Cz5MLx6p5Xj=a99BVe9PEffDFVZ_bG15Cpn0w@mail.gmail.com>
References: <CABtA9mH=PjDv2Cz5MLx6p5Xj=a99BVe9PEffDFVZ_bG15Cpn0w@mail.gmail.com>
Message-ID: <6b6c49ef-72d2-d237-a66f-2cd696fb2f46@stat.auckland.ac.nz>

Hi

The general "evolution" of grid.*() functions (that I have written) have 
tended towards the grid.polyline() style ...

grid.*(...) {
     grid.draw(*Grob(...))
}

With my thinking at least heading towards:  if you are calling grid.*(), 
then you want to actually draw something;  if you want to just create a 
description of something to draw, then you want to call *Grob().

In other words, I have come to view the 'draw' argument to grid.*() as 
redundant.

That reflects how I use 'grid', so I may be unaware of an important 
counter argument.

Paul

On 25/03/23 13:02, mikefc wrote:
> Caution - Forged External Domain!
> This e-mail cannot be validated and may not have been sent by the sender 
> shown in the 'From' field.
> If you were not expecting to receive this e-mail we recommend you 
> contact the sender to confirm that they sent it.
> If you believe this email was legitimately sent, we suggest the sender 
> notify their e-mail administrator that it has been received as a forged 
> (fake) e-mail by the University of Auckland.
> Please contact the Staff Service Centre on extension 86000 if you 
> require further assistance.
> 
> Hi Paul and R-devel team,
> 
> There is an inconsistency in the definition of ?grid.polyline? in 
> comparison to the other grid.* functions.
> 
> grid.polyline() simply passes all args (specified via ? only) ?to 
> polylineGrob() and unconditionally calls grid.draw() on the returned object.
> 
> In contrast, all other functions in the grid.* family have a full set of 
> named arguments (reflecting the arguments to the *Grob() form of the 
> function).? Internally to each of the grid.* family of functions, a draw 
> argument is used to enable/disable the drawing of the object at call time.
> 
> Is this a conscious choice?? Should grid.polyline() behave like the 
> other grid.*() functions?
> 
> Kind regards,
> Mike.
> 
> 

-- 
Dr Paul Murrell
Te Kura Tatauranga | Department of Statistics
Waipapa Taumata Rau | The University of Auckland
Private Bag 92019, Auckland 1142, New Zealand
64 9 3737599 x85392
paul at stat.auckland.ac.nz
www.stat.auckland.ac.nz/~paul/


From @nto|ne@|@br| @end|ng |rom gm@||@com  Tue Mar 28 17:42:52 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Tue, 28 Mar 2023 17:42:52 +0200
Subject: [Rd] subfolders in the R folder
Message-ID: <CAEKh8uhzLqFM=mPoNG+bDK5H8Fh-H0pEO_e8T8aV39YXhqv2pg@mail.gmail.com>

Dear R-devel,

Packages don't allow for subfolders in R with a couple exceptions. We find
in "Writing R extensions" :

> The R and man subdirectories may contain OS-specific subdirectories named
unix or windows.

This is something I've seen discussed outside of the mailing list numerous
times, and thanks to this SO question
https://stackoverflow.com/questions/14902199/using-source-subdirectories-within-r-packages-with-roxygen2
I could find a couple instances where this was discussed here as well,
apologies if I missed later discussions :

* https://stat.ethz.ch/pipermail/r-devel/2009-December/056022.html
* https://stat.ethz.ch/pipermail/r-devel/2010-February/056513.html

I don't see a very compelling conclusion, nor a justification for the
behavior, and I see that it makes some users snarky (second link is an
example), so let me make a case.

This limitation is an annoyance for bigger projects where we must choose
between having fewer files with too many objects defined (less structure,
more scrolling), or to have too many scripts, often with long prefixed
names to emulate essentially what folders would do. In my experience this
creates confusion, slows down the workflow, makes onboarding or open source
contributions on a new project harder (where do we start ?), makes dead
code easier to happen, makes it harder to test the rights things etc...

It would seem to me, but I might be naive, that it'd be a quick enough fix
to flatten the R folders not named "unix" or "windows"  when building the
package. Is there a good reason why we can't do that ?

Thanks,

Antoine

PS:
Other SO Q&As:
https://stackoverflow.com/questions/33776643/subdirectory-in-r-package
https://stackoverflow.com/questions/18584807/code-organisation-in-r-package-development

	[[alternative HTML version deleted]]


From @nto|ne@|@br| @end|ng |rom gm@||@com  Tue Mar 28 17:59:23 2023
From: @nto|ne@|@br| @end|ng |rom gm@||@com (Antoine Fabri)
Date: Tue, 28 Mar 2023 17:59:23 +0200
Subject: [Rd] subfolders in the R folder
In-Reply-To: <CAEKh8uhzLqFM=mPoNG+bDK5H8Fh-H0pEO_e8T8aV39YXhqv2pg@mail.gmail.com>
References: <CAEKh8uhzLqFM=mPoNG+bDK5H8Fh-H0pEO_e8T8aV39YXhqv2pg@mail.gmail.com>
Message-ID: <CAEKh8ugS5JPfxxMM2Rb1qe=OkeC_kahBcJX+nSTDqHpiZ8Ha5w@mail.gmail.com>

I just found this other discussion, with some more snark (who would have
thought this subject would be so slippery!) :
https://bugs.r-project.org/show_bug.cgi?id=17258

Duncan makes the argument that R's history shows the feature is not
absolutely necessary, but that's what make it a feature request and not a
bug report in my opinion. Feng makes the point that Python's history shows
that the feature is useful, and no counterpoint is made.

	[[alternative HTML version deleted]]


From b@row||ng@on @end|ng |rom |@nc@@ter@@c@uk  Tue Mar 28 18:23:29 2023
From: b@row||ng@on @end|ng |rom |@nc@@ter@@c@uk (Barry Rowlingson)
Date: Tue, 28 Mar 2023 16:23:29 +0000
Subject: [Rd] [External]  subfolders in the R folder
In-Reply-To: <4f78fcc4efb247fbbb1d5e69cc3e8122@LO2P265MB3344.GBRP265.PROD.OUTLOOK.COM>
References: <4f78fcc4efb247fbbb1d5e69cc3e8122@LO2P265MB3344.GBRP265.PROD.OUTLOOK.COM>
Message-ID: <CANVKczOxZ9KEW_3GXms7jdDNHezEfQ8kYwH_Tg_zBOUUxvPSRQ@mail.gmail.com>

The "good reason" is all the tooling in R doesn't work with subfolders and
would have to be rewritten. All the package check and build stuff. And
that's assuming you don't want to change the basic flat package structure -
for example to allow something like `library(foo)` to attach a package and
`library(foo.bar)` to attach some subset of package `foo`. That would
require more changes of core R package and namespace code.

As a workaround, you could implement a hierarchical structure in your file
*names*. That's what `ggplot2` does with its (...downloads tarball...) 192
files in its R folder. Well mostly, there's a load of files called
annotation- and geom- and plot- and position- and stat- etc etc. No reason
why you can't have multiple "levels" separated with "-" as you would have
multiple folder levels separated with "/". You can then do `ls geom-*` to
see the `geom` "folder" and so on (on a unix shell).

And then when R Core receive a patch that implements subfolders, a quick
shell script will be able to create the hierarchy for you and drop all the
files in the right place.

One reason for the flat folder structure may be that R's packages
themselves have no structure to the functions - compare with Python where
modules can have subfolders and functions in subfolders can be access with
module.subfolder.subsub.foo(x), and module subfolders can be imported etc.
The whole module ecosystem was designed with structure in mind.

I don't think there's any restriction on subfolders in the "inst" folder of
a package so if you have scripts you can arrange them there.

Given that most of my students seem to keep all their 23,420 files in one
folder called "Stuff" I think we can manage like this for a bit longer.

B



On Tue, Mar 28, 2023 at 4:43?PM Antoine Fabri <antoine.fabri at gmail.com>
wrote:

> This email originated outside the University. Check before clicking links
> or attachments.
>
> Dear R-devel,
>
> Packages don't allow for subfolders in R with a couple exceptions. We find
> in "Writing R extensions" :
>
> > The R and man subdirectories may contain OS-specific subdirectories named
> unix or windows.
>
> This is something I've seen discussed outside of the mailing list numerous
> times, and thanks to this SO question
>
> https://stackoverflow.com/questions/14902199/using-source-subdirectories-within-r-packages-with-roxygen2
> I could find a couple instances where this was discussed here as well,
> apologies if I missed later discussions :
>
> * https://stat.ethz.ch/pipermail/r-devel/2009-December/056022.html
> * https://stat.ethz.ch/pipermail/r-devel/2010-February/056513.html
>
> I don't see a very compelling conclusion, nor a justification for the
> behavior, and I see that it makes some users snarky (second link is an
> example), so let me make a case.
>
> This limitation is an annoyance for bigger projects where we must choose
> between having fewer files with too many objects defined (less structure,
> more scrolling), or to have too many scripts, often with long prefixed
> names to emulate essentially what folders would do. In my experience this
> creates confusion, slows down the workflow, makes onboarding or open source
> contributions on a new project harder (where do we start ?), makes dead
> code easier to happen, makes it harder to test the rights things etc...
>
> It would seem to me, but I might be naive, that it'd be a quick enough fix
> to flatten the R folders not named "unix" or "windows"  when building the
> package. Is there a good reason why we can't do that ?
>
> Thanks,
>
> Antoine
>
> PS:
> Other SO Q&As:
> https://stackoverflow.com/questions/33776643/subdirectory-in-r-package
>
> https://stackoverflow.com/questions/18584807/code-organisation-in-r-package-development
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From henr|k@bengt@@on @end|ng |rom gm@||@com  Tue Mar 28 20:00:06 2023
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Tue, 28 Mar 2023 20:00:06 +0200
Subject: [Rd] [External] subfolders in the R folder
In-Reply-To: <CANVKczOxZ9KEW_3GXms7jdDNHezEfQ8kYwH_Tg_zBOUUxvPSRQ@mail.gmail.com>
References: <4f78fcc4efb247fbbb1d5e69cc3e8122@LO2P265MB3344.GBRP265.PROD.OUTLOOK.COM>
 <CANVKczOxZ9KEW_3GXms7jdDNHezEfQ8kYwH_Tg_zBOUUxvPSRQ@mail.gmail.com>
Message-ID: <CAFDcVCSOeMm38k96QVtP7vBcioG7EhjY1uAdo4aPkZLx_Yor-g@mail.gmail.com>

A quick drive-by-comment: What if 'R CMD build' would have an option
to flatten R/ subfolders when building the tarball, e.g.

R/unix/a.R
R/windows/a.R
R/a.R

becomes:

R/00__unix__a.R
R/00__windows__a.R
R/a.R

?  Maybe that would be sufficient for most use cases.  The only thing
I can imagine is that source file references (e.g. in check NOTEs)
will be toward the latter and not the former.

Of course, one could write a 'build2' shell script locally that wraps
all this internally, so that one can call 'R CMD build2 mypkg', which
then creates a flattened copy of the package folder, and runs 'R CMD
build' on that. Prototyping that could be a good start to see what
such a solution will bring and what it breaks.

/Henrik

On Tue, Mar 28, 2023 at 6:24?PM Barry Rowlingson
<b.rowlingson at lancaster.ac.uk> wrote:
>
> The "good reason" is all the tooling in R doesn't work with subfolders and
> would have to be rewritten. All the package check and build stuff. And
> that's assuming you don't want to change the basic flat package structure -
> for example to allow something like `library(foo)` to attach a package and
> `library(foo.bar)` to attach some subset of package `foo`. That would
> require more changes of core R package and namespace code.
>
> As a workaround, you could implement a hierarchical structure in your file
> *names*. That's what `ggplot2` does with its (...downloads tarball...) 192
> files in its R folder. Well mostly, there's a load of files called
> annotation- and geom- and plot- and position- and stat- etc etc. No reason
> why you can't have multiple "levels" separated with "-" as you would have
> multiple folder levels separated with "/". You can then do `ls geom-*` to
> see the `geom` "folder" and so on (on a unix shell).
>
> And then when R Core receive a patch that implements subfolders, a quick
> shell script will be able to create the hierarchy for you and drop all the
> files in the right place.
>
> One reason for the flat folder structure may be that R's packages
> themselves have no structure to the functions - compare with Python where
> modules can have subfolders and functions in subfolders can be access with
> module.subfolder.subsub.foo(x), and module subfolders can be imported etc.
> The whole module ecosystem was designed with structure in mind.
>
> I don't think there's any restriction on subfolders in the "inst" folder of
> a package so if you have scripts you can arrange them there.
>
> Given that most of my students seem to keep all their 23,420 files in one
> folder called "Stuff" I think we can manage like this for a bit longer.
>
> B
>
>
>
> On Tue, Mar 28, 2023 at 4:43?PM Antoine Fabri <antoine.fabri at gmail.com>
> wrote:
>
> > This email originated outside the University. Check before clicking links
> > or attachments.
> >
> > Dear R-devel,
> >
> > Packages don't allow for subfolders in R with a couple exceptions. We find
> > in "Writing R extensions" :
> >
> > > The R and man subdirectories may contain OS-specific subdirectories named
> > unix or windows.
> >
> > This is something I've seen discussed outside of the mailing list numerous
> > times, and thanks to this SO question
> >
> > https://stackoverflow.com/questions/14902199/using-source-subdirectories-within-r-packages-with-roxygen2
> > I could find a couple instances where this was discussed here as well,
> > apologies if I missed later discussions :
> >
> > * https://stat.ethz.ch/pipermail/r-devel/2009-December/056022.html
> > * https://stat.ethz.ch/pipermail/r-devel/2010-February/056513.html
> >
> > I don't see a very compelling conclusion, nor a justification for the
> > behavior, and I see that it makes some users snarky (second link is an
> > example), so let me make a case.
> >
> > This limitation is an annoyance for bigger projects where we must choose
> > between having fewer files with too many objects defined (less structure,
> > more scrolling), or to have too many scripts, often with long prefixed
> > names to emulate essentially what folders would do. In my experience this
> > creates confusion, slows down the workflow, makes onboarding or open source
> > contributions on a new project harder (where do we start ?), makes dead
> > code easier to happen, makes it harder to test the rights things etc...
> >
> > It would seem to me, but I might be naive, that it'd be a quick enough fix
> > to flatten the R folders not named "unix" or "windows"  when building the
> > package. Is there a good reason why we can't do that ?
> >
> > Thanks,
> >
> > Antoine
> >
> > PS:
> > Other SO Q&As:
> > https://stackoverflow.com/questions/33776643/subdirectory-in-r-package
> >
> > https://stackoverflow.com/questions/18584807/code-organisation-in-r-package-development
> >
> >         [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Tue Mar 28 20:24:26 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Tue, 28 Mar 2023 14:24:26 -0400
Subject: [Rd] [External] subfolders in the R folder
In-Reply-To: <CAFDcVCSOeMm38k96QVtP7vBcioG7EhjY1uAdo4aPkZLx_Yor-g@mail.gmail.com>
References: <4f78fcc4efb247fbbb1d5e69cc3e8122@LO2P265MB3344.GBRP265.PROD.OUTLOOK.COM>
 <CANVKczOxZ9KEW_3GXms7jdDNHezEfQ8kYwH_Tg_zBOUUxvPSRQ@mail.gmail.com>
 <CAFDcVCSOeMm38k96QVtP7vBcioG7EhjY1uAdo4aPkZLx_Yor-g@mail.gmail.com>
Message-ID: <b8e89651-c811-d1b9-59fd-6a3b59fba6ca@gmail.com>

On 28/03/2023 2:00 p.m., Henrik Bengtsson wrote:
> A quick drive-by-comment: What if 'R CMD build' would have an option
> to flatten R/ subfolders when building the tarball, e.g.
> 
> R/unix/a.R
> R/windows/a.R
> R/a.R
> 
> becomes:
> 
> R/00__unix__a.R
> R/00__windows__a.R
> R/a.R
> 
> ?  Maybe that would be sufficient for most use cases.  The only thing
> I can imagine is that source file references (e.g. in check NOTEs)
> will be toward the latter and not the former.

If you are renaming a file (or merging multiple files, etc.) you can use 
#line directives so that diagnostic messages refer to the original file.

Duncan Murdoch

> Of course, one could write a 'build2' shell script locally that wraps
> all this internally, so that one can call 'R CMD build2 mypkg', which
> then creates a flattened copy of the package folder, and runs 'R CMD
> build' on that. Prototyping that could be a good start to see what
> such a solution will bring and what it breaks.


> 
> /Henrik
> 
> On Tue, Mar 28, 2023 at 6:24?PM Barry Rowlingson
> <b.rowlingson at lancaster.ac.uk> wrote:
>>
>> The "good reason" is all the tooling in R doesn't work with subfolders and
>> would have to be rewritten. All the package check and build stuff. And
>> that's assuming you don't want to change the basic flat package structure -
>> for example to allow something like `library(foo)` to attach a package and
>> `library(foo.bar)` to attach some subset of package `foo`. That would
>> require more changes of core R package and namespace code.
>>
>> As a workaround, you could implement a hierarchical structure in your file
>> *names*. That's what `ggplot2` does with its (...downloads tarball...) 192
>> files in its R folder. Well mostly, there's a load of files called
>> annotation- and geom- and plot- and position- and stat- etc etc. No reason
>> why you can't have multiple "levels" separated with "-" as you would have
>> multiple folder levels separated with "/". You can then do `ls geom-*` to
>> see the `geom` "folder" and so on (on a unix shell).
>>
>> And then when R Core receive a patch that implements subfolders, a quick
>> shell script will be able to create the hierarchy for you and drop all the
>> files in the right place.
>>
>> One reason for the flat folder structure may be that R's packages
>> themselves have no structure to the functions - compare with Python where
>> modules can have subfolders and functions in subfolders can be access with
>> module.subfolder.subsub.foo(x), and module subfolders can be imported etc.
>> The whole module ecosystem was designed with structure in mind.
>>
>> I don't think there's any restriction on subfolders in the "inst" folder of
>> a package so if you have scripts you can arrange them there.
>>
>> Given that most of my students seem to keep all their 23,420 files in one
>> folder called "Stuff" I think we can manage like this for a bit longer.
>>
>> B
>>
>>
>>
>> On Tue, Mar 28, 2023 at 4:43?PM Antoine Fabri <antoine.fabri at gmail.com>
>> wrote:
>>
>>> This email originated outside the University. Check before clicking links
>>> or attachments.
>>>
>>> Dear R-devel,
>>>
>>> Packages don't allow for subfolders in R with a couple exceptions. We find
>>> in "Writing R extensions" :
>>>
>>>> The R and man subdirectories may contain OS-specific subdirectories named
>>> unix or windows.
>>>
>>> This is something I've seen discussed outside of the mailing list numerous
>>> times, and thanks to this SO question
>>>
>>> https://stackoverflow.com/questions/14902199/using-source-subdirectories-within-r-packages-with-roxygen2
>>> I could find a couple instances where this was discussed here as well,
>>> apologies if I missed later discussions :
>>>
>>> * https://stat.ethz.ch/pipermail/r-devel/2009-December/056022.html
>>> * https://stat.ethz.ch/pipermail/r-devel/2010-February/056513.html
>>>
>>> I don't see a very compelling conclusion, nor a justification for the
>>> behavior, and I see that it makes some users snarky (second link is an
>>> example), so let me make a case.
>>>
>>> This limitation is an annoyance for bigger projects where we must choose
>>> between having fewer files with too many objects defined (less structure,
>>> more scrolling), or to have too many scripts, often with long prefixed
>>> names to emulate essentially what folders would do. In my experience this
>>> creates confusion, slows down the workflow, makes onboarding or open source
>>> contributions on a new project harder (where do we start ?), makes dead
>>> code easier to happen, makes it harder to test the rights things etc...
>>>
>>> It would seem to me, but I might be naive, that it'd be a quick enough fix
>>> to flatten the R folders not named "unix" or "windows"  when building the
>>> package. Is there a good reason why we can't do that ?
>>>
>>> Thanks,
>>>
>>> Antoine
>>>
>>> PS:
>>> Other SO Q&As:
>>> https://stackoverflow.com/questions/33776643/subdirectory-in-r-package
>>>
>>> https://stackoverflow.com/questions/18584807/code-organisation-in-r-package-development
>>>
>>>          [[alternative HTML version deleted]]
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>
>>          [[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From Kurt@Horn|k @end|ng |rom wu@@c@@t  Wed Mar 29 10:44:42 2023
From: Kurt@Horn|k @end|ng |rom wu@@c@@t (Kurt Hornik)
Date: Wed, 29 Mar 2023 10:44:42 +0200
Subject: [Rd] Incorrect behavior of ks.test and psmirnov functions with
 exact=TRUE
In-Reply-To: <CAMGHQ95wXZ=LMVkUjDRsCJ_0P2VAbWnQrj-4_NvdXRGMuvVDvA@mail.gmail.com>
References: <CAMGHQ95wXZ=LMVkUjDRsCJ_0P2VAbWnQrj-4_NvdXRGMuvVDvA@mail.gmail.com>
Message-ID: <25635.64122.246376.31423@hornik.net>

>>>>> Alexey Sergushichev writes:

Thanks.  This is now fixed for the upcoming 4.3.0 release.

Best
-k

> HI,
> I've noticed what I think is an incorrect behavior of stats::psmirnov
> function and consequently of ks.test when run in an exact mode.

> For example:
> psmirnov(1, sizes=c(50, 50), z=1:100, two.sided = FALSE, lower.tail = F,
> exact=TRUE)

> produces 2.775558e-15

> However, the exact value should be 1/combination(100, 50), which is
> 9.9e-30. While the absolute error is small, the relative error is huge, and
> it is not fixed by setting option log.p=T

> To compare, SciPy has a correct implementation in scipy.stats.ks_2samp:
> scipy.stats.ks_2samp(list(range(1,51)), list(range(51, 101)),
> alternative="greater", method="exact")
> returns 9.911653021418333e-30.

> I've tried to dig in a bit and the problem comes down to how the final
> value is calculated in psmirnov function:

>     if (log.p & !lower.tail)
>         return(log1p(-ret/exp(logdenom)))
>     if (!log.p & !lower.tail)
>         return(1 - ret/exp(logdenom))

> There exp(logdenom) is a relatively good (but not perfect) approximation of
> combination(100, 50) = 1.008913e+29, ret is also a good approximation of
> combination(100, 50)-1 = 1.008913e+29 but there is not enough double
> precision for 1 - ret/exp(logdenom) to capture 1/combination(100, 50).

> I don't have time to provide a fix, at least not now, but I think this
> behavior (good absolute error, but poor relative error for small values)
> should at least be mentioned in the manual of the methods psmirnov and/or
> ks.test

> Best,
> Alexey Sergushichev

> 	[[alternative HTML version deleted]]

> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From tdhock5 @end|ng |rom gm@||@com  Thu Mar 30 06:53:59 2023
From: tdhock5 @end|ng |rom gm@||@com (Toby Hocking)
Date: Wed, 29 Mar 2023 21:53:59 -0700
Subject: [Rd] read.csv quadratic time in number of columns
Message-ID: <CALK03d3m4wN1o=m8V6_4Za4uZ-FQrU8pRU8FuxkFORPdoQwRYg@mail.gmail.com>

Dear R-devel,
A number of people have observed anecdotally that read.csv is slow for
large number of columns, for example:
https://stackoverflow.com/questions/7327851/read-csv-is-extremely-slow-in-reading-csv-files-with-large-numbers-of-columns
I did a systematic comparison of read.csv with similar functions, and
observed that read.csv is quadratic time (N^2) in the number of columns N,
whereas the others are linear (N).
Can read.csv be improved to use a linear time algorithm, so it can handle
CSV files with larger numbers of columns?
For more details including figures and session info, please see
https://github.com/tdhock/atime/issues/8
Sincerely,
Toby Dylan Hocking

	[[alternative HTML version deleted]]


From tdhock5 @end|ng |rom gm@||@com  Thu Mar 30 07:24:13 2023
From: tdhock5 @end|ng |rom gm@||@com (Toby Hocking)
Date: Wed, 29 Mar 2023 22:24:13 -0700
Subject: [Rd] write.csv performance improvements?
Message-ID: <CALK03d06ooGiZ+vq7kZVPUzx9B=t9gvJ8f7xwZCWv4CUrBwrJg@mail.gmail.com>

Dear R-devel,
I did a systematic comparison of write.csv with similar functions, and
observed two asymptotic inefficiencies that could be improved.

1. write.csv is quadratic time (N^2) in the number of columns N.
Can write.csv be improved to use a linear time algorithm, so it can handle
CSV files with larger numbers of columns?
For more details including figures and session info, please see
https://github.com/tdhock/atime/issues/9

2. write.csv uses memory that is linear in the number of rows, whereas
similar R functions for writing CSV use only constant memory. This is not
as important of an issue to fix, because anyway linear memory is used to
store the data in R. But since the other functions use constant memory,
could write.csv also? Is there some copying happening that could be
avoided? (this memory measurement uses bench::mark, which in turn uses
utils::Rprofmem)
https://github.com/tdhock/atime/issues/10

Sincerely,
Toby Dylan Hocking

	[[alternative HTML version deleted]]


From kry|ov@r00t @end|ng |rom gm@||@com  Thu Mar 30 16:32:39 2023
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Thu, 30 Mar 2023 17:32:39 +0300
Subject: [Rd] removeSource() vs. function literals
Message-ID: <20230330173239.72da4e14@arachnoid>

Dear R-devel,

In a package of mine, I use removeSource on expression objects in order
to make expressions that are semantically the same serialize to the
same byte sequences:
https://github.com/cran/depcache/blob/854d68a/R/fixup.R#L8-L34

Today I learned that expressions containing function definitions also
contain the source references for the functions, not as an attribute,
but as a separate argument to the `function` call:

str(quote(function() NULL)[[4]])
# 'srcref' int [1:8] 1 11 1 25 11 25 1 1
# - attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile'
#   <environment:0x55aba55a8a50>

This means that removeSource() on an expression that would define a
function when evaluated doesn't actually remove the source reference
from the object.

Do you think it would be appropriate to teach removeSource() to remove
such source references? What could be a good way to implement that?
if (is.call(fn) && identical(fn[[1]], 'function')) fn[[4]] <- NULL
sounds too arbitrary. if (inherits(fn, 'srcref')) return(NULL) sounds
too broad.

-- 
Best regards,
Ivan


From murdoch@dunc@n @end|ng |rom gm@||@com  Thu Mar 30 18:38:24 2023
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Thu, 30 Mar 2023 12:38:24 -0400
Subject: [Rd] removeSource() vs. function literals
In-Reply-To: <20230330173239.72da4e14@arachnoid>
References: <20230330173239.72da4e14@arachnoid>
Message-ID: <509b2249-d533-6f15-5b14-c5cfb8218059@gmail.com>

On 30/03/2023 10:32 a.m., Ivan Krylov wrote:
> Dear R-devel,
> 
> In a package of mine, I use removeSource on expression objects in order
> to make expressions that are semantically the same serialize to the
> same byte sequences:
> https://github.com/cran/depcache/blob/854d68a/R/fixup.R#L8-L34
> 
> Today I learned that expressions containing function definitions also
> contain the source references for the functions, not as an attribute,
> but as a separate argument to the `function` call:
> 
> str(quote(function() NULL)[[4]])
> # 'srcref' int [1:8] 1 11 1 25 11 25 1 1
> # - attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile'
> #   <environment:0x55aba55a8a50>
> 
> This means that removeSource() on an expression that would define a
> function when evaluated doesn't actually remove the source reference
> from the object.
> 
> Do you think it would be appropriate to teach removeSource() to remove
> such source references? What could be a good way to implement that?
> if (is.call(fn) && identical(fn[[1]], 'function')) fn[[4]] <- NULL
> sounds too arbitrary. if (inherits(fn, 'srcref')) return(NULL) sounds
> too broad.
> 

I don't think there's a simple way to do that.  Functions can define 
functions within themselves.  If you're talking about code that was 
constructed by messing with language objects, it could contain both 
function objects and calls to `function` to construct them.  You'd need 
to recurse through all expressions in the object.  Some of those 
expressions might be environments, so your changes could leak out of the 
function you're working on.

Things are simpler if you know the expression is the unmodified result 
of parsing source code, but if you know that, wouldn't you usually be 
able to control things by setting keep.source = FALSE?

Maybe a workable solution is something like parse(deparse(expr, control 
= "exact"), keep.source = FALSE).  Wouldn't work on environments or 
various exotic types, but would probably warn you if it wasn't working.

Duncan Murdoch


From g@bembecker @end|ng |rom gm@||@com  Fri Mar 31 00:50:35 2023
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Thu, 30 Mar 2023 15:50:35 -0700
Subject: [Rd] write.csv performance improvements?
In-Reply-To: <CALK03d06ooGiZ+vq7kZVPUzx9B=t9gvJ8f7xwZCWv4CUrBwrJg@mail.gmail.com>
References: <CALK03d06ooGiZ+vq7kZVPUzx9B=t9gvJ8f7xwZCWv4CUrBwrJg@mail.gmail.com>
Message-ID: <CAD4oTHEEY8oD5qQs5X0zT5rizS8+zuP_LCZziVSHjYxXwCf6tw@mail.gmail.com>

Hi Toby et al,



On Wed, Mar 29, 2023 at 10:24?PM Toby Hocking <tdhock5 at gmail.com> wrote:

> Dear R-devel,
> I did a systematic comparison of write.csv with similar functions, and
> observed two asymptotic inefficiencies that could be improved.
>
> 1. write.csv is quadratic time (N^2) in the number of columns N.
> Can write.csv be improved to use a linear time algorithm, so it can handle
> CSV files with larger numbers of columns?
>

Yes, I think there is a narrow fix and a wider discussion to be had.

I've posted a discussion and the narrow fix at:
https://bugs.r-project.org/show_bug.cgi?id=18500

For "normal data", ie data that doesn't have classed object columns, the
narrow change I propose in the patch us the performance we might expect
(see the attached, admittedly very ugly plots).

The fact remains though, that with the patch, write.table is still
quadratic in the number of *object-classed *columns.

It doesn't seem like it should be, but I haven't (yet) had a chance to dig
deeper to attack that.  Might be a good subject for the R developer sprint,
if R-core agrees.

~G

> For more details including figures and session info, please see
> https://github.com/tdhock/atime/issues/9
>
> 2. write.csv uses memory that is linear in the number of rows, whereas
> similar R functions for writing CSV use only constant memory. This is not
> as important of an issue to fix, because anyway linear memory is used to
> store the data in R. But since the other functions use constant memory,
> could write.csv also? Is there some copying happening that could be
> avoided? (this memory measurement uses bench::mark, which in turn uses
> utils::Rprofmem)
> https://github.com/tdhock/atime/issues/10
>
> Sincerely,
> Toby Dylan Hocking
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: csv_ncols_time_4.2.2.png
Type: image/png
Size: 19358 bytes
Desc: not available
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20230330/957ed575/attachment.png>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: csv_nobjcols_time_4.2.2.png
Type: image/png
Size: 21430 bytes
Desc: not available
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20230330/957ed575/attachment-0001.png>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: csv_ncols_time.png
Type: image/png
Size: 20187 bytes
Desc: not available
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20230330/957ed575/attachment-0002.png>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: csv_nobjcols_time.png
Type: image/png
Size: 21411 bytes
Desc: not available
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20230330/957ed575/attachment-0003.png>

