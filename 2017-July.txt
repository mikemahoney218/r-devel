From skostyshak at ufl.edu  Mon Jul  3 08:09:47 2017
From: skostyshak at ufl.edu (Scott Kostyshak)
Date: Mon, 3 Jul 2017 02:09:47 -0400
Subject: [Rd] Patch for R-exts.texi
Message-ID: <20170703060947.22pm6oiyivj7illt@steph>

Attached is a patch for R-exts.texi against r72880.

Here are some of the changes I made:

- Fix a broken link:
    https://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Introduction/Introduction.html
    ->
    https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html

- Changed a few http to https (and checked that the connections are
  indeed secure, as judged by Chromium and Firefox).

- A couple of grammar fixes and "sounds more natural to me" changes.

- "x84_64" -> x86_64

- One change of "which" -> "that"

- The link to Luke's uiowa.edu page involves two changes, removing the
  duplicate URL and changing the protocol to https.

Thanks for your time,

Scott


-- 
Scott Kostyshak
Assistant Professor of Economics
University of Florida
https://people.clas.ufl.edu/skostyshak/

-------------- next part --------------
Index: doc/manual/R-exts.texi
===================================================================
--- doc/manual/R-exts.texi	(revision 72880)
+++ doc/manual/R-exts.texi	(working copy)
@@ -1457,7 +1457,7 @@
 
 @noindent
 then download the sources from
- at uref{http://sourceforge.net/@/projects/@/tcllib/@/files/@/BWidget/} and
+ at uref{https://sourceforge.net/@/projects/@/tcllib/@/files/@/BWidget/} and
 at the command line run something like
 
 @example
@@ -1494,7 +1494,7 @@
 
 @noindent
 and not a version starting
- at samp{http://cran.r-project.org/web/packages/@var{pkgname}}.
+ at samp{https://cran.r-project.org/web/packages/@var{pkgname}}.
 
 @node Configure and cleanup, Checking and building packages, Package structure, Creating R packages
 @section Configure and cleanup
@@ -2117,7 +2117,7 @@
 word, so computations done on OpenMP threads will not make use of
 extended-precision arithmetic which is the default for the main process.
 @c mingw64-public, 2015-02-02.
- at c http://stackoverflow.com/questions/2553725/is-the-fpu-control-word-setting-per-thread-or-per-process
+ at c https://stackoverflow.com/questions/2553725/is-the-fpu-control-word-setting-per-thread-or-per-process
 
 Calling any of the @R{} API from threaded code is `for experts only':
 they will need to read the source code to determine if it is
@@ -7645,7 +7645,7 @@
 which is a GUI version), @command{Shark} (in version of @code{Xcode}
 up to those for Snow Leopard), and @command{Instruments} (part of
 @code{Xcode}, see
- at uref{https://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Introduction/Introduction.html}).
+ at uref{https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html}).
 
 
 @node Debugging, System and foreign language interfaces, Tidying and profiling R code, Top
@@ -8295,8 +8295,8 @@
 to be installed separately, and for checking C++ you may also need
 @pkg{libubsan}.} of @command{gcc} and @command{clang} on common Linux
 and macOS platforms.  See
- at uref{http://clang.llvm.org/@/docs/@/UsersManual.html#controlling-code-generation},
- at uref{http://clang.llvm.org/@/docs/@/AddressSanitizer.html} and
+ at uref{https://clang.llvm.org/@/docs/@/UsersManual.html#controlling-code-generation},
+ at uref{https://clang.llvm.org/@/docs/@/AddressSanitizer.html} and
 @uref{https://code.google.com/@/p/@/address-sanitizer/}.
 
 More thorough checks of C++ code are done if the C++ library has been
@@ -8455,7 +8455,7 @@
 
 Finer control of what is checked can be achieved by other options: for
 @command{clang} see
- at uref{http://clang.llvm.org/@/docs/@/UsersManual.html#controlling-code-generation}. at footnote{or
+ at uref{https://clang.llvm.org/@/docs/@/UsersManual.html#controlling-code-generation}. at footnote{or
 the user manual for your version of @command{clang}, e.g.@: (the paths
 have differed for some versions)
 @uref{http://llvm.org/@/releases/@/4.0.0/@/tools/@/clang/@/docs/@/UsersManual.html}.}
@@ -8560,13 +8560,13 @@
 Recent versions of @command{clang} on @cputype{x86_64} Linux have
 `ThreadSanitizer' (@uref{https://code.google.com/@/p/@/thread-sanitizer/}),
 a `data race detector for C/C++ programs', and `MemorySanitizer'
-(@uref{http://clang.llvm.org/@/docs/@/MemorySanitizer.html},
+(@uref{https://clang.llvm.org/@/docs/@/MemorySanitizer.html},
 @uref{https://code.google.com/@/p/@/memory-sanitizer/@/wiki/@/MemorySanitizer})
 for the detection of uninitialized memory.  Both are based on and
 provide similar functionality to tools in @command{valgrind}.
 
 @command{clang} has a `Static Analyser' which can be run on the source
-files during compilation: see @uref{http://clang-analyzer.llvm.org/}.
+files during compilation: see @uref{https://clang-analyzer.llvm.org/}.
 
 @node Using `Dr. Memory', Fortran array bounds checking, Other analyses with `clang', Checking memory access
 @subsection Using `Dr. Memory'
@@ -9429,7 +9429,7 @@
 @uref{https://www.r-project.org/@/doc/@/Rnews/Rnews_2001-3.pdf}).
 
 Once routines are registered, they can be referred to as @R{} objects if
-they this is arranged in the @code{useDynLib} call in the package's
+this is arranged in the @code{useDynLib} call in the package's
 @file{NAMESPACE} file (see @ref{useDynLib}).  So for example the
 @pkg{stats} package has
 @example
@@ -9516,7 +9516,7 @@
 the OS (and even if it is 32- or 64-bit), on the version of @R{} and
 what else is loaded into @R{} at the time.
 
-To fix ideas, first consider @code{x84_64} OS 10.7 and @R{} 2.15.2.  A
+To fix ideas, first consider @code{x86_64} OS 10.7 and @R{} 2.15.2.  A
 simple @code{.Call} function might be
 @example
 foo <- function(x) .Call("foo", x)
@@ -9696,7 +9696,7 @@
 suffices. (For most platforms one can omit all the arguments.)
 
 @item
-(Optional but highly recommended.)  Restrict @code{.Call} etc to using the
+(Optional but highly recommended.)  Restrict @code{.Call} etc to use the
 symbols you chose to register by editing @file{src/init.c} to contain
 
 @example
@@ -9749,7 +9749,7 @@
 unintentionally exports the newly created @R{} objects.
 
 @item
-Restrict @code{.Call} to using the @R{} symbols by editing
+Restrict @code{.Call} to use the @R{} symbols by editing
 @file{src/init.c} to contain
 
 @example
@@ -9781,7 +9781,7 @@
 @noindent
 If there were any entry points not intended to be used by the package we
 should try to avoid exporting them, for example by making them
- at code{static}.  Now the two relevant entry points are only accessed
+ at code{static}.  Now that the two relevant entry points are only accessed
 @emph{via} the registration table, we can hide them.  There are two ways
 to do so on some Unix-alikes.  We can hide individual entry points
 @emph{via}
@@ -9899,8 +9899,8 @@
 A package that wishes to make use of header files in other packages
 needs to declare them as a comma-separated list in the field
 @samp{LinkingTo} in the @file{DESCRIPTION} file.  This then arranges
-that the @file{include} directories in the installed linked-to packages
-are added to the include paths for C and C++ code.
+for the @file{include} directories in the installed linked-to packages
+to be added to the include paths for C and C++ code.
 
 It must specify at footnote{whether or not @samp{LinkingTo} is used.}
 @samp{Imports} or @samp{Depends} of those packages, for they have to be
@@ -9911,7 +9911,7 @@
 
 @acronym{CRAN} examples of the use of this mechanism include @CRANpkg{coxme}
 linking to @CRANpkg{bdsmatrix} and @CRANpkg{xts} linking to
- at CRANpkg{zoo}
+ at CRANpkg{zoo}.
 
 @node Creating shared objects, Interfacing C++ code, Registering native routines, System and foreign language interfaces
 @section Creating shared objects
@@ -9955,7 +9955,7 @@
 by setting the macro @samp{OBJECTS} in file @file{Makevars}, together
 with suitable rules to make the objects.
 
-Flags which are already set (for example in file
+Flags that are already set (for example in file
 @file{etc at var{R_ARCH}/Makeconf}) can be overridden by the environment
 variable @env{MAKEFLAGS} (at least for systems using a POSIX-compliant
 @code{make}), as in (Bourne shell syntax)
@@ -12121,8 +12121,7 @@
 @end example
 
 A toy example of the use of weak references can be found at
- at uref{http://homepage.stat.uiowa.edu/~luke/R/references/weakfinex.html,
- at code{homepage.@/stat.@/uiowa.@/edu/@/~luke/@/R/references/@/weakfinex.html}},
+ at uref{https://homepage.stat.uiowa.edu/~luke/R/references/weakfinex.html},
 but that is used to add finalizers to external pointers which can now be
 done more directly.  At the time of writing no @acronym{CRAN} or
 Bioconductor package uses weak references.

From ligges at statistik.tu-dortmund.de  Mon Jul  3 14:02:36 2017
From: ligges at statistik.tu-dortmund.de (Uwe Ligges)
Date: Mon, 3 Jul 2017 14:02:36 +0200
Subject: [Rd] Are you considering the possibility of partnership?
In-Reply-To: <CAOiGp=FzhJ-VumnD=zoweWWv_XcR9Px-UBUG1Q0ZgrBinCcweQ@mail.gmail.com>
References: <CAOiGp=GrOb2t9ugezJqQAgpsc5_EJGF88UpGoYmyTiSRxOSw=w@mail.gmail.com>
 <CAOiGp=GUHxAwq84uHH0r+HjOL3yc7gDFagGmW8zs2jtvJEJuqw@mail.gmail.com>
 <CAOiGp=FzhJ-VumnD=zoweWWv_XcR9Px-UBUG1Q0ZgrBinCcweQ@mail.gmail.com>
Message-ID: <7795746f-2dba-7c4d-06c5-15281f6fe60a@statistik.tu-dortmund.de>

Plese stop this.

Best,
Uwe Ligges



On 03.07.2017 11:29, Keira Cohen wrote:
> Hi,
> 
> I've sent you partnership offer via e-mail several days ago. Did you
> receive it? Are you interested in placing ads on your site?
> 
> 
> Best regards,
> Keira
> 
> On Fri, Jun 30, 2017 at 11:10 AM, Keira Cohen <cohenkeira at gmail.com> wrote:
> 
>> Hi,
>>
>> did you receive my mail about ad placements? If so it would be great to
>> get a feedback from you.
>>
>>
>> Best regards,
>> Keira
>>
>> On Wed, Jun 28, 2017 at 11:54 AM, Keira Cohen <cohenkeira at gmail.com>
>> wrote:
>>
>>> Hi,
>>> I'm software developer and I think it might be great to advertise my
>>> software on your web site. If you are interested in partnership please
>>> contact me at any time.
>>>
>>> Best regards,
>>> Keira
>>>
>>
>>
> 
> 	[[alternative HTML version deleted]]
>


From spencer.graves at prodsyse.com  Mon Jul  3 14:07:06 2017
From: spencer.graves at prodsyse.com (Spencer Graves)
Date: Mon, 3 Jul 2017 14:07:06 +0200
Subject: [Rd] Are you considering the possibility of partnership?
In-Reply-To: <7795746f-2dba-7c4d-06c5-15281f6fe60a@statistik.tu-dortmund.de>
References: <CAOiGp=GrOb2t9ugezJqQAgpsc5_EJGF88UpGoYmyTiSRxOSw=w@mail.gmail.com>
 <CAOiGp=GUHxAwq84uHH0r+HjOL3yc7gDFagGmW8zs2jtvJEJuqw@mail.gmail.com>
 <CAOiGp=FzhJ-VumnD=zoweWWv_XcR9Px-UBUG1Q0ZgrBinCcweQ@mail.gmail.com>
 <7795746f-2dba-7c4d-06c5-15281f6fe60a@statistik.tu-dortmund.de>
Message-ID: <08263a59-ca48-7ad5-3dda-7deeb253390f@prodsyse.com>



On 2017-07-03 2:02 PM, Uwe Ligges wrote:
> Plese stop this.


       People who reply to spammers only invite more spam.  The only way 
I know to defeat them is to get software to block them.  The anti-spam 
software I have is not great but is better than nothing.


       Spencer

>
> Best,
> Uwe Ligges
>
>
>
> On 03.07.2017 11:29, Keira Cohen wrote:
>> Hi,
>>
>> I've sent you partnership offer via e-mail several days ago. Did you
>> receive it? Are you interested in placing ads on your site?
>>
>>
>> Best regards,
>> Keira
>>
>> On Fri, Jun 30, 2017 at 11:10 AM, Keira Cohen <cohenkeira at gmail.com> 
>> wrote:
>>
>>> Hi,
>>>
>>> did you receive my mail about ad placements? If so it would be great to
>>> get a feedback from you.
>>>
>>>
>>> Best regards,
>>> Keira
>>>
>>> On Wed, Jun 28, 2017 at 11:54 AM, Keira Cohen <cohenkeira at gmail.com>
>>> wrote:
>>>
>>>> Hi,
>>>> I'm software developer and I think it might be great to advertise my
>>>> software on your web site. If you are interested in partnership please
>>>> contact me at any time.
>>>>
>>>> Best regards,
>>>> Keira
>>>>
>>>
>>>
>>
>>     [[alternative HTML version deleted]]
>>
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From marc_schwartz at me.com  Mon Jul  3 14:18:45 2017
From: marc_schwartz at me.com (Marc Schwartz)
Date: Mon, 03 Jul 2017 07:18:45 -0500
Subject: [Rd] Are you considering the possibility of partnership?
In-Reply-To: <08263a59-ca48-7ad5-3dda-7deeb253390f@prodsyse.com>
References: <CAOiGp=GrOb2t9ugezJqQAgpsc5_EJGF88UpGoYmyTiSRxOSw=w@mail.gmail.com>
 <CAOiGp=GUHxAwq84uHH0r+HjOL3yc7gDFagGmW8zs2jtvJEJuqw@mail.gmail.com>
 <CAOiGp=FzhJ-VumnD=zoweWWv_XcR9Px-UBUG1Q0ZgrBinCcweQ@mail.gmail.com>
 <7795746f-2dba-7c4d-06c5-15281f6fe60a@statistik.tu-dortmund.de>
 <08263a59-ca48-7ad5-3dda-7deeb253390f@prodsyse.com>
Message-ID: <B2CDED3B-C988-4518-8BCD-B12D853EE476@me.com>

Hi All,

Just an FYI, that the sender's e-mail was set up last week to auto-discard for R-Devel and their reply below to R-Devel was filtered in that manner.

Unfortunately, it would seem that they also targeted some other specific accounts as well. 

As Spencer notes, I would add their e-mail address to any spam filters folks may be using.

Regards,

Marc


> On Jul 3, 2017, at 7:07 AM, Spencer Graves <spencer.graves at prodsyse.com> wrote:
> 
> 
> 
> On 2017-07-03 2:02 PM, Uwe Ligges wrote:
>> Plese stop this.
> 
> 
>      People who reply to spammers only invite more spam.  The only way I know to defeat them is to get software to block them.  The anti-spam software I have is not great but is better than nothing.
> 
> 
>      Spencer
> 
>> 
>> Best,
>> Uwe Ligges
>> 
>> 
>> 
>> On 03.07.2017 11:29, Keira Cohen wrote:
>>> Hi,
>>> 
>>> I've sent you partnership offer via e-mail several days ago. Did you
>>> receive it? Are you interested in placing ads on your site?
>>> 
>>> 
>>> Best regards,
>>> Keira
>>> 
>>> On Fri, Jun 30, 2017 at 11:10 AM, Keira Cohen <cohenkeira at gmail.com> wrote:
>>> 
>>>> Hi,
>>>> 
>>>> did you receive my mail about ad placements? If so it would be great to
>>>> get a feedback from you.
>>>> 
>>>> 
>>>> Best regards,
>>>> Keira
>>>> 
>>>> On Wed, Jun 28, 2017 at 11:54 AM, Keira Cohen <cohenkeira at gmail.com>
>>>> wrote:
>>>> 
>>>>> Hi,
>>>>> I'm software developer and I think it might be great to advertise my
>>>>> software on your web site. If you are interested in partnership please
>>>>> contact me at any time.
>>>>> 
>>>>> Best regards,
>>>>> Keira
>>>>> 
>>>> 
>>>> 
>>> 
>>>    [[alternative HTML version deleted]]
>>> 
>> 
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From csgillespie at gmail.com  Mon Jul  3 14:35:10 2017
From: csgillespie at gmail.com (Colin Gillespie)
Date: Mon, 03 Jul 2017 12:35:10 +0000
Subject: [Rd] The ByteCompile & LazyLoading fields
Message-ID: <CADbDLZ=YQ9vdHXQ6CzAYmY0syYRJ8aZ0xuYkUzszJ4bgYkDXjQ@mail.gmail.com>

Hi,

In the DESCRIPTION file the ByteCompile and LazyLoading arguments appear to
accept any value.

>From the manual the field should be a "logical field". However, authors
interpret this in a variety of ways:

unique(tools::CRAN_package_db()$ByteCompile)
# [1] NA     "TRUE" "yes"  "true" "Yes"  "no"
# unique(tools::CRAN_package_db()$LazyData)
# [1] NA               "true"           "TRUE"           "yes"
 "no"             "false"
# [7] "True"           "Yes"            "FALSE"          "YES"
 "LazyData: true" "NA"
# [13] "No"

I presume that all non NA are treated as TRUE.

This observation applies to other logical fields in the DESCRIPTION file.

Colin

	[[alternative HTML version deleted]]


From sluedtke at gfz-potsdam.de  Mon Jul  3 15:35:42 2017
From: sluedtke at gfz-potsdam.de (Stefan =?ISO-8859-1?Q?L=FCdtke?=)
Date: Mon, 03 Jul 2017 15:35:42 +0200
Subject: [Rd] R_LIBS_USER on Ubuntu 16.04
Message-ID: <7007487.FzibmnvGII@hydro39>

Dear all, 

the recent update to R-3.4.1 kind of screwed the path to the libraries 
installed on a user basis.

The previous version of the file /etc/R/Renviron had the following line 
activated:

R_LIBS_USER=${R_LIBS_USER-'~/R/x86_64-pc-linux-gnu-library/3.4'}

This one is commented in the current one which means  that the path to the 
libraries installed previously is not found. I never touched this file before. 

Was that on purpose or did that happen accidentally?

Cheers, 

STefan 
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 473 bytes
Desc: This is a digitally signed message part.
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20170703/a2f7e130/attachment.sig>

From istazahn at gmail.com  Mon Jul  3 16:26:37 2017
From: istazahn at gmail.com (Ista Zahn)
Date: Mon, 3 Jul 2017 10:26:37 -0400
Subject: [Rd] R_LIBS_USER on Ubuntu 16.04
In-Reply-To: <7007487.FzibmnvGII@hydro39>
References: <7007487.FzibmnvGII@hydro39>
Message-ID: <CA+vqiLHTDVjQfd=kaSSWf2K6poASMuPhjEDE+tMaxMz_QGMeRg@mail.gmail.com>

Hi Stefan,

This is a packaging issue, not a change in the R source code. Further,
it has already been discussed on R-sig-debian -- see
https://stat.ethz.ch/pipermail/r-sig-debian/2017-July/thread.html

Best,
Ista

On Mon, Jul 3, 2017 at 9:35 AM, Stefan L?dtke <sluedtke at gfz-potsdam.de> wrote:
> Dear all,
>
> the recent update to R-3.4.1 kind of screwed the path to the libraries
> installed on a user basis.
>
> The previous version of the file /etc/R/Renviron had the following line
> activated:
>
> R_LIBS_USER=${R_LIBS_USER-'~/R/x86_64-pc-linux-gnu-library/3.4'}
>
> This one is commented in the current one which means  that the path to the
> libraries installed previously is not found. I never touched this file before.
>
> Was that on purpose or did that happen accidentally?
>
> Cheers,
>
> STefan
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From edd at debian.org  Mon Jul  3 16:39:18 2017
From: edd at debian.org (Dirk Eddelbuettel)
Date: Mon, 3 Jul 2017 09:39:18 -0500
Subject: [Rd] R_LIBS_USER on Ubuntu 16.04
In-Reply-To: <7007487.FzibmnvGII@hydro39>
References: <7007487.FzibmnvGII@hydro39>
Message-ID: <22874.22294.59652.760259@bud.eddelbuettel.com>


On 3 July 2017 at 15:35, Stefan L?dtke wrote:
| the recent update to R-3.4.1 kind of screwed the path to the libraries 
| installed on a user basis.
| 
| The previous version of the file /etc/R/Renviron had the following line 
| activated:
| 
| R_LIBS_USER=${R_LIBS_USER-'~/R/x86_64-pc-linux-gnu-library/3.4'}
| 
| This one is commented in the current one which means  that the path to the 
| libraries installed previously is not found. I never touched this file before. 
| 
| Was that on purpose or did that happen accidentally?

i)   Wrong venue. Discussion of this should be on r-sig-debian.

ii)  On purpose. I have explained the rationale there (ie r-sig-debian) as
     well as this Debian bug report:  https://bugs.debian.org/866768

iii) Easiest fix: Remove _one_ character, the '#' on line 43 of file
     /etc/R/Renviron

iv)  "Correct" fix is the determine a use policy for directory
     /usr/local/lib/R/site-library -- at work several of us are in a shared
     group and you can use 'staff' or 'adm'.  On my laptop I just give the
     directory my own group.

Dirk, at DSC preceding useR! 2017

-- 
http://dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org


From james.f.hester at gmail.com  Tue Jul  4 10:04:50 2017
From: james.f.hester at gmail.com (Jim Hester)
Date: Tue, 4 Jul 2017 10:04:50 +0200
Subject: [Rd] The ByteCompile & LazyLoading fields
In-Reply-To: <CADbDLZ=YQ9vdHXQ6CzAYmY0syYRJ8aZ0xuYkUzszJ4bgYkDXjQ@mail.gmail.com>
References: <CADbDLZ=YQ9vdHXQ6CzAYmY0syYRJ8aZ0xuYkUzszJ4bgYkDXjQ@mail.gmail.com>
Message-ID: <CAD6tx95Ayf3+0-WLiQRZdL9TpcLBgvb6MHFPC2WLR4xDZvf0_g@mail.gmail.com>

In WRE [1] it states

> Several optional fields take logical values: these can be specified as ?yes?, ?true?, ?no? or ?false?: capitalized values are also accepted.

And if you look at the source [2], [3] you will see exactly what
values this entails.

[1]: https://cran.r-project.org/doc/manuals/r-release/R-exts.html#The-DESCRIPTION-file
[2]: https://github.com/wch/r-source/blob/212add0254abe36d1f77e5248f9c9a2bf95884d8/src/library/tools/R/install.R#L1111
[3]: https://github.com/wch/r-source/blob/a3a73a730962fa214b4af0ded55b497fb5688b8b/src/library/tools/R/utils.R#L2162-L2168

On Mon, Jul 3, 2017 at 2:35 PM, Colin Gillespie <csgillespie at gmail.com> wrote:
> Hi,
>
> In the DESCRIPTION file the ByteCompile and LazyLoading arguments appear to
> accept any value.
>
> From the manual the field should be a "logical field". However, authors
> interpret this in a variety of ways:
>
> unique(tools::CRAN_package_db()$ByteCompile)
> # [1] NA     "TRUE" "yes"  "true" "Yes"  "no"
> # unique(tools::CRAN_package_db()$LazyData)
> # [1] NA               "true"           "TRUE"           "yes"
>  "no"             "false"
> # [7] "True"           "Yes"            "FALSE"          "YES"
>  "LazyData: true" "NA"
> # [13] "No"
>
> I presume that all non NA are treated as TRUE.
>
> This observation applies to other logical fields in the DESCRIPTION file.
>
> Colin
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From jean-luc.lipatz at insee.fr  Tue Jul  4 11:40:18 2017
From: jean-luc.lipatz at insee.fr (Lipatz Jean-Luc)
Date: Tue, 4 Jul 2017 09:40:18 +0000
Subject: [Rd] write.csv
Message-ID: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>

Hi all,

I am currently studying how to generalize the usage of R in my statistical institute and I encountered a problem that I cannot declare on bugzilla (cannot understand why). Sorry for trying this mailing list but I am really worried about the problem itself and the possible implications in using R in a professionnal data production context.
The issue about 'write.csv' is that it just doesn't check if there is enough space on disk and doesn't report failure to write data.

Example (R 3.4.0 windows 32 bits, but I reproduced the problem with older versions and under Mac OS/X)

> fwrite(as.list(1:1000000),"G:/Test")
Error in fwrite(as.list(1:1e+06), "G:/Test") :
  No space left on device: 'G:/Test'
> write.csv(1:1000000,"G:/Test")
>

I have a big concern here, because it means that you could save some important data at one point of time and discover a long time after that you actually lost them. I suppose that the fix is relatively straightforward, but how can we be sure that there is no another function with the same bad properties? Is the lesson that you should not use a R function, even from the core, without having personnally tested it against extreme conditions? And wouldn't it be the work of the developpers to do such elementary tests?

Thanks


Jean-Luc LIPATZ
Insee - Direction g?n?rale

Responsable de la coordination sur le d?veloppement de R et la mise en oeuvre d'alternatives ? SAS






	[[alternative HTML version deleted]]


From murdoch.duncan at gmail.com  Tue Jul  4 14:24:16 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Tue, 4 Jul 2017 08:24:16 -0400
Subject: [Rd] write.csv
In-Reply-To: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
Message-ID: <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>

On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
> Hi all,
>
> I am currently studying how to generalize the usage of R in my statistical institute and I encountered a problem that I cannot declare on bugzilla (cannot understand why).

Bugzilla was badly abused by spammers last year, so you need to have 
your account created manually by one of the admins to post there.  Write 
to me privately if you'd like me to create an account for you.  (If you 
want it attached to a different email address, that's fine.)

Sorry for trying this mailing list but I am really worried about the 
problem itself and the possible implications in using R in a 
professionnal data production context.
> The issue about 'write.csv' is that it just doesn't check if there is enough space on disk and doesn't report failure to write data.
>
> Example (R 3.4.0 windows 32 bits, but I reproduced the problem with older versions and under Mac OS/X)
>
>> fwrite(as.list(1:1000000),"G:/Test")
> Error in fwrite(as.list(1:1e+06), "G:/Test") :
>   No space left on device: 'G:/Test'
>> write.csv(1:1000000,"G:/Test")
>>
>
> I have a big concern here, because it means that you could save some important data at one point of time and discover a long time after that you actually lost them.
 > I suppose that the fix is relatively straightforward, but how can we 
be sure that there is no another function with the same bad properties?

R is open source.  You could work out the patch for this bug, and in the 
process see the pattern of coding that leads to it.  Then you'll know if 
other functions use the same buggy pattern.

> Is the lesson that you should not use a R function, even from the core, without having personnally tested it against extreme conditions?

I think the answer to that is yes.  Most people never write such big 
files that they fill their disk:  if they did, all sorts of things would 
go wrong on their systems.  So this kind of extreme condition isn't 
often tested.  It's not easy to test in a platform independent way:  R 
would need to be able to create a volume with a small capacity.  That's 
a very system-dependent thing to do.

> And wouldn't it be the work of the developpers to do such elementary tests?

Again, R is open source.  You can and should contribute code (and 
therefore become one of the developers) if you are working in unusual 
conditions.

R states quite clearly in the welcome message every time it starts: "R 
is free software and comes with ABSOLUTELY NO WARRANTY."  This is 
essentially the same lack of warranty that you get with commercial 
software, though it's stated a lot more clearly.

Duncan Murdoch


From jean-luc.lipatz at insee.fr  Tue Jul  4 14:40:19 2017
From: jean-luc.lipatz at insee.fr (Lipatz Jean-Luc)
Date: Tue, 4 Jul 2017 12:40:19 +0000
Subject: [Rd] write.csv
In-Reply-To: <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
 <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
Message-ID: <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>

I would really like the bug fixed. At least this one, because I know people in my institute using this function.
I understand your arguments about open source, but I also saw in this mail list a proposal for a fix for this bug for which there were no answer from the people who are able to include it in the distribution. It looks like if there were interesting bugs and the other ones.
I don't understand the other arguments : the example was reproduced with a simple USB key and you cannot state that a disk will eternally be empty enough, specially when it has several users.

JLL


-----Message d'origine-----
De : Duncan Murdoch [mailto:murdoch.duncan at gmail.com] 
Envoy? : mardi 4 juillet 2017 14:24
? : Lipatz Jean-Luc; r-devel at r-project.org
Objet : Re: [Rd] write.csv

On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
> Hi all,
>
> I am currently studying how to generalize the usage of R in my statistical institute and I encountered a problem that I cannot declare on bugzilla (cannot understand why).

Bugzilla was badly abused by spammers last year, so you need to have your account created manually by one of the admins to post there.  Write to me privately if you'd like me to create an account for you.  (If you want it attached to a different email address, that's fine.)

Sorry for trying this mailing list but I am really worried about the problem itself and the possible implications in using R in a professionnal data production context.
> The issue about 'write.csv' is that it just doesn't check if there is enough space on disk and doesn't report failure to write data.
>
> Example (R 3.4.0 windows 32 bits, but I reproduced the problem with older versions and under Mac OS/X)
>
>> fwrite(as.list(1:1000000),"G:/Test")
> Error in fwrite(as.list(1:1e+06), "G:/Test") :
>   No space left on device: 'G:/Test'
>> write.csv(1:1000000,"G:/Test")
>>
>
> I have a big concern here, because it means that you could save some important data at one point of time and discover a long time after that you actually lost them.
 > I suppose that the fix is relatively straightforward, but how can we 
be sure that there is no another function with the same bad properties?

R is open source.  You could work out the patch for this bug, and in the 
process see the pattern of coding that leads to it.  Then you'll know if 
other functions use the same buggy pattern.

> Is the lesson that you should not use a R function, even from the core, without having personnally tested it against extreme conditions?

I think the answer to that is yes.  Most people never write such big 
files that they fill their disk:  if they did, all sorts of things would 
go wrong on their systems.  So this kind of extreme condition isn't 
often tested.  It's not easy to test in a platform independent way:  R 
would need to be able to create a volume with a small capacity.  That's 
a very system-dependent thing to do.

> And wouldn't it be the work of the developpers to do such elementary tests?

Again, R is open source.  You can and should contribute code (and 
therefore become one of the developers) if you are working in unusual 
conditions.

R states quite clearly in the welcome message every time it starts: "R 
is free software and comes with ABSOLUTELY NO WARRANTY."  This is 
essentially the same lack of warranty that you get with commercial 
software, though it's stated a lot more clearly.

Duncan Murdoch


From nsosnov at microsoft.com  Tue Jul  4 14:46:57 2017
From: nsosnov at microsoft.com (Nathan Sosnovske)
Date: Tue, 4 Jul 2017 12:46:57 +0000
Subject: [Rd] write.csv
In-Reply-To: <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
 <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
 <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
Message-ID: <SN1PR21MB00610583F90D1F99EE62E7CFB7D70@SN1PR21MB0061.namprd21.prod.outlook.com>

This doesn't really strike me as a bug. Lots of (most?) programming languages expect you to handle this as an error condition. If you tried the same thing in C you would get the same error.

-----Original Message-----
From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of Lipatz Jean-Luc
Sent: Tuesday, July 4, 2017 5:40 AM
To: Duncan Murdoch <murdoch.duncan at gmail.com>
Cc: r-devel at r-project.org
Subject: Re: [Rd] write.csv

I would really like the bug fixed. At least this one, because I know people in my institute using this function.
I understand your arguments about open source, but I also saw in this mail list a proposal for a fix for this bug for which there were no answer from the people who are able to include it in the distribution. It looks like if there were interesting bugs and the other ones.
I don't understand the other arguments : the example was reproduced with a simple USB key and you cannot state that a disk will eternally be empty enough, specially when it has several users.

JLL


-----Message d'origine-----
De : Duncan Murdoch [mailto:murdoch.duncan at gmail.com] Envoy? : mardi 4 juillet 2017 14:24 ? : Lipatz Jean-Luc; r-devel at r-project.org Objet : Re: [Rd] write.csv

On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
> Hi all,
>
> I am currently studying how to generalize the usage of R in my statistical institute and I encountered a problem that I cannot declare on bugzilla (cannot understand why).

Bugzilla was badly abused by spammers last year, so you need to have your account created manually by one of the admins to post there.  Write to me privately if you'd like me to create an account for you.  (If you want it attached to a different email address, that's fine.)

Sorry for trying this mailing list but I am really worried about the problem itself and the possible implications in using R in a professionnal data production context.
> The issue about 'write.csv' is that it just doesn't check if there is enough space on disk and doesn't report failure to write data.
>
> Example (R 3.4.0 windows 32 bits, but I reproduced the problem with 
> older versions and under Mac OS/X)
>
>> fwrite(as.list(1:1000000),"G:/Test")
> Error in fwrite(as.list(1:1e+06), "G:/Test") :
>   No space left on device: 'G:/Test'
>> write.csv(1:1000000,"G:/Test")
>>
>
> I have a big concern here, because it means that you could save some important data at one point of time and discover a long time after that you actually lost them.
 > I suppose that the fix is relatively straightforward, but how can we be sure that there is no another function with the same bad properties?

R is open source.  You could work out the patch for this bug, and in the process see the pattern of coding that leads to it.  Then you'll know if other functions use the same buggy pattern.

> Is the lesson that you should not use a R function, even from the core, without having personnally tested it against extreme conditions?

I think the answer to that is yes.  Most people never write such big files that they fill their disk:  if they did, all sorts of things would go wrong on their systems.  So this kind of extreme condition isn't often tested.  It's not easy to test in a platform independent way:  R would need to be able to create a volume with a small capacity.  That's a very system-dependent thing to do.

> And wouldn't it be the work of the developpers to do such elementary tests?

Again, R is open source.  You can and should contribute code (and therefore become one of the developers) if you are working in unusual conditions.

R states quite clearly in the welcome message every time it starts: "R is free software and comes with ABSOLUTELY NO WARRANTY."  This is essentially the same lack of warranty that you get with commercial software, though it's stated a lot more clearly.

Duncan Murdoch

______________________________________________
R-devel at r-project.org mailing list
https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40microsoft.com%7C92c3e87c4ca1482e32f908d4c2d9dd57%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636347688364867350&sdata=7z5OJqLZDZ1zIvx8pP7KhQzNaQ%2FBrhZFKdUHeiFfke4%3D&reserved=0


From murdoch.duncan at gmail.com  Tue Jul  4 15:38:31 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Tue, 4 Jul 2017 09:38:31 -0400
Subject: [Rd] write.csv
In-Reply-To: <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
 <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
 <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
Message-ID: <f74dd537-cc00-50aa-0f33-c097aa08914a@gmail.com>

On 04/07/2017 8:40 AM, Lipatz Jean-Luc wrote:
> I would really like the bug fixed. At least this one, because I know people in my institute using this function.
> I understand your arguments about open source, but I also saw in this mail list a proposal for a fix for this bug for which there were no answer from the people who are able to include it in the distribution. It looks like if there were interesting bugs and the other ones.

Please post a link to that, and I'll look.  Bug reports should be posted 
to the bug list.  It's unfortunate that it is currently so difficult to 
do so, but if they are only posted here, they are often overlooked.

> I don't understand the other arguments : the example was reproduced with a simple USB key and you cannot state that a disk will eternally be empty enough, specially when it has several users.

I am not denying that it's a bug, I'm just saying that it is a difficult 
one to test automatically (so we probably won't add a regression test 
once it's fixed), and it's not one that has been reported often.  I 
didn't know there were any reports before yours.

Duncan Murdoch

> JLL
>
>
> -----Message d'origine-----
> De : Duncan Murdoch [mailto:murdoch.duncan at gmail.com]
> Envoy? : mardi 4 juillet 2017 14:24
> ? : Lipatz Jean-Luc; r-devel at r-project.org
> Objet : Re: [Rd] write.csv
>
> On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
>> Hi all,
>>
>> I am currently studying how to generalize the usage of R in my statistical institute and I encountered a problem that I cannot declare on bugzilla (cannot understand why).
>
> Bugzilla was badly abused by spammers last year, so you need to have your account created manually by one of the admins to post there.  Write to me privately if you'd like me to create an account for you.  (If you want it attached to a different email address, that's fine.)
>
> Sorry for trying this mailing list but I am really worried about the problem itself and the possible implications in using R in a professionnal data production context.
>> The issue about 'write.csv' is that it just doesn't check if there is enough space on disk and doesn't report failure to write data.
>>
>> Example (R 3.4.0 windows 32 bits, but I reproduced the problem with older versions and under Mac OS/X)
>>
>>> fwrite(as.list(1:1000000),"G:/Test")
>> Error in fwrite(as.list(1:1e+06), "G:/Test") :
>>   No space left on device: 'G:/Test'
>>> write.csv(1:1000000,"G:/Test")
>>>
>>
>> I have a big concern here, because it means that you could save some important data at one point of time and discover a long time after that you actually lost them.
>  > I suppose that the fix is relatively straightforward, but how can we
> be sure that there is no another function with the same bad properties?
>
> R is open source.  You could work out the patch for this bug, and in the
> process see the pattern of coding that leads to it.  Then you'll know if
> other functions use the same buggy pattern.
>
>> Is the lesson that you should not use a R function, even from the core, without having personnally tested it against extreme conditions?
>
> I think the answer to that is yes.  Most people never write such big
> files that they fill their disk:  if they did, all sorts of things would
> go wrong on their systems.  So this kind of extreme condition isn't
> often tested.  It's not easy to test in a platform independent way:  R
> would need to be able to create a volume with a small capacity.  That's
> a very system-dependent thing to do.
>
>> And wouldn't it be the work of the developpers to do such elementary tests?
>
> Again, R is open source.  You can and should contribute code (and
> therefore become one of the developers) if you are working in unusual
> conditions.
>
> R states quite clearly in the welcome message every time it starts: "R
> is free software and comes with ABSOLUTELY NO WARRANTY."  This is
> essentially the same lack of warranty that you get with commercial
> software, though it's stated a lot more clearly.
>
> Duncan Murdoch
>


From murdoch.duncan at gmail.com  Tue Jul  4 15:39:18 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Tue, 4 Jul 2017 09:39:18 -0400
Subject: [Rd] write.csv
In-Reply-To: <SN1PR21MB00610583F90D1F99EE62E7CFB7D70@SN1PR21MB0061.namprd21.prod.outlook.com>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
 <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
 <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
 <SN1PR21MB00610583F90D1F99EE62E7CFB7D70@SN1PR21MB0061.namprd21.prod.outlook.com>
Message-ID: <db38cf87-82f7-835c-2cac-412d6db8c5a1@gmail.com>

On 04/07/2017 8:46 AM, Nathan Sosnovske wrote:
> This doesn't really strike me as a bug. Lots of (most?) programming languages expect you to handle this as an error condition. If you tried the same thing in C you would get the same error.

The bug is that there is no error signalled.  It looks as though the 
write succeeded, when it didn't.

Duncan Murdoch

> -----Original Message-----
> From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of Lipatz Jean-Luc
> Sent: Tuesday, July 4, 2017 5:40 AM
> To: Duncan Murdoch <murdoch.duncan at gmail.com>
> Cc: r-devel at r-project.org
> Subject: Re: [Rd] write.csv
>
> I would really like the bug fixed. At least this one, because I know people in my institute using this function.
> I understand your arguments about open source, but I also saw in this mail list a proposal for a fix for this bug for which there were no answer from the people who are able to include it in the distribution. It looks like if there were interesting bugs and the other ones.
> I don't understand the other arguments : the example was reproduced with a simple USB key and you cannot state that a disk will eternally be empty enough, specially when it has several users.
>
> JLL
>
>
> -----Message d'origine-----
> De : Duncan Murdoch [mailto:murdoch.duncan at gmail.com] Envoy? : mardi 4 juillet 2017 14:24 ? : Lipatz Jean-Luc; r-devel at r-project.org Objet : Re: [Rd] write.csv
>
> On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
>> Hi all,
>>
>> I am currently studying how to generalize the usage of R in my statistical institute and I encountered a problem that I cannot declare on bugzilla (cannot understand why).
>
> Bugzilla was badly abused by spammers last year, so you need to have your account created manually by one of the admins to post there.  Write to me privately if you'd like me to create an account for you.  (If you want it attached to a different email address, that's fine.)
>
> Sorry for trying this mailing list but I am really worried about the problem itself and the possible implications in using R in a professionnal data production context.
>> The issue about 'write.csv' is that it just doesn't check if there is enough space on disk and doesn't report failure to write data.
>>
>> Example (R 3.4.0 windows 32 bits, but I reproduced the problem with
>> older versions and under Mac OS/X)
>>
>>> fwrite(as.list(1:1000000),"G:/Test")
>> Error in fwrite(as.list(1:1e+06), "G:/Test") :
>>   No space left on device: 'G:/Test'
>>> write.csv(1:1000000,"G:/Test")
>>>
>>
>> I have a big concern here, because it means that you could save some important data at one point of time and discover a long time after that you actually lost them.
>  > I suppose that the fix is relatively straightforward, but how can we be sure that there is no another function with the same bad properties?
>
> R is open source.  You could work out the patch for this bug, and in the process see the pattern of coding that leads to it.  Then you'll know if other functions use the same buggy pattern.
>
>> Is the lesson that you should not use a R function, even from the core, without having personnally tested it against extreme conditions?
>
> I think the answer to that is yes.  Most people never write such big files that they fill their disk:  if they did, all sorts of things would go wrong on their systems.  So this kind of extreme condition isn't often tested.  It's not easy to test in a platform independent way:  R would need to be able to create a volume with a small capacity.  That's a very system-dependent thing to do.
>
>> And wouldn't it be the work of the developpers to do such elementary tests?
>
> Again, R is open source.  You can and should contribute code (and therefore become one of the developers) if you are working in unusual conditions.
>
> R states quite clearly in the welcome message every time it starts: "R is free software and comes with ABSOLUTELY NO WARRANTY."  This is essentially the same lack of warranty that you get with commercial software, though it's stated a lot more clearly.
>
> Duncan Murdoch
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40microsoft.com%7C92c3e87c4ca1482e32f908d4c2d9dd57%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636347688364867350&sdata=7z5OJqLZDZ1zIvx8pP7KhQzNaQ%2FBrhZFKdUHeiFfke4%3D&reserved=0
>


From nsosnov at microsoft.com  Tue Jul  4 15:44:48 2017
From: nsosnov at microsoft.com (Nathan Sosnovske)
Date: Tue, 4 Jul 2017 13:44:48 +0000
Subject: [Rd] write.csv
In-Reply-To: <db38cf87-82f7-835c-2cac-412d6db8c5a1@gmail.com>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
 <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
 <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
 <SN1PR21MB00610583F90D1F99EE62E7CFB7D70@SN1PR21MB0061.namprd21.prod.outlook.com>
 <db38cf87-82f7-835c-2cac-412d6db8c5a1@gmail.com>
Message-ID: <SN1PR21MB00617B4EDC5B0AE24A070966B7D70@SN1PR21MB0061.namprd21.prod.outlook.com>

Ah, I misread the example code (went straight to the line where the error was raised for fwrite). Apologies Jean-Luc.

-----Original Message-----
From: Duncan Murdoch [mailto:murdoch.duncan at gmail.com] 
Sent: Tuesday, July 4, 2017 6:39 AM
To: Nathan Sosnovske <nsosnov at microsoft.com>; Lipatz Jean-Luc <jean-luc.lipatz at insee.fr>
Cc: r-devel at r-project.org
Subject: Re: [Rd] write.csv

On 04/07/2017 8:46 AM, Nathan Sosnovske wrote:
> This doesn't really strike me as a bug. Lots of (most?) programming languages expect you to handle this as an error condition. If you tried the same thing in C you would get the same error.

The bug is that there is no error signalled.  It looks as though the write succeeded, when it didn't.

Duncan Murdoch

> -----Original Message-----
> From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of 
> Lipatz Jean-Luc
> Sent: Tuesday, July 4, 2017 5:40 AM
> To: Duncan Murdoch <murdoch.duncan at gmail.com>
> Cc: r-devel at r-project.org
> Subject: Re: [Rd] write.csv
>
> I would really like the bug fixed. At least this one, because I know people in my institute using this function.
> I understand your arguments about open source, but I also saw in this mail list a proposal for a fix for this bug for which there were no answer from the people who are able to include it in the distribution. It looks like if there were interesting bugs and the other ones.
> I don't understand the other arguments : the example was reproduced with a simple USB key and you cannot state that a disk will eternally be empty enough, specially when it has several users.
>
> JLL
>
>
> -----Message d'origine-----
> De : Duncan Murdoch [mailto:murdoch.duncan at gmail.com] Envoy? : mardi 4 
> juillet 2017 14:24 ? : Lipatz Jean-Luc; r-devel at r-project.org Objet : 
> Re: [Rd] write.csv
>
> On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
>> Hi all,
>>
>> I am currently studying how to generalize the usage of R in my statistical institute and I encountered a problem that I cannot declare on bugzilla (cannot understand why).
>
> Bugzilla was badly abused by spammers last year, so you need to have 
> your account created manually by one of the admins to post there.  
> Write to me privately if you'd like me to create an account for you.  
> (If you want it attached to a different email address, that's fine.)
>
> Sorry for trying this mailing list but I am really worried about the problem itself and the possible implications in using R in a professionnal data production context.
>> The issue about 'write.csv' is that it just doesn't check if there is enough space on disk and doesn't report failure to write data.
>>
>> Example (R 3.4.0 windows 32 bits, but I reproduced the problem with 
>> older versions and under Mac OS/X)
>>
>>> fwrite(as.list(1:1000000),"G:/Test")
>> Error in fwrite(as.list(1:1e+06), "G:/Test") :
>>   No space left on device: 'G:/Test'
>>> write.csv(1:1000000,"G:/Test")
>>>
>>
>> I have a big concern here, because it means that you could save some important data at one point of time and discover a long time after that you actually lost them.
>  > I suppose that the fix is relatively straightforward, but how can we be sure that there is no another function with the same bad properties?
>
> R is open source.  You could work out the patch for this bug, and in the process see the pattern of coding that leads to it.  Then you'll know if other functions use the same buggy pattern.
>
>> Is the lesson that you should not use a R function, even from the core, without having personnally tested it against extreme conditions?
>
> I think the answer to that is yes.  Most people never write such big files that they fill their disk:  if they did, all sorts of things would go wrong on their systems.  So this kind of extreme condition isn't often tested.  It's not easy to test in a platform independent way:  R would need to be able to create a volume with a small capacity.  That's a very system-dependent thing to do.
>
>> And wouldn't it be the work of the developpers to do such elementary tests?
>
> Again, R is open source.  You can and should contribute code (and therefore become one of the developers) if you are working in unusual conditions.
>
> R states quite clearly in the welcome message every time it starts: "R is free software and comes with ABSOLUTELY NO WARRANTY."  This is essentially the same lack of warranty that you get with commercial software, though it's stated a lot more clearly.
>
> Duncan Murdoch
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.
> ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40micros
> oft.com%7C92c3e87c4ca1482e32f908d4c2d9dd57%7C72f988bf86f141af91ab2d7cd
> 011db47%7C1%7C0%7C636347688364867350&sdata=7z5OJqLZDZ1zIvx8pP7KhQzNaQ%
> 2FBrhZFKdUHeiFfke4%3D&reserved=0
>


From jorismeys at gmail.com  Tue Jul  4 15:49:19 2017
From: jorismeys at gmail.com (Joris Meys)
Date: Tue, 4 Jul 2017 15:49:19 +0200
Subject: [Rd] write.csv
In-Reply-To: <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
 <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
 <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
Message-ID: <CAO1zAVZpBPhsF-qCr7Nv80+ue_bVPzxw6JPW224Vpym8pM6jNw@mail.gmail.com>

I tested myself, and the "reason" why write.csv() is not giving any error,
is because a file is created. I tested the following with a USB stick
containing only 32Mb of free space:

write.csv(data.frame(V=rnorm(2e7),
                     V2= rnorm(2e7),
                     V3 = rnorm(2e7)),
          file = "G:/Test.csv")

X <- read.csv("G:/Test.csv")

Gives:

> str(X)
'data.frame':    506336 obs. of  4 variables:
 $ X : int  1 2 3 4 5 6 7 8 9 10 ...
 $ V : num  0.0666 -1.2052 -0.2288 -0.4758 1.9168 ...
 $ V2: num  -0.304 -1.766 -1.611 -0.221 -1.118 ...
 $ V3: num  -0.6774 0.0841 0.2062 1.7053 -0.2105 ...

So the first part of the data is stored actually. I totally agree that at
least a warning could be given to tell you not all lines are saved.

While Duncan's reaction might come off a bit direct, please understand that
they are not employees but volunteers. You can demand things from a
company, but in the case of R that's actually rather rude, even when not
intended that way.

Given my limited C skills and my wife hating it when I'm solving other
people's problems in the middle of the night, I'm not hacking in the R core
myself. But as for now, I can offer you this very naive and for big
datasets very time consuming function to check beforehand whether you have
enough space:

testSpace <- function(df,dir){
   totchar <- do.call(sum,
                      lapply(df,
                             function(i) sum(nchar(as.character(i)))))
   # On Windows!
   path <- path.expand(dir)
   path <- gsub("(^[A-Z]{1}:)/.*","\\1",path)

   disks <- system("wmic logicaldisk get freespace, caption",
                   inter = TRUE)

   available <- disks[grep(path,disks)]
   available <- gsub("\\D","",available)
   # Assume 2 bytes per char in UTF-8, which is very liberal
   # but not uncommon
   totchar*16 < as.numeric(available)
}

Gives after about half a minute:

> mydf <- data.frame(V=rnorm(1e7))
> testSpace(mydf, "G:/text.csv")
[1] FALSE

Best regards
Joris

On Tue, Jul 4, 2017 at 2:40 PM, Lipatz Jean-Luc <jean-luc.lipatz at insee.fr>
wrote:

> I would really like the bug fixed. At least this one, because I know
> people in my institute using this function.
> I understand your arguments about open source, but I also saw in this mail
> list a proposal for a fix for this bug for which there were no answer from
> the people who are able to include it in the distribution. It looks like if
> there were interesting bugs and the other ones.
> I don't understand the other arguments : the example was reproduced with a
> simple USB key and you cannot state that a disk will eternally be empty
> enough, specially when it has several users.
>
> JLL
>
>
> -----Message d'origine-----
> De : Duncan Murdoch [mailto:murdoch.duncan at gmail.com]
> Envoy? : mardi 4 juillet 2017 14:24
> ? : Lipatz Jean-Luc; r-devel at r-project.org
> Objet : Re: [Rd] write.csv
>
> On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
> > Hi all,
> >
> > I am currently studying how to generalize the usage of R in my
> statistical institute and I encountered a problem that I cannot declare on
> bugzilla (cannot understand why).
>
> Bugzilla was badly abused by spammers last year, so you need to have your
> account created manually by one of the admins to post there.  Write to me
> privately if you'd like me to create an account for you.  (If you want it
> attached to a different email address, that's fine.)
>
> Sorry for trying this mailing list but I am really worried about the
> problem itself and the possible implications in using R in a professionnal
> data production context.
> > The issue about 'write.csv' is that it just doesn't check if there is
> enough space on disk and doesn't report failure to write data.
> >
> > Example (R 3.4.0 windows 32 bits, but I reproduced the problem with
> older versions and under Mac OS/X)
> >
> >> fwrite(as.list(1:1000000),"G:/Test")
> > Error in fwrite(as.list(1:1e+06), "G:/Test") :
> >   No space left on device: 'G:/Test'
> >> write.csv(1:1000000,"G:/Test")
> >>
> >
> > I have a big concern here, because it means that you could save some
> important data at one point of time and discover a long time after that you
> actually lost them.
>  > I suppose that the fix is relatively straightforward, but how can we
> be sure that there is no another function with the same bad properties?
>
> R is open source.  You could work out the patch for this bug, and in the
> process see the pattern of coding that leads to it.  Then you'll know if
> other functions use the same buggy pattern.
>
> > Is the lesson that you should not use a R function, even from the core,
> without having personnally tested it against extreme conditions?
>
> I think the answer to that is yes.  Most people never write such big
> files that they fill their disk:  if they did, all sorts of things would
> go wrong on their systems.  So this kind of extreme condition isn't
> often tested.  It's not easy to test in a platform independent way:  R
> would need to be able to create a volume with a small capacity.  That's
> a very system-dependent thing to do.
>
> > And wouldn't it be the work of the developpers to do such elementary
> tests?
>
> Again, R is open source.  You can and should contribute code (and
> therefore become one of the developers) if you are working in unusual
> conditions.
>
> R states quite clearly in the welcome message every time it starts: "R
> is free software and comes with ABSOLUTELY NO WARRANTY."  This is
> essentially the same lack of warranty that you get with commercial
> software, though it's stated a lot more clearly.
>
> Duncan Murdoch
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>



-- 
Joris Meys
Statistical consultant

Ghent University
Faculty of Bioscience Engineering
Department of Mathematical Modelling, Statistics and Bio-Informatics

tel :  +32 (0)9 264 61 79
Joris.Meys at Ugent.be
-------------------------------
Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php

	[[alternative HTML version deleted]]


From james.f.hester at gmail.com  Tue Jul  4 16:01:46 2017
From: james.f.hester at gmail.com (Jim Hester)
Date: Tue, 4 Jul 2017 16:01:46 +0200
Subject: [Rd] write.csv
In-Reply-To: <f74dd537-cc00-50aa-0f33-c097aa08914a@gmail.com>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
 <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
 <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
 <f74dd537-cc00-50aa-0f33-c097aa08914a@gmail.com>
Message-ID: <CAD6tx94WZzdeQXHFN=dkT+K7ZU6V-McRWM9tjU74hzG=KpRUEw@mail.gmail.com>

On linux at least you can use `/dev/full` [1] to test writing to a full device.

    > echo 'foo' > /dev/full
    bash: echo: write error: No space left on device

Although that won't be a perfect test for this case where part of the
file is written successfully.

An alternative suggestion for testing this is to create and mount a
loop device [2] with a small file.

[1]: https://en.wikipedia.org/wiki//dev/full
[2]: https://stackoverflow.com/a/16044420/2055486

On Tue, Jul 4, 2017 at 3:38 PM, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> On 04/07/2017 8:40 AM, Lipatz Jean-Luc wrote:
>>
>> I would really like the bug fixed. At least this one, because I know
>> people in my institute using this function.
>> I understand your arguments about open source, but I also saw in this mail
>> list a proposal for a fix for this bug for which there were no answer from
>> the people who are able to include it in the distribution. It looks like if
>> there were interesting bugs and the other ones.
>
>
> Please post a link to that, and I'll look.  Bug reports should be posted to
> the bug list.  It's unfortunate that it is currently so difficult to do so,
> but if they are only posted here, they are often overlooked.
>
>> I don't understand the other arguments : the example was reproduced with a
>> simple USB key and you cannot state that a disk will eternally be empty
>> enough, specially when it has several users.
>
>
> I am not denying that it's a bug, I'm just saying that it is a difficult one
> to test automatically (so we probably won't add a regression test once it's
> fixed), and it's not one that has been reported often.  I didn't know there
> were any reports before yours.
>
> Duncan Murdoch
>
>
>> JLL
>>
>>
>> -----Message d'origine-----
>> De : Duncan Murdoch [mailto:murdoch.duncan at gmail.com]
>> Envoy? : mardi 4 juillet 2017 14:24
>> ? : Lipatz Jean-Luc; r-devel at r-project.org
>> Objet : Re: [Rd] write.csv
>>
>> On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
>>>
>>> Hi all,
>>>
>>> I am currently studying how to generalize the usage of R in my
>>> statistical institute and I encountered a problem that I cannot declare on
>>> bugzilla (cannot understand why).
>>
>>
>> Bugzilla was badly abused by spammers last year, so you need to have your
>> account created manually by one of the admins to post there.  Write to me
>> privately if you'd like me to create an account for you.  (If you want it
>> attached to a different email address, that's fine.)
>>
>> Sorry for trying this mailing list but I am really worried about the
>> problem itself and the possible implications in using R in a professionnal
>> data production context.
>>>
>>> The issue about 'write.csv' is that it just doesn't check if there is
>>> enough space on disk and doesn't report failure to write data.
>>>
>>> Example (R 3.4.0 windows 32 bits, but I reproduced the problem with older
>>> versions and under Mac OS/X)
>>>
>>>> fwrite(as.list(1:1000000),"G:/Test")
>>>
>>> Error in fwrite(as.list(1:1e+06), "G:/Test") :
>>>   No space left on device: 'G:/Test'
>>>>
>>>> write.csv(1:1000000,"G:/Test")
>>>>
>>>
>>> I have a big concern here, because it means that you could save some
>>> important data at one point of time and discover a long time after that you
>>> actually lost them.
>>
>>  > I suppose that the fix is relatively straightforward, but how can we
>> be sure that there is no another function with the same bad properties?
>>
>> R is open source.  You could work out the patch for this bug, and in the
>> process see the pattern of coding that leads to it.  Then you'll know if
>> other functions use the same buggy pattern.
>>
>>> Is the lesson that you should not use a R function, even from the core,
>>> without having personnally tested it against extreme conditions?
>>
>>
>> I think the answer to that is yes.  Most people never write such big
>> files that they fill their disk:  if they did, all sorts of things would
>> go wrong on their systems.  So this kind of extreme condition isn't
>> often tested.  It's not easy to test in a platform independent way:  R
>> would need to be able to create a volume with a small capacity.  That's
>> a very system-dependent thing to do.
>>
>>> And wouldn't it be the work of the developpers to do such elementary
>>> tests?
>>
>>
>> Again, R is open source.  You can and should contribute code (and
>> therefore become one of the developers) if you are working in unusual
>> conditions.
>>
>> R states quite clearly in the welcome message every time it starts: "R
>> is free software and comes with ABSOLUTELY NO WARRANTY."  This is
>> essentially the same lack of warranty that you get with commercial
>> software, though it's stated a lot more clearly.
>>
>> Duncan Murdoch
>>
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch.duncan at gmail.com  Tue Jul  4 16:52:39 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Tue, 4 Jul 2017 10:52:39 -0400
Subject: [Rd] write.csv
In-Reply-To: <CAD6tx94WZzdeQXHFN=dkT+K7ZU6V-McRWM9tjU74hzG=KpRUEw@mail.gmail.com>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
 <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
 <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
 <f74dd537-cc00-50aa-0f33-c097aa08914a@gmail.com>
 <CAD6tx94WZzdeQXHFN=dkT+K7ZU6V-McRWM9tjU74hzG=KpRUEw@mail.gmail.com>
Message-ID: <d989fa4d-9e88-b60e-2a34-1657acee774b@gmail.com>

On 04/07/2017 10:01 AM, Jim Hester wrote:
> On linux at least you can use `/dev/full` [1] to test writing to a full device.
>
>     > echo 'foo' > /dev/full
>     bash: echo: write error: No space left on device

Unfortunately, I get a permission denied error if I try to write there 
from MacOS.  I don't know if Windows has an equivalent.

I've taken a look at the code.  Essentially it comes down to a call to 
the C function vfprintf, which is supposed to return the number of bytes 
written, or a negative value for an error. This return value is often 
not checked; in particular, write.table and friends don't check it.

I'll add code to signal an error if there's a negative value.

I don't think it's feasible to check the number of bytes (formatted text 
with possible translation to a different encoding could have any number 
of bytes) if it's positive.  So hopefully all of our file systems will 
correctly signal an error, and not just report how many bytes were 
successfully written.

>
> Although that won't be a perfect test for this case where part of the
> file is written successfully.
>
> An alternative suggestion for testing this is to create and mount a
> loop device [2] with a small file.
>
> [1]: https://en.wikipedia.org/wiki//dev/full
> [2]: https://stackoverflow.com/a/16044420/2055486

Loop devices sound ideal, but seem to be Linux-only (at least with that 
recipe).

Duncan


>
> On Tue, Jul 4, 2017 at 3:38 PM, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>> On 04/07/2017 8:40 AM, Lipatz Jean-Luc wrote:
>>>
>>> I would really like the bug fixed. At least this one, because I know
>>> people in my institute using this function.
>>> I understand your arguments about open source, but I also saw in this mail
>>> list a proposal for a fix for this bug for which there were no answer from
>>> the people who are able to include it in the distribution. It looks like if
>>> there were interesting bugs and the other ones.
>>
>>
>> Please post a link to that, and I'll look.  Bug reports should be posted to
>> the bug list.  It's unfortunate that it is currently so difficult to do so,
>> but if they are only posted here, they are often overlooked.
>>
>>> I don't understand the other arguments : the example was reproduced with a
>>> simple USB key and you cannot state that a disk will eternally be empty
>>> enough, specially when it has several users.
>>
>>
>> I am not denying that it's a bug, I'm just saying that it is a difficult one
>> to test automatically (so we probably won't add a regression test once it's
>> fixed), and it's not one that has been reported often.  I didn't know there
>> were any reports before yours.
>>
>> Duncan Murdoch
>>
>>
>>> JLL
>>>
>>>
>>> -----Message d'origine-----
>>> De : Duncan Murdoch [mailto:murdoch.duncan at gmail.com]
>>> Envoy? : mardi 4 juillet 2017 14:24
>>> ? : Lipatz Jean-Luc; r-devel at r-project.org
>>> Objet : Re: [Rd] write.csv
>>>
>>> On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
>>>>
>>>> Hi all,
>>>>
>>>> I am currently studying how to generalize the usage of R in my
>>>> statistical institute and I encountered a problem that I cannot declare on
>>>> bugzilla (cannot understand why).
>>>
>>>
>>> Bugzilla was badly abused by spammers last year, so you need to have your
>>> account created manually by one of the admins to post there.  Write to me
>>> privately if you'd like me to create an account for you.  (If you want it
>>> attached to a different email address, that's fine.)
>>>
>>> Sorry for trying this mailing list but I am really worried about the
>>> problem itself and the possible implications in using R in a professionnal
>>> data production context.
>>>>
>>>> The issue about 'write.csv' is that it just doesn't check if there is
>>>> enough space on disk and doesn't report failure to write data.
>>>>
>>>> Example (R 3.4.0 windows 32 bits, but I reproduced the problem with older
>>>> versions and under Mac OS/X)
>>>>
>>>>> fwrite(as.list(1:1000000),"G:/Test")
>>>>
>>>> Error in fwrite(as.list(1:1e+06), "G:/Test") :
>>>>   No space left on device: 'G:/Test'
>>>>>
>>>>> write.csv(1:1000000,"G:/Test")
>>>>>
>>>>
>>>> I have a big concern here, because it means that you could save some
>>>> important data at one point of time and discover a long time after that you
>>>> actually lost them.
>>>
>>>  > I suppose that the fix is relatively straightforward, but how can we
>>> be sure that there is no another function with the same bad properties?
>>>
>>> R is open source.  You could work out the patch for this bug, and in the
>>> process see the pattern of coding that leads to it.  Then you'll know if
>>> other functions use the same buggy pattern.
>>>
>>>> Is the lesson that you should not use a R function, even from the core,
>>>> without having personnally tested it against extreme conditions?
>>>
>>>
>>> I think the answer to that is yes.  Most people never write such big
>>> files that they fill their disk:  if they did, all sorts of things would
>>> go wrong on their systems.  So this kind of extreme condition isn't
>>> often tested.  It's not easy to test in a platform independent way:  R
>>> would need to be able to create a volume with a small capacity.  That's
>>> a very system-dependent thing to do.
>>>
>>>> And wouldn't it be the work of the developpers to do such elementary
>>>> tests?
>>>
>>>
>>> Again, R is open source.  You can and should contribute code (and
>>> therefore become one of the developers) if you are working in unusual
>>> conditions.
>>>
>>> R states quite clearly in the welcome message every time it starts: "R
>>> is free software and comes with ABSOLUTELY NO WARRANTY."  This is
>>> essentially the same lack of warranty that you get with commercial
>>> software, though it's stated a lot more clearly.
>>>
>>> Duncan Murdoch
>>>
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel


From nsosnov at microsoft.com  Tue Jul  4 17:01:51 2017
From: nsosnov at microsoft.com (Nathan Sosnovske)
Date: Tue, 4 Jul 2017 15:01:51 +0000
Subject: [Rd] write.csv
In-Reply-To: <d989fa4d-9e88-b60e-2a34-1657acee774b@gmail.com>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
 <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
 <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
 <f74dd537-cc00-50aa-0f33-c097aa08914a@gmail.com>
 <CAD6tx94WZzdeQXHFN=dkT+K7ZU6V-McRWM9tjU74hzG=KpRUEw@mail.gmail.com>
 <d989fa4d-9e88-b60e-2a34-1657acee774b@gmail.com>
Message-ID: <SN1PR21MB0061BBA34200B3F6609F2536B7D70@SN1PR21MB0061.namprd21.prod.outlook.com>

The best way to test on Windows would probably be creating a small virtual hard disk (via CreateVirtualDisk), mounting it, and writing to the mounted location. I believe the drive could even be mounted to an arbitrary location on the filesystem (instead of a drive letter) so that drive letter conflicts don't come into play.

-----Original Message-----
From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of Duncan Murdoch
Sent: Tuesday, July 4, 2017 7:53 AM
To: Jim Hester <james.f.hester at gmail.com>
Cc: r-devel at r-project.org; Lipatz Jean-Luc <jean-luc.lipatz at insee.fr>
Subject: Re: [Rd] write.csv

On 04/07/2017 10:01 AM, Jim Hester wrote:
> On linux at least you can use `/dev/full` [1] to test writing to a full device.
>
>     > echo 'foo' > /dev/full
>     bash: echo: write error: No space left on device

Unfortunately, I get a permission denied error if I try to write there from MacOS.  I don't know if Windows has an equivalent.

I've taken a look at the code.  Essentially it comes down to a call to the C function vfprintf, which is supposed to return the number of bytes written, or a negative value for an error. This return value is often not checked; in particular, write.table and friends don't check it.

I'll add code to signal an error if there's a negative value.

I don't think it's feasible to check the number of bytes (formatted text with possible translation to a different encoding could have any number of bytes) if it's positive.  So hopefully all of our file systems will correctly signal an error, and not just report how many bytes were successfully written.

>
> Although that won't be a perfect test for this case where part of the 
> file is written successfully.
>
> An alternative suggestion for testing this is to create and mount a 
> loop device [2] with a small file.
>
> [1]: 
> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fen.wi
> kipedia.org%2Fwiki%2F%2Fdev%2Ffull&data=02%7C01%7Cnsosnov%40microsoft.
> com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd011d
> b47%7C1%7C0%7C636347767773809248&sdata=Cb2oduozc2IDCLvXZGG1C4i4hQA7FPs
> 5jHmnFYbk7zQ%3D&reserved=0
> [2]: 
> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstack
> overflow.com%2Fa%2F16044420%2F2055486&data=02%7C01%7Cnsosnov%40microso
> ft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd0
> 11db47%7C1%7C0%7C636347767773809248&sdata=%2BWPfqD0nUS%2F30DUNDqQU79lR
> EJh02ZX0yik9HXiY5kg%3D&reserved=0

Loop devices sound ideal, but seem to be Linux-only (at least with that recipe).

Duncan


>
> On Tue, Jul 4, 2017 at 3:38 PM, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>> On 04/07/2017 8:40 AM, Lipatz Jean-Luc wrote:
>>>
>>> I would really like the bug fixed. At least this one, because I know 
>>> people in my institute using this function.
>>> I understand your arguments about open source, but I also saw in 
>>> this mail list a proposal for a fix for this bug for which there 
>>> were no answer from the people who are able to include it in the 
>>> distribution. It looks like if there were interesting bugs and the other ones.
>>
>>
>> Please post a link to that, and I'll look.  Bug reports should be 
>> posted to the bug list.  It's unfortunate that it is currently so 
>> difficult to do so, but if they are only posted here, they are often overlooked.
>>
>>> I don't understand the other arguments : the example was reproduced 
>>> with a simple USB key and you cannot state that a disk will 
>>> eternally be empty enough, specially when it has several users.
>>
>>
>> I am not denying that it's a bug, I'm just saying that it is a 
>> difficult one to test automatically (so we probably won't add a 
>> regression test once it's fixed), and it's not one that has been 
>> reported often.  I didn't know there were any reports before yours.
>>
>> Duncan Murdoch
>>
>>
>>> JLL
>>>
>>>
>>> -----Message d'origine-----
>>> De : Duncan Murdoch [mailto:murdoch.duncan at gmail.com] Envoy? : mardi 
>>> 4 juillet 2017 14:24 ? : Lipatz Jean-Luc; r-devel at r-project.org 
>>> Objet : Re: [Rd] write.csv
>>>
>>> On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
>>>>
>>>> Hi all,
>>>>
>>>> I am currently studying how to generalize the usage of R in my 
>>>> statistical institute and I encountered a problem that I cannot 
>>>> declare on bugzilla (cannot understand why).
>>>
>>>
>>> Bugzilla was badly abused by spammers last year, so you need to have 
>>> your account created manually by one of the admins to post there.  
>>> Write to me privately if you'd like me to create an account for you.  
>>> (If you want it attached to a different email address, that's fine.)
>>>
>>> Sorry for trying this mailing list but I am really worried about the 
>>> problem itself and the possible implications in using R in a 
>>> professionnal data production context.
>>>>
>>>> The issue about 'write.csv' is that it just doesn't check if there 
>>>> is enough space on disk and doesn't report failure to write data.
>>>>
>>>> Example (R 3.4.0 windows 32 bits, but I reproduced the problem with 
>>>> older versions and under Mac OS/X)
>>>>
>>>>> fwrite(as.list(1:1000000),"G:/Test")
>>>>
>>>> Error in fwrite(as.list(1:1e+06), "G:/Test") :
>>>>   No space left on device: 'G:/Test'
>>>>>
>>>>> write.csv(1:1000000,"G:/Test")
>>>>>
>>>>
>>>> I have a big concern here, because it means that you could save 
>>>> some important data at one point of time and discover a long time 
>>>> after that you actually lost them.
>>>
>>>  > I suppose that the fix is relatively straightforward, but how can 
>>> we be sure that there is no another function with the same bad properties?
>>>
>>> R is open source.  You could work out the patch for this bug, and in 
>>> the process see the pattern of coding that leads to it.  Then you'll 
>>> know if other functions use the same buggy pattern.
>>>
>>>> Is the lesson that you should not use a R function, even from the 
>>>> core, without having personnally tested it against extreme conditions?
>>>
>>>
>>> I think the answer to that is yes.  Most people never write such big 
>>> files that they fill their disk:  if they did, all sorts of things 
>>> would go wrong on their systems.  So this kind of extreme condition 
>>> isn't often tested.  It's not easy to test in a platform independent 
>>> way:  R would need to be able to create a volume with a small 
>>> capacity.  That's a very system-dependent thing to do.
>>>
>>>> And wouldn't it be the work of the developpers to do such 
>>>> elementary tests?
>>>
>>>
>>> Again, R is open source.  You can and should contribute code (and 
>>> therefore become one of the developers) if you are working in 
>>> unusual conditions.
>>>
>>> R states quite clearly in the welcome message every time it starts: 
>>> "R is free software and comes with ABSOLUTELY NO WARRANTY."  This is 
>>> essentially the same lack of warranty that you get with commercial 
>>> software, though it's stated a lot more clearly.
>>>
>>> Duncan Murdoch
>>>
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat
>> .ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40micr
>> osoft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d
>> 7cd011db47%7C1%7C0%7C636347767773809248&sdata=zMU5Ua2gL3fVPc%2FOPhfdc
>> iAdoHzwDyaRnKusZCnXqWo%3D&reserved=0

______________________________________________
R-devel at r-project.org mailing list
https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40microsoft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636347767773809248&sdata=zMU5Ua2gL3fVPc%2FOPhfdciAdoHzwDyaRnKusZCnXqWo%3D&reserved=0

From realitix at gmail.com  Tue Jul  4 17:50:26 2017
From: realitix at gmail.com (=?UTF-8?Q?Jean=2DS=C3=A9bastien_Bevilacqua?=)
Date: Tue, 4 Jul 2017 17:50:26 +0200
Subject: [Rd] [New Patch] Fix disk corruption when writing
Message-ID: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>

Hello,
You can find here a patch to fix disk corruption.
When your disk is full, the write function exit without error but the file
is truncated.

https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243

Sincerely,
Jean-S?bastien Bevilacqua

	[[alternative HTML version deleted]]


From murdoch.duncan at gmail.com  Tue Jul  4 21:37:13 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Tue, 4 Jul 2017 15:37:13 -0400
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
Message-ID: <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>

On 04/07/2017 11:50 AM, Jean-S?bastien Bevilacqua wrote:
> Hello,
> You can find here a patch to fix disk corruption.
> When your disk is full, the write function exit without error but the file
> is truncated.
>
> https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243

Thanks.  I didn't see that when it came through (or did and forgot). 
I'll probably move the error check to a lower level (in the Rconn_printf 
function), if tests show that works.

Duncan Murdoch


From henrik.bengtsson at gmail.com  Wed Jul  5 01:43:28 2017
From: henrik.bengtsson at gmail.com (Henrik Bengtsson)
Date: Tue, 4 Jul 2017 16:43:28 -0700
Subject: [Rd] R_LIBS_USER on Ubuntu 16.04
In-Reply-To: <22874.22294.59652.760259@bud.eddelbuettel.com>
References: <7007487.FzibmnvGII@hydro39>
 <22874.22294.59652.760259@bud.eddelbuettel.com>
Message-ID: <CAFDcVCQkmiDOkPxWaBimkr5RSxH1pzg_-3QzySw0ri4SqVO3Rw@mail.gmail.com>

Users without privileges to fix this themselves can add the following
(verbatim) to their ~/.Renviron:

R_LIBS_USER=~/R/%p-library/%v

No need to update when R is updated. For details on the above format,
see help(".libPaths").

/Henrik

On Mon, Jul 3, 2017 at 7:39 AM, Dirk Eddelbuettel <edd at debian.org> wrote:
>
> On 3 July 2017 at 15:35, Stefan L?dtke wrote:
> | the recent update to R-3.4.1 kind of screwed the path to the libraries
> | installed on a user basis.
> |
> | The previous version of the file /etc/R/Renviron had the following line
> | activated:
> |
> | R_LIBS_USER=${R_LIBS_USER-'~/R/x86_64-pc-linux-gnu-library/3.4'}
> |
> | This one is commented in the current one which means  that the path to the
> | libraries installed previously is not found. I never touched this file before.
> |
> | Was that on purpose or did that happen accidentally?
>
> i)   Wrong venue. Discussion of this should be on r-sig-debian.
>
> ii)  On purpose. I have explained the rationale there (ie r-sig-debian) as
>      well as this Debian bug report:  https://bugs.debian.org/866768
>
> iii) Easiest fix: Remove _one_ character, the '#' on line 43 of file
>      /etc/R/Renviron
>
> iv)  "Correct" fix is the determine a use policy for directory
>      /usr/local/lib/R/site-library -- at work several of us are in a shared
>      group and you can use 'staff' or 'adm'.  On my laptop I just give the
>      directory my own group.
>
> Dirk, at DSC preceding useR! 2017
>
> --
> http://dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From january.weiner at gmail.com  Wed Jul  5 10:39:41 2017
From: january.weiner at gmail.com (January W.)
Date: Wed, 5 Jul 2017 10:39:41 +0200
Subject: [Rd] write.csv
In-Reply-To: <SN1PR21MB0061BBA34200B3F6609F2536B7D70@SN1PR21MB0061.namprd21.prod.outlook.com>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
 <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
 <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
 <f74dd537-cc00-50aa-0f33-c097aa08914a@gmail.com>
 <CAD6tx94WZzdeQXHFN=dkT+K7ZU6V-McRWM9tjU74hzG=KpRUEw@mail.gmail.com>
 <d989fa4d-9e88-b60e-2a34-1657acee774b@gmail.com>
 <SN1PR21MB0061BBA34200B3F6609F2536B7D70@SN1PR21MB0061.namprd21.prod.outlook.com>
Message-ID: <CA+A1kV66BXN_sC0b_JCeqrZROqUOerezzxwJ_dxs6nUaZhKUvQ@mail.gmail.com>

Dear Jean-Luc,

neither write.csv nor save nor save.image nor any other default write
functions in R check for enough space remaining. While this might be indeed
a problem that one should take care of -- sooner or later -- I would
strongly recommend using data.table::fwrite as the working horse for saving
CSV files anyway.

Firstly, it takes better care of error conditions (as demonstrated by you).
Second, it is much faster:

> system.time(fwrite(list(a=1:1e8), file="test.csv"))
   user  system elapsed
  4.672   0.572   0.857
> system.time(write.csv(list(a=1:1e8), file="test.csv"))
   user  system elapsed
165.056   2.684 176.832

That said, I think that the larger issue here is that the logic behind the
family of functions for saving data in base R is different from the logic
of fwrite(). While fwrite allows to write some contents to a file, save(),
write.csv() and family are based on R file connections and can write not
only to a file, but just any sort of a connection. For example, you can
directly write to a compressed file:

df <- data.frame(a=1:1000)
gz <- gzfile("file.gz")
write.csv(df, file=gz)

It can be a socket, it can be a pipe, an URL etc etc.

The problem might be that there is no easy, general way for testing the
specific errors. Internally (see code in the connections.c file in R
sources), the Rconnection object has a member called "write", which is a
pointer to function writing the data to the connection, a different
function for different types of connections. I do not fully understand all
of this code, but since the functions used for writing return errors (I
think) in different ways, it could be that a reasonable solution is not
straightforward.

In the end and at the moment, as usual, you are faced with a compromise
between safety and freedom. If you need freedom or flexibility, you need to
use the core R functions which allow you to compress data on the fly or use
all sorts of connections. If you rather have stay safe, tell your users to
use fwrite for crucial data.

Best,

j.


On 4 July 2017 at 17:01, Nathan Sosnovske via R-devel <r-devel at r-project.org
> wrote:

> The best way to test on Windows would probably be creating a small virtual
> hard disk (via CreateVirtualDisk), mounting it, and writing to the mounted
> location. I believe the drive could even be mounted to an arbitrary
> location on the filesystem (instead of a drive letter) so that drive letter
> conflicts don't come into play.
>
> -----Original Message-----
> From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of Duncan
> Murdoch
> Sent: Tuesday, July 4, 2017 7:53 AM
> To: Jim Hester <james.f.hester at gmail.com>
> Cc: r-devel at r-project.org; Lipatz Jean-Luc <jean-luc.lipatz at insee.fr>
> Subject: Re: [Rd] write.csv
>
> On 04/07/2017 10:01 AM, Jim Hester wrote:
> > On linux at least you can use `/dev/full` [1] to test writing to a full
> device.
> >
> >     > echo 'foo' > /dev/full
> >     bash: echo: write error: No space left on device
>
> Unfortunately, I get a permission denied error if I try to write there
> from MacOS.  I don't know if Windows has an equivalent.
>
> I've taken a look at the code.  Essentially it comes down to a call to the
> C function vfprintf, which is supposed to return the number of bytes
> written, or a negative value for an error. This return value is often not
> checked; in particular, write.table and friends don't check it.
>
> I'll add code to signal an error if there's a negative value.
>
> I don't think it's feasible to check the number of bytes (formatted text
> with possible translation to a different encoding could have any number of
> bytes) if it's positive.  So hopefully all of our file systems will
> correctly signal an error, and not just report how many bytes were
> successfully written.
>
> >
> > Although that won't be a perfect test for this case where part of the
> > file is written successfully.
> >
> > An alternative suggestion for testing this is to create and mount a
> > loop device [2] with a small file.
> >
> > [1]:
> > https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fen.wi
> > kipedia.org%2Fwiki%2F%2Fdev%2Ffull&data=02%7C01%7Cnsosnov%40microsoft.
> > com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd011d
> > b47%7C1%7C0%7C636347767773809248&sdata=Cb2oduozc2IDCLvXZGG1C4i4hQA7FPs
> > 5jHmnFYbk7zQ%3D&reserved=0
> > [2]:
> > https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstack
> > overflow.com%2Fa%2F16044420%2F2055486&data=02%7C01%7Cnsosnov%40microso
> > ft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd0
> > 11db47%7C1%7C0%7C636347767773809248&sdata=%2BWPfqD0nUS%2F30DUNDqQU79lR
> > EJh02ZX0yik9HXiY5kg%3D&reserved=0
>
> Loop devices sound ideal, but seem to be Linux-only (at least with that
> recipe).
>
> Duncan
>
>
> >
> > On Tue, Jul 4, 2017 at 3:38 PM, Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
> >> On 04/07/2017 8:40 AM, Lipatz Jean-Luc wrote:
> >>>
> >>> I would really like the bug fixed. At least this one, because I know
> >>> people in my institute using this function.
> >>> I understand your arguments about open source, but I also saw in
> >>> this mail list a proposal for a fix for this bug for which there
> >>> were no answer from the people who are able to include it in the
> >>> distribution. It looks like if there were interesting bugs and the
> other ones.
> >>
> >>
> >> Please post a link to that, and I'll look.  Bug reports should be
> >> posted to the bug list.  It's unfortunate that it is currently so
> >> difficult to do so, but if they are only posted here, they are often
> overlooked.
> >>
> >>> I don't understand the other arguments : the example was reproduced
> >>> with a simple USB key and you cannot state that a disk will
> >>> eternally be empty enough, specially when it has several users.
> >>
> >>
> >> I am not denying that it's a bug, I'm just saying that it is a
> >> difficult one to test automatically (so we probably won't add a
> >> regression test once it's fixed), and it's not one that has been
> >> reported often.  I didn't know there were any reports before yours.
> >>
> >> Duncan Murdoch
> >>
> >>
> >>> JLL
> >>>
> >>>
> >>> -----Message d'origine-----
> >>> De : Duncan Murdoch [mailto:murdoch.duncan at gmail.com] Envoy? : mardi
> >>> 4 juillet 2017 14:24 ? : Lipatz Jean-Luc; r-devel at r-project.org
> >>> Objet : Re: [Rd] write.csv
> >>>
> >>> On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
> >>>>
> >>>> Hi all,
> >>>>
> >>>> I am currently studying how to generalize the usage of R in my
> >>>> statistical institute and I encountered a problem that I cannot
> >>>> declare on bugzilla (cannot understand why).
> >>>
> >>>
> >>> Bugzilla was badly abused by spammers last year, so you need to have
> >>> your account created manually by one of the admins to post there.
> >>> Write to me privately if you'd like me to create an account for you.
> >>> (If you want it attached to a different email address, that's fine.)
> >>>
> >>> Sorry for trying this mailing list but I am really worried about the
> >>> problem itself and the possible implications in using R in a
> >>> professionnal data production context.
> >>>>
> >>>> The issue about 'write.csv' is that it just doesn't check if there
> >>>> is enough space on disk and doesn't report failure to write data.
> >>>>
> >>>> Example (R 3.4.0 windows 32 bits, but I reproduced the problem with
> >>>> older versions and under Mac OS/X)
> >>>>
> >>>>> fwrite(as.list(1:1000000),"G:/Test")
> >>>>
> >>>> Error in fwrite(as.list(1:1e+06), "G:/Test") :
> >>>>   No space left on device: 'G:/Test'
> >>>>>
> >>>>> write.csv(1:1000000,"G:/Test")
> >>>>>
> >>>>
> >>>> I have a big concern here, because it means that you could save
> >>>> some important data at one point of time and discover a long time
> >>>> after that you actually lost them.
> >>>
> >>>  > I suppose that the fix is relatively straightforward, but how can
> >>> we be sure that there is no another function with the same bad
> properties?
> >>>
> >>> R is open source.  You could work out the patch for this bug, and in
> >>> the process see the pattern of coding that leads to it.  Then you'll
> >>> know if other functions use the same buggy pattern.
> >>>
> >>>> Is the lesson that you should not use a R function, even from the
> >>>> core, without having personnally tested it against extreme conditions?
> >>>
> >>>
> >>> I think the answer to that is yes.  Most people never write such big
> >>> files that they fill their disk:  if they did, all sorts of things
> >>> would go wrong on their systems.  So this kind of extreme condition
> >>> isn't often tested.  It's not easy to test in a platform independent
> >>> way:  R would need to be able to create a volume with a small
> >>> capacity.  That's a very system-dependent thing to do.
> >>>
> >>>> And wouldn't it be the work of the developpers to do such
> >>>> elementary tests?
> >>>
> >>>
> >>> Again, R is open source.  You can and should contribute code (and
> >>> therefore become one of the developers) if you are working in
> >>> unusual conditions.
> >>>
> >>> R states quite clearly in the welcome message every time it starts:
> >>> "R is free software and comes with ABSOLUTELY NO WARRANTY."  This is
> >>> essentially the same lack of warranty that you get with commercial
> >>> software, though it's stated a lot more clearly.
> >>>
> >>> Duncan Murdoch
> >>>
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat
> >> .ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40micr
> >> osoft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d
> >> 7cd011db47%7C1%7C0%7C636347767773809248&sdata=zMU5Ua2gL3fVPc%2FOPhfdc
> >> iAdoHzwDyaRnKusZCnXqWo%3D&reserved=0
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://na01.safelinks.protection.outlook.com/?url=https%3A%
> 2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%
> 7C01%7Cnsosnov%40microsoft.com%7Cb97a7371538b4dbe9a7308d4
> c2ec5aa0%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636347
> 767773809248&sdata=zMU5Ua2gL3fVPc%2FOPhfdciAdoHzwDyaRnKusZCn
> XqWo%3D&reserved=0
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>



-- 
-------- January Weiner --------------------------------------

	[[alternative HTML version deleted]]


From january.weiner at gmail.com  Wed Jul  5 11:26:59 2017
From: january.weiner at gmail.com (January W.)
Date: Wed, 5 Jul 2017 11:26:59 +0200
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
Message-ID: <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>

I tried the newest patch, but it does not seem to work for me (on Linux).
Despite the check in Rconn_printf, the write.csv happily writes to
/dev/full and does not report an error. When I added a printf("%d\n", res);
to the Rconn_printf() definition, I see only positive values returned by
the vfprintf call.

Cheers,

j.


On 4 July 2017 at 21:37, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:

> On 04/07/2017 11:50 AM, Jean-S?bastien Bevilacqua wrote:
>
>> Hello,
>> You can find here a patch to fix disk corruption.
>> When your disk is full, the write function exit without error but the file
>> is truncated.
>>
>> https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243
>>
>
> Thanks.  I didn't see that when it came through (or did and forgot). I'll
> probably move the error check to a lower level (in the Rconn_printf
> function), if tests show that works.
>
> Duncan Murdoch
>
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>



-- 
-------- January Weiner --------------------------------------

	[[alternative HTML version deleted]]


From murdoch.duncan at gmail.com  Wed Jul  5 13:09:35 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Wed, 5 Jul 2017 07:09:35 -0400
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
Message-ID: <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>

On 05/07/2017 5:26 AM, January W. wrote:
> I tried the newest patch, but it does not seem to work for me (on
> Linux). Despite the check in Rconn_printf, the write.csv happily writes
> to /dev/full and does not report an error. When I added a printf("%d\n",
> res); to the Rconn_printf() definition, I see only positive values
> returned by the vfprintf call.
>

That's likely because you aren't writing enough to actually trigger a 
write to disk during the write.  Writes are buffered, and the error 
doesn't happen until the buffer is written.  The regression test I put 
in had this problem; I'm working on MacOS and Windows, so I never got to 
actually try it before committing.

Unfortunately, it doesn't look possible to catch the final flush of the 
buffer when the connection is closed, so small writes won't trigger any 
error.

It's also possible that whatever system you're on doesn't signal an 
error when the write fails.

Duncan Murdoch

> Cheers,
>
> j.
>
>
> On 4 July 2017 at 21:37, Duncan Murdoch <murdoch.duncan at gmail.com
> <mailto:murdoch.duncan at gmail.com>> wrote:
>
>     On 04/07/2017 11:50 AM, Jean-S?bastien Bevilacqua wrote:
>
>         Hello,
>         You can find here a patch to fix disk corruption.
>         When your disk is full, the write function exit without error
>         but the file
>         is truncated.
>
>         https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243
>         <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243>
>
>
>     Thanks.  I didn't see that when it came through (or did and forgot).
>     I'll probably move the error check to a lower level (in the
>     Rconn_printf function), if tests show that works.
>
>     Duncan Murdoch
>
>
>     ______________________________________________
>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>     https://stat.ethz.ch/mailman/listinfo/r-devel
>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>
>
>
>
> --
> -------- January Weiner --------------------------------------


From january.weiner at gmail.com  Wed Jul  5 13:14:53 2017
From: january.weiner at gmail.com (January W.)
Date: Wed, 5 Jul 2017 13:14:53 +0200
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
Message-ID: <CA+A1kV5ZD7ncet7Q2h3Tj8_5rLoSpcQ+PWT6HkfbPiCySC2Fag@mail.gmail.com>

OK, this does indeed seem to be the case. It is interesting that it works
on MacOS, though. I think that given that errors on flushing the cache
cannot be caught, the behavior is inadvertently unpredictable.

best,

j.



On 5 July 2017 at 13:09, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:

> On 05/07/2017 5:26 AM, January W. wrote:
>
>> I tried the newest patch, but it does not seem to work for me (on
>> Linux). Despite the check in Rconn_printf, the write.csv happily writes
>> to /dev/full and does not report an error. When I added a printf("%d\n",
>> res); to the Rconn_printf() definition, I see only positive values
>> returned by the vfprintf call.
>>
>>
> That's likely because you aren't writing enough to actually trigger a
> write to disk during the write.  Writes are buffered, and the error doesn't
> happen until the buffer is written.  The regression test I put in had this
> problem; I'm working on MacOS and Windows, so I never got to actually try
> it before committing.
>
> Unfortunately, it doesn't look possible to catch the final flush of the
> buffer when the connection is closed, so small writes won't trigger any
> error.
>
> It's also possible that whatever system you're on doesn't signal an error
> when the write fails.
>
> Duncan Murdoch
>
> Cheers,
>>
>> j.
>>
>>
>> On 4 July 2017 at 21:37, Duncan Murdoch <murdoch.duncan at gmail.com
>> <mailto:murdoch.duncan at gmail.com>> wrote:
>>
>>     On 04/07/2017 11:50 AM, Jean-S?bastien Bevilacqua wrote:
>>
>>         Hello,
>>         You can find here a patch to fix disk corruption.
>>         When your disk is full, the write function exit without error
>>         but the file
>>         is truncated.
>>
>>         https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243
>>         <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243>
>>
>>
>>     Thanks.  I didn't see that when it came through (or did and forgot).
>>     I'll probably move the error check to a lower level (in the
>>     Rconn_printf function), if tests show that works.
>>
>>     Duncan Murdoch
>>
>>
>>     ______________________________________________
>>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>>     https://stat.ethz.ch/mailman/listinfo/r-devel
>>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>>
>>
>>
>>
>> --
>> -------- January Weiner --------------------------------------
>>
>
>


-- 
-------- January Weiner --------------------------------------

	[[alternative HTML version deleted]]


From sokol at insa-toulouse.fr  Wed Jul  5 14:46:52 2017
From: sokol at insa-toulouse.fr (Serguei Sokol)
Date: Wed, 5 Jul 2017 14:46:52 +0200
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
Message-ID: <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>

Le 05/07/2017 ? 13:09, Duncan Murdoch a ?crit :
> On 05/07/2017 5:26 AM, January W. wrote:
>> I tried the newest patch, but it does not seem to work for me (on
>> Linux). Despite the check in Rconn_printf, the write.csv happily writes
>> to /dev/full and does not report an error. When I added a printf("%d\n",
>> res); to the Rconn_printf() definition, I see only positive values
>> returned by the vfprintf call.
>>
>
> That's likely because you aren't writing enough to actually trigger a write to disk during the write.  Writes are buffered, and the error doesn't happen until 
> the buffer is written.
I can confirm this behavior with fvprintf(). Small and medium sized writings
on /dev/full don't trigger error and 1MB does.

But if fprintf() is used, it returns a negative value from the very first byte written.

Serguei.

>   The regression test I put in had this problem; I'm working on MacOS and Windows, so I never got to actually try it before committing.
>
> Unfortunately, it doesn't look possible to catch the final flush of the buffer when the connection is closed, so small writes won't trigger any error.
>
> It's also possible that whatever system you're on doesn't signal an error when the write fails.
>
> Duncan Murdoch
>
>> Cheers,
>>
>> j.
>>
>>
>> On 4 July 2017 at 21:37, Duncan Murdoch <murdoch.duncan at gmail.com
>> <mailto:murdoch.duncan at gmail.com>> wrote:
>>
>>     On 04/07/2017 11:50 AM, Jean-S?bastien Bevilacqua wrote:
>>
>>         Hello,
>>         You can find here a patch to fix disk corruption.
>>         When your disk is full, the write function exit without error
>>         but the file
>>         is truncated.
>>
>> https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243
>> <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243>
>>
>>
>>     Thanks.  I didn't see that when it came through (or did and forgot).
>>     I'll probably move the error check to a lower level (in the
>>     Rconn_printf function), if tests show that works.
>>
>>     Duncan Murdoch
>>
>>
>>     ______________________________________________
>>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>>     https://stat.ethz.ch/mailman/listinfo/r-devel
>>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>>
>>
>>
>>
>> -- 
>> -------- January Weiner --------------------------------------
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


-- 
Serguei Sokol
Ingenieur de recherche INRA
Metabolisme Integre et Dynamique des Systemes Metaboliques (MetaSys)

LISBP, INSA/INRA UMR 792, INSA/CNRS UMR 5504
135 Avenue de Rangueil
31077 Toulouse Cedex 04

tel: +33 5 6155 9276
fax: +33 5 6704 8825
email: sokol at insa-toulouse.fr
http://metasys.insa-toulouse.fr
http://www.lisbp.fr


From sokol at insa-toulouse.fr  Wed Jul  5 15:33:01 2017
From: sokol at insa-toulouse.fr (Serguei Sokol)
Date: Wed, 5 Jul 2017 15:33:01 +0200
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
Message-ID: <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>

Le 05/07/2017 ? 14:46, Serguei Sokol a ?crit :
> Le 05/07/2017 ? 13:09, Duncan Murdoch a ?crit :
>> On 05/07/2017 5:26 AM, January W. wrote:
>>> I tried the newest patch, but it does not seem to work for me (on
>>> Linux). Despite the check in Rconn_printf, the write.csv happily writes
>>> to /dev/full and does not report an error. When I added a printf("%d\n",
>>> res); to the Rconn_printf() definition, I see only positive values
>>> returned by the vfprintf call.
>>>
>>
>> That's likely because you aren't writing enough to actually trigger a write to disk during the write.  Writes are buffered, and the error doesn't happen 
>> until the buffer is written.
> I can confirm this behavior with fvprintf(). Small and medium sized writings
> on /dev/full don't trigger error and 1MB does.
>
> But if fprintf() is used, it returns a negative value from the very first byte written.
I correct myself. In my test, fprintf() returned -1 for another reason (connection was already closed
at this moment)
However, if fvprintf(...) is followed by res=fflush(con) then res is -1
if we try to write on /dev/full. May be we have to use this to trigger
an error message in R.

Serguei.

>>   The regression test I put in had this problem; I'm working on MacOS and Windows, so I never got to actually try it before committing.
>>
>> Unfortunately, it doesn't look possible to catch the final flush of the buffer when the connection is closed, so small writes won't trigger any error.
>>
>> It's also possible that whatever system you're on doesn't signal an error when the write fails.
>>
>> Duncan Murdoch
>>
>>> Cheers,
>>>
>>> j.
>>>
>>>
>>> On 4 July 2017 at 21:37, Duncan Murdoch <murdoch.duncan at gmail.com
>>> <mailto:murdoch.duncan at gmail.com>> wrote:
>>>
>>>     On 04/07/2017 11:50 AM, Jean-S?bastien Bevilacqua wrote:
>>>
>>>         Hello,
>>>         You can find here a patch to fix disk corruption.
>>>         When your disk is full, the write function exit without error
>>>         but the file
>>>         is truncated.
>>>
>>> https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243
>>> <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243>
>>>
>>>
>>>     Thanks.  I didn't see that when it came through (or did and forgot).
>>>     I'll probably move the error check to a lower level (in the
>>>     Rconn_printf function), if tests show that works.
>>>
>>>     Duncan Murdoch
>>>
>>>
>>>     ______________________________________________
>>>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>>>     https://stat.ethz.ch/mailman/listinfo/r-devel
>>>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>>>
>>>
>>>
>>>
>>> -- 
>>> -------- January Weiner --------------------------------------
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>
>

-- 
Serguei Sokol
Ingenieur de recherche INRA
Metabolisme Integre et Dynamique des Systemes Metaboliques (MetaSys)

LISBP, INSA/INRA UMR 792, INSA/CNRS UMR 5504
135 Avenue de Rangueil
31077 Toulouse Cedex 04

tel: +33 5 6155 9276
fax: +33 5 6704 8825
email: sokol at insa-toulouse.fr
http://metasys.insa-toulouse.fr
http://www.lisbp.fr


From pauljohn32 at gmail.com  Wed Jul  5 17:46:48 2017
From: pauljohn32 at gmail.com (Paul Johnson)
Date: Wed, 5 Jul 2017 10:46:48 -0500
Subject: [Rd] Rmpi, openMPI editions.
In-Reply-To: <CAErODj-Btn4868SPftMKSUyFO3SZ6tRwvdqb5r+hkTCL+kJGNQ@mail.gmail.com>
References: <CAErODj-Btn4868SPftMKSUyFO3SZ6tRwvdqb5r+hkTCL+kJGNQ@mail.gmail.com>
Message-ID: <CAErODj9WoMEnvfeOmCxrm7=6FJZ5HRqmULyeQjYZJ8DZ1Y6cHQ@mail.gmail.com>

Here is what I've learned about OpenMPI and Rmpi during the past 2
weeks. Please tell me if you think I'm incorrect.

I don't understand computer science enough to understand fully the
dangers of forks and data corruption when OpenMPI uses infiniband.
However, perhaps one of you can tell me.

1. Rmpi will compile with OpenMPI >= 2.0, but it is not fully
compatible. The Rmpi author has written to me directly that he is
working on revisions that will make these compatible.  One symptom of
the problem we find is that stopCluster() does not work. It hangs the
session entirely. The only way to shut down the cluster is mpi.quit(),
which terminates the R session entirely.

2. Rmpi will compile/run with OpenMPI < 2.0.

However, on systems that have Infiniband connective devices and openib
libraries, there will be warnings about threads and forks as well as a
danger of data corruption.  The warning from OpenMPI is triggered by
such innocuous R functions as sessionInfo().

Here is a session that shows the warning.

$ R

R version 3.4.0 (2017-04-21) -- "You Stupid Darkness"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

Microsoft R Open 3.4.0
The enhanced R distribution from Microsoft
Microsoft packages Copyright (C) 2017 Microsoft Corporation

Using the Intel MKL for parallel mathematical computing(using 1 cores).

Default CRAN mirror snapshot taken on 2017-05-01.
See: https://mran.microsoft.com/.

[Previously saved workspace restored]

> library(Rmpi)
> sessionInfo()
--------------------------------------------------------------------------
An MPI process has executed an operation involving a call to the
"fork()" system call to create a child process.  Open MPI is currently
operating in a condition that could result in memory corruption or
other system errors; your MPI job may hang, crash, or produce silent
data corruption.  The use of fork() (or system() or other calls that
create child processes) is strongly discouraged.

The process that invoked fork was:

  Local host:          n410 (PID 34456)
  MPI_COMM_WORLD rank: 0

If you are *absolutely sure* that your application will successfully
and correctly survive a call to fork(), you may disable this warning
by setting the mpi_warn_on_fork MCA parameter to 0.
--------------------------------------------------------------------------
R version 3.4.0 (2017-04-21)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Red Hat Enterprise Linux Server release 6.4 (Santiago)

Matrix products: default
BLAS: /panfs/pfs.local/software/install/MRO/3.4.0/microsoft-r/3.4/lib64/R/lib/libRblas.so
LAPACK: /panfs/pfs.local/software/install/MRO/3.4.0/microsoft-r/3.4/lib64/R/lib/libRlapack.so

locale:
[1] C

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base

other attached packages:
[1] Rmpi_0.6-6           RevoUtilsMath_10.0.0

loaded via a namespace (and not attached):
[1] compiler_3.4.0   RevoUtils_10.0.4 parallel_3.4.0


I do not know how how dangerous forks might be, but if you go read
this message, it appears they can cause data corruption, and this has
been known since 2010:

https://www.mail-archive.com/devel at lists.open-mpi.org/msg08785.html

It is above my understanding to say whether garden variety R users
will cause these problems. I do know the R parallel documentation
warns against system calls and forks, possibly for same reason. R
functions that use disk--dir.create, list.files--make a system call
that would fall into the dangerous fork category? I'm not stating that
as a fact, I'm asking if that's right.

Anyway, my "better safe than sorry" instinct leads to this conclusion:
TURN OFF INFINIBAND SUPPORT IN OpenMPI. This is the policy we adopted
in 2010, but I had forgotten until a new cluster computer network came
on line.  With newly installed OpenMPI, I ran into same old problem.

This can be done in the user account, by adding
~/.openmpi/mca-params.conf  (or, systemwide in the openmpi install
folder etc/openmpi-mca-params.conf) with this line.

btl = ^openib

That prevents OpenMPI from using Infiniband transport layer.

One can tell that an Infiniband device is detected with the shell
program "ompi_info" provided by OpenMPI. Look for the btl stanza: The
return from ompi_info is like this if you have Infiniband.

   MCA btl: ofud (MCA v2.0, API v2.0, Component v1.6.5)
   MCA btl: openib (MCA v2.0, API v2.0, Component v1.6.5)
   MCA btl: self (MCA v2.0, API v2.0, Component v1.6.5)
   MCA btl: sm (MCA v2.0, API v2.0, Component v1.6.5)
   MCA btl: tcp (MCA v2.0, API v2.0, Component v1.6.5)

And like this after changing either ~/openmpi/mca-params.conf or,
etc/openmpi-mca-params.conf).

   MCA btl: ofud (MCA v2.0, API v2.0, Component v1.6.5)
   MCA btl: self (MCA v2.0, API v2.0, Component v1.6.5)
   MCA btl: sm (MCA v2.0, API v2.0, Component v1.6.5)
   MCA btl: tcp (MCA v2.0, API v2.0, Component v1.6.5)

I believe it is worth mentioning that, if some of your compute nodes
have Infiniband, an some do not, then OpenMPI jobs will crash if they
try to integrate nodes connected with ethernet and Infiniband.  That
is another reason to tell OpenMPI not to try to use Infiniband at all.

pj

On Mon, Jun 19, 2017 at 2:34 PM, Paul Johnson <pauljohn32 at gmail.com> wrote:
> Greetings.
>
> I see a warning message while compiling OpenMPI and would appreciate
> it if you tell me what it means.
>
> This warning happens with any OpenMPI > 1.6.5.  Even before starting a
> cluster, just "sessionInfo" triggers this warning.
>
> I'm pasting in the message from R-3.3.2 (this is MRO).
>
> Do the R parallel package cluster functions violate the warnings described here?
>
>> library("Rmpi")
>> sessionInfo()
> --------------------------------------------------------------------------
> An MPI process has executed an operation involving a call to the
> "fork()" system call to create a child process.  Open MPI is currently
> operating in a condition that could result in memory corruption or
> other system errors; your MPI job may hang, crash, or produce silent
> data corruption.  The use of fork() (or system() or other calls that
> create child processes) is strongly discouraged.
>
> The process that invoked fork was:
>
>   Local host:          n401 (PID 114242)
>   MPI_COMM_WORLD rank: 0
>
> If you are *absolutely sure* that your application will successfully
> and correctly survive a call to fork(), you may disable this warning
> by setting the mpi_warn_on_fork MCA parameter to 0.
> --------------------------------------------------------------------------
> R version 3.3.2 (2016-10-31)
> Platform: x86_64-pc-linux-gnu (64-bit)
> Running under: Red Hat Enterprise Linux Server release 6.4 (Santiago)
>
> locale:
> [1] C
>
> attached base packages:
> [1] stats     graphics  grDevices utils     datasets  methods   base
>
> other attached packages:
> [1] Rmpi_0.6-6           RevoUtilsMath_10.0.0
>
> loaded via a namespace (and not attached):
> [1] RevoUtils_10.0.2 parallel_3.3.2   tools_3.3.2
>>
>
> What I think this means is that we need to never run any multicore
> functions and we need to be very careful that MKL or such does not
> launch threads.  Is that right? Is it worse than that?
>
> Why am I chasing this one today?
>
> I've been on an adventure compiling R in a RedHat 6 cluster again. The
> cluster admins here like the Microsoft R, and they had both 3.3 and
> 3.4 installed. However, we found some packaging flaws in 3.4 and so
> that MRO was removed. I'm interested in building R-3.4, but it is a
> pretty big job on the old RedHat.  I want to get this correct.
>
> I've run into the problem I'd forgotten about OpenMPI. If OpenMPI >=
> 2, then Rmpi will compile, but jobs hang with "stopCluster".  With
> OpenMPI-1.6.5, we get a clean build and no warnings, and clusters do
> start and stop cleanly.  With newer version 1 editions of OpenMPI,
> such as 1.10 or 1.12 (I suspect any versions (> 1.6.5), the Rmpi
> generates an intimidating warning, but the cluster will stop when
> asked.
>
>
> --
> Paul E. Johnson   http://pj.freefaculty.org
> Director, Center for Research Methods and Data Analysis http://crmda.ku.edu
>
> To write to me directly, please address me at pauljohn at ku.edu.



-- 
Paul E. Johnson   http://pj.freefaculty.org
Director, Center for Research Methods and Data Analysis http://crmda.ku.edu

To write to me directly, please address me at pauljohn at ku.edu.


From benjamin.hall at pw.utc.com  Wed Jul  5 22:03:11 2017
From: benjamin.hall at pw.utc.com (HALL, BENJAMIN            PW)
Date: Wed, 5 Jul 2017 20:03:11 +0000
Subject: [Rd] bug with dlnorm
Message-ID: <d1b856e80fe04762ba7d739d7de3d3a9@UUSALE06.utcmail.com>

I've found some funny behavior in the dlnorm() function that I believe to be a bug.  For example, the following command:

> dlnorm( c(5e-323, 5e-324, 5e-325), 0, 0.3 )

Produces the output below, including the NaN value that should (ideally would be) zero.
[1]   0 NaN   0
Warning message:
In dlnorm(c(4.94065645841247e-323, 4.94065645841247e-324, 0), 0,  :
  NaNs produced

Calling the log() function directly seems to produce appropriate results, e.g.:
> log(c(5e-323,5e-324,5e-524))
[1] -742.1375 -744.4401      -Inf

I realize that I am working in the regime of very small numbers, and that these values are smaller than the value reported by .Machine$double.xmin == 2.225074e-308, but it would be better (for me, at least!) if this corner case(s?) was handled at a lower level.

I have found this behavior in the 64-bit versions (but NOT the 32-bit versions) of R that I have access to.  These include:
                R version 3.2.5 (2016-04-14) -- "Very, Very Secure Dishes"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)
And
R version 3.3.0 (2016-05-03) -- "Supposedly Educational"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)
And
R version 3.0.0 (2013-04-03) -- "Masked Marvel"
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)
And
R version 3.0.1 (2013-05-16) -- "Good Sport"
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-unknown-linux-gnu (64-bit)
And
R version 3.0.1 (2013-05-16) -- "Good Sport"
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-unknown-linux-gnu (64-bit)

But NOT in any of the 32-bit versions I have access to, including:
R version 2.11.1 (2010-05-31)
Copyright (C) 2010 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
And
R version 3.0.0 (2013-04-03) -- "Masked Marvel"
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: i386-w64-mingw32/i386 (32-bit)

Thanks,
Ben


	[[alternative HTML version deleted]]


From sokol at insa-toulouse.fr  Thu Jul  6 11:21:54 2017
From: sokol at insa-toulouse.fr (Serguei Sokol)
Date: Thu, 6 Jul 2017 11:21:54 +0200
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
Message-ID: <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>

I propose the following patch against the current R-devel/src/main/connection.c (cf. attached file).
It gives (on my linux box):
 > fc=file("/dev/full", "w")
 > write.csv("a", file=fc)
Error in writeLines(paste(col.names, collapse = sep), file, sep = eol) :
   system call failure on writing
 > close(fc)

Serguei.

Le 05/07/2017 ? 15:33, Serguei Sokol a ?crit :
> Le 05/07/2017 ? 14:46, Serguei Sokol a ?crit :
>> Le 05/07/2017 ? 13:09, Duncan Murdoch a ?crit :
>>> On 05/07/2017 5:26 AM, January W. wrote:
>>>> I tried the newest patch, but it does not seem to work for me (on
>>>> Linux). Despite the check in Rconn_printf, the write.csv happily writes
>>>> to /dev/full and does not report an error. When I added a printf("%d\n",
>>>> res); to the Rconn_printf() definition, I see only positive values
>>>> returned by the vfprintf call.
>>>>
>>>
>>> That's likely because you aren't writing enough to actually trigger a write to disk during the write.  Writes are buffered, and the error doesn't happen 
>>> until the buffer is written.
>> I can confirm this behavior with fvprintf(). Small and medium sized writings
>> on /dev/full don't trigger error and 1MB does.
>>
>> But if fprintf() is used, it returns a negative value from the very first byte written.
> I correct myself. In my test, fprintf() returned -1 for another reason (connection was already closed
> at this moment)
> However, if fvprintf(...) is followed by res=fflush(con) then res is -1
> if we try to write on /dev/full. May be we have to use this to trigger
> an error message in R.
>
> Serguei.
>
>>>   The regression test I put in had this problem; I'm working on MacOS and Windows, so I never got to actually try it before committing.
>>>
>>> Unfortunately, it doesn't look possible to catch the final flush of the buffer when the connection is closed, so small writes won't trigger any error.
>>>
>>> It's also possible that whatever system you're on doesn't signal an error when the write fails.
>>>
>>> Duncan Murdoch
>>>
>>>> Cheers,
>>>>
>>>> j.
>>>>
>>>>
>>>> On 4 July 2017 at 21:37, Duncan Murdoch <murdoch.duncan at gmail.com
>>>> <mailto:murdoch.duncan at gmail.com>> wrote:
>>>>
>>>>     On 04/07/2017 11:50 AM, Jean-S?bastien Bevilacqua wrote:
>>>>
>>>>         Hello,
>>>>         You can find here a patch to fix disk corruption.
>>>>         When your disk is full, the write function exit without error
>>>>         but the file
>>>>         is truncated.
>>>>
>>>> https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243
>>>> <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243>
>>>>
>>>>
>>>>     Thanks.  I didn't see that when it came through (or did and forgot).
>>>>     I'll probably move the error check to a lower level (in the
>>>>     Rconn_printf function), if tests show that works.
>>>>
>>>>     Duncan Murdoch
>>>>
>>>>
>>>>     ______________________________________________
>>>>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>>>>     https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>>>>
>>>>
>>>>
>>>>
>>>> -- 
>>>> -------- January Weiner --------------------------------------
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>>
>

-- 
Serguei Sokol
Ingenieur de recherche INRA
Metabolisme Integre et Dynamique des Systemes Metaboliques (MetaSys)

LISBP, INSA/INRA UMR 792, INSA/CNRS UMR 5504
135 Avenue de Rangueil
31077 Toulouse Cedex 04

tel: +33 5 6155 9276
fax: +33 5 6704 8825
email: sokol at insa-toulouse.fr
http://metasys.insa-toulouse.fr
http://www.lisbp.fr

-------------- next part --------------
A non-text attachment was scrubbed...
Name: connection.patch
Type: text/x-patch
Size: 599 bytes
Desc: not available
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20170706/289146b1/attachment.bin>

From sahil.kang at asilaycomputing.com  Thu Jul  6 16:40:23 2017
From: sahil.kang at asilaycomputing.com (Sahil Kang)
Date: Thu, 6 Jul 2017 07:40:23 -0700
Subject: [Rd]  [Bug Fix] Default values not applied to ... arguments
Message-ID: <8b83c113-8ec1-bf78-17f5-66682b798475@asilaycomputing.com>

Hi Duncan, Martin

Here's a small patch that fixes bug 15199 reported at:
https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=15199

I was able to reproduce the bug as Duncan had outlined just fine, but I 
did notice that when we debug(f), the problem went away.
I later realized that f(1,,3) behaved correctly the first time it was 
executed, but misbehaved as documented on subsequent calls.
This narrowed the problem down to the byte-compilation that occurs on 
subsequent function calls.

This patch prevents byte-compilation on closure objects.
Although it's a less than ideal solution, this patch fixes the bug at 
least until the underlying byte-compilation issue can be found (I'm 
currently scrutinizing the promiseArgs function at eval.c:2771).

Thanks,
Sahil
-------------- next part --------------
A non-text attachment was scrubbed...
Name: patch.diff
Type: text/x-patch
Size: 531 bytes
Desc: not available
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20170706/9c1a55db/attachment.bin>

From tomas.kalibera at gmail.com  Thu Jul  6 18:29:07 2017
From: tomas.kalibera at gmail.com (Tomas Kalibera)
Date: Thu, 6 Jul 2017 18:29:07 +0200
Subject: [Rd] [Bug Fix] Default values not applied to ... arguments
In-Reply-To: <8b83c113-8ec1-bf78-17f5-66682b798475@asilaycomputing.com>
References: <8b83c113-8ec1-bf78-17f5-66682b798475@asilaycomputing.com>
Message-ID: <0555003e-e7fe-9b3d-def7-852a0644ebdc@gmail.com>


Thanks for the report, I've fixed 15199 in the AST interpreter in 72664, 
I will fix it in the byte-code interpreter as well.

If you ever needed to disable the JIT, there is API for that, see 
?compiler. Note though that by disabling the JIT you won't disable the 
byte-code interpreter, because code also gets compiled when packages are 
installed or when the compiler is invoked explicitly.

Best,
Tomas

On 07/06/2017 04:40 PM, Sahil Kang wrote:
> Hi Duncan, Martin
>
> Here's a small patch that fixes bug 15199 reported at:
> https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=15199
>
> I was able to reproduce the bug as Duncan had outlined just fine, but 
> I did notice that when we debug(f), the problem went away.
> I later realized that f(1,,3) behaved correctly the first time it was 
> executed, but misbehaved as documented on subsequent calls.
> This narrowed the problem down to the byte-compilation that occurs on 
> subsequent function calls.
>
> This patch prevents byte-compilation on closure objects.
> Although it's a less than ideal solution, this patch fixes the bug at 
> least until the underlying byte-compilation issue can be found (I'm 
> currently scrutinizing the promiseArgs function at eval.c:2771).
>
> Thanks,
> Sahil
>
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



	[[alternative HTML version deleted]]


From murdoch.duncan at gmail.com  Thu Jul  6 19:58:10 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Thu, 6 Jul 2017 13:58:10 -0400
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
 <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
Message-ID: <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>

On 06/07/2017 5:21 AM, Serguei Sokol wrote:
> I propose the following patch against the current R-devel/src/main/connection.c (cf. attached file).
> It gives (on my linux box):
>  > fc=file("/dev/full", "w")
>  > write.csv("a", file=fc)
> Error in writeLines(paste(col.names, collapse = sep), file, sep = eol) :
>    system call failure on writing
>  > close(fc)
>
> Serguei.

I suspect that flushing on every write will slow things down too much.

I think a better approach is to catch the error in the Rconn_printf 
calls (as R-devel currently does), and also catch errors on 
con->close(con).  This one requires more changes to the source, so it 
may be a day or two before I commit.

One thing I have to look into:  is anyone making use of the fact that 
the R-level close.connection() function can return -1 to signal an 
error?  Base R ignores that, which is why we need to do something, but 
if packages are using it, things need to be changed carefully.  I can't 
just change it to raise an error instead.

Duncan Murdoch


>
> Le 05/07/2017 ? 15:33, Serguei Sokol a ?crit :
>> Le 05/07/2017 ? 14:46, Serguei Sokol a ?crit :
>>> Le 05/07/2017 ? 13:09, Duncan Murdoch a ?crit :
>>>> On 05/07/2017 5:26 AM, January W. wrote:
>>>>> I tried the newest patch, but it does not seem to work for me (on
>>>>> Linux). Despite the check in Rconn_printf, the write.csv happily writes
>>>>> to /dev/full and does not report an error. When I added a printf("%d\n",
>>>>> res); to the Rconn_printf() definition, I see only positive values
>>>>> returned by the vfprintf call.
>>>>>
>>>>
>>>> That's likely because you aren't writing enough to actually trigger a write to disk during the write.  Writes are buffered, and the error doesn't happen
>>>> until the buffer is written.
>>> I can confirm this behavior with fvprintf(). Small and medium sized writings
>>> on /dev/full don't trigger error and 1MB does.
>>>
>>> But if fprintf() is used, it returns a negative value from the very first byte written.
>> I correct myself. In my test, fprintf() returned -1 for another reason (connection was already closed
>> at this moment)
>> However, if fvprintf(...) is followed by res=fflush(con) then res is -1
>> if we try to write on /dev/full. May be we have to use this to trigger
>> an error message in R.
>>
>> Serguei.
>>
>>>>   The regression test I put in had this problem; I'm working on MacOS and Windows, so I never got to actually try it before committing.
>>>>
>>>> Unfortunately, it doesn't look possible to catch the final flush of the buffer when the connection is closed, so small writes won't trigger any error.
>>>>
>>>> It's also possible that whatever system you're on doesn't signal an error when the write fails.
>>>>
>>>> Duncan Murdoch
>>>>
>>>>> Cheers,
>>>>>
>>>>> j.
>>>>>
>>>>>
>>>>> On 4 July 2017 at 21:37, Duncan Murdoch <murdoch.duncan at gmail.com
>>>>> <mailto:murdoch.duncan at gmail.com>> wrote:
>>>>>
>>>>>     On 04/07/2017 11:50 AM, Jean-S?bastien Bevilacqua wrote:
>>>>>
>>>>>         Hello,
>>>>>         You can find here a patch to fix disk corruption.
>>>>>         When your disk is full, the write function exit without error
>>>>>         but the file
>>>>>         is truncated.
>>>>>
>>>>> https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243
>>>>> <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243>
>>>>>
>>>>>
>>>>>     Thanks.  I didn't see that when it came through (or did and forgot).
>>>>>     I'll probably move the error check to a lower level (in the
>>>>>     Rconn_printf function), if tests show that works.
>>>>>
>>>>>     Duncan Murdoch
>>>>>
>>>>>
>>>>>     ______________________________________________
>>>>>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>>>>>     https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>> --
>>>>> -------- January Weiner --------------------------------------
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>>
>>
>


From wdunlap at tibco.com  Thu Jul  6 22:20:45 2017
From: wdunlap at tibco.com (William Dunlap)
Date: Thu, 6 Jul 2017 13:20:45 -0700
Subject: [Rd] attributes on symbols
Message-ID: <CAF8bMcY0Sq9qf-24VKQe3BV+fi4KnLppbU221dXZkkS1_862vQ@mail.gmail.com>

The multcomp package has code in multcomp:::expression2coef that attaches
the 'coef' attribute to symbols.  Since there is only one symbol object in
a session with a given name, this means that this attaching has a global
effect.  Should this be quietly allowed or should there be a warning or an
error?

E.g.,

str(quote(Education))
# symbol Education
lmod <- stats::lm(Fertility ~ ., data = datasets::swiss)
glmod <- multcomp::glht(lmod, c("Agriculture=0", "Education=0"))
str(quote(Education))
# symbol Education
# - attr(*, "coef")= num 1

Bill Dunlap
TIBCO Software
wdunlap tibco.com

	[[alternative HTML version deleted]]


From gmbecker at ucdavis.edu  Thu Jul  6 23:26:39 2017
From: gmbecker at ucdavis.edu (Gabriel Becker)
Date: Thu, 6 Jul 2017 14:26:39 -0700
Subject: [Rd] make check-recommended hanging on up-to-date Rdevel from SVN
Message-ID: <CADwqtCM4Nse-nUrHnaxACa9CYBHg4iq4yMLQT89tSnnBH3mNQQ@mail.gmail.com>

Hi all,

I'm getting an issue with Rdevel where make check-recommended hangs
consistently for me on Mac El Capitan when checking the Matrix package. I
did svn update and tools/rsync_recommended earlier today and it didn't fix
the issue.

Specifically, it is hanging on the

* checking dependencies in R code ...


stage (while checking Matrix, it passes fine for MASS and lattice).
Currently I'm getting the same behavior when I do

tools:::.check_packages("<builddir>/tests/RecPackages/Matrix")


Is this a known issue and if not, do other people see this behavior?

Best,
~G


Various info:

Build script:

#!/bin/bash

export CC="gcc -std=gnu99 -fsanitize=address"
# make -O0 if we want full debugging symbols
export CFLAGS="-fno-omit-frame-pointer -g -O2 -Wall -pedantic -mtune=native"
#export CFLAGS="-fno-omit-frame-pointer -g -O0 -Wall -pedantic
-mtune=native"

export CXX="g++ -fsanitize=address -fno-omit-frame-pointer"
export F77="gfortran -arch x86_64"
export FC="gfortran -arch x86_64"
export MAIN_LDFLAGS=" -fsanitize=address"

../checkedout/Rsource/rawtrunk/configure
--prefix=/Users/beckerg4/local/Rdevel --enable-R-framework
--enable-memory-profiling
make -j3
make install

Svn Info:

beckerg4-T4G3QN:rawtrunk beckerg4$ *svn info*

Path: .

Working Copy Root Path: /Users/beckerg4/gabe/checkedout/Rsource/rawtrunk

URL: https://svn.r-project.org/R/trunk

Relative URL: ^/trunk

Repository Root: https://svn.r-project.org/R

Repository UUID: 00db46b3-68df-0310-9c12-caf00c1e9a41

Revision: 72894

Node Kind: directory

Schedule: normal

Last Changed Author: lawrence

Last Changed Rev: 72894

Last Changed Date: 2017-07-06 00:12:06 -0700 (Thu, 06 Jul 2017)



Svn status (no local changes)

beckerg4-T4G3QN:rawtrunk beckerg4$* svn status*

beckerg4-T4G3QN:rawtrunk beckerg4$


Session info after Matrix is attached:

*> library(Matrix)*

*> sessionInfo()*

R Under development (unstable) (2017-07-06 r72894)

Platform: x86_64-apple-darwin15.6.0 (64-bit)

Running under: OS X El Capitan 10.11.6


Matrix products: default

BLAS: /Users/beckerg4/gabe/Rdevelbuild/lib/libRblas.dylib

LAPACK: /Users/beckerg4/gabe/Rdevelbuild/lib/libRlapack.dylib


locale:

[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8


attached base packages:

[1] stats     graphics  grDevices utils     datasets  methods   base


other attached packages:

[1] Matrix_1.2-10


loaded via a namespace (and not attached):

[1] compiler_3.5.0  grid_3.5.0      lattice_0.20-35



-- 
Gabriel Becker, PhD
Associate Scientist (Bioinformatics)
Genentech Research

	[[alternative HTML version deleted]]


From sokol at insa-toulouse.fr  Fri Jul  7 00:43:41 2017
From: sokol at insa-toulouse.fr (Sokol Serguei)
Date: Fri, 7 Jul 2017 00:43:41 +0159.55
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
 <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
 <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>
Message-ID: <ed2899b8-f945-1dad-348a-cee0f8614ba7@insa-toulouse.fr>

Duncan Murdoch has written at  Thu, 6 Jul 2017 13:58:10 -0400
> On 06/07/2017 5:21 AM, Serguei Sokol wrote:
>> I propose the following patch against the current 
>> R-devel/src/main/connection.c (cf. attached file).
>> It gives (on my linux box):
>>  > fc=file("/dev/full", "w")
>>  > write.csv("a", file=fc)
>> Error in writeLines(paste(col.names, collapse = sep), file, sep = eol) :
>>    system call failure on writing
>>  > close(fc)
>>
>> Serguei.
>
> I suspect that flushing on every write will slow things down too much.
That's quite plausible.

>
> I think a better approach is to catch the error in the Rconn_printf 
> calls (as R-devel currently does), and also catch errors on 
> con->close(con).  This one requires more changes to the source, so it 
> may be a day or two before I commit.
I have testes it on file_close() and it works (cf. attached patch):
 > fc=file("/dev/full", "w")
 > write.csv("a", file=fc)
 > close(fc)
Error in close.connection(fc) : closing file failed

>
> One thing I have to look into:  is anyone making use of the fact that 
> the R-level close.connection() function can return -1 to signal an 
> error?  Base R ignores that, which is why we need to do something, but 
> if packages are using it, things need to be changed carefully.  I 
> can't just change it to raise an error instead.
As you can see in the patch, no need to change close.connection() function
but we have to add a test of con->status to all *_close() functions 
(gzfile_close() and co.)

Serguei.

>>
>> Le 05/07/2017 ? 15:33, Serguei Sokol a ?crit :
>>> Le 05/07/2017 ? 14:46, Serguei Sokol a ?crit :
>>>> Le 05/07/2017 ? 13:09, Duncan Murdoch a ?crit :
>>>>> On 05/07/2017 5:26 AM, January W. wrote:
>>>>>> I tried the newest patch, but it does not seem to work for me (on
>>>>>> Linux). Despite the check in Rconn_printf, the write.csv happily 
>>>>>> writes
>>>>>> to /dev/full and does not report an error. When I added a 
>>>>>> printf("%d\n",
>>>>>> res); to the Rconn_printf() definition, I see only positive values
>>>>>> returned by the vfprintf call.
>>>>>>
>>>>>
>>>>> That's likely because you aren't writing enough to actually 
>>>>> trigger a write to disk during the write.  Writes are buffered, 
>>>>> and the error doesn't happen
>>>>> until the buffer is written.
>>>> I can confirm this behavior with fvprintf(). Small and medium sized 
>>>> writings
>>>> on /dev/full don't trigger error and 1MB does.
>>>>
>>>> But if fprintf() is used, it returns a negative value from the very 
>>>> first byte written.
>>> I correct myself. In my test, fprintf() returned -1 for another 
>>> reason (connection was already closed
>>> at this moment)
>>> However, if fvprintf(...) is followed by res=fflush(con) then res is -1
>>> if we try to write on /dev/full. May be we have to use this to trigger
>>> an error message in R.
>>>
>>> Serguei.
>>>
>>>>>   The regression test I put in had this problem; I'm working on 
>>>>> MacOS and Windows, so I never got to actually try it before 
>>>>> committing.
>>>>>
>>>>> Unfortunately, it doesn't look possible to catch the final flush 
>>>>> of the buffer when the connection is closed, so small writes won't 
>>>>> trigger any error.
>>>>>
>>>>> It's also possible that whatever system you're on doesn't signal 
>>>>> an error when the write fails.
>>>>>
>>>>> Duncan Murdoch
>>>>>
>>>>>> Cheers,
>>>>>>
>>>>>> j.
>>>>>>
>>>>>>
>>>>>> On 4 July 2017 at 21:37, Duncan Murdoch <murdoch.duncan at gmail.com
>>>>>> <mailto:murdoch.duncan at gmail.com>> wrote:
>>>>>>
>>>>>>     On 04/07/2017 11:50 AM, Jean-S?bastien Bevilacqua wrote:
>>>>>>
>>>>>>         Hello,
>>>>>>         You can find here a patch to fix disk corruption.
>>>>>>         When your disk is full, the write function exit without 
>>>>>> error
>>>>>>         but the file
>>>>>>         is truncated.
>>>>>>
>>>>>> https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243
>>>>>> <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243>
>>>>>>
>>>>>>
>>>>>>     Thanks.  I didn't see that when it came through (or did and 
>>>>>> forgot).
>>>>>>     I'll probably move the error check to a lower level (in the
>>>>>>     Rconn_printf function), if tests show that works.
>>>>>>
>>>>>>     Duncan Murdoch
>>>>>>
>>>>>>
>>>>>>     ______________________________________________
>>>>>>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing 
>>>>>> list
>>>>>>     https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>> <https://stat.ethz.ch/mailman/listinfo/r-devel>
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>> -- 
>>>>>> -------- January Weiner --------------------------------------
>>>>>
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>>
>>>
>>
>
>


-------------- next part --------------
A non-text attachment was scrubbed...
Name: file_close.patch
Type: text/x-patch
Size: 384 bytes
Desc: not available
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20170707/336be5fc/attachment.bin>

From murdoch.duncan at gmail.com  Fri Jul  7 01:09:30 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Thu, 6 Jul 2017 19:09:30 -0400
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <ed2899b8-f945-1dad-348a-cee0f8614ba7@insa-toulouse.fr>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
 <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
 <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>
 <ed2899b8-f945-1dad-348a-cee0f8614ba7@insa-toulouse.fr>
Message-ID: <e8804ff7-473f-3b89-fa65-c1b0d79d85e3@gmail.com>

On 06/07/2017 6:44 PM, Sokol Serguei wrote:
> Duncan Murdoch has written at  Thu, 6 Jul 2017 13:58:10 -0400
>> On 06/07/2017 5:21 AM, Serguei Sokol wrote:
>>> I propose the following patch against the current
>>> R-devel/src/main/connection.c (cf. attached file).
>>> It gives (on my linux box):
>>>  > fc=file("/dev/full", "w")
>>>  > write.csv("a", file=fc)
>>> Error in writeLines(paste(col.names, collapse = sep), file, sep = eol) :
>>>    system call failure on writing
>>>  > close(fc)
>>>
>>> Serguei.
>>
>> I suspect that flushing on every write will slow things down too much.
> That's quite plausible.
>
>>
>> I think a better approach is to catch the error in the Rconn_printf
>> calls (as R-devel currently does), and also catch errors on
>> con->close(con).  This one requires more changes to the source, so it
>> may be a day or two before I commit.
> I have testes it on file_close() and it works (cf. attached patch):
>> fc=file("/dev/full", "w")
>> write.csv("a", file=fc)
>> close(fc)
> Error in close.connection(fc) : closing file failed
>
>>
>> One thing I have to look into:  is anyone making use of the fact that
>> the R-level close.connection() function can return -1 to signal an
>> error?  Base R ignores that, which is why we need to do something, but
>> if packages are using it, things need to be changed carefully.  I
>> can't just change it to raise an error instead.
> As you can see in the patch, no need to change close.connection() function
> but we have to add a test of con->status to all *_close() functions
> (gzfile_close() and co.)

You missed my point.  Currently the R close() function may return -1 to 
signal that there was an error closing.  We can't change that to an 
error if packages are using it.

Duncan Murdoch

>
> Serguei.
>
>>>
>>> Le 05/07/2017 ? 15:33, Serguei Sokol a ?crit :
>>>> Le 05/07/2017 ? 14:46, Serguei Sokol a ?crit :
>>>>> Le 05/07/2017 ? 13:09, Duncan Murdoch a ?crit :
>>>>>> On 05/07/2017 5:26 AM, January W. wrote:
>>>>>>> I tried the newest patch, but it does not seem to work for me (on
>>>>>>> Linux). Despite the check in Rconn_printf, the write.csv happily
>>>>>>> writes
>>>>>>> to /dev/full and does not report an error. When I added a
>>>>>>> printf("%d\n",
>>>>>>> res); to the Rconn_printf() definition, I see only positive values
>>>>>>> returned by the vfprintf call.
>>>>>>>
>>>>>>
>>>>>> That's likely because you aren't writing enough to actually
>>>>>> trigger a write to disk during the write.  Writes are buffered,
>>>>>> and the error doesn't happen
>>>>>> until the buffer is written.
>>>>> I can confirm this behavior with fvprintf(). Small and medium sized
>>>>> writings
>>>>> on /dev/full don't trigger error and 1MB does.
>>>>>
>>>>> But if fprintf() is used, it returns a negative value from the very
>>>>> first byte written.
>>>> I correct myself. In my test, fprintf() returned -1 for another
>>>> reason (connection was already closed
>>>> at this moment)
>>>> However, if fvprintf(...) is followed by res=fflush(con) then res is -1
>>>> if we try to write on /dev/full. May be we have to use this to trigger
>>>> an error message in R.
>>>>
>>>> Serguei.
>>>>
>>>>>>   The regression test I put in had this problem; I'm working on
>>>>>> MacOS and Windows, so I never got to actually try it before
>>>>>> committing.
>>>>>>
>>>>>> Unfortunately, it doesn't look possible to catch the final flush
>>>>>> of the buffer when the connection is closed, so small writes won't
>>>>>> trigger any error.
>>>>>>
>>>>>> It's also possible that whatever system you're on doesn't signal
>>>>>> an error when the write fails.
>>>>>>
>>>>>> Duncan Murdoch
>>>>>>
>>>>>>> Cheers,
>>>>>>>
>>>>>>> j.
>>>>>>>
>>>>>>>
>>>>>>> On 4 July 2017 at 21:37, Duncan Murdoch <murdoch.duncan at gmail.com
>>>>>>> <mailto:murdoch.duncan at gmail.com>> wrote:
>>>>>>>
>>>>>>>     On 04/07/2017 11:50 AM, Jean-S?bastien Bevilacqua wrote:
>>>>>>>
>>>>>>>         Hello,
>>>>>>>         You can find here a patch to fix disk corruption.
>>>>>>>         When your disk is full, the write function exit without
>>>>>>> error
>>>>>>>         but the file
>>>>>>>         is truncated.
>>>>>>>
>>>>>>> https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243
>>>>>>> <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243>
>>>>>>>
>>>>>>>
>>>>>>>     Thanks.  I didn't see that when it came through (or did and
>>>>>>> forgot).
>>>>>>>     I'll probably move the error check to a lower level (in the
>>>>>>>     Rconn_printf function), if tests show that works.
>>>>>>>
>>>>>>>     Duncan Murdoch
>>>>>>>
>>>>>>>
>>>>>>>     ______________________________________________
>>>>>>>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing
>>>>>>> list
>>>>>>>     https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>> --
>>>>>>> -------- January Weiner --------------------------------------
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>
>>>>>
>>>>
>>>
>>
>>
>
>
>
>


From sahil.kang at asilaycomputing.com  Fri Jul  7 11:42:58 2017
From: sahil.kang at asilaycomputing.com (Sahil Kang)
Date: Fri, 7 Jul 2017 02:42:58 -0700
Subject: [Rd] [Bug Fix] Default values not applied to ... arguments
In-Reply-To: <0555003e-e7fe-9b3d-def7-852a0644ebdc@gmail.com>
References: <8b83c113-8ec1-bf78-17f5-66682b798475@asilaycomputing.com>
 <0555003e-e7fe-9b3d-def7-852a0644ebdc@gmail.com>
Message-ID: <ae901a0e-9088-df16-3d75-67c841ef1c35@asilaycomputing.com>

Yes, I see what you mean. My patch only disables JIT compilation for 
closures. If a user manually compiles a closure, however, the bug pops 
up again.

I think the bug may either lie in how the byte-compiler compiles 
closures, or how closures with compiled body's are executed by the AST 
interpreter (without my patch applied):

compiler::enableJIT(0) # turn off JIT compilation
f <- function(...) { g(...) }
g <- function(a=4, b=5, c=6) {
   print(c(missing(a), missing(b), missing(c)))
   b
}

f(1,,3) # works fine
# [1] FALSE TRUE FALSE
# [1] 5

f(1,,3) # works fine
# [1] FALSE TRUE FALSE
# [1] 5

ff_1 <- compiler::compile(f) # compile f
ff_2 <- compiler::cmpfun(f) # compile body of closure

eval(ff_1)(1,,3) # works fine
# [1] FALSE TRUE FALSE
# [1] 5

eval(ff_2)(1,,3) # bug shows up again
# [1] FALSE TRUE FALSE
# Error in g(...) : argument is missing, with no default

Thanks,
Sahil

On 07/06/2017 09:29 AM, Tomas Kalibera wrote:
>
> Thanks for the report, I've fixed 15199 in the AST interpreter in 
> 72664, I will fix it in the byte-code interpreter as well.
>
> If you ever needed to disable the JIT, there is API for that, see 
> ?compiler. Note though that by disabling the JIT you won't disable the 
> byte-code interpreter, because code also gets compiled when packages 
> are installed or when the compiler is invoked explicitly.
>
> Best,
> Tomas
>
> On 07/06/2017 04:40 PM, Sahil Kang wrote:
>> Hi Duncan, Martin
>>
>> Here's a small patch that fixes bug 15199 reported at:
>> https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=15199
>>
>> I was able to reproduce the bug as Duncan had outlined just fine, but 
>> I did notice that when we debug(f), the problem went away.
>> I later realized that f(1,,3) behaved correctly the first time it was 
>> executed, but misbehaved as documented on subsequent calls.
>> This narrowed the problem down to the byte-compilation that occurs on 
>> subsequent function calls.
>>
>> This patch prevents byte-compilation on closure objects.
>> Although it's a less than ideal solution, this patch fixes the bug at 
>> least until the underlying byte-compilation issue can be found (I'm 
>> currently scrutinizing the promiseArgs function at eval.c:2771).
>>
>> Thanks,
>> Sahil
>>
>>
>> ______________________________________________
>> R-devel at r-project.org  mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>
>


	[[alternative HTML version deleted]]


From ilia-kats at gmx.net  Fri Jul  7 10:30:46 2017
From: ilia-kats at gmx.net (Ilia Kats)
Date: Fri, 7 Jul 2017 10:30:46 +0200
Subject: [Rd] italic font on cairo devices in R 3.4
Message-ID: <2093e0fa-f923-0822-60d2-7509d38224af@gmx.net>

[cross-post from R-help]

Hi all,

I have the following problem: Since R 3.4.0, italic fonts rendered on 
Cairo devices appear pixelated. Here's a minimal example:
cairo_pdf('test.pdf')
plot(1:10, ylab=expression(italic(test)))
dev.off()

The same problem occurs with bolditalic, but not bold. I am using Debian 
Stretch. Several friends tried the same on their machines, another 
Debian machine has the same problem. On MacOSX the output was not 
pixelated, but it wasn't italic either. Ubuntu 16.04.2 xenial works 
fine. My impression is that R somehow can't find the proper font to use 
and falls back to something weird. Ideas?

Note that I'm not subscribed to the list, so please CC me in replies.

Cheers, Ilia


From Torsten.Hothorn at uzh.ch  Fri Jul  7 15:06:07 2017
From: Torsten.Hothorn at uzh.ch (Torsten Hothorn)
Date: Fri, 7 Jul 2017 15:06:07 +0200 (CEST)
Subject: [Rd] attributes on symbols
In-Reply-To: <CAF8bMcY0Sq9qf-24VKQe3BV+fi4KnLppbU221dXZkkS1_862vQ@mail.gmail.com>
References: <CAF8bMcY0Sq9qf-24VKQe3BV+fi4KnLppbU221dXZkkS1_862vQ@mail.gmail.com>
Message-ID: <alpine.DEB.2.20.1707071505480.9494@achilles>


Here is a simpler example:

> ex <- as.name("a")
> attr(ex, "test") <- 1
> quote(a)
a
attr(,"test")
[1] 1

Torsten

On Thu, 6 Jul 2017, William Dunlap wrote:

> The multcomp package has code in multcomp:::expression2coef that attaches the 'coef' attribute to
> symbols.? Since there is only one symbol object in a session with a given name, this means that
> this attaching has a global effect.? Should this be quietly allowed or should there be a warning or
> an error?
> E.g.,
> 
> str(quote(Education))
> # symbol Education
> lmod <- stats::lm(Fertility ~ ., data = datasets::swiss)
> glmod <- multcomp::glht(lmod, c("Agriculture=0", "Education=0"))
> str(quote(Education))
> # symbol Education
> # - attr(*, "coef")= num 1
> 
> Bill Dunlap
> TIBCO Software
> wdunlap tibco.com
> 
>

From sokol at insa-toulouse.fr  Fri Jul  7 15:54:05 2017
From: sokol at insa-toulouse.fr (Serguei Sokol)
Date: Fri, 7 Jul 2017 15:54:05 +0200
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <e8804ff7-473f-3b89-fa65-c1b0d79d85e3@gmail.com>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
 <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
 <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>
 <ed2899b8-f945-1dad-348a-cee0f8614ba7@insa-toulouse.fr>
 <e8804ff7-473f-3b89-fa65-c1b0d79d85e3@gmail.com>
Message-ID: <e1cf1c31-2e7c-72cb-453f-68df8321cc3f@insa-toulouse.fr>

Le 07/07/2017 ? 01:09, Duncan Murdoch a ?crit :
> On 06/07/2017 6:44 PM, Sokol Serguei wrote:
>> Duncan Murdoch has written at  Thu, 6 Jul 2017 13:58:10 -0400
>>> On 06/07/2017 5:21 AM, Serguei Sokol wrote:
>>>> I propose the following patch against the current
>>>> R-devel/src/main/connection.c (cf. attached file).
>>>> It gives (on my linux box):
>>>>  > fc=file("/dev/full", "w")
>>>>  > write.csv("a", file=fc)
>>>> Error in writeLines(paste(col.names, collapse = sep), file, sep = eol) :
>>>>    system call failure on writing
>>>>  > close(fc)
>>>>
>>>> Serguei.
>>>
>>> I suspect that flushing on every write will slow things down too much.
>> That's quite plausible.
>>
>>>
>>> I think a better approach is to catch the error in the Rconn_printf
>>> calls (as R-devel currently does), and also catch errors on
>>> con->close(con).  This one requires more changes to the source, so it
>>> may be a day or two before I commit.
>> I have testes it on file_close() and it works (cf. attached patch):
>>> fc=file("/dev/full", "w")
>>> write.csv("a", file=fc)
>>> close(fc)
>> Error in close.connection(fc) : closing file failed
>>
>>>
>>> One thing I have to look into:  is anyone making use of the fact that
>>> the R-level close.connection() function can return -1 to signal an
>>> error?  Base R ignores that, which is why we need to do something, but
>>> if packages are using it, things need to be changed carefully.  I
>>> can't just change it to raise an error instead.
>> As you can see in the patch, no need to change close.connection() function
>> but we have to add a test of con->status to all *_close() functions
>> (gzfile_close() and co.)
>
> You missed my point.  Currently the R close() function may return -1 to signal that there was an error closing.  We can't change that to an error if packages 
> are using it.
May be I missed it but finally, me too, I was saying that we don't have to do so.
Anyhow, the situation of writing to full disk cannot be passed in silence.
IMHO, trigger an error would be the most appropriate in this situation but if for legacy
or any other reason we cannot do so, let whistle a warning, at least.
Here few tests with a new small patch:
 > fc=file("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
[1] -1
Warning message:
In close.connection(fc) :
   closing '/dev/full' failed: No space left on device
 > fc=gzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
NULL
Warning message:
In close.connection(fc) :
   closing '/dev/full' failed: No space left on device
 > fc=xzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
NULL
Warning message:
In close.connection(fc) :
   closing '/dev/full' failed: No space left on device
 > fc=bzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
NULL
Warning message:
In close.connection(fc) :
   closing '/dev/full' failed: No space left on device

Note that if we test only status < 0 (without errno) then there are too many warnings
on seemingly "innocent" file closings.

Serguei.

>>>>
>>>> Le 05/07/2017 ? 15:33, Serguei Sokol a ?crit :
>>>>> Le 05/07/2017 ? 14:46, Serguei Sokol a ?crit :
>>>>>> Le 05/07/2017 ? 13:09, Duncan Murdoch a ?crit :
>>>>>>> On 05/07/2017 5:26 AM, January W. wrote:
>>>>>>>> I tried the newest patch, but it does not seem to work for me (on
>>>>>>>> Linux). Despite the check in Rconn_printf, the write.csv happily
>>>>>>>> writes
>>>>>>>> to /dev/full and does not report an error. When I added a
>>>>>>>> printf("%d\n",
>>>>>>>> res); to the Rconn_printf() definition, I see only positive values
>>>>>>>> returned by the vfprintf call.
>>>>>>>>
>>>>>>>
>>>>>>> That's likely because you aren't writing enough to actually
>>>>>>> trigger a write to disk during the write.  Writes are buffered,
>>>>>>> and the error doesn't happen
>>>>>>> until the buffer is written.
>>>>>> I can confirm this behavior with fvprintf(). Small and medium sized
>>>>>> writings
>>>>>> on /dev/full don't trigger error and 1MB does.
>>>>>>
>>>>>> But if fprintf() is used, it returns a negative value from the very
>>>>>> first byte written.
>>>>> I correct myself. In my test, fprintf() returned -1 for another
>>>>> reason (connection was already closed
>>>>> at this moment)
>>>>> However, if fvprintf(...) is followed by res=fflush(con) then res is -1
>>>>> if we try to write on /dev/full. May be we have to use this to trigger
>>>>> an error message in R.
>>>>>
>>>>> Serguei.
>>>>>
>>>>>>>   The regression test I put in had this problem; I'm working on
>>>>>>> MacOS and Windows, so I never got to actually try it before
>>>>>>> committing.
>>>>>>>
>>>>>>> Unfortunately, it doesn't look possible to catch the final flush
>>>>>>> of the buffer when the connection is closed, so small writes won't
>>>>>>> trigger any error.
>>>>>>>
>>>>>>> It's also possible that whatever system you're on doesn't signal
>>>>>>> an error when the write fails.
>>>>>>>
>>>>>>> Duncan Murdoch
>>>>>>>
>>>>>>>> Cheers,
>>>>>>>>
>>>>>>>> j.
>>>>>>>>
>>>>>>>>
>>>>>>>> On 4 July 2017 at 21:37, Duncan Murdoch <murdoch.duncan at gmail.com
>>>>>>>> <mailto:murdoch.duncan at gmail.com>> wrote:
>>>>>>>>
>>>>>>>>     On 04/07/2017 11:50 AM, Jean-S?bastien Bevilacqua wrote:
>>>>>>>>
>>>>>>>>         Hello,
>>>>>>>>         You can find here a patch to fix disk corruption.
>>>>>>>>         When your disk is full, the write function exit without
>>>>>>>> error
>>>>>>>>         but the file
>>>>>>>>         is truncated.
>>>>>>>>
>>>>>>>> https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243
>>>>>>>> <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243>
>>>>>>>>
>>>>>>>>
>>>>>>>>     Thanks.  I didn't see that when it came through (or did and
>>>>>>>> forgot).
>>>>>>>>     I'll probably move the error check to a lower level (in the
>>>>>>>>     Rconn_printf function), if tests show that works.
>>>>>>>>
>>>>>>>>     Duncan Murdoch
>>>>>>>>
>>>>>>>>
>>>>>>>>     ______________________________________________
>>>>>>>>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing
>>>>>>>> list
>>>>>>>>     https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>> <https://stat.ethz.ch/mailman/listinfo/r-devel>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>> -- 
>>>>>>>> -------- January Weiner --------------------------------------
>>>>>>>
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>>>
>>>>>
>>>>
>>>
>>>
>>
>>
>>
>>
>
>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: close1.patch
Type: text/x-patch
Size: 870 bytes
Desc: not available
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20170707/3e17e20e/attachment.bin>

From murdoch.duncan at gmail.com  Fri Jul  7 16:52:43 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Fri, 7 Jul 2017 10:52:43 -0400
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <e1cf1c31-2e7c-72cb-453f-68df8321cc3f@insa-toulouse.fr>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
 <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
 <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>
 <ed2899b8-f945-1dad-348a-cee0f8614ba7@insa-toulouse.fr>
 <e8804ff7-473f-3b89-fa65-c1b0d79d85e3@gmail.com>
 <e1cf1c31-2e7c-72cb-453f-68df8321cc3f@insa-toulouse.fr>
Message-ID: <8ca82104-19ae-a7be-d27f-9f2982b63140@gmail.com>

On 07/07/2017 9:54 AM, Serguei Sokol wrote:
> Le 07/07/2017 ? 01:09, Duncan Murdoch a ?crit :
>> On 06/07/2017 6:44 PM, Sokol Serguei wrote:
>>> Duncan Murdoch has written at  Thu, 6 Jul 2017 13:58:10 -0400
>>>> On 06/07/2017 5:21 AM, Serguei Sokol wrote:
>>>>> I propose the following patch against the current
>>>>> R-devel/src/main/connection.c (cf. attached file).
>>>>> It gives (on my linux box):
>>>>>  > fc=file("/dev/full", "w")
>>>>>  > write.csv("a", file=fc)
>>>>> Error in writeLines(paste(col.names, collapse = sep), file, sep = eol) :
>>>>>    system call failure on writing
>>>>>  > close(fc)
>>>>>
>>>>> Serguei.
>>>>
>>>> I suspect that flushing on every write will slow things down too much.
>>> That's quite plausible.
>>>
>>>>
>>>> I think a better approach is to catch the error in the Rconn_printf
>>>> calls (as R-devel currently does), and also catch errors on
>>>> con->close(con).  This one requires more changes to the source, so it
>>>> may be a day or two before I commit.
>>> I have testes it on file_close() and it works (cf. attached patch):
>>>> fc=file("/dev/full", "w")
>>>> write.csv("a", file=fc)
>>>> close(fc)
>>> Error in close.connection(fc) : closing file failed
>>>
>>>>
>>>> One thing I have to look into:  is anyone making use of the fact that
>>>> the R-level close.connection() function can return -1 to signal an
>>>> error?  Base R ignores that, which is why we need to do something, but
>>>> if packages are using it, things need to be changed carefully.  I
>>>> can't just change it to raise an error instead.
>>> As you can see in the patch, no need to change close.connection() function
>>> but we have to add a test of con->status to all *_close() functions
>>> (gzfile_close() and co.)
>>
>> You missed my point.  Currently the R close() function may return -1 to signal that there was an error closing.  We can't change that to an error if packages
>> are using it.
> May be I missed it but finally, me too, I was saying that we don't have to do so.
> Anyhow, the situation of writing to full disk cannot be passed in silence.
> IMHO, trigger an error would be the most appropriate in this situation but if for legacy
> or any other reason we cannot do so, let whistle a warning, at least.
> Here few tests with a new small patch:
>  > fc=file("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
> [1] -1
> Warning message:
> In close.connection(fc) :
>    closing '/dev/full' failed: No space left on device
>  > fc=gzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
> NULL
> Warning message:
> In close.connection(fc) :
>    closing '/dev/full' failed: No space left on device
>  > fc=xzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
> NULL
> Warning message:
> In close.connection(fc) :
>    closing '/dev/full' failed: No space left on device
>  > fc=bzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
> NULL
> Warning message:
> In close.connection(fc) :
>    closing '/dev/full' failed: No space left on device
>
> Note that if we test only status < 0 (without errno) then there are too many warnings
> on seemingly "innocent" file closings.

Could you give an example of how to get status < 0 on a valid closing?

Duncan Murdoch

>
> Serguei.
>
>>>>>
>>>>> Le 05/07/2017 ? 15:33, Serguei Sokol a ?crit :
>>>>>> Le 05/07/2017 ? 14:46, Serguei Sokol a ?crit :
>>>>>>> Le 05/07/2017 ? 13:09, Duncan Murdoch a ?crit :
>>>>>>>> On 05/07/2017 5:26 AM, January W. wrote:
>>>>>>>>> I tried the newest patch, but it does not seem to work for me (on
>>>>>>>>> Linux). Despite the check in Rconn_printf, the write.csv happily
>>>>>>>>> writes
>>>>>>>>> to /dev/full and does not report an error. When I added a
>>>>>>>>> printf("%d\n",
>>>>>>>>> res); to the Rconn_printf() definition, I see only positive values
>>>>>>>>> returned by the vfprintf call.
>>>>>>>>>
>>>>>>>>
>>>>>>>> That's likely because you aren't writing enough to actually
>>>>>>>> trigger a write to disk during the write.  Writes are buffered,
>>>>>>>> and the error doesn't happen
>>>>>>>> until the buffer is written.
>>>>>>> I can confirm this behavior with fvprintf(). Small and medium sized
>>>>>>> writings
>>>>>>> on /dev/full don't trigger error and 1MB does.
>>>>>>>
>>>>>>> But if fprintf() is used, it returns a negative value from the very
>>>>>>> first byte written.
>>>>>> I correct myself. In my test, fprintf() returned -1 for another
>>>>>> reason (connection was already closed
>>>>>> at this moment)
>>>>>> However, if fvprintf(...) is followed by res=fflush(con) then res is -1
>>>>>> if we try to write on /dev/full. May be we have to use this to trigger
>>>>>> an error message in R.
>>>>>>
>>>>>> Serguei.
>>>>>>
>>>>>>>>   The regression test I put in had this problem; I'm working on
>>>>>>>> MacOS and Windows, so I never got to actually try it before
>>>>>>>> committing.
>>>>>>>>
>>>>>>>> Unfortunately, it doesn't look possible to catch the final flush
>>>>>>>> of the buffer when the connection is closed, so small writes won't
>>>>>>>> trigger any error.
>>>>>>>>
>>>>>>>> It's also possible that whatever system you're on doesn't signal
>>>>>>>> an error when the write fails.
>>>>>>>>
>>>>>>>> Duncan Murdoch
>>>>>>>>
>>>>>>>>> Cheers,
>>>>>>>>>
>>>>>>>>> j.
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> On 4 July 2017 at 21:37, Duncan Murdoch <murdoch.duncan at gmail.com
>>>>>>>>> <mailto:murdoch.duncan at gmail.com>> wrote:
>>>>>>>>>
>>>>>>>>>     On 04/07/2017 11:50 AM, Jean-S?bastien Bevilacqua wrote:
>>>>>>>>>
>>>>>>>>>         Hello,
>>>>>>>>>         You can find here a patch to fix disk corruption.
>>>>>>>>>         When your disk is full, the write function exit without
>>>>>>>>> error
>>>>>>>>>         but the file
>>>>>>>>>         is truncated.
>>>>>>>>>
>>>>>>>>> https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243
>>>>>>>>> <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17243>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>     Thanks.  I didn't see that when it came through (or did and
>>>>>>>>> forgot).
>>>>>>>>>     I'll probably move the error check to a lower level (in the
>>>>>>>>>     Rconn_printf function), if tests show that works.
>>>>>>>>>
>>>>>>>>>     Duncan Murdoch
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>     ______________________________________________
>>>>>>>>>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing
>>>>>>>>> list
>>>>>>>>>     https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>> <https://stat.ethz.ch/mailman/listinfo/r-devel>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> --
>>>>>>>>> -------- January Weiner --------------------------------------
>>>>>>>>
>>>>>>>> ______________________________________________
>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>
>>>>>>>
>>>>>>
>>>>>
>>>>
>>>>
>>>
>>>
>>>
>>>
>>
>>
>


From sokol at insa-toulouse.fr  Fri Jul  7 17:13:15 2017
From: sokol at insa-toulouse.fr (Serguei Sokol)
Date: Fri, 7 Jul 2017 17:13:15 +0200
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <8ca82104-19ae-a7be-d27f-9f2982b63140@gmail.com>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
 <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
 <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>
 <ed2899b8-f945-1dad-348a-cee0f8614ba7@insa-toulouse.fr>
 <e8804ff7-473f-3b89-fa65-c1b0d79d85e3@gmail.com>
 <e1cf1c31-2e7c-72cb-453f-68df8321cc3f@insa-toulouse.fr>
 <8ca82104-19ae-a7be-d27f-9f2982b63140@gmail.com>
Message-ID: <ce8dbd19-c6f1-fcf0-c9af-fccc27eb37c8@insa-toulouse.fr>

Le 07/07/2017 ? 16:52, Duncan Murdoch a ?crit :
> On 07/07/2017 9:54 AM, Serguei Sokol wrote:
>> Le 07/07/2017 ? 01:09, Duncan Murdoch a ?crit :
>>> On 06/07/2017 6:44 PM, Sokol Serguei wrote:
>>>> Duncan Murdoch has written at  Thu, 6 Jul 2017 13:58:10 -0400
>>>>> On 06/07/2017 5:21 AM, Serguei Sokol wrote:
>>>>>> I propose the following patch against the current
>>>>>> R-devel/src/main/connection.c (cf. attached file).
>>>>>> It gives (on my linux box):
>>>>>>  > fc=file("/dev/full", "w")
>>>>>>  > write.csv("a", file=fc)
>>>>>> Error in writeLines(paste(col.names, collapse = sep), file, sep = eol) :
>>>>>>    system call failure on writing
>>>>>>  > close(fc)
>>>>>>
>>>>>> Serguei.
>>>>>
>>>>> I suspect that flushing on every write will slow things down too much.
>>>> That's quite plausible.
>>>>
>>>>>
>>>>> I think a better approach is to catch the error in the Rconn_printf
>>>>> calls (as R-devel currently does), and also catch errors on
>>>>> con->close(con).  This one requires more changes to the source, so it
>>>>> may be a day or two before I commit.
>>>> I have testes it on file_close() and it works (cf. attached patch):
>>>>> fc=file("/dev/full", "w")
>>>>> write.csv("a", file=fc)
>>>>> close(fc)
>>>> Error in close.connection(fc) : closing file failed
>>>>
>>>>>
>>>>> One thing I have to look into:  is anyone making use of the fact that
>>>>> the R-level close.connection() function can return -1 to signal an
>>>>> error?  Base R ignores that, which is why we need to do something, but
>>>>> if packages are using it, things need to be changed carefully.  I
>>>>> can't just change it to raise an error instead.
>>>> As you can see in the patch, no need to change close.connection() function
>>>> but we have to add a test of con->status to all *_close() functions
>>>> (gzfile_close() and co.)
>>>
>>> You missed my point.  Currently the R close() function may return -1 to signal that there was an error closing.  We can't change that to an error if packages
>>> are using it.
>> May be I missed it but finally, me too, I was saying that we don't have to do so.
>> Anyhow, the situation of writing to full disk cannot be passed in silence.
>> IMHO, trigger an error would be the most appropriate in this situation but if for legacy
>> or any other reason we cannot do so, let whistle a warning, at least.
>> Here few tests with a new small patch:
>>  > fc=file("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>> [1] -1
>> Warning message:
>> In close.connection(fc) :
>>    closing '/dev/full' failed: No space left on device
>>  > fc=gzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>> NULL
>> Warning message:
>> In close.connection(fc) :
>>    closing '/dev/full' failed: No space left on device
>>  > fc=xzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>> NULL
>> Warning message:
>> In close.connection(fc) :
>>    closing '/dev/full' failed: No space left on device
>>  > fc=bzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>> NULL
>> Warning message:
>> In close.connection(fc) :
>>    closing '/dev/full' failed: No space left on device
>>
>> Note that if we test only status < 0 (without errno) then there are too many warnings
>> on seemingly "innocent" file closings.
>
> Could you give an example of how to get status < 0 on a valid closing? 
If you remove "&& errno" and leave only "if (status < 0)" in the previous patch
then during make I have many warnings, e.g. :
Warning messages:
1: In close.connection(con) :
   closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/nsInfo.rds' failed: Success
2: In close.connection(con) :
   closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/package.rds' failed: Success
3: In close(con) :
   closing '/home/sokol/dev/R/R-devel/library/compiler/R/compiler.rdx' failed: Success
4: In close.connection(con) :
   closing '/home/sokol/dev/R/R-devel/library/tools/Meta/nsInfo.rds' failed: Success
5: In close.connection(con) :
   closing '/home/sokol/dev/R/R-devel/library/tools/Meta/package.rds' failed: Success
6: In close(con) :
   closing '/home/sokol/dev/R/R-devel/library/tools/R/tools.rdx' failed: Success
7: In close(con) :
   closing '/home/sokol/dev/R/R-devel/library/tools/R/sysdata.rdx' failed: Success
8: In close.connection(con) :
   closing '../../library/parallel/Meta/Rd.rds' failed: Success
9: In close.connection(con) :
   closing '../../library/parallel/help/aliases.rds' failed: Success
10: In close.connection(file) :
   closing '../../library/parallel/DESCRIPTION' failed: Success

Note "Succes" as the reason of "failure".

And if I use thus compiled R, at startup I get:

Warning message:
In close(con) :
   closing '/home/sokol/dev/R/R-devel/library/base/R/base.rdx' failed: Success

R Under development (unstable) (2017-06-01 r72753) -- "Unsuffered Consequences"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

Warning messages:
1: In close.connection(con) :
   closing '/home/sokol/dev/R/R-devel/library/methods/Meta/package.rds' failed: Success
2: In close.connection(con) :
   closing '/home/sokol/dev/R/R-devel/library/methods/Meta/features.rds' failed: Success
3: In close.connection(con) :
   closing '/home/sokol/dev/R/R-devel/library/methods/Meta/nsInfo.rds' failed: Success
4: In close.connection(con) :
   closing '/home/sokol/dev/R/R-devel/library/methods/Meta/package.rds' failed: Success
5: In close(con) :
   closing '/home/sokol/dev/R/R-devel/library/methods/R/methods.rdx' failed: Success
[Previously saved workspace restored]

During startup - There were 27 warnings (use warnings() to see them)

All these closings seem valid to me but obviously the warnings indicate that status was < 0.

Finaly, if I open and close a valid file in this session, I don't get a warning for _this_ file:
 > fc=file("/tmp/aha", "w")
Warning messages:
1: In close.connection(con) :
   closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/nsInfo.rds' failed: Success
2: In close.connection(con) :
   closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/package.rds' failed: Success
3: In close(con) :
   closing '/home/sokol/dev/R/R-devel/library/compiler/R/compiler.rdx' failed: Success
 > write.csv("a", file=fc)
 > close(fc) # no warning


Serguei.


From murdoch.duncan at gmail.com  Fri Jul  7 17:42:39 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Fri, 7 Jul 2017 11:42:39 -0400
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <ce8dbd19-c6f1-fcf0-c9af-fccc27eb37c8@insa-toulouse.fr>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
 <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
 <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>
 <ed2899b8-f945-1dad-348a-cee0f8614ba7@insa-toulouse.fr>
 <e8804ff7-473f-3b89-fa65-c1b0d79d85e3@gmail.com>
 <e1cf1c31-2e7c-72cb-453f-68df8321cc3f@insa-toulouse.fr>
 <8ca82104-19ae-a7be-d27f-9f2982b63140@gmail.com>
 <ce8dbd19-c6f1-fcf0-c9af-fccc27eb37c8@insa-toulouse.fr>
Message-ID: <02239f51-3592-d3f3-5f4a-f479b35b4da9@gmail.com>

On 07/07/2017 11:13 AM, Serguei Sokol wrote:
> Le 07/07/2017 ? 16:52, Duncan Murdoch a ?crit :
>> On 07/07/2017 9:54 AM, Serguei Sokol wrote:
>>> Le 07/07/2017 ? 01:09, Duncan Murdoch a ?crit :
>>>> On 06/07/2017 6:44 PM, Sokol Serguei wrote:
>>>>> Duncan Murdoch has written at  Thu, 6 Jul 2017 13:58:10 -0400
>>>>>> On 06/07/2017 5:21 AM, Serguei Sokol wrote:
>>>>>>> I propose the following patch against the current
>>>>>>> R-devel/src/main/connection.c (cf. attached file).
>>>>>>> It gives (on my linux box):
>>>>>>>  > fc=file("/dev/full", "w")
>>>>>>>  > write.csv("a", file=fc)
>>>>>>> Error in writeLines(paste(col.names, collapse = sep), file, sep = eol) :
>>>>>>>    system call failure on writing
>>>>>>>  > close(fc)
>>>>>>>
>>>>>>> Serguei.
>>>>>>
>>>>>> I suspect that flushing on every write will slow things down too much.
>>>>> That's quite plausible.
>>>>>
>>>>>>
>>>>>> I think a better approach is to catch the error in the Rconn_printf
>>>>>> calls (as R-devel currently does), and also catch errors on
>>>>>> con->close(con).  This one requires more changes to the source, so it
>>>>>> may be a day or two before I commit.
>>>>> I have testes it on file_close() and it works (cf. attached patch):
>>>>>> fc=file("/dev/full", "w")
>>>>>> write.csv("a", file=fc)
>>>>>> close(fc)
>>>>> Error in close.connection(fc) : closing file failed
>>>>>
>>>>>>
>>>>>> One thing I have to look into:  is anyone making use of the fact that
>>>>>> the R-level close.connection() function can return -1 to signal an
>>>>>> error?  Base R ignores that, which is why we need to do something, but
>>>>>> if packages are using it, things need to be changed carefully.  I
>>>>>> can't just change it to raise an error instead.
>>>>> As you can see in the patch, no need to change close.connection() function
>>>>> but we have to add a test of con->status to all *_close() functions
>>>>> (gzfile_close() and co.)
>>>>
>>>> You missed my point.  Currently the R close() function may return -1 to signal that there was an error closing.  We can't change that to an error if packages
>>>> are using it.
>>> May be I missed it but finally, me too, I was saying that we don't have to do so.
>>> Anyhow, the situation of writing to full disk cannot be passed in silence.
>>> IMHO, trigger an error would be the most appropriate in this situation but if for legacy
>>> or any other reason we cannot do so, let whistle a warning, at least.
>>> Here few tests with a new small patch:
>>>  > fc=file("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>> [1] -1
>>> Warning message:
>>> In close.connection(fc) :
>>>    closing '/dev/full' failed: No space left on device
>>>  > fc=gzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>> NULL
>>> Warning message:
>>> In close.connection(fc) :
>>>    closing '/dev/full' failed: No space left on device
>>>  > fc=xzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>> NULL
>>> Warning message:
>>> In close.connection(fc) :
>>>    closing '/dev/full' failed: No space left on device
>>>  > fc=bzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>> NULL
>>> Warning message:
>>> In close.connection(fc) :
>>>    closing '/dev/full' failed: No space left on device
>>>
>>> Note that if we test only status < 0 (without errno) then there are too many warnings
>>> on seemingly "innocent" file closings.
>>
>> Could you give an example of how to get status < 0 on a valid closing?
> If you remove "&& errno" and leave only "if (status < 0)" in the previous patch
> then during make I have many warnings, e.g. :
> Warning messages:
> 1: In close.connection(con) :
>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/nsInfo.rds' failed: Success
> 2: In close.connection(con) :
>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/package.rds' failed: Success
> 3: In close(con) :
>    closing '/home/sokol/dev/R/R-devel/library/compiler/R/compiler.rdx' failed: Success
> 4: In close.connection(con) :
>    closing '/home/sokol/dev/R/R-devel/library/tools/Meta/nsInfo.rds' failed: Success
> 5: In close.connection(con) :
>    closing '/home/sokol/dev/R/R-devel/library/tools/Meta/package.rds' failed: Success
> 6: In close(con) :
>    closing '/home/sokol/dev/R/R-devel/library/tools/R/tools.rdx' failed: Success
> 7: In close(con) :
>    closing '/home/sokol/dev/R/R-devel/library/tools/R/sysdata.rdx' failed: Success
> 8: In close.connection(con) :
>    closing '../../library/parallel/Meta/Rd.rds' failed: Success
> 9: In close.connection(con) :
>    closing '../../library/parallel/help/aliases.rds' failed: Success
> 10: In close.connection(file) :
>    closing '../../library/parallel/DESCRIPTION' failed: Success
>

You are probably seeing cases where status is never set:  then status is 
NA_INTEGER, which (in C) is negative.

Duncan Murdoch


> Note "Succes" as the reason of "failure".
>
> And if I use thus compiled R, at startup I get:
>
> Warning message:
> In close(con) :
>    closing '/home/sokol/dev/R/R-devel/library/base/R/base.rdx' failed: Success
>
> R Under development (unstable) (2017-06-01 r72753) -- "Unsuffered Consequences"
> Copyright (C) 2017 The R Foundation for Statistical Computing
> Platform: x86_64-pc-linux-gnu (64-bit)
>
> R is free software and comes with ABSOLUTELY NO WARRANTY.
> You are welcome to redistribute it under certain conditions.
> Type 'license()' or 'licence()' for distribution details.
>
> R is a collaborative project with many contributors.
> Type 'contributors()' for more information and
> 'citation()' on how to cite R or R packages in publications.
>
> Type 'demo()' for some demos, 'help()' for on-line help, or
> 'help.start()' for an HTML browser interface to help.
> Type 'q()' to quit R.
>
> Warning messages:
> 1: In close.connection(con) :
>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/package.rds' failed: Success
> 2: In close.connection(con) :
>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/features.rds' failed: Success
> 3: In close.connection(con) :
>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/nsInfo.rds' failed: Success
> 4: In close.connection(con) :
>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/package.rds' failed: Success
> 5: In close(con) :
>    closing '/home/sokol/dev/R/R-devel/library/methods/R/methods.rdx' failed: Success
> [Previously saved workspace restored]
>
> During startup - There were 27 warnings (use warnings() to see them)
>
> All these closings seem valid to me but obviously the warnings indicate that status was < 0.
>
> Finaly, if I open and close a valid file in this session, I don't get a warning for _this_ file:
>  > fc=file("/tmp/aha", "w")
> Warning messages:
> 1: In close.connection(con) :
>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/nsInfo.rds' failed: Success
> 2: In close.connection(con) :
>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/package.rds' failed: Success
> 3: In close(con) :
>    closing '/home/sokol/dev/R/R-devel/library/compiler/R/compiler.rdx' failed: Success
>  > write.csv("a", file=fc)
>  > close(fc) # no warning
>
>
> Serguei.
>


From frederik at ofb.net  Fri Jul  7 18:17:34 2017
From: frederik at ofb.net (frederik at ofb.net)
Date: Fri, 7 Jul 2017 09:17:34 -0700
Subject: [Rd] italic font on cairo devices in R 3.4
In-Reply-To: <2093e0fa-f923-0822-60d2-7509d38224af@gmx.net>
 <597b749b-47f0-1d00-1fe3-907f927c6fdb@gmx.net>
Message-ID: <20170707161734.GA833@ofb.net>

Hi Ilia,

I'm running Arch Linux, R 3.4.0.

Here's my test.pdf from your minimal example: https://ptpb.pw/HxsA.pdf

It doesn't look pixelated to me...

Here's a post that I wrote when I solved my last font problem in R,
almost 2 years ago:

https://stackoverflow.com/a/40940331/5087283

I had to install some Microsoft font packages, which is sad, because
there are some perfectly good free fonts that R could be using
instead. It could be considered a bug that R requires Microsoft fonts,
at least by default. However, does this even fix your problem? I.e. if
you install the corresponding Debian Microsoft font packages, does the
text appear anti-aliased?

Frederick

On Fri, Jul 07, 2017 at 10:30:46AM +0200, Ilia Kats wrote:
> [cross-post from R-help]
> 
> Hi all,
> 
> I have the following problem: Since R 3.4.0, italic fonts rendered on Cairo
> devices appear pixelated. Here's a minimal example:
> cairo_pdf('test.pdf')
> plot(1:10, ylab=expression(italic(test)))
> dev.off()
> 
> The same problem occurs with bolditalic, but not bold. I am using Debian
> Stretch. Several friends tried the same on their machines, another Debian
> machine has the same problem. On MacOSX the output was not pixelated, but it
> wasn't italic either. Ubuntu 16.04.2 xenial works fine. My impression is
> that R somehow can't find the proper font to use and falls back to something
> weird. Ideas?
> 
> Note that I'm not subscribed to the list, so please CC me in replies.
> 
> Cheers, Ilia
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From ilia-kats at gmx.net  Fri Jul  7 19:08:52 2017
From: ilia-kats at gmx.net (Ilia Kats)
Date: Fri, 7 Jul 2017 19:08:52 +0200
Subject: [Rd] italic font on cairo devices in R 3.4
In-Reply-To: <20170707161734.GA833@ofb.net>
References: <20170707161734.GA833@ofb.net>
Message-ID: <815d1e56-2fb9-1f7c-aa32-b15769cc72c8@gmx.net>

Interesting. I did not have the package installed, but I did at some 
point extract Helvetica from some MacOSX font files and R was using that 
just fine until 3.3. This is how the plot looks in 3.4 (still using 
Helvetica): https://ptpb.pw/HikX.pdf . After removing Helvetica, 
installing the ttf-mscorefonts-installer package, and running fc-cache 
--force  the plot looks like this: https://ptpb.pw/CM8A.pdf

Also note that the standard pdf device works fine: 
https://ptpb.pw/3Ml1.pdf , it's just the cairo devices (both pdf and 
svg) that have the issue. Unfortunately I need to use cairo_pdf due to 
unicode characters in axis labels.

Cheers, Ilia


-------- Original Message --------
Subject: Re: [Rd] italic font on cairo devices in R 3.4
Date: 2017-07-07 18:17:34 +0200
From: frederik
To: Ilia Kats
CC: r-devel, r-help
> Hi Ilia,
>
> I'm running Arch Linux, R 3.4.0.
>
> Here's my test.pdf from your minimal example: https://ptpb.pw/HxsA.pdf
>
> It doesn't look pixelated to me...
>
> Here's a post that I wrote when I solved my last font problem in R,
> almost 2 years ago:
>
> https://stackoverflow.com/a/40940331/5087283
>
> I had to install some Microsoft font packages, which is sad, because
> there are some perfectly good free fonts that R could be using
> instead. It could be considered a bug that R requires Microsoft fonts,
> at least by default. However, does this even fix your problem? I.e. if
> you install the corresponding Debian Microsoft font packages, does the
> text appear anti-aliased?
>
> Frederick
>
> On Fri, Jul 07, 2017 at 10:30:46AM +0200, Ilia Kats wrote:
>> [cross-post from R-help]
>>
>> Hi all,
>>
>> I have the following problem: Since R 3.4.0, italic fonts rendered on Cairo
>> devices appear pixelated. Here's a minimal example:
>> cairo_pdf('test.pdf')
>> plot(1:10, ylab=expression(italic(test)))
>> dev.off()
>>
>> The same problem occurs with bolditalic, but not bold. I am using Debian
>> Stretch. Several friends tried the same on their machines, another Debian
>> machine has the same problem. On MacOSX the output was not pixelated, but it
>> wasn't italic either. Ubuntu 16.04.2 xenial works fine. My impression is
>> that R somehow can't find the proper font to use and falls back to something
>> weird. Ideas?
>>
>> Note that I'm not subscribed to the list, so please CC me in replies.
>>
>> Cheers, Ilia
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>

-- 
The first is to ensure your partner understands that nature has root
privileges - nature doesn't have to make sense.
-- Telsa Gwynne


From frederik at ofb.net  Fri Jul  7 19:28:44 2017
From: frederik at ofb.net (frederik at ofb.net)
Date: Fri, 7 Jul 2017 10:28:44 -0700
Subject: [Rd] italic font on cairo devices in R 3.4
In-Reply-To: <815d1e56-2fb9-1f7c-aa32-b15769cc72c8@gmx.net>
References: <20170707161734.GA833@ofb.net>
 <815d1e56-2fb9-1f7c-aa32-b15769cc72c8@gmx.net>
Message-ID: <20170707172844.GE833@ofb.net>

On Fri, Jul 07, 2017 at 07:08:52PM +0200, Ilia Kats wrote:
> Interesting. I did not have the package installed, but I did at some point
> extract Helvetica from some MacOSX font files and R was using that just fine
> until 3.3. This is how the plot looks in 3.4 (still using Helvetica):
> https://ptpb.pw/HikX.pdf . After removing Helvetica, installing the
> ttf-mscorefonts-installer package, and running fc-cache --force  the plot
> looks like this: https://ptpb.pw/CM8A.pdf

The second plot looks worse, in other words, and the Microsoft fonts
didn't help.

Maybe the Cairo device should be giving better warning messages.

Anyway it sounds like you are describing a regression so maybe someone
can track down the commit that created this problem.

Thanks,

Frederick


> Also note that the standard pdf device works fine: https://ptpb.pw/3Ml1.pdf
> , it's just the cairo devices (both pdf and svg) that have the issue.
> Unfortunately I need to use cairo_pdf due to unicode characters in axis
> labels.
> 
> Cheers, Ilia
> 
> 
> -------- Original Message --------
> Subject: Re: [Rd] italic font on cairo devices in R 3.4
> Date: 2017-07-07 18:17:34 +0200
> From: frederik
> To: Ilia Kats
> CC: r-devel, r-help
> > Hi Ilia,
> > 
> > I'm running Arch Linux, R 3.4.0.
> > 
> > Here's my test.pdf from your minimal example: https://ptpb.pw/HxsA.pdf
> > 
> > It doesn't look pixelated to me...
> > 
> > Here's a post that I wrote when I solved my last font problem in R,
> > almost 2 years ago:
> > 
> > https://stackoverflow.com/a/40940331/5087283
> > 
> > I had to install some Microsoft font packages, which is sad, because
> > there are some perfectly good free fonts that R could be using
> > instead. It could be considered a bug that R requires Microsoft fonts,
> > at least by default. However, does this even fix your problem? I.e. if
> > you install the corresponding Debian Microsoft font packages, does the
> > text appear anti-aliased?
> > 
> > Frederick
> > 
> > On Fri, Jul 07, 2017 at 10:30:46AM +0200, Ilia Kats wrote:
> > > [cross-post from R-help]
> > > 
> > > Hi all,
> > > 
> > > I have the following problem: Since R 3.4.0, italic fonts rendered on Cairo
> > > devices appear pixelated. Here's a minimal example:
> > > cairo_pdf('test.pdf')
> > > plot(1:10, ylab=expression(italic(test)))
> > > dev.off()
> > > 
> > > The same problem occurs with bolditalic, but not bold. I am using Debian
> > > Stretch. Several friends tried the same on their machines, another Debian
> > > machine has the same problem. On MacOSX the output was not pixelated, but it
> > > wasn't italic either. Ubuntu 16.04.2 xenial works fine. My impression is
> > > that R somehow can't find the proper font to use and falls back to something
> > > weird. Ideas?
> > > 
> > > Note that I'm not subscribed to the list, so please CC me in replies.
> > > 
> > > Cheers, Ilia
> > > 
> > > ______________________________________________
> > > R-devel at r-project.org mailing list
> > > https://stat.ethz.ch/mailman/listinfo/r-devel
> > > 
> 
> -- 
> The first is to ensure your partner understands that nature has root
> privileges - nature doesn't have to make sense.
> -- Telsa Gwynne
>


From pdalgd at gmail.com  Fri Jul  7 20:29:00 2017
From: pdalgd at gmail.com (peter dalgaard)
Date: Fri, 7 Jul 2017 20:29:00 +0200
Subject: [Rd] make check-recommended hanging on up-to-date Rdevel from
	SVN
In-Reply-To: <CADwqtCM4Nse-nUrHnaxACa9CYBHg4iq4yMLQT89tSnnBH3mNQQ@mail.gmail.com>
References: <CADwqtCM4Nse-nUrHnaxACa9CYBHg4iq4yMLQT89tSnnBH3mNQQ@mail.gmail.com>
Message-ID: <A8898DB5-1497-40D6-8A39-512F8E42BDE6@gmail.com>


> On 6 Jul 2017, at 23:26 , Gabriel Becker <gmbecker at ucdavis.edu> wrote:
> 
> Hi all,
> 
> I'm getting an issue with Rdevel where make check-recommended hangs
> consistently for me on Mac El Capitan when checking the Matrix package. I
> did svn update and tools/rsync_recommended earlier today and it didn't fix
> the issue.
> 
> Specifically, it is hanging on the
> 
> * checking dependencies in R code ...

Not happening for me on Sierra, it seems. However, I have a minimal source install of R-devel, so that

* checking package dependencies ... NOTE
Package suggested but not available for checking: ?expm?

Packages which this enhances but not available for checking:
  ?MatrixModels? ?graph? ?SparseM? ?sfsmisc?

... and it is thinkable that the issue is with one of those(?)

-pd

> 
> 
> stage (while checking Matrix, it passes fine for MASS and lattice).
> Currently I'm getting the same behavior when I do
> 
> tools:::.check_packages("<builddir>/tests/RecPackages/Matrix")
> 
> 
> Is this a known issue and if not, do other people see this behavior?
> 
> Best,
> ~G
> 
> 
> Various info:
> 
> Build script:
> 
> #!/bin/bash
> 
> export CC="gcc -std=gnu99 -fsanitize=address"
> # make -O0 if we want full debugging symbols
> export CFLAGS="-fno-omit-frame-pointer -g -O2 -Wall -pedantic -mtune=native"
> #export CFLAGS="-fno-omit-frame-pointer -g -O0 -Wall -pedantic
> -mtune=native"
> 
> export CXX="g++ -fsanitize=address -fno-omit-frame-pointer"
> export F77="gfortran -arch x86_64"
> export FC="gfortran -arch x86_64"
> export MAIN_LDFLAGS=" -fsanitize=address"
> 
> ../checkedout/Rsource/rawtrunk/configure
> --prefix=/Users/beckerg4/local/Rdevel --enable-R-framework
> --enable-memory-profiling
> make -j3
> make install
> 
> Svn Info:
> 
> beckerg4-T4G3QN:rawtrunk beckerg4$ *svn info*
> 
> Path: .
> 
> Working Copy Root Path: /Users/beckerg4/gabe/checkedout/Rsource/rawtrunk
> 
> URL: https://svn.r-project.org/R/trunk
> 
> Relative URL: ^/trunk
> 
> Repository Root: https://svn.r-project.org/R
> 
> Repository UUID: 00db46b3-68df-0310-9c12-caf00c1e9a41
> 
> Revision: 72894
> 
> Node Kind: directory
> 
> Schedule: normal
> 
> Last Changed Author: lawrence
> 
> Last Changed Rev: 72894
> 
> Last Changed Date: 2017-07-06 00:12:06 -0700 (Thu, 06 Jul 2017)
> 
> 
> 
> Svn status (no local changes)
> 
> beckerg4-T4G3QN:rawtrunk beckerg4$* svn status*
> 
> beckerg4-T4G3QN:rawtrunk beckerg4$
> 
> 
> Session info after Matrix is attached:
> 
> *> library(Matrix)*
> 
> *> sessionInfo()*
> 
> R Under development (unstable) (2017-07-06 r72894)
> 
> Platform: x86_64-apple-darwin15.6.0 (64-bit)
> 
> Running under: OS X El Capitan 10.11.6
> 
> 
> Matrix products: default
> 
> BLAS: /Users/beckerg4/gabe/Rdevelbuild/lib/libRblas.dylib
> 
> LAPACK: /Users/beckerg4/gabe/Rdevelbuild/lib/libRlapack.dylib
> 
> 
> locale:
> 
> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
> 
> 
> attached base packages:
> 
> [1] stats     graphics  grDevices utils     datasets  methods   base
> 
> 
> other attached packages:
> 
> [1] Matrix_1.2-10
> 
> 
> loaded via a namespace (and not attached):
> 
> [1] compiler_3.5.0  grid_3.5.0      lattice_0.20-35
> 
> 
> 
> -- 
> Gabriel Becker, PhD
> Associate Scientist (Bioinformatics)
> Genentech Research
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From sahil.kang at asilaycomputing.com  Fri Jul  7 21:25:07 2017
From: sahil.kang at asilaycomputing.com (Sahil Kang)
Date: Fri, 07 Jul 2017 12:25:07 -0700
Subject: [Rd] [Bug Fix] Default values not applied to ... arguments
In-Reply-To: <364e7d99-7351-8803-7093-6c79c7fcc2e7@gmail.com>
References: <8b83c113-8ec1-bf78-17f5-66682b798475@asilaycomputing.com>
 <0555003e-e7fe-9b3d-def7-852a0644ebdc@gmail.com>
 <ae901a0e-9088-df16-3d75-67c841ef1c35@asilaycomputing.com>
 <364e7d99-7351-8803-7093-6c79c7fcc2e7@gmail.com>
Message-ID: <AE2BF40B-9F40-47F4-A606-AADEF81C0D65@asilaycomputing.com>

I'm glad I could help, and I look forward to reading your patch so that I can learn more about the R internals. It'd be nice to close this 4 year old bug.

Sahil



-------- Original Message --------
From: Tomas Kalibera <tomas.kalibera at gmail.com>
Sent: July 7, 2017 11:10:05 AM PDT
To: Sahil Kang <sahil.kang at asilaycomputing.com>
Subject: Re: [Rd] [Bug Fix] Default values not applied to ... arguments

As I said the old behavior had been for several years both in AST and BC 
interpreter. I fixed it in AST and I will fix it in BC. I know exactly 
where it is and how to fix it, there is no more help I could use on this 
issue and I don't think there is any need to discuss this further, and 
particularly so on R-devel. Please do not send speculative emails to 
R-devel, in the interest of saving time of people following the list.

Thanks
Tomas

On 07/07/2017 11:42 AM, Sahil Kang wrote:
> Yes, I see what you mean. My patch only disables JIT compilation for 
> closures. If a user manually compiles a closure, however, the bug pops 
> up again.
>

> I think the bug may either lie in how the byte-compiler compiles 
> closures, or how closures with compiled body's are executed by the AST 
> interpreter (without my patch applied):
>
> compiler::enableJIT(0) # turn off JIT compilation
> f <- function(...) { g(...) }
> g <- function(a=4, b=5, c=6) {
>   print(c(missing(a), missing(b), missing(c)))
>   b
> }
>
> f(1,,3) # works fine
> # [1] FALSE TRUE FALSE
> # [1] 5
>
> f(1,,3) # works fine
> # [1] FALSE TRUE FALSE
> # [1] 5
>
> ff_1 <- compiler::compile(f) # compile f
> ff_2 <- compiler::cmpfun(f) # compile body of closure
>
> eval(ff_1)(1,,3) # works fine
> # [1] FALSE TRUE FALSE
> # [1] 5
>
> eval(ff_2)(1,,3) # bug shows up again
> # [1] FALSE TRUE FALSE
> # Error in g(...) : argument is missing, with no default
>
> Thanks,
> Sahil
>
> On 07/06/2017 09:29 AM, Tomas Kalibera wrote:
>>
>> Thanks for the report, I've fixed 15199 in the AST interpreter in 
>> 72664, I will fix it in the byte-code interpreter as well.
>>
>> If you ever needed to disable the JIT, there is API for that, see 
>> ?compiler. Note though that by disabling the JIT you won't disable 
>> the byte-code interpreter, because code also gets compiled when 
>> packages are installed or when the compiler is invoked explicitly.
>>
>> Best,
>> Tomas
>>
>> On 07/06/2017 04:40 PM, Sahil Kang wrote:
>>> Hi Duncan, Martin
>>>
>>> Here's a small patch that fixes bug 15199 reported at:
>>> https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=15199
>>>
>>> I was able to reproduce the bug as Duncan had outlined just fine, 
>>> but I did notice that when we debug(f), the problem went away.
>>> I later realized that f(1,,3) behaved correctly the first time it 
>>> was executed, but misbehaved as documented on subsequent calls.
>>> This narrowed the problem down to the byte-compilation that occurs 
>>> on subsequent function calls.
>>>
>>> This patch prevents byte-compilation on closure objects.
>>> Although it's a less than ideal solution, this patch fixes the bug 
>>> at least until the underlying byte-compilation issue can be found 
>>> (I'm currently scrutinizing the promiseArgs function at eval.c:2771).
>>>
>>> Thanks,
>>> Sahil
>>>
>>>
>>> ______________________________________________
>>> R-devel at r-project.org  mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>>
>


From Ma.Binder at campus.lmu.de  Fri Jul  7 23:45:43 2017
From: Ma.Binder at campus.lmu.de (Binder, Martin)
Date: Fri, 07 Jul 2017 17:45:43 -0400
Subject: [Rd] bug: deparse sometimes omits parentheses for unary operators
Message-ID: <3bfc58402caae8fd20f3a263405f2506@campus.lmu.de>

When turning a language object into a string (e.g. using dput, deparse, 
or just
printing it), R usually inserts parentheses so that the printed string 
is an
accurate representation of the underlying AST.

Example (good):
> (expr = substitute(a * 10, list(a = quote(if (TRUE) 1 else 0))))
(if (TRUE) 1 else 0) * 10
> eval(expr)
[1] 10

The representation is incorrect, however, when unary operators around 
language
constructs like "if", "for" etc. are involved.

Example (bad):
> (expr = substitute(-a * 10, list(a = quote(if (TRUE) 1 else 0))))
-if (TRUE) 1 else 0 * 10

The parentheses around the "if"-construct are missing. The expected 
output
(the true representation of the expression) is, in fact:

-(if (TRUE) 1 else 0) * 10

as can be tested when evaluating it (which shows that this is not a bug 
in
"substitute"):

> eval(expr)
[1] -10

The deparsed string on the other hand evaluates to:

> -if (TRUE) 1 else 0 * 10
[1] -1

Even when using deparse with control="all", which comes, per its help 
file,
"closest to making 'deparse()' an inverse of 'parse()'", this bug 
persists:

> deparse(expr, control="all")
[1] "quote(-if (TRUE) 1 else 0 * 10)"

Only some language constructs appear to be affected. Unary operators 
applied to
function calls, other unary operators, or binary operators render as 
expected:

> (expr = substitute(-a * 10, list(a = quote(!0))))
-(!0) * 10

I am using the R version 3.4.0 (2017-04-21) platform 
x86_64-redhat-linux-gnu
package from Fedora 25.

Regards,

Martin Binder


From murdoch.duncan at gmail.com  Sat Jul  8 00:54:52 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Fri, 7 Jul 2017 18:54:52 -0400
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <02239f51-3592-d3f3-5f4a-f479b35b4da9@gmail.com>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
 <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
 <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>
 <ed2899b8-f945-1dad-348a-cee0f8614ba7@insa-toulouse.fr>
 <e8804ff7-473f-3b89-fa65-c1b0d79d85e3@gmail.com>
 <e1cf1c31-2e7c-72cb-453f-68df8321cc3f@insa-toulouse.fr>
 <8ca82104-19ae-a7be-d27f-9f2982b63140@gmail.com>
 <ce8dbd19-c6f1-fcf0-c9af-fccc27eb37c8@insa-toulouse.fr>
 <02239f51-3592-d3f3-5f4a-f479b35b4da9@gmail.com>
Message-ID: <a5920916-a708-14d3-0e0f-66e5f35f7871@gmail.com>

I have now committed changes to R-devel (rev 72898) that seem to catch 
large and small errors.  They only give a warning if the error happens 
when the connection is closed, because that can happen asynchronously: 
I didn't want to mess up some later unrelated computation that triggered 
garbage collection.

I will wait a while before porting these to R-patched, because there may 
still be some problems to clean up.

Duncan Murdoch



On 07/07/2017 11:42 AM, Duncan Murdoch wrote:
> On 07/07/2017 11:13 AM, Serguei Sokol wrote:
>> Le 07/07/2017 ? 16:52, Duncan Murdoch a ?crit :
>>> On 07/07/2017 9:54 AM, Serguei Sokol wrote:
>>>> Le 07/07/2017 ? 01:09, Duncan Murdoch a ?crit :
>>>>> On 06/07/2017 6:44 PM, Sokol Serguei wrote:
>>>>>> Duncan Murdoch has written at  Thu, 6 Jul 2017 13:58:10 -0400
>>>>>>> On 06/07/2017 5:21 AM, Serguei Sokol wrote:
>>>>>>>> I propose the following patch against the current
>>>>>>>> R-devel/src/main/connection.c (cf. attached file).
>>>>>>>> It gives (on my linux box):
>>>>>>>>  > fc=file("/dev/full", "w")
>>>>>>>>  > write.csv("a", file=fc)
>>>>>>>> Error in writeLines(paste(col.names, collapse = sep), file, sep = eol) :
>>>>>>>>    system call failure on writing
>>>>>>>>  > close(fc)
>>>>>>>>
>>>>>>>> Serguei.
>>>>>>>
>>>>>>> I suspect that flushing on every write will slow things down too much.
>>>>>> That's quite plausible.
>>>>>>
>>>>>>>
>>>>>>> I think a better approach is to catch the error in the Rconn_printf
>>>>>>> calls (as R-devel currently does), and also catch errors on
>>>>>>> con->close(con).  This one requires more changes to the source, so it
>>>>>>> may be a day or two before I commit.
>>>>>> I have testes it on file_close() and it works (cf. attached patch):
>>>>>>> fc=file("/dev/full", "w")
>>>>>>> write.csv("a", file=fc)
>>>>>>> close(fc)
>>>>>> Error in close.connection(fc) : closing file failed
>>>>>>
>>>>>>>
>>>>>>> One thing I have to look into:  is anyone making use of the fact that
>>>>>>> the R-level close.connection() function can return -1 to signal an
>>>>>>> error?  Base R ignores that, which is why we need to do something, but
>>>>>>> if packages are using it, things need to be changed carefully.  I
>>>>>>> can't just change it to raise an error instead.
>>>>>> As you can see in the patch, no need to change close.connection() function
>>>>>> but we have to add a test of con->status to all *_close() functions
>>>>>> (gzfile_close() and co.)
>>>>>
>>>>> You missed my point.  Currently the R close() function may return -1 to signal that there was an error closing.  We can't change that to an error if packages
>>>>> are using it.
>>>> May be I missed it but finally, me too, I was saying that we don't have to do so.
>>>> Anyhow, the situation of writing to full disk cannot be passed in silence.
>>>> IMHO, trigger an error would be the most appropriate in this situation but if for legacy
>>>> or any other reason we cannot do so, let whistle a warning, at least.
>>>> Here few tests with a new small patch:
>>>>  > fc=file("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>>> [1] -1
>>>> Warning message:
>>>> In close.connection(fc) :
>>>>    closing '/dev/full' failed: No space left on device
>>>>  > fc=gzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>>> NULL
>>>> Warning message:
>>>> In close.connection(fc) :
>>>>    closing '/dev/full' failed: No space left on device
>>>>  > fc=xzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>>> NULL
>>>> Warning message:
>>>> In close.connection(fc) :
>>>>    closing '/dev/full' failed: No space left on device
>>>>  > fc=bzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>>> NULL
>>>> Warning message:
>>>> In close.connection(fc) :
>>>>    closing '/dev/full' failed: No space left on device
>>>>
>>>> Note that if we test only status < 0 (without errno) then there are too many warnings
>>>> on seemingly "innocent" file closings.
>>>
>>> Could you give an example of how to get status < 0 on a valid closing?
>> If you remove "&& errno" and leave only "if (status < 0)" in the previous patch
>> then during make I have many warnings, e.g. :
>> Warning messages:
>> 1: In close.connection(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/nsInfo.rds' failed: Success
>> 2: In close.connection(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/package.rds' failed: Success
>> 3: In close(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/compiler/R/compiler.rdx' failed: Success
>> 4: In close.connection(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/tools/Meta/nsInfo.rds' failed: Success
>> 5: In close.connection(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/tools/Meta/package.rds' failed: Success
>> 6: In close(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/tools/R/tools.rdx' failed: Success
>> 7: In close(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/tools/R/sysdata.rdx' failed: Success
>> 8: In close.connection(con) :
>>    closing '../../library/parallel/Meta/Rd.rds' failed: Success
>> 9: In close.connection(con) :
>>    closing '../../library/parallel/help/aliases.rds' failed: Success
>> 10: In close.connection(file) :
>>    closing '../../library/parallel/DESCRIPTION' failed: Success
>>
>
> You are probably seeing cases where status is never set:  then status is
> NA_INTEGER, which (in C) is negative.
>
> Duncan Murdoch
>
>
>> Note "Succes" as the reason of "failure".
>>
>> And if I use thus compiled R, at startup I get:
>>
>> Warning message:
>> In close(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/base/R/base.rdx' failed: Success
>>
>> R Under development (unstable) (2017-06-01 r72753) -- "Unsuffered Consequences"
>> Copyright (C) 2017 The R Foundation for Statistical Computing
>> Platform: x86_64-pc-linux-gnu (64-bit)
>>
>> R is free software and comes with ABSOLUTELY NO WARRANTY.
>> You are welcome to redistribute it under certain conditions.
>> Type 'license()' or 'licence()' for distribution details.
>>
>> R is a collaborative project with many contributors.
>> Type 'contributors()' for more information and
>> 'citation()' on how to cite R or R packages in publications.
>>
>> Type 'demo()' for some demos, 'help()' for on-line help, or
>> 'help.start()' for an HTML browser interface to help.
>> Type 'q()' to quit R.
>>
>> Warning messages:
>> 1: In close.connection(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/package.rds' failed: Success
>> 2: In close.connection(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/features.rds' failed: Success
>> 3: In close.connection(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/nsInfo.rds' failed: Success
>> 4: In close.connection(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/package.rds' failed: Success
>> 5: In close(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/methods/R/methods.rdx' failed: Success
>> [Previously saved workspace restored]
>>
>> During startup - There were 27 warnings (use warnings() to see them)
>>
>> All these closings seem valid to me but obviously the warnings indicate that status was < 0.
>>
>> Finaly, if I open and close a valid file in this session, I don't get a warning for _this_ file:
>>  > fc=file("/tmp/aha", "w")
>> Warning messages:
>> 1: In close.connection(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/nsInfo.rds' failed: Success
>> 2: In close.connection(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/package.rds' failed: Success
>> 3: In close(con) :
>>    closing '/home/sokol/dev/R/R-devel/library/compiler/R/compiler.rdx' failed: Success
>>  > write.csv("a", file=fc)
>>  > close(fc) # no warning
>>
>>
>> Serguei.
>>
>


From maechler at stat.math.ethz.ch  Sat Jul  8 18:18:25 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Sat, 8 Jul 2017 18:18:25 +0200
Subject: [Rd] Patch for R-exts.texi
In-Reply-To: <20170703060947.22pm6oiyivj7illt@steph>
References: <20170703060947.22pm6oiyivj7illt@steph>
Message-ID: <22881.1489.179348.530152@stat.math.ethz.ch>

>>>>> Scott Kostyshak <skostyshak at ufl.edu>
>>>>>     on Mon, 3 Jul 2017 02:09:47 -0400 writes:

    > Attached is a patch for R-exts.texi against r72880.  Here
    > are some of the changes I made:

    > - Fix a broken link:
    > https://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Introduction/Introduction.html
    -> 
    >     https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html

    > - Changed a few http to https (and checked that the
    > connections are indeed secure, as judged by Chromium and
    > Firefox).

    > - A couple of grammar fixes and "sounds more natural to
    > me" changes.

    > - "x84_64" -> x86_64

    > - One change of "which" -> "that"

    > - The link to Luke's uiowa.edu page involves two changes,
    > removing the duplicate URL and changing the protocol to
    > https.

    > Thanks for your time,
    > Scott

    > -- 
    > Scott Kostyshak Assistant Professor of Economics
    > University of Florida
    > https://people.clas.ufl.edu/skostyshak/

    > [DELETED ATTACHMENT external: R-exts.texi.diff, plain
    > text]

Thank you very much, Scott!

This is a clear improvement
 ((even though some of the style changes may be debatable - but only by native
   English/American (;-) speakers, not me. ...))

Hence I've committed it (R-devel, svn rev 72900).

Martin Maechler


From skostyshak at ufl.edu  Sat Jul  8 19:15:39 2017
From: skostyshak at ufl.edu (Scott Kostyshak)
Date: Sat, 8 Jul 2017 13:15:39 -0400
Subject: [Rd] Patch for R-exts.texi
In-Reply-To: <22881.1489.179348.530152@stat.math.ethz.ch>
References: <20170703060947.22pm6oiyivj7illt@steph>
 <22881.1489.179348.530152@stat.math.ethz.ch>
Message-ID: <20170708171539.372yxxceg5ypqoyc@steph>

On Sat, Jul 08, 2017 at 06:18:25PM +0200, Martin Maechler wrote:
> >>>>> Scott Kostyshak <skostyshak at ufl.edu>
> >>>>>     on Mon, 3 Jul 2017 02:09:47 -0400 writes:
> 
>     > Attached is a patch for R-exts.texi against r72880.  Here
>     > are some of the changes I made:
> 
>     > - Fix a broken link:
>     > https://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Introduction/Introduction.html
>     -> 
>     >     https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html
> 
>     > - Changed a few http to https (and checked that the
>     > connections are indeed secure, as judged by Chromium and
>     > Firefox).
> 
>     > - A couple of grammar fixes and "sounds more natural to
>     > me" changes.
> 
>     > - "x84_64" -> x86_64
> 
>     > - One change of "which" -> "that"
> 
>     > - The link to Luke's uiowa.edu page involves two changes,
>     > removing the duplicate URL and changing the protocol to
>     > https.
> 
>     > Thanks for your time,
>     > Scott
> 
>     > -- 
>     > Scott Kostyshak Assistant Professor of Economics
>     > University of Florida
>     > https://people.clas.ufl.edu/skostyshak/
> 
>     > [DELETED ATTACHMENT external: R-exts.texi.diff, plain
>     > text]
> 
> Thank you very much, Scott!
> 
> This is a clear improvement
>  ((even though some of the style changes may be debatable - but only by native
>    English/American (;-) speakers, not me. ...))
> 
> Hence I've committed it (R-devel, svn rev 72900).

Thanks for putting it in, Martin! I do my best to not impose American
English, but sometimes I just don't realize. I actually have adopted
several non-American rules because I find them more logical. For
example, I like to put punctuation outside of quotes, such as "this is a
quote", where for some reason in American English it is preferred to put
it as "this is a quote."

Thanks for taking the time to review the patch and commit it.

Scott


-- 
Scott Kostyshak
Assistant Professor of Economics
University of Florida
https://people.clas.ufl.edu/skostyshak/


From radford at cs.toronto.edu  Sat Jul  8 19:53:29 2017
From: radford at cs.toronto.edu (Radford Neal)
Date: Sat, 8 Jul 2017 13:53:29 -0400
Subject: [Rd] attributes on symbols
In-Reply-To: <mailman.9.1499508002.52936.r-devel@r-project.org>
References: <mailman.9.1499508002.52936.r-devel@r-project.org>
Message-ID: <20170708175329.GA17505@mail.cs.toronto.edu>

Attributes on symbols seem like a bad idea to me.  An additional
obscure part of the global state seems undesirable.  I can't see how
any use of them would be preferrable to storing an environment in some
global variable, in which the same information could be recorded.

Note that the attributes on symbols are not saved when the workspace
is saved with q("yes").

   Radford Neal


From radford at cs.toronto.edu  Sat Jul  8 22:03:20 2017
From: radford at cs.toronto.edu (Radford Neal)
Date: Sat, 8 Jul 2017 16:03:20 -0400
Subject: [Rd] bug: deparse sometimes omits parentheses for unary
	operators
In-Reply-To: <mailman.9.1499508002.52936.r-devel@r-project.org>
References: <mailman.9.1499508002.52936.r-devel@r-project.org>
Message-ID: <20170708200320.GA11757@mail.cs.toronto.edu>

> From: "Binder, Martin" <Ma.Binder at campus.lmu.de>
> To: r-devel at r-project.org
> Subject: [Rd] bug: deparse sometimes omits parentheses for unary
> 	operators
>
> Example (bad):
> > (expr = substitute(-a * 10, list(a = quote(if (TRUE) 1 else 0))))
> -if (TRUE) 1 else 0 * 10
>
> The parentheses around the "if"-construct are missing. The expected
> output (the true representation of the expression) is, in fact:
>
> -(if (TRUE) 1 else 0) * 10


It would also be OK for the result to be

  (-if (TRUE) 1 else 0) * 10

It's possible that producing this form is more natural for the deparser.

There are a number of other bugs in the deparser, many of which I
fixed in the pqR deparser when doing a major rewrite, though I missed
the one you report above.  You can see them at

    http://www.pqr-project.org/NEWS.txt

Look for BUG FIXES under VERSION RELEASED 2015-09-14.  Some are fixed
in R-3.4.0, but most remain.

   Radford Neal


From selivanov.dmitriy at gmail.com  Sun Jul  9 12:12:29 2017
From: selivanov.dmitriy at gmail.com (Dmitriy Selivanov)
Date: Sun, 9 Jul 2017 14:12:29 +0400
Subject: [Rd] Issue with memory deallocation/fragmentation on systems
	which use glibc
In-Reply-To: <CAJdZCv1acw4A1VOHgT7DWO3hp5XqLmwt5kmFHq6Kq-bQ8DGhXg@mail.gmail.com>
References: <CAJdZCv1acw4A1VOHgT7DWO3hp5XqLmwt5kmFHq6Kq-bQ8DGhXg@mail.gmail.com>
Message-ID: <CAJdZCv2wTRetp1ponmxKLfXARQmoPZVLTcbPc6E2mz9nfEFCWA@mail.gmail.com>

Dear R-devel mailing list and especially R-core, is there any chance to
receive feedback on issue I described in previous emails? I would consider
such behaviour as a bug.

As a work-around I've created small "clean-up" function:

malloc_trim_finalizer = function(e) {
  res = NULL
  if(R.version$os == "linux-gnu") {
    flog.debug("Calling malloc_trim(0L) to trigger glibc to release
memory\n")
    res = malloc_trim(0L)
  }
  res
}

And at the end of each function which produce a lot of intermediate small
objects I provide it to reg.finalizer():
some_function = function(...) {
  # do some useful work
  result = TRUE
  # register finalizer
  e = environment()
  reg.finalizer(e, malloc_trim_finalizer)
  return(result)
}

2017-06-22 11:12 GMT+04:00 Dmitriy Selivanov <selivanov.dmitriy at gmail.com>:

> A few additional details. According to Linux Programmer's Manual
>
>    1. http://man7.org/linux/man-pages/man3/mallopt.3.html
>    2. http://man7.org/linux/man-pages/man3/malloc_trim.3.html
>
> And if I understood everything correctly `free` could trigger
> `malloc_trim` based on value of several environment variables -
> MALLOC_TOP_PAD_ and MALLOC_TRIM_THRESHOLD_. However setting them as low as
> 1 or 0 doesn't have any effect (but as I wrote in previous email manual
> call of `malloc_trim` helps to release memory).
>



-- 
Regards
Dmitriy Selivanov

	[[alternative HTML version deleted]]


From marc_grt at yahoo.fr  Sun Jul  9 16:05:49 2017
From: marc_grt at yahoo.fr (Marc Girondot)
Date: Sun, 9 Jul 2017 16:05:49 +0200
Subject: [Rd] MASS:::dropterm.glm() and MASS:::addterm.glm() should use ...
 for extractAIC()
Message-ID: <89d0ae23-3560-8c1a-fcd9-4ead33a49496@yahoo.fr>

Here is a change required from MASS:::dropterm.glm() and 
MASS:::addterm.glm().

Thanks

Marc


The stepAIC() function from package MASS uses extractAIC() to get the 
AIC from a model.
Several methods exist:
extractAIC.glm() for example, some in MASS packages and some in stats 
package.

The parameters for extractAIC() are:
fit, scale, k = 2, ...

The ... are not used in most of the extractAIC.xxx() methods, from 
example in stats:::extractAIC.glm() or MASS:::extractAIC.loglm() but its 
presence could be necessary if extractAIC() is changed to use for 
example to use AICc rather than AIC.

Within stepAIC(), extractAIC() uses always the ... parameter. So all is 
ok for that.

However, stepAIC() uses dropterm() or addterm().

Within MASS:::dropterm.glm() and MASS:::addterm.glm(), extractAIC() is 
also used but without the ... parameter.

It prevents to use new version of extractAIC() that could use this 
parameter.

The solution is simple:
In MASS:::dropterm.glm(), line 60 and MASS:::addterm.glm(), line 84:
aic <- aic + (extractAIC(object, k = k)[2L] - aic[1L])
must be changed to
aic <- aic + (extractAIC(object, k = k, ...)[2L] - aic[1L])

Other dropterm.xxx() and addterm.xxx() do not suffer this problem.


From sokol at insa-toulouse.fr  Mon Jul 10 10:54:34 2017
From: sokol at insa-toulouse.fr (Serguei Sokol)
Date: Mon, 10 Jul 2017 10:54:34 +0200
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <a5920916-a708-14d3-0e0f-66e5f35f7871@gmail.com>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
 <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
 <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>
 <ed2899b8-f945-1dad-348a-cee0f8614ba7@insa-toulouse.fr>
 <e8804ff7-473f-3b89-fa65-c1b0d79d85e3@gmail.com>
 <e1cf1c31-2e7c-72cb-453f-68df8321cc3f@insa-toulouse.fr>
 <8ca82104-19ae-a7be-d27f-9f2982b63140@gmail.com>
 <ce8dbd19-c6f1-fcf0-c9af-fccc27eb37c8@insa-toulouse.fr>
 <02239f51-3592-d3f3-5f4a-f479b35b4da9@gmail.com>
 <a5920916-a708-14d3-0e0f-66e5f35f7871@gmail.com>
Message-ID: <ce5bb61d-0eb4-cc7d-49ec-d43b8de14eab@insa-toulouse.fr>

Le 08/07/2017 ? 00:54, Duncan Murdoch a ?crit :
> I have now committed changes to R-devel (rev 72898) that seem to catch large and small errors.  They only give a warning if the error happens when the 
> connection is closed, because that can happen asynchronously
For this asynchronous behavior, would not it be more useful to have
the name of the file that failed at closing? If many files were open
during a session and not closed explicitly (yes, bad practice but it
can happen), the warning message doesn't help to understand
which of files were corrupted, e.g.:
 > fc=file("/dev/full", "w")
 > write.csv("a", file=fc)
 > q("yes")
Warning message:
In close.connection(getConnection(set[i])) :
   Problem closing connection:  No space left on device

Having only "set[i]" for indication is not very informative, is it?

Serguei.

> : I didn't want to mess up some later unrelated computation that triggered garbage collection.
>
> I will wait a while before porting these to R-patched, because there may still be some problems to clean up.
>
> Duncan Murdoch
>
>
>
> On 07/07/2017 11:42 AM, Duncan Murdoch wrote:
>> On 07/07/2017 11:13 AM, Serguei Sokol wrote:
>>> Le 07/07/2017 ? 16:52, Duncan Murdoch a ?crit :
>>>> On 07/07/2017 9:54 AM, Serguei Sokol wrote:
>>>>> Le 07/07/2017 ? 01:09, Duncan Murdoch a ?crit :
>>>>>> On 06/07/2017 6:44 PM, Sokol Serguei wrote:
>>>>>>> Duncan Murdoch has written at Thu, 6 Jul 2017 13:58:10 -0400
>>>>>>>> On 06/07/2017 5:21 AM, Serguei Sokol wrote:
>>>>>>>>> I propose the following patch against the current
>>>>>>>>> R-devel/src/main/connection.c (cf. attached file).
>>>>>>>>> It gives (on my linux box):
>>>>>>>>>  > fc=file("/dev/full", "w")
>>>>>>>>>  > write.csv("a", file=fc)
>>>>>>>>> Error in writeLines(paste(col.names, collapse = sep), file, sep = eol) :
>>>>>>>>>    system call failure on writing
>>>>>>>>>  > close(fc)
>>>>>>>>>
>>>>>>>>> Serguei.
>>>>>>>>
>>>>>>>> I suspect that flushing on every write will slow things down too much.
>>>>>>> That's quite plausible.
>>>>>>>
>>>>>>>>
>>>>>>>> I think a better approach is to catch the error in the Rconn_printf
>>>>>>>> calls (as R-devel currently does), and also catch errors on
>>>>>>>> con->close(con).  This one requires more changes to the source, so it
>>>>>>>> may be a day or two before I commit.
>>>>>>> I have testes it on file_close() and it works (cf. attached patch):
>>>>>>>> fc=file("/dev/full", "w")
>>>>>>>> write.csv("a", file=fc)
>>>>>>>> close(fc)
>>>>>>> Error in close.connection(fc) : closing file failed
>>>>>>>
>>>>>>>>
>>>>>>>> One thing I have to look into:  is anyone making use of the fact that
>>>>>>>> the R-level close.connection() function can return -1 to signal an
>>>>>>>> error?  Base R ignores that, which is why we need to do something, but
>>>>>>>> if packages are using it, things need to be changed carefully.  I
>>>>>>>> can't just change it to raise an error instead.
>>>>>>> As you can see in the patch, no need to change close.connection() function
>>>>>>> but we have to add a test of con->status to all *_close() functions
>>>>>>> (gzfile_close() and co.)
>>>>>>
>>>>>> You missed my point.  Currently the R close() function may return -1 to signal that there was an error closing.  We can't change that to an error if 
>>>>>> packages
>>>>>> are using it.
>>>>> May be I missed it but finally, me too, I was saying that we don't have to do so.
>>>>> Anyhow, the situation of writing to full disk cannot be passed in silence.
>>>>> IMHO, trigger an error would be the most appropriate in this situation but if for legacy
>>>>> or any other reason we cannot do so, let whistle a warning, at least.
>>>>> Here few tests with a new small patch:
>>>>>  > fc=file("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>>>> [1] -1
>>>>> Warning message:
>>>>> In close.connection(fc) :
>>>>>    closing '/dev/full' failed: No space left on device
>>>>>  > fc=gzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>>>> NULL
>>>>> Warning message:
>>>>> In close.connection(fc) :
>>>>>    closing '/dev/full' failed: No space left on device
>>>>>  > fc=xzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>>>> NULL
>>>>> Warning message:
>>>>> In close.connection(fc) :
>>>>>    closing '/dev/full' failed: No space left on device
>>>>>  > fc=bzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>>>> NULL
>>>>> Warning message:
>>>>> In close.connection(fc) :
>>>>>    closing '/dev/full' failed: No space left on device
>>>>>
>>>>> Note that if we test only status < 0 (without errno) then there are too many warnings
>>>>> on seemingly "innocent" file closings.
>>>>
>>>> Could you give an example of how to get status < 0 on a valid closing?
>>> If you remove "&& errno" and leave only "if (status < 0)" in the previous patch
>>> then during make I have many warnings, e.g. :
>>> Warning messages:
>>> 1: In close.connection(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/nsInfo.rds' failed: Success
>>> 2: In close.connection(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/package.rds' failed: Success
>>> 3: In close(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/compiler/R/compiler.rdx' failed: Success
>>> 4: In close.connection(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/tools/Meta/nsInfo.rds' failed: Success
>>> 5: In close.connection(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/tools/Meta/package.rds' failed: Success
>>> 6: In close(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/tools/R/tools.rdx' failed: Success
>>> 7: In close(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/tools/R/sysdata.rdx' failed: Success
>>> 8: In close.connection(con) :
>>>    closing '../../library/parallel/Meta/Rd.rds' failed: Success
>>> 9: In close.connection(con) :
>>>    closing '../../library/parallel/help/aliases.rds' failed: Success
>>> 10: In close.connection(file) :
>>>    closing '../../library/parallel/DESCRIPTION' failed: Success
>>>
>>
>> You are probably seeing cases where status is never set:  then status is
>> NA_INTEGER, which (in C) is negative.
>>
>> Duncan Murdoch
>>
>>
>>> Note "Succes" as the reason of "failure".
>>>
>>> And if I use thus compiled R, at startup I get:
>>>
>>> Warning message:
>>> In close(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/base/R/base.rdx' failed: Success
>>>
>>> R Under development (unstable) (2017-06-01 r72753) -- "Unsuffered Consequences"
>>> Copyright (C) 2017 The R Foundation for Statistical Computing
>>> Platform: x86_64-pc-linux-gnu (64-bit)
>>>
>>> R is free software and comes with ABSOLUTELY NO WARRANTY.
>>> You are welcome to redistribute it under certain conditions.
>>> Type 'license()' or 'licence()' for distribution details.
>>>
>>> R is a collaborative project with many contributors.
>>> Type 'contributors()' for more information and
>>> 'citation()' on how to cite R or R packages in publications.
>>>
>>> Type 'demo()' for some demos, 'help()' for on-line help, or
>>> 'help.start()' for an HTML browser interface to help.
>>> Type 'q()' to quit R.
>>>
>>> Warning messages:
>>> 1: In close.connection(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/package.rds' failed: Success
>>> 2: In close.connection(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/features.rds' failed: Success
>>> 3: In close.connection(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/nsInfo.rds' failed: Success
>>> 4: In close.connection(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/package.rds' failed: Success
>>> 5: In close(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/methods/R/methods.rdx' failed: Success
>>> [Previously saved workspace restored]
>>>
>>> During startup - There were 27 warnings (use warnings() to see them)
>>>
>>> All these closings seem valid to me but obviously the warnings indicate that status was < 0.
>>>
>>> Finaly, if I open and close a valid file in this session, I don't get a warning for _this_ file:
>>>  > fc=file("/tmp/aha", "w")
>>> Warning messages:
>>> 1: In close.connection(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/nsInfo.rds' failed: Success
>>> 2: In close.connection(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/package.rds' failed: Success
>>> 3: In close(con) :
>>>    closing '/home/sokol/dev/R/R-devel/library/compiler/R/compiler.rdx' failed: Success
>>>  > write.csv("a", file=fc)
>>>  > close(fc) # no warning
>>>
>>>
>>> Serguei.
>>>
>>
>
>

-- 
Serguei Sokol
Ingenieur de recherche INRA
Metabolisme Integre et Dynamique des Systemes Metaboliques (MetaSys)

LISBP, INSA/INRA UMR 792, INSA/CNRS UMR 5504
135 Avenue de Rangueil
31077 Toulouse Cedex 04

tel: +33 5 6155 9276
fax: +33 5 6704 8825
email:sokol at insa-toulouse.fr
http://metasys.insa-toulouse.fr
http://www.lisbp.fr


From murdoch.duncan at gmail.com  Mon Jul 10 11:19:30 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Mon, 10 Jul 2017 05:19:30 -0400
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <ce5bb61d-0eb4-cc7d-49ec-d43b8de14eab@insa-toulouse.fr>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
 <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
 <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>
 <ed2899b8-f945-1dad-348a-cee0f8614ba7@insa-toulouse.fr>
 <e8804ff7-473f-3b89-fa65-c1b0d79d85e3@gmail.com>
 <e1cf1c31-2e7c-72cb-453f-68df8321cc3f@insa-toulouse.fr>
 <8ca82104-19ae-a7be-d27f-9f2982b63140@gmail.com>
 <ce8dbd19-c6f1-fcf0-c9af-fccc27eb37c8@insa-toulouse.fr>
 <02239f51-3592-d3f3-5f4a-f479b35b4da9@gmail.com>
 <a5920916-a708-14d3-0e0f-66e5f35f7871@gmail.com>
 <ce5bb61d-0eb4-cc7d-49ec-d43b8de14eab@insa-toulouse.fr>
Message-ID: <a974c35e-aadb-c9b7-af70-f486e3c24dd2@gmail.com>

On 10/07/2017 4:54 AM, Serguei Sokol wrote:
> Le 08/07/2017 ? 00:54, Duncan Murdoch a ?crit :
>> I have now committed changes to R-devel (rev 72898) that seem to catch large and small errors.  They only give a warning if the error happens when the
>> connection is closed, because that can happen asynchronously
> For this asynchronous behavior, would not it be more useful to have
> the name of the file that failed at closing? If many files were open
> during a session and not closed explicitly (yes, bad practice but it
> can happen), the warning message doesn't help to understand
> which of files were corrupted, e.g.:
>  > fc=file("/dev/full", "w")
>  > write.csv("a", file=fc)
>  > q("yes")
> Warning message:
> In close.connection(getConnection(set[i])) :
>    Problem closing connection:  No space left on device
>
> Having only "set[i]" for indication is not very informative, is it?

To debug your failure to close fc, reproduce the conditions before the 
warning was issued, and call showConnections().

Duncan Murdoch

>
> Serguei.
>
>> : I didn't want to mess up some later unrelated computation that triggered garbage collection.
>>
>> I will wait a while before porting these to R-patched, because there may still be some problems to clean up.
>>
>> Duncan Murdoch
>>
>>
>>
>> On 07/07/2017 11:42 AM, Duncan Murdoch wrote:
>>> On 07/07/2017 11:13 AM, Serguei Sokol wrote:
>>>> Le 07/07/2017 ? 16:52, Duncan Murdoch a ?crit :
>>>>> On 07/07/2017 9:54 AM, Serguei Sokol wrote:
>>>>>> Le 07/07/2017 ? 01:09, Duncan Murdoch a ?crit :
>>>>>>> On 06/07/2017 6:44 PM, Sokol Serguei wrote:
>>>>>>>> Duncan Murdoch has written at Thu, 6 Jul 2017 13:58:10 -0400
>>>>>>>>> On 06/07/2017 5:21 AM, Serguei Sokol wrote:
>>>>>>>>>> I propose the following patch against the current
>>>>>>>>>> R-devel/src/main/connection.c (cf. attached file).
>>>>>>>>>> It gives (on my linux box):
>>>>>>>>>>  > fc=file("/dev/full", "w")
>>>>>>>>>>  > write.csv("a", file=fc)
>>>>>>>>>> Error in writeLines(paste(col.names, collapse = sep), file, sep = eol) :
>>>>>>>>>>    system call failure on writing
>>>>>>>>>>  > close(fc)
>>>>>>>>>>
>>>>>>>>>> Serguei.
>>>>>>>>>
>>>>>>>>> I suspect that flushing on every write will slow things down too much.
>>>>>>>> That's quite plausible.
>>>>>>>>
>>>>>>>>>
>>>>>>>>> I think a better approach is to catch the error in the Rconn_printf
>>>>>>>>> calls (as R-devel currently does), and also catch errors on
>>>>>>>>> con->close(con).  This one requires more changes to the source, so it
>>>>>>>>> may be a day or two before I commit.
>>>>>>>> I have testes it on file_close() and it works (cf. attached patch):
>>>>>>>>> fc=file("/dev/full", "w")
>>>>>>>>> write.csv("a", file=fc)
>>>>>>>>> close(fc)
>>>>>>>> Error in close.connection(fc) : closing file failed
>>>>>>>>
>>>>>>>>>
>>>>>>>>> One thing I have to look into:  is anyone making use of the fact that
>>>>>>>>> the R-level close.connection() function can return -1 to signal an
>>>>>>>>> error?  Base R ignores that, which is why we need to do something, but
>>>>>>>>> if packages are using it, things need to be changed carefully.  I
>>>>>>>>> can't just change it to raise an error instead.
>>>>>>>> As you can see in the patch, no need to change close.connection() function
>>>>>>>> but we have to add a test of con->status to all *_close() functions
>>>>>>>> (gzfile_close() and co.)
>>>>>>>
>>>>>>> You missed my point.  Currently the R close() function may return -1 to signal that there was an error closing.  We can't change that to an error if
>>>>>>> packages
>>>>>>> are using it.
>>>>>> May be I missed it but finally, me too, I was saying that we don't have to do so.
>>>>>> Anyhow, the situation of writing to full disk cannot be passed in silence.
>>>>>> IMHO, trigger an error would be the most appropriate in this situation but if for legacy
>>>>>> or any other reason we cannot do so, let whistle a warning, at least.
>>>>>> Here few tests with a new small patch:
>>>>>>  > fc=file("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>>>>> [1] -1
>>>>>> Warning message:
>>>>>> In close.connection(fc) :
>>>>>>    closing '/dev/full' failed: No space left on device
>>>>>>  > fc=gzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>>>>> NULL
>>>>>> Warning message:
>>>>>> In close.connection(fc) :
>>>>>>    closing '/dev/full' failed: No space left on device
>>>>>>  > fc=xzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>>>>> NULL
>>>>>> Warning message:
>>>>>> In close.connection(fc) :
>>>>>>    closing '/dev/full' failed: No space left on device
>>>>>>  > fc=bzfile("/dev/full", "w"); write.csv("a", file=fc); (res=close(fc))
>>>>>> NULL
>>>>>> Warning message:
>>>>>> In close.connection(fc) :
>>>>>>    closing '/dev/full' failed: No space left on device
>>>>>>
>>>>>> Note that if we test only status < 0 (without errno) then there are too many warnings
>>>>>> on seemingly "innocent" file closings.
>>>>>
>>>>> Could you give an example of how to get status < 0 on a valid closing?
>>>> If you remove "&& errno" and leave only "if (status < 0)" in the previous patch
>>>> then during make I have many warnings, e.g. :
>>>> Warning messages:
>>>> 1: In close.connection(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/nsInfo.rds' failed: Success
>>>> 2: In close.connection(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/package.rds' failed: Success
>>>> 3: In close(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/compiler/R/compiler.rdx' failed: Success
>>>> 4: In close.connection(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/tools/Meta/nsInfo.rds' failed: Success
>>>> 5: In close.connection(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/tools/Meta/package.rds' failed: Success
>>>> 6: In close(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/tools/R/tools.rdx' failed: Success
>>>> 7: In close(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/tools/R/sysdata.rdx' failed: Success
>>>> 8: In close.connection(con) :
>>>>    closing '../../library/parallel/Meta/Rd.rds' failed: Success
>>>> 9: In close.connection(con) :
>>>>    closing '../../library/parallel/help/aliases.rds' failed: Success
>>>> 10: In close.connection(file) :
>>>>    closing '../../library/parallel/DESCRIPTION' failed: Success
>>>>
>>>
>>> You are probably seeing cases where status is never set:  then status is
>>> NA_INTEGER, which (in C) is negative.
>>>
>>> Duncan Murdoch
>>>
>>>
>>>> Note "Succes" as the reason of "failure".
>>>>
>>>> And if I use thus compiled R, at startup I get:
>>>>
>>>> Warning message:
>>>> In close(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/base/R/base.rdx' failed: Success
>>>>
>>>> R Under development (unstable) (2017-06-01 r72753) -- "Unsuffered Consequences"
>>>> Copyright (C) 2017 The R Foundation for Statistical Computing
>>>> Platform: x86_64-pc-linux-gnu (64-bit)
>>>>
>>>> R is free software and comes with ABSOLUTELY NO WARRANTY.
>>>> You are welcome to redistribute it under certain conditions.
>>>> Type 'license()' or 'licence()' for distribution details.
>>>>
>>>> R is a collaborative project with many contributors.
>>>> Type 'contributors()' for more information and
>>>> 'citation()' on how to cite R or R packages in publications.
>>>>
>>>> Type 'demo()' for some demos, 'help()' for on-line help, or
>>>> 'help.start()' for an HTML browser interface to help.
>>>> Type 'q()' to quit R.
>>>>
>>>> Warning messages:
>>>> 1: In close.connection(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/package.rds' failed: Success
>>>> 2: In close.connection(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/features.rds' failed: Success
>>>> 3: In close.connection(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/nsInfo.rds' failed: Success
>>>> 4: In close.connection(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/methods/Meta/package.rds' failed: Success
>>>> 5: In close(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/methods/R/methods.rdx' failed: Success
>>>> [Previously saved workspace restored]
>>>>
>>>> During startup - There were 27 warnings (use warnings() to see them)
>>>>
>>>> All these closings seem valid to me but obviously the warnings indicate that status was < 0.
>>>>
>>>> Finaly, if I open and close a valid file in this session, I don't get a warning for _this_ file:
>>>>  > fc=file("/tmp/aha", "w")
>>>> Warning messages:
>>>> 1: In close.connection(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/nsInfo.rds' failed: Success
>>>> 2: In close.connection(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/compiler/Meta/package.rds' failed: Success
>>>> 3: In close(con) :
>>>>    closing '/home/sokol/dev/R/R-devel/library/compiler/R/compiler.rdx' failed: Success
>>>>  > write.csv("a", file=fc)
>>>>  > close(fc) # no warning
>>>>
>>>>
>>>> Serguei.
>>>>
>>>
>>
>>
>


From sokol at insa-toulouse.fr  Mon Jul 10 11:34:19 2017
From: sokol at insa-toulouse.fr (Serguei Sokol)
Date: Mon, 10 Jul 2017 11:34:19 +0200
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <a974c35e-aadb-c9b7-af70-f486e3c24dd2@gmail.com>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
 <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
 <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>
 <ed2899b8-f945-1dad-348a-cee0f8614ba7@insa-toulouse.fr>
 <e8804ff7-473f-3b89-fa65-c1b0d79d85e3@gmail.com>
 <e1cf1c31-2e7c-72cb-453f-68df8321cc3f@insa-toulouse.fr>
 <8ca82104-19ae-a7be-d27f-9f2982b63140@gmail.com>
 <ce8dbd19-c6f1-fcf0-c9af-fccc27eb37c8@insa-toulouse.fr>
 <02239f51-3592-d3f3-5f4a-f479b35b4da9@gmail.com>
 <a5920916-a708-14d3-0e0f-66e5f35f7871@gmail.com>
 <ce5bb61d-0eb4-cc7d-49ec-d43b8de14eab@insa-toulouse.fr>
 <a974c35e-aadb-c9b7-af70-f486e3c24dd2@gmail.com>
Message-ID: <1631c430-ce0a-ff60-6b22-cdacfc1a80b6@insa-toulouse.fr>

Le 10/07/2017 ? 11:19, Duncan Murdoch a ?crit :
> On 10/07/2017 4:54 AM, Serguei Sokol wrote:
>> Le 08/07/2017 ? 00:54, Duncan Murdoch a ?crit :
>>> I have now committed changes to R-devel (rev 72898) that seem to catch large and small errors.  They only give a warning if the error happens when the
>>> connection is closed, because that can happen asynchronously
>> For this asynchronous behavior, would not it be more useful to have
>> the name of the file that failed at closing? If many files were open
>> during a session and not closed explicitly (yes, bad practice but it
>> can happen), the warning message doesn't help to understand
>> which of files were corrupted, e.g.:
>>  > fc=file("/dev/full", "w")
>>  > write.csv("a", file=fc)
>>  > q("yes")
>> Warning message:
>> In close.connection(getConnection(set[i])) :
>>    Problem closing connection:  No space left on device
>>
>> Having only "set[i]" for indication is not very informative, is it?
>
> To debug your failure to close fc, reproduce the conditions before the warning was issued, and call showConnections().
It can help in some cases but in all.
First, to reproduce the exact condition of failure is not always possible. It could
happen after a long calculation and the environment that caused
the failure could evolve meantime. And second, having the list of
connections still does not say which one (or many) has/have failed as
we have only "set[i]" not even the connection number (which in turn
could be not the same between the first failure and a tentative to reproduce it).

Is adding con->description to the warning message problematic in any sens ?

Serguei.


From murdoch.duncan at gmail.com  Mon Jul 10 13:13:13 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Mon, 10 Jul 2017 07:13:13 -0400
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <1631c430-ce0a-ff60-6b22-cdacfc1a80b6@insa-toulouse.fr>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <ba1bb252-8524-ce6d-b0d7-0d66a09789d2@gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
 <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
 <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>
 <ed2899b8-f945-1dad-348a-cee0f8614ba7@insa-toulouse.fr>
 <e8804ff7-473f-3b89-fa65-c1b0d79d85e3@gmail.com>
 <e1cf1c31-2e7c-72cb-453f-68df8321cc3f@insa-toulouse.fr>
 <8ca82104-19ae-a7be-d27f-9f2982b63140@gmail.com>
 <ce8dbd19-c6f1-fcf0-c9af-fccc27eb37c8@insa-toulouse.fr>
 <02239f51-3592-d3f3-5f4a-f479b35b4da9@gmail.com>
 <a5920916-a708-14d3-0e0f-66e5f35f7871@gmail.com>
 <ce5bb61d-0eb4-cc7d-49ec-d43b8de14eab@insa-toulouse.fr>
 <a974c35e-aadb-c9b7-af70-f486e3c24dd2@gmail.com>
 <1631c430-ce0a-ff60-6b22-cdacfc1a80b6@insa-toulouse.fr>
Message-ID: <49f943c9-2e1f-65a5-dcd9-62e9773e57c0@gmail.com>

On 10/07/2017 5:34 AM, Serguei Sokol wrote:
> Le 10/07/2017 ? 11:19, Duncan Murdoch a ?crit :
>> On 10/07/2017 4:54 AM, Serguei Sokol wrote:
>>> Le 08/07/2017 ? 00:54, Duncan Murdoch a ?crit :
>>>> I have now committed changes to R-devel (rev 72898) that seem to catch large and small errors.  They only give a warning if the error happens when the
>>>> connection is closed, because that can happen asynchronously
>>> For this asynchronous behavior, would not it be more useful to have
>>> the name of the file that failed at closing? If many files were open
>>> during a session and not closed explicitly (yes, bad practice but it
>>> can happen), the warning message doesn't help to understand
>>> which of files were corrupted, e.g.:
>>>  > fc=file("/dev/full", "w")
>>>  > write.csv("a", file=fc)
>>>  > q("yes")
>>> Warning message:
>>> In close.connection(getConnection(set[i])) :
>>>    Problem closing connection:  No space left on device
>>>
>>> Having only "set[i]" for indication is not very informative, is it?
>>
>> To debug your failure to close fc, reproduce the conditions before the warning was issued, and call showConnections().
> It can help in some cases but in all.
> First, to reproduce the exact condition of failure is not always possible. It could
> happen after a long calculation and the environment that caused
> the failure could evolve meantime. And second, having the list of
> connections still does not say which one (or many) has/have failed as
> we have only "set[i]" not even the connection number (which in turn
> could be not the same between the first failure and a tentative to reproduce it).
>
> Is adding con->description to the warning message problematic in any sens ?

Yes, we don't know if it is still valid after the connection has been 
closed.  It's just a pointer, whose target is allocated when the 
connection is created, and deallocated when it is closed.  Using it 
after closing could lead to a seg fault.

Duncan


From sokol at insa-toulouse.fr  Mon Jul 10 15:00:08 2017
From: sokol at insa-toulouse.fr (Serguei Sokol)
Date: Mon, 10 Jul 2017 15:00:08 +0200
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <49f943c9-2e1f-65a5-dcd9-62e9773e57c0@gmail.com>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <CA+A1kV5xB3yfD2SnKenrnrfgV6wDObQW8vFMxUVQd2kxTc0BjQ@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
 <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
 <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>
 <ed2899b8-f945-1dad-348a-cee0f8614ba7@insa-toulouse.fr>
 <e8804ff7-473f-3b89-fa65-c1b0d79d85e3@gmail.com>
 <e1cf1c31-2e7c-72cb-453f-68df8321cc3f@insa-toulouse.fr>
 <8ca82104-19ae-a7be-d27f-9f2982b63140@gmail.com>
 <ce8dbd19-c6f1-fcf0-c9af-fccc27eb37c8@insa-toulouse.fr>
 <02239f51-3592-d3f3-5f4a-f479b35b4da9@gmail.com>
 <a5920916-a708-14d3-0e0f-66e5f35f7871@gmail.com>
 <ce5bb61d-0eb4-cc7d-49ec-d43b8de14eab@insa-toulouse.fr>
 <a974c35e-aadb-c9b7-af70-f486e3c24dd2@gmail.com>
 <1631c430-ce0a-ff60-6b22-cdacfc1a80b6@insa-toulouse.fr>
 <49f943c9-2e1f-65a5-dcd9-62e9773e57c0@gmail.com>
Message-ID: <92cd247a-52d7-d862-f5aa-509a62cc46a1@insa-toulouse.fr>

Le 10/07/2017 ? 13:13, Duncan Murdoch a ?crit :
> On 10/07/2017 5:34 AM, Serguei Sokol wrote:
>> Le 10/07/2017 ? 11:19, Duncan Murdoch a ?crit :
>>> On 10/07/2017 4:54 AM, Serguei Sokol wrote:
>>>> Le 08/07/2017 ? 00:54, Duncan Murdoch a ?crit :
>>>>> I have now committed changes to R-devel (rev 72898) that seem to catch large and small errors.  They only give a warning if the error happens when the
>>>>> connection is closed, because that can happen asynchronously
>>>> For this asynchronous behavior, would not it be more useful to have
>>>> the name of the file that failed at closing? If many files were open
>>>> during a session and not closed explicitly (yes, bad practice but it
>>>> can happen), the warning message doesn't help to understand
>>>> which of files were corrupted, e.g.:
>>>>  > fc=file("/dev/full", "w")
>>>>  > write.csv("a", file=fc)
>>>>  > q("yes")
>>>> Warning message:
>>>> In close.connection(getConnection(set[i])) :
>>>>    Problem closing connection:  No space left on device
>>>>
>>>> Having only "set[i]" for indication is not very informative, is it?
>>>
>>> To debug your failure to close fc, reproduce the conditions before the warning was issued, and call showConnections().
>> It can help in some cases but in all.
>> First, to reproduce the exact condition of failure is not always possible. It could
>> happen after a long calculation and the environment that caused
>> the failure could evolve meantime. And second, having the list of
>> connections still does not say which one (or many) has/have failed as
>> we have only "set[i]" not even the connection number (which in turn
>> could be not the same between the first failure and a tentative to reproduce it).
>>
>> Is adding con->description to the warning message problematic in any sens ?
>
> Yes, we don't know if it is still valid after the connection has been closed.  It's just a pointer, whose target is allocated when the connection is created, 
> and deallocated when it is closed. Using it after closing could lead to a seg fault. 
If you mean "free(con->description);" which is in con_close1() at connections.c:3536
it occurs after calling checkClose(). Then logically, con-description is still valid
during generation of warning message.

Serguei.


From murdoch.duncan at gmail.com  Mon Jul 10 18:03:04 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Mon, 10 Jul 2017 12:03:04 -0400
Subject: [Rd] [New Patch] Fix disk corruption when writing
In-Reply-To: <92cd247a-52d7-d862-f5aa-509a62cc46a1@insa-toulouse.fr>
References: <CAPXDfF=770SgtaLoMeaF7XGUfj3wFSU6hUn6ZFrds0VnwG_+zA@mail.gmail.com>
 <1093380f-a632-ce28-af21-a87e1a40a8db@gmail.com>
 <8ede4416-7745-e66c-7d2f-53c04f1a9067@insa-toulouse.fr>
 <fe2b1e03-2f57-820e-6226-217be4184907@insa-toulouse.fr>
 <0783f593-8624-6f3f-7c54-eb3ab2938a48@insa-toulouse.fr>
 <42077a0f-0e88-8400-8310-afaaa5ef6f9e@gmail.com>
 <ed2899b8-f945-1dad-348a-cee0f8614ba7@insa-toulouse.fr>
 <e8804ff7-473f-3b89-fa65-c1b0d79d85e3@gmail.com>
 <e1cf1c31-2e7c-72cb-453f-68df8321cc3f@insa-toulouse.fr>
 <8ca82104-19ae-a7be-d27f-9f2982b63140@gmail.com>
 <ce8dbd19-c6f1-fcf0-c9af-fccc27eb37c8@insa-toulouse.fr>
 <02239f51-3592-d3f3-5f4a-f479b35b4da9@gmail.com>
 <a5920916-a708-14d3-0e0f-66e5f35f7871@gmail.com>
 <ce5bb61d-0eb4-cc7d-49ec-d43b8de14eab@insa-toulouse.fr>
 <a974c35e-aadb-c9b7-af70-f486e3c24dd2@gmail.com>
 <1631c430-ce0a-ff60-6b22-cdacfc1a80b6@insa-toulouse.fr>
 <49f943c9-2e1f-65a5-dcd9-62e9773e57c0@gmail.com>
 <92cd247a-52d7-d862-f5aa-509a62cc46a1@insa-toulouse.fr>
Message-ID: <f75f5dc7-06ae-65ae-b02c-2eea745e101c@gmail.com>

On 10/07/2017 9:00 AM, Serguei Sokol wrote:
> Le 10/07/2017 ? 13:13, Duncan Murdoch a ?crit :
>> On 10/07/2017 5:34 AM, Serguei Sokol wrote:
>>> Le 10/07/2017 ? 11:19, Duncan Murdoch a ?crit :
>>>> On 10/07/2017 4:54 AM, Serguei Sokol wrote:
>>>>> Le 08/07/2017 ? 00:54, Duncan Murdoch a ?crit :
>>>>>> I have now committed changes to R-devel (rev 72898) that seem to catch large and small errors.  They only give a warning if the error happens when the
>>>>>> connection is closed, because that can happen asynchronously
>>>>> For this asynchronous behavior, would not it be more useful to have
>>>>> the name of the file that failed at closing? If many files were open
>>>>> during a session and not closed explicitly (yes, bad practice but it
>>>>> can happen), the warning message doesn't help to understand
>>>>> which of files were corrupted, e.g.:
>>>>>  > fc=file("/dev/full", "w")
>>>>>  > write.csv("a", file=fc)
>>>>>  > q("yes")
>>>>> Warning message:
>>>>> In close.connection(getConnection(set[i])) :
>>>>>    Problem closing connection:  No space left on device
>>>>>
>>>>> Having only "set[i]" for indication is not very informative, is it?
>>>>
>>>> To debug your failure to close fc, reproduce the conditions before the warning was issued, and call showConnections().
>>> It can help in some cases but in all.
>>> First, to reproduce the exact condition of failure is not always possible. It could
>>> happen after a long calculation and the environment that caused
>>> the failure could evolve meantime. And second, having the list of
>>> connections still does not say which one (or many) has/have failed as
>>> we have only "set[i]" not even the connection number (which in turn
>>> could be not the same between the first failure and a tentative to reproduce it).
>>>
>>> Is adding con->description to the warning message problematic in any sens ?
>>
>> Yes, we don't know if it is still valid after the connection has been closed.  It's just a pointer, whose target is allocated when the connection is created,
>> and deallocated when it is closed. Using it after closing could lead to a seg fault.
> If you mean "free(con->description);" which is in con_close1() at connections.c:3536
> it occurs after calling checkClose(). Then logically, con-description is still valid
> during generation of warning message.

No, because we don't know what happened in the con->close() function. 
It may have set the description to NULL.  Or it may have been NULL from 
the beginning.

Obviously this obscure aspect of poor programming behaviour could get a 
better diagnostic message, but it's not worth my time to spend any more 
time on it.  I'd rather spend time on things that actually matter.

Duncan Murdoch


From Michael.Stravs at eawag.ch  Mon Jul 10 19:12:57 2017
From: Michael.Stravs at eawag.ch (Stravs, Michael)
Date: Mon, 10 Jul 2017 17:12:57 +0000
Subject: [Rd] Background session with R
Message-ID: <9DD73F68AC266D4AA329E07B678177B191E37796@EE-MBX3.ee.emp-eaw.ch>

Hi,

I am working on some code to have a background R process running that I can submit data to, check computation progress, and retrieve results later. I am aware that "parallel" does a lot of that - however, "parallel" shuts down the nodes when I quit the master process. On the contrary, I would want these nodes to continue running, so I can fire up R again later and reconnect to the nodes to retrieve the results.

The use case is Shiny apps, where I want a thin frontend as a GUI, workflow launcher and result viewer, and launch background computation that isn't dependent on the Shiny script staying alive.

Has this been done already, and/or are there simple modifications of parallel/snow/etc that allow this? My current WIP thing uses Rserve.

(shiny-discuss cc'd).

Michael Stravs
Eawag
Umweltchemie
BU E 23
?berlandstrasse 133
8600 D?bendorf
+41 58 765 6742


	[[alternative HTML version deleted]]


From csardi.gabor at gmail.com  Mon Jul 10 19:18:05 2017
From: csardi.gabor at gmail.com (=?UTF-8?B?R8OhYm9yIENzw6FyZGk=?=)
Date: Mon, 10 Jul 2017 18:18:05 +0100
Subject: [Rd] Background session with R
In-Reply-To: <9DD73F68AC266D4AA329E07B678177B191E37796@EE-MBX3.ee.emp-eaw.ch>
References: <9DD73F68AC266D4AA329E07B678177B191E37796@EE-MBX3.ee.emp-eaw.ch>
Message-ID: <CABtg=K=MJiDhWb65m28ZwPxUCW_chcpgtcyp53sCVcz5Oj0FrA@mail.gmail.com>

You might find the https://github.com/r-lib/processx package useful.

Also, the dev version of https://github.com/r-lib/callr might be
useful. (The CRAN version of callr does not support background
processes.)

Gabor

On Mon, Jul 10, 2017 at 6:12 PM, Stravs, Michael
<Michael.Stravs at eawag.ch> wrote:
> Hi,
>
> I am working on some code to have a background R process running that I can submit data to, check computation progress, and retrieve results later. I am aware that "parallel" does a lot of that - however, "parallel" shuts down the nodes when I quit the master process. On the contrary, I would want these nodes to continue running, so I can fire up R again later and reconnect to the nodes to retrieve the results.
>
> The use case is Shiny apps, where I want a thin frontend as a GUI, workflow launcher and result viewer, and launch background computation that isn't dependent on the Shiny script staying alive.
>
> Has this been done already, and/or are there simple modifications of parallel/snow/etc that allow this? My current WIP thing uses Rserve.
>
> (shiny-discuss cc'd).
>
> Michael Stravs
> Eawag
> Umweltchemie
> BU E 23
> ?berlandstrasse 133
> 8600 D?bendorf
> +41 58 765 6742
>
>
>         [[alternative HTML version deleted]]
>
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From daniel.schlaepfer at yale.edu  Mon Jul 10 21:37:11 2017
From: daniel.schlaepfer at yale.edu (Schlaepfer, Daniel)
Date: Mon, 10 Jul 2017 19:37:11 +0000
Subject: [Rd] 'do.call' appears to show inconsistent behavior for arguments
 of format "pkg::fun"
Message-ID: <837EA172-E958-4207-9C1C-F1C1F12123DC@yale.edu>

Hi all,

I believe that 'do.call' shows inconsistent/undocumented behavior when its 'what' argument is of the format "pkg::fun". The documentation (?do.call) suggests that
    what: either a function or a non-empty character string naming the function to be called.

Thus, I expected that all four of below formats of the value for the 'what' argument would work, here I use 'utils::person' as an example:
Three formats work:
> do.call(person, list(given = "Jane", family = "Doe"))
> do.call("person", list(given = "Jane", family = "Doe"))
> do.call(utils::person, list(given = "Jane", family = "Doe"))

but the format "pkg::fun" doesn't work as I expected:
> do.call("utils::person", list(given = "Jane", family = "Doe"))
  Error in `utils::person`(given = "Jane", family = "Doe") : 
    could not find function "utils::person"

This seemingly inconsistent behavior of 'do.call' is also exposed when working in parallel and the message doesn't make it easy to see that this error derives actually from 'do.call'.

> library(parallel)
> cl <- makePSOCKcluster(2)

These work
> clusterCall(cl, person, list(given = "Jane", family = "Doe"))
> clusterCall(cl, "person", list(given = "Jane", family = "Doe"))
> clusterCall(cl, utils::person, list(given = "Jane", family = "Doe"))

This doesn't work
> clusterCall(cl, "utils::person", list(given = "Jane", family = "Doe"))
  Error in checkForRemoteErrors(lapply(cl, recvResult)) : 
    2 nodes produced errors; first error: could not find function "utils::person"

This is again not obvious from the documentation (?clusterCall): fun, FUN: function or character string naming a function.

This behavior of 'clusterCall' is because the function 'makePSOCKcluster' calls newPSOCKnode() which calls .slaveRSOCK(), which calls slaveLoop(). This is then waiting and on receving an appropriate message will call 'do.call':
>  value <- tryCatch(do.call(msg$data$fun, msg$data$args, quote = TRUE), error = handler)

Thus, if 'msg$data$fun' (as received from recvData() which was sent via sendData(), via postNote() from function sendCall() wrapped in clusterCall()) is of the type "pkg::fun", then this will fail as above and work otherwise.

## Temporary work-around: re-define function in local namespace and export to workers
> temp_fun <- function(...) utils::person(...)
> clusterExport(cl, "temp_fun")
> clusterCall(cl, "temp_fun", list(given = "Jane", family = "Doe"))

Clean up
> stopCluster(cl)


## Motivation: I learned about this behavior of 'do.call' when attempting to write code such as
> Rmpi::mpi.bcast.cmd(mypackage2::fun, ...)

in my package1. The function Rmpi::mpi.bcast.cmd() calls eventually something along the lines of

> scmd <- scmd <- substitute(cmd)
> arg <- list(...)
> scmd.arg <-serialize(list(scmd=scmd, arg=arg), NULL)
> if (length(scmd.arg$args) > 0)
>    do.call(as.character(scmd.arg$$scmd), scmd.arg$args, envir = .GlobalEnv)

and thus expresses this same inconsistent behavior of do.call. I cannot avoid calling with pkg::fun because a package should not attach another package and change the search path of the user.



## My installation
> sessionInfo()
R version 3.4.1 (2017-06-30)
Platform: x86_64-apple-darwin16.6.0 (64-bit)
Running under: macOS Sierra 10.12.5

Matrix products: default
BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
LAPACK: /opt/local/Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRlapack.dylib

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base

loaded via a namespace (and not attached):
[1] compiler_3.4.1



I would appreciate any help with identifying whether this is indeed inconsistent/undocumented behavior of 'do.call' or whether I am simply missing the point and how to deal with the situation.

Thank you,
Daniel Schlaepfer


From murdoch.duncan at gmail.com  Mon Jul 10 21:51:12 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Mon, 10 Jul 2017 15:51:12 -0400
Subject: [Rd] 'do.call' appears to show inconsistent behavior for
 arguments of format "pkg::fun"
In-Reply-To: <837EA172-E958-4207-9C1C-F1C1F12123DC@yale.edu>
References: <837EA172-E958-4207-9C1C-F1C1F12123DC@yale.edu>
Message-ID: <ca633e0b-a43c-3f55-032a-77387b24ffa8@gmail.com>

On 10/07/2017 3:37 PM, Schlaepfer, Daniel wrote:
> Hi all,
>
> I believe that 'do.call' shows inconsistent/undocumented behavior when its 'what' argument is of the format "pkg::fun". The documentation (?do.call) suggests that
>     what: either a function or a non-empty character string naming the function to be called.

No, it is working just as documented.

>
> Thus, I expected that all four of below formats of the value for the 'what' argument would work, here I use 'utils::person' as an example:
> Three formats work:
>> do.call(person, list(given = "Jane", family = "Doe"))
>> do.call("person", list(given = "Jane", family = "Doe"))
>> do.call(utils::person, list(given = "Jane", family = "Doe"))
>
> but the format "pkg::fun" doesn't work as I expected:
>> do.call("utils::person", list(given = "Jane", family = "Doe"))
>   Error in `utils::person`(given = "Jane", family = "Doe") :
>     could not find function "utils::person"

person and utils::person are both expressions that give a function as 
the value.  "person" and "utils::person" are both expressions that give 
a character string, but "utils::person" is not the name of a function.

It's similar to this:

as.numeric(1)
as.numeric("1")
as.numeric(0+1)
as.numeric("0+1")

The 4th expression is not something that as.numeric knows how to coerce 
to a number.  The rest are expressions that evaluate to 1 or "1", and 
as.numeric() knows how to deal with both of those.


Duncan Murdoch

>
> This seemingly inconsistent behavior of 'do.call' is also exposed when working in parallel and the message doesn't make it easy to see that this error derives actually from 'do.call'.
>
>> library(parallel)
>> cl <- makePSOCKcluster(2)
>
> These work
>> clusterCall(cl, person, list(given = "Jane", family = "Doe"))
>> clusterCall(cl, "person", list(given = "Jane", family = "Doe"))
>> clusterCall(cl, utils::person, list(given = "Jane", family = "Doe"))
>
> This doesn't work
>> clusterCall(cl, "utils::person", list(given = "Jane", family = "Doe"))
>   Error in checkForRemoteErrors(lapply(cl, recvResult)) :
>     2 nodes produced errors; first error: could not find function "utils::person"
>
> This is again not obvious from the documentation (?clusterCall): fun, FUN: function or character string naming a function.
>
> This behavior of 'clusterCall' is because the function 'makePSOCKcluster' calls newPSOCKnode() which calls .slaveRSOCK(), which calls slaveLoop(). This is then waiting and on receving an appropriate message will call 'do.call':
>>  value <- tryCatch(do.call(msg$data$fun, msg$data$args, quote = TRUE), error = handler)
>
> Thus, if 'msg$data$fun' (as received from recvData() which was sent via sendData(), via postNote() from function sendCall() wrapped in clusterCall()) is of the type "pkg::fun", then this will fail as above and work otherwise.
>
> ## Temporary work-around: re-define function in local namespace and export to workers
>> temp_fun <- function(...) utils::person(...)
>> clusterExport(cl, "temp_fun")
>> clusterCall(cl, "temp_fun", list(given = "Jane", family = "Doe"))
>
> Clean up
>> stopCluster(cl)
>
>
> ## Motivation: I learned about this behavior of 'do.call' when attempting to write code such as
>> Rmpi::mpi.bcast.cmd(mypackage2::fun, ...)
>
> in my package1. The function Rmpi::mpi.bcast.cmd() calls eventually something along the lines of
>
>> scmd <- scmd <- substitute(cmd)
>> arg <- list(...)
>> scmd.arg <-serialize(list(scmd=scmd, arg=arg), NULL)
>> if (length(scmd.arg$args) > 0)
>>    do.call(as.character(scmd.arg$$scmd), scmd.arg$args, envir = .GlobalEnv)
>
> and thus expresses this same inconsistent behavior of do.call. I cannot avoid calling with pkg::fun because a package should not attach another package and change the search path of the user.
>
>
>
> ## My installation
>> sessionInfo()
> R version 3.4.1 (2017-06-30)
> Platform: x86_64-apple-darwin16.6.0 (64-bit)
> Running under: macOS Sierra 10.12.5
>
> Matrix products: default
> BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
> LAPACK: /opt/local/Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRlapack.dylib
>
> locale:
> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
>
> attached base packages:
> [1] stats     graphics  grDevices utils     datasets  methods   base
>
> loaded via a namespace (and not attached):
> [1] compiler_3.4.1
>
>
>
> I would appreciate any help with identifying whether this is indeed inconsistent/undocumented behavior of 'do.call' or whether I am simply missing the point and how to deal with the situation.
>
> Thank you,
> Daniel Schlaepfer
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From wdunlap at tibco.com  Mon Jul 10 22:28:43 2017
From: wdunlap at tibco.com (William Dunlap)
Date: Mon, 10 Jul 2017 13:28:43 -0700
Subject: [Rd] 'do.call' appears to show inconsistent behavior for
 arguments of format "pkg::fun"
In-Reply-To: <837EA172-E958-4207-9C1C-F1C1F12123DC@yale.edu>
References: <837EA172-E958-4207-9C1C-F1C1F12123DC@yale.edu>
Message-ID: <CAF8bMcbpfJMTCTS8QG-VP_4-WHefp3e3tini9TxacUkcWnnWsA@mail.gmail.com>

>The function Rmpi::mpi.bcast.cmd() calls eventually something along the
lines of
>
>> scmd <- scmd <- substitute(cmd)
>> arg <- list(...)
>> scmd.arg <-serialize(list(scmd=scmd, arg=arg), NULL)
>> if (length(scmd.arg$args) > 0)
>>    do.call(as.character(scmd.arg$scmd), scmd.arg$args, envir =
.GlobalEnv)

Perhaps you or the maintainer of the Rmpi package should investigate why
that as.character() is needed in the call to do.call().  I suspect it is
not.



Bill Dunlap
TIBCO Software
wdunlap tibco.com

On Mon, Jul 10, 2017 at 12:37 PM, Schlaepfer, Daniel <
daniel.schlaepfer at yale.edu> wrote:

> Hi all,
>
> I believe that 'do.call' shows inconsistent/undocumented behavior when its
> 'what' argument is of the format "pkg::fun". The documentation (?do.call)
> suggests that
>     what: either a function or a non-empty character string naming the
> function to be called.
>
> Thus, I expected that all four of below formats of the value for the
> 'what' argument would work, here I use 'utils::person' as an example:
> Three formats work:
> > do.call(person, list(given = "Jane", family = "Doe"))
> > do.call("person", list(given = "Jane", family = "Doe"))
> > do.call(utils::person, list(given = "Jane", family = "Doe"))
>
> but the format "pkg::fun" doesn't work as I expected:
> > do.call("utils::person", list(given = "Jane", family = "Doe"))
>   Error in `utils::person`(given = "Jane", family = "Doe") :
>     could not find function "utils::person"
>
> This seemingly inconsistent behavior of 'do.call' is also exposed when
> working in parallel and the message doesn't make it easy to see that this
> error derives actually from 'do.call'.
>
> > library(parallel)
> > cl <- makePSOCKcluster(2)
>
> These work
> > clusterCall(cl, person, list(given = "Jane", family = "Doe"))
> > clusterCall(cl, "person", list(given = "Jane", family = "Doe"))
> > clusterCall(cl, utils::person, list(given = "Jane", family = "Doe"))
>
> This doesn't work
> > clusterCall(cl, "utils::person", list(given = "Jane", family = "Doe"))
>   Error in checkForRemoteErrors(lapply(cl, recvResult)) :
>     2 nodes produced errors; first error: could not find function
> "utils::person"
>
> This is again not obvious from the documentation (?clusterCall): fun, FUN:
> function or character string naming a function.
>
> This behavior of 'clusterCall' is because the function 'makePSOCKcluster'
> calls newPSOCKnode() which calls .slaveRSOCK(), which calls slaveLoop().
> This is then waiting and on receving an appropriate message will call
> 'do.call':
> >  value <- tryCatch(do.call(msg$data$fun, msg$data$args, quote = TRUE),
> error = handler)
>
> Thus, if 'msg$data$fun' (as received from recvData() which was sent via
> sendData(), via postNote() from function sendCall() wrapped in
> clusterCall()) is of the type "pkg::fun", then this will fail as above and
> work otherwise.
>
> ## Temporary work-around: re-define function in local namespace and export
> to workers
> > temp_fun <- function(...) utils::person(...)
> > clusterExport(cl, "temp_fun")
> > clusterCall(cl, "temp_fun", list(given = "Jane", family = "Doe"))
>
> Clean up
> > stopCluster(cl)
>
>
> ## Motivation: I learned about this behavior of 'do.call' when attempting
> to write code such as
> > Rmpi::mpi.bcast.cmd(mypackage2::fun, ...)
>
> in my package1. The function Rmpi::mpi.bcast.cmd() calls eventually
> something along the lines of
>
> > scmd <- scmd <- substitute(cmd)
> > arg <- list(...)
> > scmd.arg <-serialize(list(scmd=scmd, arg=arg), NULL)
> > if (length(scmd.arg$args) > 0)
> >    do.call(as.character(scmd.arg$$scmd), scmd.arg$args, envir =
> .GlobalEnv)
>
> and thus expresses this same inconsistent behavior of do.call. I cannot
> avoid calling with pkg::fun because a package should not attach another
> package and change the search path of the user.
>
>
>
> ## My installation
> > sessionInfo()
> R version 3.4.1 (2017-06-30)
> Platform: x86_64-apple-darwin16.6.0 (64-bit)
> Running under: macOS Sierra 10.12.5
>
> Matrix products: default
> BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/
> A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
> LAPACK: /opt/local/Library/Frameworks/R.framework/Versions/3.4/
> Resources/lib/libRlapack.dylib
>
> locale:
> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
>
> attached base packages:
> [1] stats     graphics  grDevices utils     datasets  methods   base
>
> loaded via a namespace (and not attached):
> [1] compiler_3.4.1
>
>
>
> I would appreciate any help with identifying whether this is indeed
> inconsistent/undocumented behavior of 'do.call' or whether I am simply
> missing the point and how to deal with the situation.
>
> Thank you,
> Daniel Schlaepfer
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From nsosnov at microsoft.com  Tue Jul 11 00:59:20 2017
From: nsosnov at microsoft.com (Nathan Sosnovske)
Date: Mon, 10 Jul 2017 22:59:20 +0000
Subject: [Rd] write.csv
In-Reply-To: <SN1PR21MB0061BBA34200B3F6609F2536B7D70@SN1PR21MB0061.namprd21.prod.outlook.com>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
 <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
 <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
 <f74dd537-cc00-50aa-0f33-c097aa08914a@gmail.com>
 <CAD6tx94WZzdeQXHFN=dkT+K7ZU6V-McRWM9tjU74hzG=KpRUEw@mail.gmail.com>
 <d989fa4d-9e88-b60e-2a34-1657acee774b@gmail.com>
 <SN1PR21MB0061BBA34200B3F6609F2536B7D70@SN1PR21MB0061.namprd21.prod.outlook.com>
Message-ID: <SN1PR21MB00616252B6FB957B3BABD887B7A90@SN1PR21MB0061.namprd21.prod.outlook.com>

As a follow up to this, Martin Maechler suggested that I write a small script that allows this to be tested on Windows from R. The attached script demonstrates creating and mounting a very small (4 MiB) VHD to a path on the system (in this case c:/smallmount) and then calling write.csv with a large dataframe to the newly mounted path.

The method I attached has two limitations. 

1) It will only work if run as administrator. This is a limitation of the OS. 
2) It will only work on Windows 8.1/Server 2012R2 or higher, as it uses powershell commands that only exist on those operating systems. I believe it could be made to work on Windows 7, but it would need to be written using the windows C apis at that point.

If a regression test is created for this issue I would be more than happy to integrate this method into that if there is interest and if it would work in the environment where automated builds/tests for windows are run.

-----Original Message-----
From: Nathan Sosnovske 
Sent: Tuesday, July 4, 2017 8:02 AM
To: 'Duncan Murdoch' <murdoch.duncan at gmail.com>; Jim Hester <james.f.hester at gmail.com>
Cc: r-devel at r-project.org; Lipatz Jean-Luc <jean-luc.lipatz at insee.fr>
Subject: RE: [Rd] write.csv

The best way to test on Windows would probably be creating a small virtual hard disk (via CreateVirtualDisk), mounting it, and writing to the mounted location. I believe the drive could even be mounted to an arbitrary location on the filesystem (instead of a drive letter) so that drive letter conflicts don't come into play.

-----Original Message-----
From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of Duncan Murdoch
Sent: Tuesday, July 4, 2017 7:53 AM
To: Jim Hester <james.f.hester at gmail.com>
Cc: r-devel at r-project.org; Lipatz Jean-Luc <jean-luc.lipatz at insee.fr>
Subject: Re: [Rd] write.csv

On 04/07/2017 10:01 AM, Jim Hester wrote:
> On linux at least you can use `/dev/full` [1] to test writing to a full device.
>
>     > echo 'foo' > /dev/full
>     bash: echo: write error: No space left on device

Unfortunately, I get a permission denied error if I try to write there from MacOS.  I don't know if Windows has an equivalent.

I've taken a look at the code.  Essentially it comes down to a call to the C function vfprintf, which is supposed to return the number of bytes written, or a negative value for an error. This return value is often not checked; in particular, write.table and friends don't check it.

I'll add code to signal an error if there's a negative value.

I don't think it's feasible to check the number of bytes (formatted text with possible translation to a different encoding could have any number of bytes) if it's positive.  So hopefully all of our file systems will correctly signal an error, and not just report how many bytes were successfully written.

>
> Although that won't be a perfect test for this case where part of the 
> file is written successfully.
>
> An alternative suggestion for testing this is to create and mount a 
> loop device [2] with a small file.
>
> [1]: 
> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fen.wi
> kipedia.org%2Fwiki%2F%2Fdev%2Ffull&data=02%7C01%7Cnsosnov%40microsoft.
> com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd011d
> b47%7C1%7C0%7C636347767773809248&sdata=Cb2oduozc2IDCLvXZGG1C4i4hQA7FPs
> 5jHmnFYbk7zQ%3D&reserved=0
> [2]: 
> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstack
> overflow.com%2Fa%2F16044420%2F2055486&data=02%7C01%7Cnsosnov%40microso
> ft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd0
> 11db47%7C1%7C0%7C636347767773809248&sdata=%2BWPfqD0nUS%2F30DUNDqQU79lR
> EJh02ZX0yik9HXiY5kg%3D&reserved=0

Loop devices sound ideal, but seem to be Linux-only (at least with that recipe).

Duncan


>
> On Tue, Jul 4, 2017 at 3:38 PM, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>> On 04/07/2017 8:40 AM, Lipatz Jean-Luc wrote:
>>>
>>> I would really like the bug fixed. At least this one, because I know 
>>> people in my institute using this function.
>>> I understand your arguments about open source, but I also saw in 
>>> this mail list a proposal for a fix for this bug for which there 
>>> were no answer from the people who are able to include it in the 
>>> distribution. It looks like if there were interesting bugs and the other ones.
>>
>>
>> Please post a link to that, and I'll look.  Bug reports should be 
>> posted to the bug list.  It's unfortunate that it is currently so 
>> difficult to do so, but if they are only posted here, they are often overlooked.
>>
>>> I don't understand the other arguments : the example was reproduced 
>>> with a simple USB key and you cannot state that a disk will 
>>> eternally be empty enough, specially when it has several users.
>>
>>
>> I am not denying that it's a bug, I'm just saying that it is a 
>> difficult one to test automatically (so we probably won't add a 
>> regression test once it's fixed), and it's not one that has been 
>> reported often.  I didn't know there were any reports before yours.
>>
>> Duncan Murdoch
>>
>>
>>> JLL
>>>
>>>
>>> -----Message d'origine-----
>>> De : Duncan Murdoch [mailto:murdoch.duncan at gmail.com] Envoy? : mardi
>>> 4 juillet 2017 14:24 ? : Lipatz Jean-Luc; r-devel at r-project.org 
>>> Objet : Re: [Rd] write.csv
>>>
>>> On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
>>>>
>>>> Hi all,
>>>>
>>>> I am currently studying how to generalize the usage of R in my 
>>>> statistical institute and I encountered a problem that I cannot 
>>>> declare on bugzilla (cannot understand why).
>>>
>>>
>>> Bugzilla was badly abused by spammers last year, so you need to have 
>>> your account created manually by one of the admins to post there.
>>> Write to me privately if you'd like me to create an account for you.  
>>> (If you want it attached to a different email address, that's fine.)
>>>
>>> Sorry for trying this mailing list but I am really worried about the 
>>> problem itself and the possible implications in using R in a 
>>> professionnal data production context.
>>>>
>>>> The issue about 'write.csv' is that it just doesn't check if there 
>>>> is enough space on disk and doesn't report failure to write data.
>>>>
>>>> Example (R 3.4.0 windows 32 bits, but I reproduced the problem with 
>>>> older versions and under Mac OS/X)
>>>>
>>>>> fwrite(as.list(1:1000000),"G:/Test")
>>>>
>>>> Error in fwrite(as.list(1:1e+06), "G:/Test") :
>>>>   No space left on device: 'G:/Test'
>>>>>
>>>>> write.csv(1:1000000,"G:/Test")
>>>>>
>>>>
>>>> I have a big concern here, because it means that you could save 
>>>> some important data at one point of time and discover a long time 
>>>> after that you actually lost them.
>>>
>>>  > I suppose that the fix is relatively straightforward, but how can 
>>> we be sure that there is no another function with the same bad properties?
>>>
>>> R is open source.  You could work out the patch for this bug, and in 
>>> the process see the pattern of coding that leads to it.  Then you'll 
>>> know if other functions use the same buggy pattern.
>>>
>>>> Is the lesson that you should not use a R function, even from the 
>>>> core, without having personnally tested it against extreme conditions?
>>>
>>>
>>> I think the answer to that is yes.  Most people never write such big 
>>> files that they fill their disk:  if they did, all sorts of things 
>>> would go wrong on their systems.  So this kind of extreme condition 
>>> isn't often tested.  It's not easy to test in a platform independent
>>> way:  R would need to be able to create a volume with a small 
>>> capacity.  That's a very system-dependent thing to do.
>>>
>>>> And wouldn't it be the work of the developpers to do such 
>>>> elementary tests?
>>>
>>>
>>> Again, R is open source.  You can and should contribute code (and 
>>> therefore become one of the developers) if you are working in 
>>> unusual conditions.
>>>
>>> R states quite clearly in the welcome message every time it starts: 
>>> "R is free software and comes with ABSOLUTELY NO WARRANTY."  This is 
>>> essentially the same lack of warranty that you get with commercial 
>>> software, though it's stated a lot more clearly.
>>>
>>> Duncan Murdoch
>>>
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat
>> .ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40micr
>> osoft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d
>> 7cd011db47%7C1%7C0%7C636347767773809248&sdata=zMU5Ua2gL3fVPc%2FOPhfdc
>> iAdoHzwDyaRnKusZCnXqWo%3D&reserved=0

______________________________________________
R-devel at r-project.org mailing list
https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40microsoft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636347767773809248&sdata=zMU5Ua2gL3fVPc%2FOPhfdciAdoHzwDyaRnKusZCnXqWo%3D&reserved=0

From ligges at statistik.tu-dortmund.de  Tue Jul 11 14:08:48 2017
From: ligges at statistik.tu-dortmund.de (Uwe Ligges)
Date: Tue, 11 Jul 2017 14:08:48 +0200
Subject: [Rd] write.csv
In-Reply-To: <SN1PR21MB00616252B6FB957B3BABD887B7A90@SN1PR21MB0061.namprd21.prod.outlook.com>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
 <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
 <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
 <f74dd537-cc00-50aa-0f33-c097aa08914a@gmail.com>
 <CAD6tx94WZzdeQXHFN=dkT+K7ZU6V-McRWM9tjU74hzG=KpRUEw@mail.gmail.com>
 <d989fa4d-9e88-b60e-2a34-1657acee774b@gmail.com>
 <SN1PR21MB0061BBA34200B3F6609F2536B7D70@SN1PR21MB0061.namprd21.prod.outlook.com>
 <SN1PR21MB00616252B6FB957B3BABD887B7A90@SN1PR21MB0061.namprd21.prod.outlook.com>
Message-ID: <3cb3d0c5-d776-0eea-954c-1197d0b29dd9@statistik.tu-dortmund.de>

This is a bit difficult:

R binaries (both for R base and R packages) are still built with Windows 
Server 2008 and my desktop machine is Windows 7, hence at least 
currently such a check would not get executed on the machines R core / 
CRAN use ...

Best,
Uwe

On 11.07.2017 00:59, Nathan Sosnovske via R-devel wrote:
> As a follow up to this, Martin Maechler suggested that I write a small script that allows this to be tested on Windows from R. The attached script demonstrates creating and mounting a very small (4 MiB) VHD to a path on the system (in this case c:/smallmount) and then calling write.csv with a large dataframe to the newly mounted path.
> 
> The method I attached has two limitations.
> 
> 1) It will only work if run as administrator. This is a limitation of the OS.
> 2) It will only work on Windows 8.1/Server 2012R2 or higher, as it uses powershell commands that only exist on those operating systems. I believe it could be made to work on Windows 7, but it would need to be written using the windows C apis at that point.
> 
> If a regression test is created for this issue I would be more than happy to integrate this method into that if there is interest and if it would work in the environment where automated builds/tests for windows are run.
> 
> -----Original Message-----
> From: Nathan Sosnovske
> Sent: Tuesday, July 4, 2017 8:02 AM
> To: 'Duncan Murdoch' <murdoch.duncan at gmail.com>; Jim Hester <james.f.hester at gmail.com>
> Cc: r-devel at r-project.org; Lipatz Jean-Luc <jean-luc.lipatz at insee.fr>
> Subject: RE: [Rd] write.csv
> 
> The best way to test on Windows would probably be creating a small virtual hard disk (via CreateVirtualDisk), mounting it, and writing to the mounted location. I believe the drive could even be mounted to an arbitrary location on the filesystem (instead of a drive letter) so that drive letter conflicts don't come into play.
> 
> -----Original Message-----
> From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of Duncan Murdoch
> Sent: Tuesday, July 4, 2017 7:53 AM
> To: Jim Hester <james.f.hester at gmail.com>
> Cc: r-devel at r-project.org; Lipatz Jean-Luc <jean-luc.lipatz at insee.fr>
> Subject: Re: [Rd] write.csv
> 
> On 04/07/2017 10:01 AM, Jim Hester wrote:
>> On linux at least you can use `/dev/full` [1] to test writing to a full device.
>>
>>      > echo 'foo' > /dev/full
>>      bash: echo: write error: No space left on device
> 
> Unfortunately, I get a permission denied error if I try to write there from MacOS.  I don't know if Windows has an equivalent.
> 
> I've taken a look at the code.  Essentially it comes down to a call to the C function vfprintf, which is supposed to return the number of bytes written, or a negative value for an error. This return value is often not checked; in particular, write.table and friends don't check it.
> 
> I'll add code to signal an error if there's a negative value.
> 
> I don't think it's feasible to check the number of bytes (formatted text with possible translation to a different encoding could have any number of bytes) if it's positive.  So hopefully all of our file systems will correctly signal an error, and not just report how many bytes were successfully written.
> 
>>
>> Although that won't be a perfect test for this case where part of the
>> file is written successfully.
>>
>> An alternative suggestion for testing this is to create and mount a
>> loop device [2] with a small file.
>>
>> [1]:
>> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fen.wi
>> kipedia.org%2Fwiki%2F%2Fdev%2Ffull&data=02%7C01%7Cnsosnov%40microsoft.
>> com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd011d
>> b47%7C1%7C0%7C636347767773809248&sdata=Cb2oduozc2IDCLvXZGG1C4i4hQA7FPs
>> 5jHmnFYbk7zQ%3D&reserved=0
>> [2]:
>> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstack
>> overflow.com%2Fa%2F16044420%2F2055486&data=02%7C01%7Cnsosnov%40microso
>> ft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd0
>> 11db47%7C1%7C0%7C636347767773809248&sdata=%2BWPfqD0nUS%2F30DUNDqQU79lR
>> EJh02ZX0yik9HXiY5kg%3D&reserved=0
> 
> Loop devices sound ideal, but seem to be Linux-only (at least with that recipe).
> 
> Duncan
> 
> 
>>
>> On Tue, Jul 4, 2017 at 3:38 PM, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>> On 04/07/2017 8:40 AM, Lipatz Jean-Luc wrote:
>>>>
>>>> I would really like the bug fixed. At least this one, because I know
>>>> people in my institute using this function.
>>>> I understand your arguments about open source, but I also saw in
>>>> this mail list a proposal for a fix for this bug for which there
>>>> were no answer from the people who are able to include it in the
>>>> distribution. It looks like if there were interesting bugs and the other ones.
>>>
>>>
>>> Please post a link to that, and I'll look.  Bug reports should be
>>> posted to the bug list.  It's unfortunate that it is currently so
>>> difficult to do so, but if they are only posted here, they are often overlooked.
>>>
>>>> I don't understand the other arguments : the example was reproduced
>>>> with a simple USB key and you cannot state that a disk will
>>>> eternally be empty enough, specially when it has several users.
>>>
>>>
>>> I am not denying that it's a bug, I'm just saying that it is a
>>> difficult one to test automatically (so we probably won't add a
>>> regression test once it's fixed), and it's not one that has been
>>> reported often.  I didn't know there were any reports before yours.
>>>
>>> Duncan Murdoch
>>>
>>>
>>>> JLL
>>>>
>>>>
>>>> -----Message d'origine-----
>>>> De : Duncan Murdoch [mailto:murdoch.duncan at gmail.com] Envoy? : mardi
>>>> 4 juillet 2017 14:24 ? : Lipatz Jean-Luc; r-devel at r-project.org
>>>> Objet : Re: [Rd] write.csv
>>>>
>>>> On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
>>>>>
>>>>> Hi all,
>>>>>
>>>>> I am currently studying how to generalize the usage of R in my
>>>>> statistical institute and I encountered a problem that I cannot
>>>>> declare on bugzilla (cannot understand why).
>>>>
>>>>
>>>> Bugzilla was badly abused by spammers last year, so you need to have
>>>> your account created manually by one of the admins to post there.
>>>> Write to me privately if you'd like me to create an account for you.
>>>> (If you want it attached to a different email address, that's fine.)
>>>>
>>>> Sorry for trying this mailing list but I am really worried about the
>>>> problem itself and the possible implications in using R in a
>>>> professionnal data production context.
>>>>>
>>>>> The issue about 'write.csv' is that it just doesn't check if there
>>>>> is enough space on disk and doesn't report failure to write data.
>>>>>
>>>>> Example (R 3.4.0 windows 32 bits, but I reproduced the problem with
>>>>> older versions and under Mac OS/X)
>>>>>
>>>>>> fwrite(as.list(1:1000000),"G:/Test")
>>>>>
>>>>> Error in fwrite(as.list(1:1e+06), "G:/Test") :
>>>>>    No space left on device: 'G:/Test'
>>>>>>
>>>>>> write.csv(1:1000000,"G:/Test")
>>>>>>
>>>>>
>>>>> I have a big concern here, because it means that you could save
>>>>> some important data at one point of time and discover a long time
>>>>> after that you actually lost them.
>>>>
>>>>   > I suppose that the fix is relatively straightforward, but how can
>>>> we be sure that there is no another function with the same bad properties?
>>>>
>>>> R is open source.  You could work out the patch for this bug, and in
>>>> the process see the pattern of coding that leads to it.  Then you'll
>>>> know if other functions use the same buggy pattern.
>>>>
>>>>> Is the lesson that you should not use a R function, even from the
>>>>> core, without having personnally tested it against extreme conditions?
>>>>
>>>>
>>>> I think the answer to that is yes.  Most people never write such big
>>>> files that they fill their disk:  if they did, all sorts of things
>>>> would go wrong on their systems.  So this kind of extreme condition
>>>> isn't often tested.  It's not easy to test in a platform independent
>>>> way:  R would need to be able to create a volume with a small
>>>> capacity.  That's a very system-dependent thing to do.
>>>>
>>>>> And wouldn't it be the work of the developpers to do such
>>>>> elementary tests?
>>>>
>>>>
>>>> Again, R is open source.  You can and should contribute code (and
>>>> therefore become one of the developers) if you are working in
>>>> unusual conditions.
>>>>
>>>> R states quite clearly in the welcome message every time it starts:
>>>> "R is free software and comes with ABSOLUTELY NO WARRANTY."  This is
>>>> essentially the same lack of warranty that you get with commercial
>>>> software, though it's stated a lot more clearly.
>>>>
>>>> Duncan Murdoch
>>>>
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat
>>> .ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40micr
>>> osoft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d
>>> 7cd011db47%7C1%7C0%7C636347767773809248&sdata=zMU5Ua2gL3fVPc%2FOPhfdc
>>> iAdoHzwDyaRnKusZCnXqWo%3D&reserved=0
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40microsoft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636347767773809248&sdata=zMU5Ua2gL3fVPc%2FOPhfdciAdoHzwDyaRnKusZCnXqWo%3D&reserved=0
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From avraham.adler at gmail.com  Tue Jul 11 17:48:08 2017
From: avraham.adler at gmail.com (Avraham Adler)
Date: Tue, 11 Jul 2017 11:48:08 -0400
Subject: [Rd] Solaris SPARC testbed
Message-ID: <CAL6gwn+UK+rUr-Kf6wrHD0EkFYCF8ooY4txgkfN8RUmUoFDMbw@mail.gmail.com>

I've looked at some package testing results and I'm not seeing Solaris
SPARC. Has that test-bed been deprecated for package testing?

Thanks,

Avi


From ripley at stats.ox.ac.uk  Tue Jul 11 19:04:04 2017
From: ripley at stats.ox.ac.uk (Prof Brian Ripley)
Date: Tue, 11 Jul 2017 18:04:04 +0100
Subject: [Rd] Solaris SPARC testbed
In-Reply-To: <CAL6gwn+UK+rUr-Kf6wrHD0EkFYCF8ooY4txgkfN8RUmUoFDMbw@mail.gmail.com>
References: <CAL6gwn+UK+rUr-Kf6wrHD0EkFYCF8ooY4txgkfN8RUmUoFDMbw@mail.gmail.com>
Message-ID: <c8907b3f-e120-2746-e279-a7d0bf0939b7@stats.ox.ac.uk>

On 11/07/2017 16:48, Avraham Adler wrote:
> I've looked at some package testing results and I'm not seeing Solaris
> SPARC. Has that test-bed been deprecated for package testing?

Are you talking about CRAN's check results?

The Sparc hardware used for CRAN died during an unplanned power outage, 
and it seems unlikely it can be resurrected.

But questions about CRAN should be sent to CRAN, and you should give 
credit where it is due if you discuss such services in public fora.

-- 
Brian D. Ripley,                  ripley at stats.ox.ac.uk
Emeritus Professor of Applied Statistics, University of Oxford


From nsmatloff at ucdavis.edu  Tue Jul 11 20:16:15 2017
From: nsmatloff at ucdavis.edu (Norm Matloff)
Date: Tue, 11 Jul 2017 11:16:15 -0700
Subject: [Rd] Background session with R
Message-ID: <20170711181615.GA24916@laura>

My Rdsm package will do what you want, 

https://cran.r-project.org/web/packages/Rdsm/index.html

Norm Matloff

> Message: 4
> Date: Mon, 10 Jul 2017 17:12:57 +0000
> From: "Stravs, Michael" <Michael.Stravs at eawag.ch>
> To: "r-devel at r-project.org" <r-devel at r-project.org>
> Cc: "shiny-discuss at googlegroups.com" <shiny-discuss at googlegroups.com>
> Subject: [Rd] Background session with R
> Message-ID:
> 	<9DD73F68AC266D4AA329E07B678177B191E37796 at EE-MBX3.ee.emp-eaw.ch>
> Content-Type: text/plain; charset="UTF-8"
> 
> Hi,
> 
> I am working on some code to have a background R process running that I can submit data to, check computation progress, and retrieve results later. I am aware that "parallel" does a lot of that - however, "parallel" shuts down the nodes when I quit the master process. On the contrary, I would want these nodes to continue running, so I can fire up R again later and reconnect to the nodes to retrieve the results.
> 
> The use case is Shiny apps, where I want a thin frontend as a GUI, workflow launcher and result viewer, and launch background computation that isn't dependent on the Shiny script staying alive.
> 
> Has this been done already, and/or are there simple modifications of parallel/snow/etc that allow this? My current WIP thing uses Rserve.
> 
> (shiny-discuss cc'd).
> 
> Michael Stravs
> Eawag
> Umweltchemie
> BU E 23
> ?berlandstrasse 133
> 8600 D?bendorf
> +41 58 765 6742


From nsosnov at microsoft.com  Wed Jul 12 05:09:57 2017
From: nsosnov at microsoft.com (Nathan Sosnovske)
Date: Wed, 12 Jul 2017 03:09:57 +0000
Subject: [Rd] write.csv
In-Reply-To: <3cb3d0c5-d776-0eea-954c-1197d0b29dd9@statistik.tu-dortmund.de>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
 <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
 <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
 <f74dd537-cc00-50aa-0f33-c097aa08914a@gmail.com>
 <CAD6tx94WZzdeQXHFN=dkT+K7ZU6V-McRWM9tjU74hzG=KpRUEw@mail.gmail.com>
 <d989fa4d-9e88-b60e-2a34-1657acee774b@gmail.com>
 <SN1PR21MB0061BBA34200B3F6609F2536B7D70@SN1PR21MB0061.namprd21.prod.outlook.com>
 <SN1PR21MB00616252B6FB957B3BABD887B7A90@SN1PR21MB0061.namprd21.prod.outlook.com>
 <3cb3d0c5-d776-0eea-954c-1197d0b29dd9@statistik.tu-dortmund.de>
Message-ID: <SN1PR21MB006107CA7C3A67122C34606BB7AF0@SN1PR21MB0061.namprd21.prod.outlook.com>

Two thoughts:

1) Will the new server that you are setting up with Server 2016 eventually host build and test? If so, this could at least run on that.
2) CreateVirtualDisk and OpenVirtualDisk are C functions that are available in Windows 7 and Server 2008 R2. So these are options that we could use, but it would require creating a small program to drive creation/mounting/deletion of the disk and compiling it at build time.

Nathan

-----Original Message-----
From: Uwe Ligges [mailto:ligges at statistik.tu-dortmund.de] 
Sent: Tuesday, July 11, 2017 5:09 AM
To: Nathan Sosnovske <nsosnov at microsoft.com>; Duncan Murdoch <murdoch.duncan at gmail.com>; Jim Hester <james.f.hester at gmail.com>
Cc: r-devel at r-project.org; Lipatz Jean-Luc <jean-luc.lipatz at insee.fr>
Subject: Re: [Rd] write.csv

This is a bit difficult:

R binaries (both for R base and R packages) are still built with Windows Server 2008 and my desktop machine is Windows 7, hence at least currently such a check would not get executed on the machines R core / CRAN use ...

Best,
Uwe

On 11.07.2017 00:59, Nathan Sosnovske via R-devel wrote:
> As a follow up to this, Martin Maechler suggested that I write a small script that allows this to be tested on Windows from R. The attached script demonstrates creating and mounting a very small (4 MiB) VHD to a path on the system (in this case c:/smallmount) and then calling write.csv with a large dataframe to the newly mounted path.
> 
> The method I attached has two limitations.
> 
> 1) It will only work if run as administrator. This is a limitation of the OS.
> 2) It will only work on Windows 8.1/Server 2012R2 or higher, as it uses powershell commands that only exist on those operating systems. I believe it could be made to work on Windows 7, but it would need to be written using the windows C apis at that point.
> 
> If a regression test is created for this issue I would be more than happy to integrate this method into that if there is interest and if it would work in the environment where automated builds/tests for windows are run.
> 
> -----Original Message-----
> From: Nathan Sosnovske
> Sent: Tuesday, July 4, 2017 8:02 AM
> To: 'Duncan Murdoch' <murdoch.duncan at gmail.com>; Jim Hester 
> <james.f.hester at gmail.com>
> Cc: r-devel at r-project.org; Lipatz Jean-Luc <jean-luc.lipatz at insee.fr>
> Subject: RE: [Rd] write.csv
> 
> The best way to test on Windows would probably be creating a small virtual hard disk (via CreateVirtualDisk), mounting it, and writing to the mounted location. I believe the drive could even be mounted to an arbitrary location on the filesystem (instead of a drive letter) so that drive letter conflicts don't come into play.
> 
> -----Original Message-----
> From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of 
> Duncan Murdoch
> Sent: Tuesday, July 4, 2017 7:53 AM
> To: Jim Hester <james.f.hester at gmail.com>
> Cc: r-devel at r-project.org; Lipatz Jean-Luc <jean-luc.lipatz at insee.fr>
> Subject: Re: [Rd] write.csv
> 
> On 04/07/2017 10:01 AM, Jim Hester wrote:
>> On linux at least you can use `/dev/full` [1] to test writing to a full device.
>>
>>      > echo 'foo' > /dev/full
>>      bash: echo: write error: No space left on device
> 
> Unfortunately, I get a permission denied error if I try to write there from MacOS.  I don't know if Windows has an equivalent.
> 
> I've taken a look at the code.  Essentially it comes down to a call to the C function vfprintf, which is supposed to return the number of bytes written, or a negative value for an error. This return value is often not checked; in particular, write.table and friends don't check it.
> 
> I'll add code to signal an error if there's a negative value.
> 
> I don't think it's feasible to check the number of bytes (formatted text with possible translation to a different encoding could have any number of bytes) if it's positive.  So hopefully all of our file systems will correctly signal an error, and not just report how many bytes were successfully written.
> 
>>
>> Although that won't be a perfect test for this case where part of the 
>> file is written successfully.
>>
>> An alternative suggestion for testing this is to create and mount a 
>> loop device [2] with a small file.
>>
>> [1]:
>> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fen.w
>> i 
>> kipedia.org%2Fwiki%2F%2Fdev%2Ffull&data=02%7C01%7Cnsosnov%40microsoft.
>> com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd011
>> d 
>> b47%7C1%7C0%7C636347767773809248&sdata=Cb2oduozc2IDCLvXZGG1C4i4hQA7FP
>> s
>> 5jHmnFYbk7zQ%3D&reserved=0
>> [2]:
>> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstac
>> k 
>> overflow.com%2Fa%2F16044420%2F2055486&data=02%7C01%7Cnsosnov%40micros
>> o
>> ft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd
>> 0 
>> 11db47%7C1%7C0%7C636347767773809248&sdata=%2BWPfqD0nUS%2F30DUNDqQU79l
>> R
>> EJh02ZX0yik9HXiY5kg%3D&reserved=0
> 
> Loop devices sound ideal, but seem to be Linux-only (at least with that recipe).
> 
> Duncan
> 
> 
>>
>> On Tue, Jul 4, 2017 at 3:38 PM, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>> On 04/07/2017 8:40 AM, Lipatz Jean-Luc wrote:
>>>>
>>>> I would really like the bug fixed. At least this one, because I 
>>>> know people in my institute using this function.
>>>> I understand your arguments about open source, but I also saw in 
>>>> this mail list a proposal for a fix for this bug for which there 
>>>> were no answer from the people who are able to include it in the 
>>>> distribution. It looks like if there were interesting bugs and the other ones.
>>>
>>>
>>> Please post a link to that, and I'll look.  Bug reports should be 
>>> posted to the bug list.  It's unfortunate that it is currently so 
>>> difficult to do so, but if they are only posted here, they are often overlooked.
>>>
>>>> I don't understand the other arguments : the example was reproduced 
>>>> with a simple USB key and you cannot state that a disk will 
>>>> eternally be empty enough, specially when it has several users.
>>>
>>>
>>> I am not denying that it's a bug, I'm just saying that it is a 
>>> difficult one to test automatically (so we probably won't add a 
>>> regression test once it's fixed), and it's not one that has been 
>>> reported often.  I didn't know there were any reports before yours.
>>>
>>> Duncan Murdoch
>>>
>>>
>>>> JLL
>>>>
>>>>
>>>> -----Message d'origine-----
>>>> De : Duncan Murdoch [mailto:murdoch.duncan at gmail.com] Envoy? : 
>>>> mardi
>>>> 4 juillet 2017 14:24 ? : Lipatz Jean-Luc; r-devel at r-project.org 
>>>> Objet : Re: [Rd] write.csv
>>>>
>>>> On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
>>>>>
>>>>> Hi all,
>>>>>
>>>>> I am currently studying how to generalize the usage of R in my 
>>>>> statistical institute and I encountered a problem that I cannot 
>>>>> declare on bugzilla (cannot understand why).
>>>>
>>>>
>>>> Bugzilla was badly abused by spammers last year, so you need to 
>>>> have your account created manually by one of the admins to post there.
>>>> Write to me privately if you'd like me to create an account for you.
>>>> (If you want it attached to a different email address, that's 
>>>> fine.)
>>>>
>>>> Sorry for trying this mailing list but I am really worried about 
>>>> the problem itself and the possible implications in using R in a 
>>>> professionnal data production context.
>>>>>
>>>>> The issue about 'write.csv' is that it just doesn't check if there 
>>>>> is enough space on disk and doesn't report failure to write data.
>>>>>
>>>>> Example (R 3.4.0 windows 32 bits, but I reproduced the problem 
>>>>> with older versions and under Mac OS/X)
>>>>>
>>>>>> fwrite(as.list(1:1000000),"G:/Test")
>>>>>
>>>>> Error in fwrite(as.list(1:1e+06), "G:/Test") :
>>>>>    No space left on device: 'G:/Test'
>>>>>>
>>>>>> write.csv(1:1000000,"G:/Test")
>>>>>>
>>>>>
>>>>> I have a big concern here, because it means that you could save 
>>>>> some important data at one point of time and discover a long time 
>>>>> after that you actually lost them.
>>>>
>>>>   > I suppose that the fix is relatively straightforward, but how 
>>>> can we be sure that there is no another function with the same bad properties?
>>>>
>>>> R is open source.  You could work out the patch for this bug, and 
>>>> in the process see the pattern of coding that leads to it.  Then 
>>>> you'll know if other functions use the same buggy pattern.
>>>>
>>>>> Is the lesson that you should not use a R function, even from the 
>>>>> core, without having personnally tested it against extreme conditions?
>>>>
>>>>
>>>> I think the answer to that is yes.  Most people never write such 
>>>> big files that they fill their disk:  if they did, all sorts of 
>>>> things would go wrong on their systems.  So this kind of extreme 
>>>> condition isn't often tested.  It's not easy to test in a platform 
>>>> independent
>>>> way:  R would need to be able to create a volume with a small 
>>>> capacity.  That's a very system-dependent thing to do.
>>>>
>>>>> And wouldn't it be the work of the developpers to do such 
>>>>> elementary tests?
>>>>
>>>>
>>>> Again, R is open source.  You can and should contribute code (and 
>>>> therefore become one of the developers) if you are working in 
>>>> unusual conditions.
>>>>
>>>> R states quite clearly in the welcome message every time it starts:
>>>> "R is free software and comes with ABSOLUTELY NO WARRANTY."  This 
>>>> is essentially the same lack of warranty that you get with 
>>>> commercial software, though it's stated a lot more clearly.
>>>>
>>>> Duncan Murdoch
>>>>
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fsta
>>> t 
>>> .ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40mic
>>> r 
>>> osoft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2
>>> d 
>>> 7cd011db47%7C1%7C0%7C636347767773809248&sdata=zMU5Ua2gL3fVPc%2FOPhfd
>>> c
>>> iAdoHzwDyaRnKusZCnXqWo%3D&reserved=0
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.
> ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40micros
> oft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd
> 011db47%7C1%7C0%7C636347767773809248&sdata=zMU5Ua2gL3fVPc%2FOPhfdciAdo
> HzwDyaRnKusZCnXqWo%3D&reserved=0 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.
> ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40micros
> oft.com%7C395a385e087e4af6005b08d4c85598ad%7C72f988bf86f141af91ab2d7cd
> 011db47%7C1%7C0%7C636353717344106719&sdata=ixzdTvi5X1mPngNq7dxAR1tLHcy
> xGyeiJbmBzL8kHjI%3D&reserved=0
> 

From paul at stat.auckland.ac.nz  Wed Jul 12 05:48:24 2017
From: paul at stat.auckland.ac.nz (Paul Murrell)
Date: Wed, 12 Jul 2017 15:48:24 +1200
Subject: [Rd] italic font on cairo devices in R 3.4
In-Reply-To: <2093e0fa-f923-0822-60d2-7509d38224af@gmx.net>
References: <2093e0fa-f923-0822-60d2-7509d38224af@gmx.net>
Message-ID: <61d483b0-b6a5-7811-9a80-34dcaed55c81@stat.auckland.ac.nz>

Hi

Do you have the 'fonts-texgyre' (Debian) package installed?
If not, does installing that help?

Paul

On 07/07/17 20:30, Ilia Kats wrote:
> [cross-post from R-help]
> 
> Hi all,
> 
> I have the following problem: Since R 3.4.0, italic fonts rendered on 
> Cairo devices appear pixelated. Here's a minimal example:
> cairo_pdf('test.pdf')
> plot(1:10, ylab=expression(italic(test)))
> dev.off()
> 
> The same problem occurs with bolditalic, but not bold. I am using Debian 
> Stretch. Several friends tried the same on their machines, another 
> Debian machine has the same problem. On MacOSX the output was not 
> pixelated, but it wasn't italic either. Ubuntu 16.04.2 xenial works 
> fine. My impression is that R somehow can't find the proper font to use 
> and falls back to something weird. Ideas?
> 
> Note that I'm not subscribed to the list, so please CC me in replies.
> 
> Cheers, Ilia
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Dr Paul Murrell
Department of Statistics
The University of Auckland
Private Bag 92019
Auckland
New Zealand
64 9 3737599 x85392
paul at stat.auckland.ac.nz
http://www.stat.auckland.ac.nz/~paul/


From ligges at statistik.tu-dortmund.de  Wed Jul 12 12:25:29 2017
From: ligges at statistik.tu-dortmund.de (Uwe Ligges)
Date: Wed, 12 Jul 2017 12:25:29 +0200
Subject: [Rd] write.csv
In-Reply-To: <SN1PR21MB006107CA7C3A67122C34606BB7AF0@SN1PR21MB0061.namprd21.prod.outlook.com>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACBE68@pdexchbalwst01.ad.insee.intra>
 <bc3fc4f2-a7ab-d061-3ef3-999479643a46@gmail.com>
 <FEF25E56AFC7064784FA97C576467E0AC7ACBEE5@pdexchbalwst01.ad.insee.intra>
 <f74dd537-cc00-50aa-0f33-c097aa08914a@gmail.com>
 <CAD6tx94WZzdeQXHFN=dkT+K7ZU6V-McRWM9tjU74hzG=KpRUEw@mail.gmail.com>
 <d989fa4d-9e88-b60e-2a34-1657acee774b@gmail.com>
 <SN1PR21MB0061BBA34200B3F6609F2536B7D70@SN1PR21MB0061.namprd21.prod.outlook.com>
 <SN1PR21MB00616252B6FB957B3BABD887B7A90@SN1PR21MB0061.namprd21.prod.outlook.com>
 <3cb3d0c5-d776-0eea-954c-1197d0b29dd9@statistik.tu-dortmund.de>
 <SN1PR21MB006107CA7C3A67122C34606BB7AF0@SN1PR21MB0061.namprd21.prod.outlook.com>
Message-ID: <f32f48e3-4e57-b1ab-c8c1-6e4c7dfa861e@statistik.tu-dortmund.de>



On 12.07.2017 05:09, Nathan Sosnovske wrote:
> Two thoughts:
> 
> 1) Will the new server that you are setting up with Server 2016 eventually host build and test? If so, this could at least run on that.
> 2) CreateVirtualDisk and OpenVirtualDisk are C functions that are available in Windows 7 and Server 2008 R2. So these are options that we could use, but it would require creating a small program to drive creation/mounting/deletion of the disk and compiling it at build time.

OK, thank you. Then the best way forward is probably to do 1) and 
include the test you propose, but keep it conditional on availability of 
admin permissions and an OS that supports it, please.

Best,
Uwe


> 
> Nathan
> 
> -----Original Message-----
> From: Uwe Ligges [mailto:ligges at statistik.tu-dortmund.de]
> Sent: Tuesday, July 11, 2017 5:09 AM
> To: Nathan Sosnovske <nsosnov at microsoft.com>; Duncan Murdoch <murdoch.duncan at gmail.com>; Jim Hester <james.f.hester at gmail.com>
> Cc: r-devel at r-project.org; Lipatz Jean-Luc <jean-luc.lipatz at insee.fr>
> Subject: Re: [Rd] write.csv
> 
> This is a bit difficult:
> 
> R binaries (both for R base and R packages) are still built with Windows Server 2008 and my desktop machine is Windows 7, hence at least currently such a check would not get executed on the machines R core / CRAN use ...
> 
> Best,
> Uwe
> 
> On 11.07.2017 00:59, Nathan Sosnovske via R-devel wrote:
>> As a follow up to this, Martin Maechler suggested that I write a small script that allows this to be tested on Windows from R. The attached script demonstrates creating and mounting a very small (4 MiB) VHD to a path on the system (in this case c:/smallmount) and then calling write.csv with a large dataframe to the newly mounted path.
>>
>> The method I attached has two limitations.
>>
>> 1) It will only work if run as administrator. This is a limitation of the OS.
>> 2) It will only work on Windows 8.1/Server 2012R2 or higher, as it uses powershell commands that only exist on those operating systems. I believe it could be made to work on Windows 7, but it would need to be written using the windows C apis at that point.
>>
>> If a regression test is created for this issue I would be more than happy to integrate this method into that if there is interest and if it would work in the environment where automated builds/tests for windows are run.
>>
>> -----Original Message-----
>> From: Nathan Sosnovske
>> Sent: Tuesday, July 4, 2017 8:02 AM
>> To: 'Duncan Murdoch' <murdoch.duncan at gmail.com>; Jim Hester
>> <james.f.hester at gmail.com>
>> Cc: r-devel at r-project.org; Lipatz Jean-Luc <jean-luc.lipatz at insee.fr>
>> Subject: RE: [Rd] write.csv
>>
>> The best way to test on Windows would probably be creating a small virtual hard disk (via CreateVirtualDisk), mounting it, and writing to the mounted location. I believe the drive could even be mounted to an arbitrary location on the filesystem (instead of a drive letter) so that drive letter conflicts don't come into play.
>>
>> -----Original Message-----
>> From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of
>> Duncan Murdoch
>> Sent: Tuesday, July 4, 2017 7:53 AM
>> To: Jim Hester <james.f.hester at gmail.com>
>> Cc: r-devel at r-project.org; Lipatz Jean-Luc <jean-luc.lipatz at insee.fr>
>> Subject: Re: [Rd] write.csv
>>
>> On 04/07/2017 10:01 AM, Jim Hester wrote:
>>> On linux at least you can use `/dev/full` [1] to test writing to a full device.
>>>
>>>       > echo 'foo' > /dev/full
>>>       bash: echo: write error: No space left on device
>>
>> Unfortunately, I get a permission denied error if I try to write there from MacOS.  I don't know if Windows has an equivalent.
>>
>> I've taken a look at the code.  Essentially it comes down to a call to the C function vfprintf, which is supposed to return the number of bytes written, or a negative value for an error. This return value is often not checked; in particular, write.table and friends don't check it.
>>
>> I'll add code to signal an error if there's a negative value.
>>
>> I don't think it's feasible to check the number of bytes (formatted text with possible translation to a different encoding could have any number of bytes) if it's positive.  So hopefully all of our file systems will correctly signal an error, and not just report how many bytes were successfully written.
>>
>>>
>>> Although that won't be a perfect test for this case where part of the
>>> file is written successfully.
>>>
>>> An alternative suggestion for testing this is to create and mount a
>>> loop device [2] with a small file.
>>>
>>> [1]:
>>> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fen.w
>>> i
>>> kipedia.org%2Fwiki%2F%2Fdev%2Ffull&data=02%7C01%7Cnsosnov%40microsoft.
>>> com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd011
>>> d
>>> b47%7C1%7C0%7C636347767773809248&sdata=Cb2oduozc2IDCLvXZGG1C4i4hQA7FP
>>> s
>>> 5jHmnFYbk7zQ%3D&reserved=0
>>> [2]:
>>> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstac
>>> k
>>> overflow.com%2Fa%2F16044420%2F2055486&data=02%7C01%7Cnsosnov%40micros
>>> o
>>> ft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd
>>> 0
>>> 11db47%7C1%7C0%7C636347767773809248&sdata=%2BWPfqD0nUS%2F30DUNDqQU79l
>>> R
>>> EJh02ZX0yik9HXiY5kg%3D&reserved=0
>>
>> Loop devices sound ideal, but seem to be Linux-only (at least with that recipe).
>>
>> Duncan
>>
>>
>>>
>>> On Tue, Jul 4, 2017 at 3:38 PM, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>>> On 04/07/2017 8:40 AM, Lipatz Jean-Luc wrote:
>>>>>
>>>>> I would really like the bug fixed. At least this one, because I
>>>>> know people in my institute using this function.
>>>>> I understand your arguments about open source, but I also saw in
>>>>> this mail list a proposal for a fix for this bug for which there
>>>>> were no answer from the people who are able to include it in the
>>>>> distribution. It looks like if there were interesting bugs and the other ones.
>>>>
>>>>
>>>> Please post a link to that, and I'll look.  Bug reports should be
>>>> posted to the bug list.  It's unfortunate that it is currently so
>>>> difficult to do so, but if they are only posted here, they are often overlooked.
>>>>
>>>>> I don't understand the other arguments : the example was reproduced
>>>>> with a simple USB key and you cannot state that a disk will
>>>>> eternally be empty enough, specially when it has several users.
>>>>
>>>>
>>>> I am not denying that it's a bug, I'm just saying that it is a
>>>> difficult one to test automatically (so we probably won't add a
>>>> regression test once it's fixed), and it's not one that has been
>>>> reported often.  I didn't know there were any reports before yours.
>>>>
>>>> Duncan Murdoch
>>>>
>>>>
>>>>> JLL
>>>>>
>>>>>
>>>>> -----Message d'origine-----
>>>>> De : Duncan Murdoch [mailto:murdoch.duncan at gmail.com] Envoy? :
>>>>> mardi
>>>>> 4 juillet 2017 14:24 ? : Lipatz Jean-Luc; r-devel at r-project.org
>>>>> Objet : Re: [Rd] write.csv
>>>>>
>>>>> On 04/07/2017 5:40 AM, Lipatz Jean-Luc wrote:
>>>>>>
>>>>>> Hi all,
>>>>>>
>>>>>> I am currently studying how to generalize the usage of R in my
>>>>>> statistical institute and I encountered a problem that I cannot
>>>>>> declare on bugzilla (cannot understand why).
>>>>>
>>>>>
>>>>> Bugzilla was badly abused by spammers last year, so you need to
>>>>> have your account created manually by one of the admins to post there.
>>>>> Write to me privately if you'd like me to create an account for you.
>>>>> (If you want it attached to a different email address, that's
>>>>> fine.)
>>>>>
>>>>> Sorry for trying this mailing list but I am really worried about
>>>>> the problem itself and the possible implications in using R in a
>>>>> professionnal data production context.
>>>>>>
>>>>>> The issue about 'write.csv' is that it just doesn't check if there
>>>>>> is enough space on disk and doesn't report failure to write data.
>>>>>>
>>>>>> Example (R 3.4.0 windows 32 bits, but I reproduced the problem
>>>>>> with older versions and under Mac OS/X)
>>>>>>
>>>>>>> fwrite(as.list(1:1000000),"G:/Test")
>>>>>>
>>>>>> Error in fwrite(as.list(1:1e+06), "G:/Test") :
>>>>>>     No space left on device: 'G:/Test'
>>>>>>>
>>>>>>> write.csv(1:1000000,"G:/Test")
>>>>>>>
>>>>>>
>>>>>> I have a big concern here, because it means that you could save
>>>>>> some important data at one point of time and discover a long time
>>>>>> after that you actually lost them.
>>>>>
>>>>>    > I suppose that the fix is relatively straightforward, but how
>>>>> can we be sure that there is no another function with the same bad properties?
>>>>>
>>>>> R is open source.  You could work out the patch for this bug, and
>>>>> in the process see the pattern of coding that leads to it.  Then
>>>>> you'll know if other functions use the same buggy pattern.
>>>>>
>>>>>> Is the lesson that you should not use a R function, even from the
>>>>>> core, without having personnally tested it against extreme conditions?
>>>>>
>>>>>
>>>>> I think the answer to that is yes.  Most people never write such
>>>>> big files that they fill their disk:  if they did, all sorts of
>>>>> things would go wrong on their systems.  So this kind of extreme
>>>>> condition isn't often tested.  It's not easy to test in a platform
>>>>> independent
>>>>> way:  R would need to be able to create a volume with a small
>>>>> capacity.  That's a very system-dependent thing to do.
>>>>>
>>>>>> And wouldn't it be the work of the developpers to do such
>>>>>> elementary tests?
>>>>>
>>>>>
>>>>> Again, R is open source.  You can and should contribute code (and
>>>>> therefore become one of the developers) if you are working in
>>>>> unusual conditions.
>>>>>
>>>>> R states quite clearly in the welcome message every time it starts:
>>>>> "R is free software and comes with ABSOLUTELY NO WARRANTY."  This
>>>>> is essentially the same lack of warranty that you get with
>>>>> commercial software, though it's stated a lot more clearly.
>>>>>
>>>>> Duncan Murdoch
>>>>>
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fsta
>>>> t
>>>> .ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40mic
>>>> r
>>>> osoft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2
>>>> d
>>>> 7cd011db47%7C1%7C0%7C636347767773809248&sdata=zMU5Ua2gL3fVPc%2FOPhfd
>>>> c
>>>> iAdoHzwDyaRnKusZCnXqWo%3D&reserved=0
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.
>> ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40micros
>> oft.com%7Cb97a7371538b4dbe9a7308d4c2ec5aa0%7C72f988bf86f141af91ab2d7cd
>> 011db47%7C1%7C0%7C636347767773809248&sdata=zMU5Ua2gL3fVPc%2FOPhfdciAdo
>> HzwDyaRnKusZCnXqWo%3D&reserved=0
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.
>> ethz.ch%2Fmailman%2Flistinfo%2Fr-devel&data=02%7C01%7Cnsosnov%40micros
>> oft.com%7C395a385e087e4af6005b08d4c85598ad%7C72f988bf86f141af91ab2d7cd
>> 011db47%7C1%7C0%7C636353717344106719&sdata=ixzdTvi5X1mPngNq7dxAR1tLHcy
>> xGyeiJbmBzL8kHjI%3D&reserved=0
>>


From ilia-kats at gmx.net  Wed Jul 12 08:38:13 2017
From: ilia-kats at gmx.net (Ilia Kats)
Date: Wed, 12 Jul 2017 08:38:13 +0200
Subject: [Rd] italic font on cairo devices in R 3.4
In-Reply-To: <61d483b0-b6a5-7811-9a80-34dcaed55c81@stat.auckland.ac.nz>
References: <2093e0fa-f923-0822-60d2-7509d38224af@gmx.net>
 <61d483b0-b6a5-7811-9a80-34dcaed55c81@stat.auckland.ac.nz>
Message-ID: <6d0304df-6ed8-bd2c-d2b4-37a792ba5294@gmx.net>

Hi Paul,

thanks for your suggestion. No, I did not have that package installed, 
but installing it didn't change anything, unfortunately.

Cheers, Ilia



-------- Original Message --------
Subject: Re: [Rd] italic font on cairo devices in R 3.4
Date: 2017-07-12 05:48:24 +0200
From: Paul Murrell
To: ilia-kats, r-devel
> Hi
>
> Do you have the 'fonts-texgyre' (Debian) package installed?
> If not, does installing that help?
>
> Paul
>
> On 07/07/17 20:30, Ilia Kats wrote:
>> [cross-post from R-help]
>>
>> Hi all,
>>
>> I have the following problem: Since R 3.4.0, italic fonts rendered on 
>> Cairo devices appear pixelated. Here's a minimal example:
>> cairo_pdf('test.pdf')
>> plot(1:10, ylab=expression(italic(test)))
>> dev.off()
>>
>> The same problem occurs with bolditalic, but not bold. I am using 
>> Debian Stretch. Several friends tried the same on their machines, 
>> another Debian machine has the same problem. On MacOSX the output was 
>> not pixelated, but it wasn't italic either. Ubuntu 16.04.2 xenial 
>> works fine. My impression is that R somehow can't find the proper 
>> font to use and falls back to something weird. Ideas?
>>
>> Note that I'm not subscribed to the list, so please CC me in replies.
>>
>> Cheers, Ilia
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>

-- 
Ha. I say let them try -- even vi+perl couldn't match the power of an
editor which is, after all, its own OS. ;-)
-- Johnie Ingram on debian-devel, about linking vim with libperl.so


From antonio.jordan at dean.com  Wed Jul 12 18:06:29 2017
From: antonio.jordan at dean.com (Antonio Jordan)
Date: Wed, 12 Jul 2017 16:06:29 +0000
Subject: [Rd] Bug in libR.so (R 3.4.1 Single Candle)
Message-ID: <20170712160629.GA76844@dean.com>

Hi all,

I believe I have found a bug in the current version of R. Bug manifested itself while testing a shiny app in both the R console and in Rstudio. I've tried a complete fresh install of R, Rstudio, & Shiny with the same results. Also tried switching kernel versions (As I know stack clash fixes have been breaking things lately), and Java versions with no better luck. Attached backtrace is from a box with fully patched CentOS 7 kernel 3.10.0-514.26.2.el7.x86_64|R 3.4.1|Rstudio 1.0.143|Shiny 1.5.3.838|Java-1.8.0-openjdk (latest build). Also tested on kernels 3.10.0-514.26.2.el7.x86_64, 3.10.0-514.26.1.el7.x86_64, 3.10.0-514.21.2.el7.x86_64, 3.10.0-514.16.1.el7.x86_64|R version 3.4.0|Java-1.7. So I launch my Shiny app and it runs fine, no errors, first interaction with the app through the UI works no problem, trying the same action again or any other action give me the 'previous R sesion was abnormally terminated due to an unexpected crash' message. Only error in logs is a simple 'ERROR session hadabend; LOGGED FROM: rstudio::core::Error<unnamed>::rInit(const rstudio::r::session::RInitInfo&) /root/rstudio/src/cpp/session/SessionMain.cpp:1934'. Googled around for a workaround or fix and non of the proposed fixes I came across worked for me. Even resetting or completely deleting .rstudio, .Rdata, and user R directory. Thanks for taking a look! 

BackTrace:

Program received signal SIGSEGV, Segmentation fault.
0x00007f397ee1784b in bcEval () from /usr/lib64/R/lib/libR.so
(gdb) bt
#0  0x00007f397ee1784b in bcEval () from /usr/lib64/R/lib/libR.so
#1  0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#2  0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#3  0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#4  0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#5  0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#6  0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#7  0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#8  0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#9  0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#10 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#11 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#12 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#13 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#14 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#15 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#16 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#17 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#18 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#19 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#20 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#21 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#22 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#23 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#24 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#25 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#26 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#27 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#28 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#29 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#30 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#31 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#32 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#33 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#34 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#35 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#36 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#37 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#38 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#39 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#40 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#41 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#42 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#43 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#44 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#45 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#46 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#47 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#48 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#49 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#50 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#51 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#52 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#53 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#54 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#55 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#56 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#57 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#58 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#59 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#60 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#61 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#62 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#63 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#64 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#65 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#66 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#67 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#68 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#69 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#70 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#71 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#72 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#73 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#74 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#75 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#76 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#77 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#78 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#79 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#80 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#81 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#82 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#83 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#84 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#85 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#86 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#87 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#88 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#89 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#90 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#91 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#92 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#93 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#94 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#95 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#96 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#97 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#98 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#99 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#100 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#101 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#102 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#103 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#104 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#105 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#106 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#107 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#108 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#109 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#110 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#111 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#112 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#113 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#114 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#115 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#116 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#117 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#118 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#119 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#120 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#121 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#122 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#123 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#124 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#125 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#126 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#127 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#128 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#129 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#130 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#131 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#132 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#133 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#134 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#135 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#136 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#137 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#138 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#139 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#140 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#141 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#142 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#143 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#144 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#145 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#146 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#147 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#148 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#149 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#150 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#151 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#152 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#153 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#154 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#155 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#156 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#157 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#158 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#159 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#160 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#161 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#162 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#163 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#164 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#165 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#166 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#167 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#168 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#169 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#170 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#171 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#172 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#173 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#174 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#175 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#176 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#177 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#178 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#179 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#180 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#181 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#182 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#183 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#184 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#185 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#186 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#187 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#188 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#189 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#190 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#191 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#192 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#193 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#194 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#195 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#196 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#197 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#198 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#199 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#200 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#201 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#202 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#203 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#204 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#205 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#206 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#207 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#208 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#209 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#210 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#211 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#212 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#213 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#214 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#215 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#216 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#217 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#218 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#219 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#220 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#221 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#222 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#223 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#224 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#225 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#226 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#227 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#228 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#229 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#230 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#231 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#232 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#233 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#234 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#235 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#236 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#237 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#238 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#239 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#240 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#241 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#242 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#243 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#244 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#245 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#246 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#247 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#248 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#249 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#250 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#251 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#252 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#253 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#254 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#255 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#256 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#257 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#258 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#259 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#260 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#261 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#262 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#263 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#264 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#265 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#266 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#267 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#268 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#269 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#270 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#271 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#272 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#273 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#274 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#275 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#276 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#277 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#278 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#279 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#280 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#281 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#282 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#283 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#284 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#285 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#286 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#287 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#288 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#289 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#290 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#291 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#292 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#293 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#294 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#295 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#296 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#297 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#298 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#299 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#300 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#301 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#302 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#303 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#304 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#305 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#306 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#307 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#308 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#309 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#310 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#311 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#312 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#313 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#314 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#315 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#316 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#317 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#318 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#319 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#320 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#321 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#322 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#323 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#324 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#325 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#326 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#327 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#328 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#329 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#330 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#331 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#332 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#333 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#334 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#335 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#336 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#337 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#338 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#339 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#340 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#341 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#342 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#343 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#344 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#345 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#346 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#347 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#348 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#349 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#350 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#351 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#352 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#353 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#354 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#355 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#356 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#357 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#358 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#359 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#360 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#361 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#362 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#363 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#364 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#365 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#366 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#367 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#368 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#369 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#370 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#371 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#372 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#373 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#374 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#375 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#376 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#377 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#378 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#379 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#380 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#381 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#382 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#383 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#384 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#385 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#386 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#387 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#388 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#389 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#390 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#391 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#392 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#393 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#394 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#395 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#396 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#397 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#398 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#399 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#400 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#401 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#402 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#403 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#404 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#405 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#406 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#407 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#408 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#409 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#410 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#411 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#412 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#413 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#414 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#415 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#416 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#417 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#418 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#419 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#420 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#421 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#422 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#423 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#424 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#425 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#426 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#427 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#428 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#429 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#430 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#431 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#432 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#433 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#434 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#435 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#436 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#437 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#438 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#439 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#440 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#441 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#442 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#443 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#444 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#445 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#446 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#447 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#448 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#449 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#450 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#451 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#452 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#453 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#454 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#455 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#456 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#457 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#458 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#459 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#460 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#461 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#462 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
#463 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
#464 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#465 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#466 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#467 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#468 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#469 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#470 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#471 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#472 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#473 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#474 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#475 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#476 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#477 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#478 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#479 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#480 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#481 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#482 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#483 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#484 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#485 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#486 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#487 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#488 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#489 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#490 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#491 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#492 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#493 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#494 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#495 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#496 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#497 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#498 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#499 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#500 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#501 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#502 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#503 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#504 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#505 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#506 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#507 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#508 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#509 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#510 0x00007f397ee2c6f8 in R_cmpfun1 () from /usr/lib64/R/lib/libR.so
#511 0x00007f397ee2c7ab in R_cmpfun () from /usr/lib64/R/lib/libR.so
#512 0x00007f397ee2d2fe in R_execClosure () from /usr/lib64/R/lib/libR.so
#513 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#514 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#515 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#516 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#517 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#518 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
#519 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#520 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#521 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#522 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#523 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#524 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#525 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#526 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#527 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#528 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#529 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#530 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#531 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#532 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#533 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#534 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#535 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#536 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#537 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
#538 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#539 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#540 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#541 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#542 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#543 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#544 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#545 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#546 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#547 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#548 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#549 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#550 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#551 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#552 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#553 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#554 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#555 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#556 0x00007f397ee564f3 in do_mapply () from /usr/lib64/R/lib/libR.so
#557 0x00007f397ee1b6bd in bcEval () from /usr/lib64/R/lib/libR.so
#558 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#559 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#560 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#561 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#562 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#563 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#564 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#565 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#566 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#567 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#568 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#569 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#570 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#571 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#572 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#573 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#574 0x00007f397ee61fc4 in dispatchMethod () from /usr/lib64/R/lib/libR.so
#575 0x00007f397ee6239b in Rf_usemethod () from /usr/lib64/R/lib/libR.so
#576 0x00007f397ee62724 in do_usemethod () from /usr/lib64/R/lib/libR.so
#577 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#578 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#579 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#580 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#581 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#582 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#583 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#584 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#585 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
#586 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#587 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#588 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#589 0x00007f397ee302cf in do_eval () from /usr/lib64/R/lib/libR.so
#590 0x00007f397ee1b6bd in bcEval () from /usr/lib64/R/lib/libR.so
#591 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#592 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#593 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#594 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#595 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#596 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#597 0x00007f397ee307e1 in do_withVisible () from /usr/lib64/R/lib/libR.so
#598 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#599 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#600 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#601 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#602 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#603 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#604 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#605 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#606 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#607 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#608 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#609 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#610 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#611 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#612 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#613 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#614 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#615 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#616 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#617 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#618 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#619 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#620 0x00007f397edb9e36 in do_docall () from /usr/lib64/R/lib/libR.so
#621 0x00007f397ee1b6bd in bcEval () from /usr/lib64/R/lib/libR.so
#622 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#623 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#624 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#625 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#626 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#627 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#628 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#629 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
#630 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#631 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#632 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#633 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#634 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#635 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#636 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#637 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#638 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#639 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#640 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#641 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#642 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#643 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#644 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#645 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#646 0x00007f397ee307e1 in do_withVisible () from /usr/lib64/R/lib/libR.so
#647 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#648 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#649 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#650 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#651 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#652 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#653 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#654 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#655 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#656 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#657 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#658 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#659 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
#660 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#661 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#662 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#663 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#664 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#665 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#666 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#667 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#668 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#669 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#670 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#671 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#672 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#673 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#674 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#675 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#676 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#677 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#678 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#679 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#680 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#681 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#682 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#683 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#684 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#685 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#686 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#687 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#688 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#689 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#690 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#691 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#692 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#693 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#694 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#695 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#696 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#697 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#698 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#699 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#700 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#701 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#702 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#703 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#704 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#705 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#706 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#707 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#708 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#709 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#710 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#711 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#712 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#713 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#714 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#715 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#716 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#717 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#718 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#719 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#720 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#721 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#722 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#723 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#724 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#725 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#726 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#727 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#728 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#729 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#730 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#731 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#732 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#733 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#734 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#735 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#736 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#737 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#738 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#739 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#740 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#741 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#742 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#743 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#744 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#745 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#746 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#747 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#748 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#749 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#750 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#751 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#752 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#753 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#754 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#755 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#756 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#757 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#758 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#759 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#760 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#761 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#762 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#763 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#764 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#765 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#766 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#767 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#768 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#769 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#770 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#771 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#772 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#773 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#774 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#775 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#776 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#777 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#778 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#779 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#780 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#781 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#782 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#783 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#784 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#785 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#786 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#787 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#788 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#789 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#790 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#791 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#792 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#793 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#794 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#795 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#796 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#797 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#798 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#799 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#800 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#801 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#802 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#803 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#804 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#805 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#806 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#807 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#808 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#809 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#810 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#811 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#812 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#813 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#814 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#815 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
#816 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#817 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#818 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#819 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#820 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#821 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#822 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#823 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#824 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#825 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#826 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#827 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#828 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#829 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#830 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#831 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#832 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#833 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#834 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#835 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#836 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#837 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#838 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#839 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#840 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#841 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#842 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#843 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#844 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#845 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#846 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#847 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#848 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#849 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#850 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#851 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#852 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#853 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#854 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#855 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#856 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#857 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#858 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#859 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#860 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#861 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#862 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#863 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#864 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#865 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#866 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#867 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#868 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#869 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#870 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#871 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#872 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#873 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#874 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#875 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#876 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#877 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#878 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#879 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#880 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#881 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#882 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#883 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#884 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#885 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#886 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#887 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#888 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#889 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#890 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#891 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#892 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#893 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#894 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#895 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#896 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#897 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#898 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#899 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#900 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#901 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#902 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#903 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#904 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#905 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#906 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#907 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#908 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#909 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#910 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#911 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#912 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#913 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#914 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#915 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#916 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#917 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#918 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#919 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#920 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#921 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#922 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#923 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#924 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
#925 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
#926 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
#927 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
#928 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#929 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#930 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#931 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#932 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#933 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#934 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#935 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#936 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#937 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#938 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#939 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#940 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#941 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#942 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#943 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#944 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#945 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#946 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#947 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#948 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#949 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#950 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#951 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#952 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#953 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#954 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#955 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#956 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#957 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#958 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#959 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#960 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#961 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#962 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#963 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#964 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#965 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#966 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#967 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#968 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#969 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#970 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#971 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#972 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#973 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#974 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#975 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#976 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#977 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#978 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#979 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#980 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#981 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#982 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#983 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#984 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#985 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#986 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#987 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#988 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#989 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#990 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#991 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#992 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#993 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#994 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#995 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#996 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#997 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#998 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#999 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1000 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#1001 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#1002 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1003 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#1004 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#1005 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1006 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1007 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#1008 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1009 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1010 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#1011 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1012 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1013 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#1014 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1015 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1016 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#1017 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1018 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1019 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#1020 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1021 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1022 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1023 0x00007f397ee302cf in do_eval () from /usr/lib64/R/lib/libR.so
#1024 0x00007f397ee1b6bd in bcEval () from /usr/lib64/R/lib/libR.so
#1025 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1026 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1027 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1028 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#1029 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#1030 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1031 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#1032 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#1033 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1034 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#1035 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#1036 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1037 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#1038 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#1039 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1040 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#1041 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#1042 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1043 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1044 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#1045 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1046 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1047 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#1048 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1049 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1050 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#1051 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1052 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#1053 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#1054 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1055 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#1056 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#1057 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1058 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1059 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#1060 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1061 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1062 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#1063 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1064 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1065 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#1066 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1067 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1068 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1069 0x00007f396ff17026 in Rcpp::Rcpp_eval (expr=<optimized out>, env=<optimized out>)
    at /usr/lib64/R/library/Rcpp/include/Rcpp/api/meat/Rcpp_eval.h:43
---Type <return> to continue, or q <return> to quit---
#1070 0x00007f396ff27a17 in operator()<std::basic_string<char>, bool, std::basic_string<char> > (
    t3="{\"method\":\"update\",\"data\":{\"plot_trigger:shiny.action\":2}}", t2=@0x7ffc4b3b581c: false, t1="209221136",
    this=0x40f448f8) at /usr/lib64/R/library/Rcpp/include/Rcpp/generated/Function__operator.h:45

#1071 RWebApplication::onWSMessage (this=0x40f448d0, pConn=<optimized out>, binary=false, data=<optimized out>,
    len=<optimized out>) at httpuv.cpp:284
#1072 0x00007f396ff2d064 in WebSocketConnection::onFrameComplete (this=0xc787610) at websockets.cpp:313
#1073 0x00007f396ff2d2cd in WSHyBiParser::read (this=0x1e1d3da0, data=0x4487c630 "", len=0) at websockets.cpp:200
#1074 0x00007f396ff1d2df in HttpRequest::_on_request_read (this=0x2a4a3bf0, nread=64, buf=...) at http.cpp:343
#1075 0x00007f396ff31e4a in uv__read (stream=stream at entry=0x2a4a3c08) at src/unix/stream.c:1020
#1076 0x00007f396ff32500 in uv__stream_io (loop=<optimized out>, w=0x2a4a3c78, events=1) at src/unix/stream.c:1115
#1077 0x00007f396ff38ddd in uv__io_poll (loop=loop at entry=0x7f3970153fa0 <default_loop_struct>, timeout=99)
    at src/unix/linux-core.c:211
#1078 0x00007f396ff2df7c in uv_run (loop=0x7f3970153fa0 <default_loop_struct>, mode=<optimized out>) at src/unix/core.c:317
#1079 0x00007f396ff20584 in run (timeoutMillis=<optimized out>) at httpuv.cpp:405
#1080 0x00007f396ff130bc in httpuv_run (timeoutMillisSEXP=0x19f67e68) at RcppExports.cpp:83
#1081 0x00007f397ede7edd in do_dotcall () from /usr/lib64/R/lib/libR.so
#1082 0x00007f397ee2b831 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1083 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#1084 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1085 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1086 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1087 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#1088 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1089 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1090 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
#1091 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1092 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1093 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1094 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#1095 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1096 0x00007f397ee323d2 in do_while () from /usr/lib64/R/lib/libR.so
#1097 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1098 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#1099 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1100 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#1101 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1102 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#1103 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
#1104 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1105 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1106 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1107 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#1108 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1109 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1110 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1111 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
#1112 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1113 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1114 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1115 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
#1116 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1117 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
#1118 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
#1119 0x00007f397ee54e42 in Rf_ReplIteration () from /usr/lib64/R/lib/libR.so
#1120 0x00007f397ee55221 in R_ReplConsole () from /usr/lib64/R/lib/libR.so
#1121 0x00007f397ee552df in run_Rmainloop () from /usr/lib64/R/lib/libR.so
#1122 0x000000000040080b in main () 


From murdoch.duncan at gmail.com  Wed Jul 12 18:40:50 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Wed, 12 Jul 2017 12:40:50 -0400
Subject: [Rd] Bug in libR.so (R 3.4.1 Single Candle)
In-Reply-To: <20170712160629.GA76844@dean.com>
References: <20170712160629.GA76844@dean.com>
Message-ID: <1ca87e50-7576-e206-290d-ed3c7e6a1967@gmail.com>

On 12/07/2017 12:06 PM, Antonio Jordan via R-devel wrote:
> Hi all,
>
> I believe I have found a bug in the current version of R.

You don't present any evidence of one.

What your stack trace looks like is an infinite regress, e.g. an R 
function that calls itself (or possibly a more complicated loop).  For 
example, I see do_lapply (the C function corresponding to the lapply() 
function in R) 18 times.  It's not common for lapply() to call an 
expression that calls lapply() even once; 18 times seems like a 
programming error.

This could be an error in R or Shiny, but more commonly such things are 
user errors.

To get R core to look at this, you'll need to simplify it to something 
self contained that doesn't make use of non-base packages.

Duncan Murdoch


  Bug manifested itself while testing a shiny app in both the R console 
and in Rstudio. I've tried a complete fresh install of R, Rstudio, & 
Shiny with the same results. Also tried switching kernel versions (As I 
know stack clash fixes have been breaking things lately), and Java 
versions with no better luck. Attached backtrace is from a box with 
fully patched CentOS 7 kernel 3.10.0-514.26.2.el7.x86_64|R 3.4.1|Rstudio 
1.0.143|Shiny 1.5.3.838|Java-1.8.0-openjdk (latest build). Also tested 
on kernels 3.10.0-514.26.2.el7.x86_64, 3.10.0-514.26.1.el7.x86_64, 
3.10.0-514.21.2.el7.x86_64, 3.10.0-514.16.1.el7.x86_64|R version 
3.4.0|Java-1.7. So I launch my Shiny app and it runs fine, no errors, 
first interaction with the app through the UI works no problem, trying 
the same action again or any other action give me the 'previous R sesion 
was abnormally terminated due to an unexpected crash' message. Only 
error in logs is a simple 'ERROR ses
>  sion hadabend; LOGGED FROM: rstudio::core::Error<unnamed>::rInit(const rstudio::r::session::RInitInfo&) /root/rstudio/src/cpp/session/SessionMain.cpp:1934'. Googled around for a workaround or fix and non of the proposed fixes I came across worked for me. Even resetting or completely deleting .rstudio, .Rdata, and user R directory. Thanks for taking a look!
>
> BackTrace:
>
> Program received signal SIGSEGV, Segmentation fault.
> 0x00007f397ee1784b in bcEval () from /usr/lib64/R/lib/libR.so
> (gdb) bt
> #0  0x00007f397ee1784b in bcEval () from /usr/lib64/R/lib/libR.so
> #1  0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #2  0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #3  0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #4  0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #5  0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #6  0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #7  0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #8  0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #9  0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #10 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #11 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #12 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #13 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #14 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #15 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #16 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #17 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #18 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #19 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #20 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #21 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #22 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #23 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #24 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #25 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #26 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #27 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #28 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #29 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #30 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #31 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #32 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #33 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #34 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #35 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #36 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #37 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #38 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #39 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #40 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #41 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #42 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #43 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #44 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #45 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #46 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #47 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #48 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #49 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #50 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #51 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #52 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #53 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #54 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #55 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #56 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #57 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #58 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #59 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #60 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #61 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #62 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #63 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #64 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #65 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #66 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #67 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #68 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #69 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #70 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #71 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #72 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #73 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #74 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #75 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #76 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #77 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #78 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #79 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #80 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #81 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #82 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #83 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #84 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #85 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #86 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #87 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #88 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #89 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #90 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #91 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #92 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #93 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #94 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #95 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #96 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #97 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #98 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #99 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #100 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #101 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #102 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #103 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #104 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #105 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #106 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #107 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #108 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #109 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #110 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #111 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #112 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #113 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #114 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #115 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #116 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #117 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #118 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #119 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #120 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #121 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #122 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #123 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #124 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #125 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #126 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #127 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #128 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #129 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #130 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #131 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #132 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #133 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #134 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #135 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #136 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #137 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #138 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #139 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #140 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #141 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #142 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #143 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #144 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #145 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #146 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #147 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #148 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #149 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #150 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #151 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #152 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #153 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #154 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #155 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #156 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #157 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #158 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #159 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #160 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #161 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #162 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #163 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #164 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #165 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #166 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #167 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #168 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #169 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #170 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #171 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #172 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #173 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #174 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #175 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #176 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #177 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #178 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #179 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #180 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #181 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #182 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #183 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #184 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #185 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #186 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #187 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #188 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #189 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #190 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #191 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #192 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #193 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #194 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #195 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #196 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #197 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #198 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #199 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #200 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #201 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #202 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #203 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #204 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #205 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #206 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #207 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #208 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #209 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #210 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #211 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #212 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #213 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #214 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #215 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #216 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #217 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #218 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #219 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #220 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #221 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #222 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #223 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #224 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #225 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #226 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #227 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #228 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #229 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #230 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #231 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #232 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #233 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #234 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #235 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #236 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #237 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #238 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #239 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #240 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #241 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #242 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #243 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #244 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #245 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #246 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #247 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #248 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #249 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #250 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #251 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #252 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #253 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #254 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #255 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #256 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #257 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #258 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #259 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #260 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #261 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #262 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #263 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #264 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #265 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #266 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #267 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #268 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #269 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #270 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #271 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #272 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #273 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #274 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #275 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #276 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #277 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #278 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #279 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #280 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #281 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #282 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #283 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #284 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #285 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #286 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #287 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #288 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #289 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #290 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #291 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #292 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #293 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #294 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #295 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #296 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #297 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #298 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #299 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #300 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #301 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #302 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #303 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #304 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #305 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #306 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #307 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #308 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #309 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #310 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #311 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #312 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #313 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #314 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #315 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #316 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #317 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #318 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #319 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #320 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #321 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #322 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #323 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #324 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #325 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #326 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #327 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #328 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #329 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #330 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #331 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #332 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #333 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #334 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #335 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #336 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #337 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #338 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #339 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #340 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #341 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #342 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #343 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #344 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #345 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #346 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #347 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #348 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #349 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #350 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #351 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #352 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #353 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #354 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #355 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #356 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #357 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #358 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #359 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #360 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #361 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #362 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #363 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #364 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #365 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #366 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #367 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #368 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #369 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #370 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #371 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #372 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #373 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #374 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #375 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #376 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #377 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #378 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #379 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #380 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #381 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #382 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #383 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #384 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #385 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #386 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #387 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #388 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #389 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #390 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #391 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #392 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #393 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #394 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #395 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #396 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #397 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #398 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #399 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #400 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #401 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #402 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #403 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #404 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #405 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #406 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #407 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #408 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #409 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #410 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #411 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #412 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #413 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #414 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #415 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #416 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #417 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #418 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #419 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #420 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #421 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #422 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #423 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #424 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #425 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #426 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #427 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #428 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #429 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #430 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #431 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #432 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #433 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #434 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #435 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #436 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #437 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #438 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #439 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #440 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #441 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #442 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #443 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #444 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #445 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #446 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #447 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #448 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #449 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #450 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #451 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #452 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #453 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #454 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #455 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #456 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #457 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #458 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #459 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #460 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #461 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #462 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> #463 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #464 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #465 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #466 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #467 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #468 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #469 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #470 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #471 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #472 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #473 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #474 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #475 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #476 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #477 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #478 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #479 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #480 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #481 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #482 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #483 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #484 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #485 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #486 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #487 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #488 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #489 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #490 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #491 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #492 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #493 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #494 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #495 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #496 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #497 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #498 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #499 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #500 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #501 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #502 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #503 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #504 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #505 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #506 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #507 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #508 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #509 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #510 0x00007f397ee2c6f8 in R_cmpfun1 () from /usr/lib64/R/lib/libR.so
> #511 0x00007f397ee2c7ab in R_cmpfun () from /usr/lib64/R/lib/libR.so
> #512 0x00007f397ee2d2fe in R_execClosure () from /usr/lib64/R/lib/libR.so
> #513 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #514 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #515 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #516 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #517 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #518 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
> #519 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #520 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #521 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #522 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #523 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #524 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #525 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #526 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #527 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #528 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #529 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #530 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #531 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #532 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #533 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #534 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #535 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #536 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #537 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
> #538 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #539 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #540 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #541 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #542 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #543 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #544 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #545 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #546 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #547 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #548 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #549 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #550 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #551 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #552 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #553 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #554 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #555 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #556 0x00007f397ee564f3 in do_mapply () from /usr/lib64/R/lib/libR.so
> #557 0x00007f397ee1b6bd in bcEval () from /usr/lib64/R/lib/libR.so
> #558 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #559 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #560 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #561 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #562 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #563 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #564 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #565 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #566 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #567 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #568 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #569 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #570 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #571 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #572 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #573 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #574 0x00007f397ee61fc4 in dispatchMethod () from /usr/lib64/R/lib/libR.so
> #575 0x00007f397ee6239b in Rf_usemethod () from /usr/lib64/R/lib/libR.so
> #576 0x00007f397ee62724 in do_usemethod () from /usr/lib64/R/lib/libR.so
> #577 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #578 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #579 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #580 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #581 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #582 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #583 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #584 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #585 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
> #586 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #587 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #588 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #589 0x00007f397ee302cf in do_eval () from /usr/lib64/R/lib/libR.so
> #590 0x00007f397ee1b6bd in bcEval () from /usr/lib64/R/lib/libR.so
> #591 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #592 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #593 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #594 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #595 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #596 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #597 0x00007f397ee307e1 in do_withVisible () from /usr/lib64/R/lib/libR.so
> #598 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #599 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #600 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #601 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #602 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #603 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #604 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #605 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #606 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #607 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #608 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #609 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #610 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #611 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #612 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #613 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #614 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #615 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #616 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #617 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #618 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #619 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #620 0x00007f397edb9e36 in do_docall () from /usr/lib64/R/lib/libR.so
> #621 0x00007f397ee1b6bd in bcEval () from /usr/lib64/R/lib/libR.so
> #622 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #623 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #624 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #625 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #626 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #627 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #628 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #629 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
> #630 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #631 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #632 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #633 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #634 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #635 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #636 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #637 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #638 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #639 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #640 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #641 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #642 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #643 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #644 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #645 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #646 0x00007f397ee307e1 in do_withVisible () from /usr/lib64/R/lib/libR.so
> #647 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #648 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #649 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #650 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #651 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #652 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #653 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #654 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #655 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #656 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #657 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #658 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #659 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
> #660 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #661 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #662 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #663 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #664 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #665 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #666 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #667 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #668 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #669 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #670 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #671 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #672 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #673 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #674 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #675 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #676 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #677 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #678 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #679 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #680 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #681 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #682 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #683 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #684 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #685 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #686 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #687 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #688 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #689 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #690 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #691 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #692 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #693 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #694 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #695 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #696 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #697 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #698 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #699 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #700 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #701 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #702 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #703 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #704 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #705 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #706 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #707 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #708 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #709 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #710 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #711 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #712 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #713 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #714 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #715 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #716 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #717 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #718 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #719 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #720 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #721 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #722 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #723 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #724 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #725 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #726 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #727 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #728 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #729 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #730 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #731 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #732 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #733 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #734 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #735 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #736 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #737 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #738 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #739 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #740 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #741 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #742 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #743 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #744 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #745 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #746 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #747 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #748 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #749 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #750 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #751 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #752 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #753 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #754 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #755 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #756 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #757 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #758 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #759 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #760 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #761 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #762 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #763 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #764 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #765 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #766 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #767 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #768 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #769 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #770 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #771 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #772 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #773 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #774 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #775 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #776 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #777 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #778 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #779 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #780 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #781 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #782 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #783 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #784 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #785 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #786 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #787 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #788 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #789 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #790 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #791 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #792 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #793 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #794 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #795 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #796 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #797 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #798 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #799 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #800 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #801 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #802 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #803 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #804 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #805 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #806 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #807 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #808 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #809 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #810 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #811 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #812 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #813 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #814 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #815 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
> #816 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #817 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #818 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #819 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #820 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #821 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #822 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #823 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #824 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #825 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #826 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #827 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #828 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #829 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #830 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #831 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #832 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #833 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #834 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #835 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #836 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #837 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #838 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #839 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #840 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #841 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #842 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #843 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #844 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #845 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #846 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #847 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #848 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #849 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #850 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #851 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #852 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #853 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #854 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #855 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #856 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #857 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #858 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #859 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #860 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #861 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #862 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #863 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #864 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #865 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #866 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #867 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #868 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #869 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #870 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #871 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #872 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #873 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #874 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #875 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #876 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #877 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #878 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #879 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #880 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #881 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #882 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #883 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #884 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #885 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #886 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #887 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #888 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #889 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #890 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #891 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #892 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #893 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #894 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #895 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #896 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #897 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #898 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #899 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #900 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #901 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #902 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #903 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #904 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #905 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #906 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #907 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #908 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #909 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #910 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #911 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #912 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #913 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #914 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #915 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #916 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #917 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #918 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #919 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #920 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #921 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #922 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #923 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #924 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> #925 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> #926 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> #927 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> #928 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #929 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #930 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #931 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #932 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #933 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #934 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #935 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #936 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #937 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #938 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #939 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #940 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #941 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #942 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #943 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #944 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #945 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #946 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #947 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #948 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #949 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #950 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #951 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #952 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #953 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #954 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #955 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #956 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #957 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #958 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #959 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #960 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #961 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #962 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #963 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #964 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #965 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #966 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #967 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #968 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #969 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #970 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #971 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #972 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #973 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #974 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #975 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #976 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #977 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #978 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #979 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #980 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #981 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #982 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #983 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #984 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #985 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #986 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #987 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #988 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #989 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #990 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #991 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #992 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #993 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #994 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #995 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #996 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #997 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #998 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #999 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1000 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #1001 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #1002 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1003 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #1004 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #1005 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1006 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1007 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #1008 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1009 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1010 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #1011 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1012 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1013 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #1014 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1015 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1016 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #1017 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1018 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1019 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #1020 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1021 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1022 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1023 0x00007f397ee302cf in do_eval () from /usr/lib64/R/lib/libR.so
> #1024 0x00007f397ee1b6bd in bcEval () from /usr/lib64/R/lib/libR.so
> #1025 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1026 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1027 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1028 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #1029 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #1030 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1031 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #1032 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #1033 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1034 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #1035 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #1036 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1037 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #1038 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #1039 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1040 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #1041 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #1042 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1043 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1044 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #1045 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1046 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1047 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #1048 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1049 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1050 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #1051 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1052 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #1053 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #1054 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1055 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #1056 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #1057 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1058 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1059 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #1060 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1061 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1062 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #1063 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1064 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1065 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #1066 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1067 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1068 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1069 0x00007f396ff17026 in Rcpp::Rcpp_eval (expr=<optimized out>, env=<optimized out>)
>     at /usr/lib64/R/library/Rcpp/include/Rcpp/api/meat/Rcpp_eval.h:43
> ---Type <return> to continue, or q <return> to quit---
> #1070 0x00007f396ff27a17 in operator()<std::basic_string<char>, bool, std::basic_string<char> > (
>     t3="{\"method\":\"update\",\"data\":{\"plot_trigger:shiny.action\":2}}", t2=@0x7ffc4b3b581c: false, t1="209221136",
>     this=0x40f448f8) at /usr/lib64/R/library/Rcpp/include/Rcpp/generated/Function__operator.h:45
>
> #1071 RWebApplication::onWSMessage (this=0x40f448d0, pConn=<optimized out>, binary=false, data=<optimized out>,
>     len=<optimized out>) at httpuv.cpp:284
> #1072 0x00007f396ff2d064 in WebSocketConnection::onFrameComplete (this=0xc787610) at websockets.cpp:313
> #1073 0x00007f396ff2d2cd in WSHyBiParser::read (this=0x1e1d3da0, data=0x4487c630 "", len=0) at websockets.cpp:200
> #1074 0x00007f396ff1d2df in HttpRequest::_on_request_read (this=0x2a4a3bf0, nread=64, buf=...) at http.cpp:343
> #1075 0x00007f396ff31e4a in uv__read (stream=stream at entry=0x2a4a3c08) at src/unix/stream.c:1020
> #1076 0x00007f396ff32500 in uv__stream_io (loop=<optimized out>, w=0x2a4a3c78, events=1) at src/unix/stream.c:1115
> #1077 0x00007f396ff38ddd in uv__io_poll (loop=loop at entry=0x7f3970153fa0 <default_loop_struct>, timeout=99)
>     at src/unix/linux-core.c:211
> #1078 0x00007f396ff2df7c in uv_run (loop=0x7f3970153fa0 <default_loop_struct>, mode=<optimized out>) at src/unix/core.c:317
> #1079 0x00007f396ff20584 in run (timeoutMillis=<optimized out>) at httpuv.cpp:405
> #1080 0x00007f396ff130bc in httpuv_run (timeoutMillisSEXP=0x19f67e68) at RcppExports.cpp:83
> #1081 0x00007f397ede7edd in do_dotcall () from /usr/lib64/R/lib/libR.so
> #1082 0x00007f397ee2b831 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1083 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #1084 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1085 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1086 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1087 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #1088 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1089 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1090 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> #1091 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1092 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1093 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1094 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #1095 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1096 0x00007f397ee323d2 in do_while () from /usr/lib64/R/lib/libR.so
> #1097 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1098 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #1099 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1100 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #1101 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1102 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #1103 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> #1104 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1105 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1106 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1107 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #1108 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1109 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1110 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1111 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> #1112 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1113 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1114 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1115 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> #1116 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1117 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> #1118 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> #1119 0x00007f397ee54e42 in Rf_ReplIteration () from /usr/lib64/R/lib/libR.so
> #1120 0x00007f397ee55221 in R_ReplConsole () from /usr/lib64/R/lib/libR.so
> #1121 0x00007f397ee552df in run_Rmainloop () from /usr/lib64/R/lib/libR.so
> #1122 0x000000000040080b in main ()
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From ilia-kats at gmx.net  Wed Jul 12 18:41:37 2017
From: ilia-kats at gmx.net (Ilia Kats)
Date: Wed, 12 Jul 2017 18:41:37 +0200
Subject: [Rd] italic font on cairo devices in R 3.4
In-Reply-To: <61d483b0-b6a5-7811-9a80-34dcaed55c81@stat.auckland.ac.nz>
References: <2093e0fa-f923-0822-60d2-7509d38224af@gmx.net>
 <61d483b0-b6a5-7811-9a80-34dcaed55c81@stat.auckland.ac.nz>
Message-ID: <4f527daa-9959-4d42-b92b-9457e1c402db@gmx.net>

FYI, I now have a second confirmed Mac OS system (with R 3.4.1) where 
the text is not rendered as italic.

Ilia



-------- Original Message --------
Subject: Re: [Rd] italic font on cairo devices in R 3.4
Date: 2017-07-12 05:48:24 +0200
From: Paul Murrell
To: ilia-kats, r-devel
> Hi
>
> Do you have the 'fonts-texgyre' (Debian) package installed?
> If not, does installing that help?
>
> Paul
>
> On 07/07/17 20:30, Ilia Kats wrote:
>> [cross-post from R-help]
>>
>> Hi all,
>>
>> I have the following problem: Since R 3.4.0, italic fonts rendered on 
>> Cairo devices appear pixelated. Here's a minimal example:
>> cairo_pdf('test.pdf')
>> plot(1:10, ylab=expression(italic(test)))
>> dev.off()
>>
>> The same problem occurs with bolditalic, but not bold. I am using 
>> Debian Stretch. Several friends tried the same on their machines, 
>> another Debian machine has the same problem. On MacOSX the output was 
>> not pixelated, but it wasn't italic either. Ubuntu 16.04.2 xenial 
>> works fine. My impression is that R somehow can't find the proper 
>> font to use and falls back to something weird. Ideas?
>>
>> Note that I'm not subscribed to the list, so please CC me in replies.
>>
>> Cheers, Ilia
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>

-- 
Linux - Where do you want to fly today?
-- Unknown source


From antonio.jordan at dean.com  Thu Jul 13 01:47:38 2017
From: antonio.jordan at dean.com (IT Infrastructure)
Date: Wed, 12 Jul 2017 23:47:38 +0000
Subject: [Rd] Bug in libR.so (R 3.4.1 Single Candle)
In-Reply-To: <1ca87e50-7576-e206-290d-ed3c7e6a1967@gmail.com>
References: <20170712160629.GA76844@dean.com>
 <1ca87e50-7576-e206-290d-ed3c7e6a1967@gmail.com>
Message-ID: <20170712234738.GA25114@dean.com>

Thanks for the tip and the quick reply. Will try to narrow the scope and repost if appropiate.

On Wed, Jul 12, 2017 at 12:40:50PM -0400, Duncan Murdoch wrote:
> On 12/07/2017 12:06 PM, IT Infrastructure via R-devel wrote:
> > Hi all,
> > 
> > I believe I have found a bug in the current version of R.
> 
> You don't present any evidence of one.
> 
> What your stack trace looks like is an infinite regress, e.g. an R function
> that calls itself (or possibly a more complicated loop).  For example, I see
> do_lapply (the C function corresponding to the lapply() function in R) 18
> times.  It's not common for lapply() to call an expression that calls
> lapply() even once; 18 times seems like a programming error.
> 
> This could be an error in R or Shiny, but more commonly such things are user
> errors.
> 
> To get R core to look at this, you'll need to simplify it to something self
> contained that doesn't make use of non-base packages.
> 
> Duncan Murdoch
> 
> 
>  Bug manifested itself while testing a shiny app in both the R console and
> in Rstudio. I've tried a complete fresh install of R, Rstudio, & Shiny with
> the same results. Also tried switching kernel versions (As I know stack
> clash fixes have been breaking things lately), and Java versions with no
> better luck. Attached backtrace is from a box with fully patched CentOS 7
> kernel 3.10.0-514.26.2.el7.x86_64|R 3.4.1|Rstudio 1.0.143|Shiny
> 1.5.3.838|Java-1.8.0-openjdk (latest build). Also tested on kernels
> 3.10.0-514.26.2.el7.x86_64, 3.10.0-514.26.1.el7.x86_64,
> 3.10.0-514.21.2.el7.x86_64, 3.10.0-514.16.1.el7.x86_64|R version
> 3.4.0|Java-1.7. So I launch my Shiny app and it runs fine, no errors, first
> interaction with the app through the UI works no problem, trying the same
> action again or any other action give me the 'previous R sesion was
> abnormally terminated due to an unexpected crash' message. Only error in
> logs is a simple 'ERROR ses
> >  sion hadabend; LOGGED FROM: rstudio::core::Error<unnamed>::rInit(const rstudio::r::session::RInitInfo&) /root/rstudio/src/cpp/session/SessionMain.cpp:1934'. Googled around for a workaround or fix and non of the proposed fixes I came across worked for me. Even resetting or completely deleting .rstudio, .Rdata, and user R directory. Thanks for taking a look!
> > 
> > BackTrace:
> > 
> > Program received signal SIGSEGV, Segmentation fault.
> > 0x00007f397ee1784b in bcEval () from /usr/lib64/R/lib/libR.so
> > (gdb) bt
> > #0  0x00007f397ee1784b in bcEval () from /usr/lib64/R/lib/libR.so
> > #1  0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #2  0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #3  0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #4  0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #5  0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #6  0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #7  0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #8  0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #9  0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #10 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #11 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #12 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #13 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #14 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #15 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #16 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #17 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #18 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #19 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #20 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #21 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #22 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #23 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #24 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #25 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #26 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #27 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #28 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #29 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #30 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #31 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #32 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #33 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #34 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #35 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #36 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #37 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #38 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #39 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #40 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #41 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #42 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #43 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #44 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #45 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #46 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #47 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #48 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #49 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #50 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #51 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #52 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #53 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #54 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #55 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #56 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #57 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #58 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #59 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #60 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #61 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #62 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #63 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #64 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #65 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #66 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #67 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #68 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #69 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #70 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #71 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #72 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #73 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #74 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #75 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #76 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #77 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #78 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #79 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #80 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #81 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #82 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #83 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #84 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #85 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #86 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #87 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #88 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #89 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #90 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #91 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #92 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #93 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #94 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #95 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #96 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #97 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #98 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #99 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #100 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #101 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #102 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #103 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #104 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #105 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #106 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #107 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #108 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #109 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #110 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #111 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #112 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #113 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #114 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #115 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #116 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #117 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #118 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #119 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #120 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #121 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #122 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #123 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #124 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #125 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #126 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #127 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #128 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #129 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #130 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #131 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #132 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #133 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #134 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #135 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #136 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #137 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #138 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #139 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #140 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #141 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #142 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #143 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #144 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #145 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #146 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #147 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #148 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #149 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #150 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #151 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #152 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #153 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #154 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #155 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #156 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #157 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #158 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #159 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #160 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #161 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #162 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #163 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #164 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #165 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #166 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #167 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #168 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #169 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #170 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #171 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #172 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #173 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #174 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #175 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #176 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #177 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #178 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #179 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #180 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #181 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #182 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #183 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #184 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #185 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #186 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #187 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #188 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #189 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #190 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #191 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #192 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #193 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #194 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #195 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #196 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #197 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #198 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #199 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #200 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #201 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #202 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #203 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #204 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #205 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #206 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #207 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #208 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #209 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #210 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #211 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #212 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #213 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #214 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #215 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #216 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #217 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #218 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #219 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #220 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #221 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #222 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #223 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #224 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #225 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #226 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #227 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #228 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #229 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #230 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #231 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #232 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #233 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #234 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #235 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #236 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #237 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #238 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #239 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #240 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #241 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #242 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #243 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #244 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #245 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #246 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #247 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #248 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #249 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #250 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #251 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #252 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #253 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #254 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #255 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #256 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #257 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #258 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #259 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #260 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #261 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #262 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #263 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #264 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #265 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #266 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #267 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #268 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #269 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #270 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #271 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #272 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #273 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #274 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #275 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #276 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #277 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #278 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #279 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #280 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #281 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #282 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #283 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #284 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #285 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #286 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #287 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #288 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #289 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #290 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #291 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #292 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #293 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #294 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #295 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #296 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #297 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #298 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #299 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #300 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #301 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #302 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #303 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #304 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #305 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #306 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #307 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #308 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #309 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #310 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #311 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #312 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #313 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #314 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #315 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #316 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #317 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #318 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #319 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #320 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #321 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #322 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #323 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #324 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #325 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #326 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #327 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #328 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #329 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #330 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #331 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #332 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #333 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #334 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #335 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #336 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #337 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #338 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #339 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #340 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #341 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #342 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #343 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #344 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #345 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #346 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #347 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #348 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #349 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #350 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #351 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #352 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #353 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #354 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #355 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #356 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #357 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #358 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #359 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #360 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #361 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #362 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #363 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #364 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #365 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #366 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #367 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #368 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #369 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #370 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #371 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #372 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #373 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #374 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #375 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #376 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #377 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #378 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #379 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #380 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #381 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #382 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #383 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #384 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #385 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #386 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #387 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #388 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #389 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #390 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #391 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #392 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #393 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #394 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #395 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #396 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #397 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #398 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #399 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #400 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #401 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #402 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #403 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #404 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #405 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #406 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #407 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #408 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #409 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #410 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #411 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #412 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #413 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #414 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #415 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #416 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #417 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #418 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #419 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #420 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #421 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #422 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #423 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #424 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #425 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #426 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #427 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #428 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #429 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #430 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #431 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #432 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #433 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #434 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #435 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #436 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #437 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #438 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #439 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #440 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #441 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #442 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #443 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #444 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #445 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #446 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #447 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #448 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #449 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #450 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #451 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #452 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #453 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #454 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #455 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #456 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #457 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #458 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #459 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #460 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #461 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #462 0x00007f397ee2b2cc in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #463 0x00007f397ee62912 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #464 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #465 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #466 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #467 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #468 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #469 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #470 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #471 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #472 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #473 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #474 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #475 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #476 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #477 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #478 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #479 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #480 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #481 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #482 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #483 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #484 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #485 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #486 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #487 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #488 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #489 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #490 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #491 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #492 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #493 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #494 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #495 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #496 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #497 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #498 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #499 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #500 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #501 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #502 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #503 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #504 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #505 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #506 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #507 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #508 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #509 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #510 0x00007f397ee2c6f8 in R_cmpfun1 () from /usr/lib64/R/lib/libR.so
> > #511 0x00007f397ee2c7ab in R_cmpfun () from /usr/lib64/R/lib/libR.so
> > #512 0x00007f397ee2d2fe in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #513 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #514 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #515 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #516 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #517 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #518 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
> > #519 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #520 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #521 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #522 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #523 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #524 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #525 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #526 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #527 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #528 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #529 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #530 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #531 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #532 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #533 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #534 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #535 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #536 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #537 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
> > #538 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #539 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #540 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #541 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #542 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #543 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #544 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #545 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #546 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #547 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #548 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #549 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #550 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #551 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #552 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #553 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #554 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #555 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #556 0x00007f397ee564f3 in do_mapply () from /usr/lib64/R/lib/libR.so
> > #557 0x00007f397ee1b6bd in bcEval () from /usr/lib64/R/lib/libR.so
> > #558 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #559 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #560 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #561 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #562 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #563 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #564 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #565 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #566 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #567 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #568 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #569 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #570 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #571 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #572 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #573 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #574 0x00007f397ee61fc4 in dispatchMethod () from /usr/lib64/R/lib/libR.so
> > #575 0x00007f397ee6239b in Rf_usemethod () from /usr/lib64/R/lib/libR.so
> > #576 0x00007f397ee62724 in do_usemethod () from /usr/lib64/R/lib/libR.so
> > #577 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #578 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #579 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #580 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #581 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #582 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #583 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #584 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #585 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
> > #586 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #587 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #588 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #589 0x00007f397ee302cf in do_eval () from /usr/lib64/R/lib/libR.so
> > #590 0x00007f397ee1b6bd in bcEval () from /usr/lib64/R/lib/libR.so
> > #591 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #592 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #593 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #594 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #595 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #596 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #597 0x00007f397ee307e1 in do_withVisible () from /usr/lib64/R/lib/libR.so
> > #598 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #599 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #600 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #601 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #602 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #603 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #604 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #605 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #606 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #607 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #608 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #609 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #610 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #611 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #612 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #613 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #614 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #615 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #616 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #617 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #618 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #619 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #620 0x00007f397edb9e36 in do_docall () from /usr/lib64/R/lib/libR.so
> > #621 0x00007f397ee1b6bd in bcEval () from /usr/lib64/R/lib/libR.so
> > #622 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #623 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #624 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #625 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #626 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #627 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #628 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #629 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
> > #630 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #631 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #632 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #633 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #634 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #635 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #636 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #637 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #638 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #639 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #640 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #641 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #642 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #643 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #644 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #645 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #646 0x00007f397ee307e1 in do_withVisible () from /usr/lib64/R/lib/libR.so
> > #647 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #648 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #649 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #650 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #651 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #652 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #653 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #654 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #655 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #656 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #657 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #658 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #659 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
> > #660 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #661 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #662 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #663 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #664 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #665 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #666 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #667 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #668 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #669 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #670 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #671 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #672 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #673 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #674 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #675 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #676 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #677 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #678 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #679 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #680 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #681 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #682 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #683 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #684 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #685 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #686 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #687 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #688 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #689 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #690 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #691 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #692 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #693 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #694 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #695 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #696 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #697 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #698 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #699 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #700 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #701 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #702 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #703 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #704 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #705 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #706 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #707 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #708 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #709 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #710 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #711 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #712 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #713 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #714 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #715 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #716 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #717 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #718 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #719 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #720 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #721 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #722 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #723 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #724 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #725 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #726 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #727 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #728 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #729 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #730 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #731 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #732 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #733 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #734 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #735 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #736 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #737 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #738 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #739 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #740 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #741 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #742 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #743 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #744 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #745 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #746 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #747 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #748 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #749 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #750 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #751 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #752 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #753 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #754 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #755 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #756 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #757 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #758 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #759 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #760 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #761 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #762 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #763 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #764 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #765 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #766 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #767 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #768 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #769 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #770 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #771 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #772 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #773 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #774 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #775 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #776 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #777 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #778 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #779 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #780 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #781 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #782 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #783 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #784 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #785 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #786 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #787 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #788 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #789 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #790 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #791 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #792 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #793 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #794 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #795 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #796 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #797 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #798 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #799 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #800 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #801 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #802 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #803 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #804 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #805 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #806 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #807 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #808 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #809 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #810 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #811 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #812 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #813 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #814 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #815 0x00007f397ee2f09e in do_set () from /usr/lib64/R/lib/libR.so
> > #816 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #817 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #818 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #819 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #820 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #821 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #822 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #823 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #824 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #825 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #826 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #827 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #828 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #829 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #830 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #831 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #832 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #833 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #834 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #835 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #836 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #837 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #838 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #839 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #840 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #841 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #842 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #843 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #844 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #845 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #846 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #847 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #848 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #849 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #850 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #851 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #852 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #853 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #854 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #855 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #856 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #857 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #858 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #859 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #860 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #861 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #862 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #863 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #864 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #865 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #866 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #867 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #868 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #869 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #870 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #871 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #872 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #873 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #874 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #875 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #876 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #877 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #878 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #879 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #880 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #881 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #882 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #883 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #884 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #885 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #886 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #887 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #888 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #889 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #890 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #891 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #892 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #893 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #894 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #895 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #896 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #897 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #898 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #899 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #900 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #901 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #902 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #903 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #904 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #905 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #906 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #907 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #908 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #909 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #910 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #911 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #912 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #913 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #914 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #915 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #916 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #917 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #918 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #919 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #920 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #921 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #922 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #923 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #924 0x00007f397ee2f5cc in R_forceAndCall () from /usr/lib64/R/lib/libR.so
> > #925 0x00007f397ed83d92 in do_lapply () from /usr/lib64/R/lib/libR.so
> > #926 0x00007f397ee60319 in do_internal () from /usr/lib64/R/lib/libR.so
> > #927 0x00007f397ee1b817 in bcEval () from /usr/lib64/R/lib/libR.so
> > #928 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #929 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #930 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #931 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #932 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #933 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #934 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #935 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #936 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #937 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #938 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #939 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #940 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #941 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #942 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #943 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #944 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #945 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #946 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #947 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #948 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #949 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #950 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #951 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #952 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #953 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #954 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #955 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #956 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #957 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #958 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #959 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #960 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #961 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #962 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #963 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #964 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #965 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #966 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #967 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #968 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #969 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #970 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #971 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #972 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #973 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #974 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #975 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #976 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #977 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #978 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #979 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #980 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #981 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #982 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #983 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #984 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #985 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #986 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #987 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #988 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #989 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #990 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #991 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #992 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #993 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #994 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #995 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #996 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #997 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #998 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #999 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1000 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #1001 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #1002 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1003 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #1004 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #1005 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1006 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1007 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #1008 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1009 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1010 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #1011 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1012 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1013 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #1014 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1015 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1016 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #1017 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1018 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1019 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #1020 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1021 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1022 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1023 0x00007f397ee302cf in do_eval () from /usr/lib64/R/lib/libR.so
> > #1024 0x00007f397ee1b6bd in bcEval () from /usr/lib64/R/lib/libR.so
> > #1025 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1026 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1027 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1028 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #1029 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #1030 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1031 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #1032 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #1033 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1034 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #1035 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #1036 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1037 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #1038 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #1039 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1040 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #1041 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #1042 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1043 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1044 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #1045 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1046 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1047 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #1048 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1049 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1050 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #1051 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1052 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #1053 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #1054 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1055 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #1056 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #1057 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1058 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1059 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #1060 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1061 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1062 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #1063 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1064 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1065 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #1066 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1067 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1068 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1069 0x00007f396ff17026 in Rcpp::Rcpp_eval (expr=<optimized out>, env=<optimized out>)
> >     at /usr/lib64/R/library/Rcpp/include/Rcpp/api/meat/Rcpp_eval.h:43
> > ---Type <return> to continue, or q <return> to quit---
> > #1070 0x00007f396ff27a17 in operator()<std::basic_string<char>, bool, std::basic_string<char> > (
> >     t3="{\"method\":\"update\",\"data\":{\"plot_trigger:shiny.action\":2}}", t2=@0x7ffc4b3b581c: false, t1="209221136",
> >     this=0x40f448f8) at /usr/lib64/R/library/Rcpp/include/Rcpp/generated/Function__operator.h:45
> > 
> > #1071 RWebApplication::onWSMessage (this=0x40f448d0, pConn=<optimized out>, binary=false, data=<optimized out>,
> >     len=<optimized out>) at httpuv.cpp:284
> > #1072 0x00007f396ff2d064 in WebSocketConnection::onFrameComplete (this=0xc787610) at websockets.cpp:313
> > #1073 0x00007f396ff2d2cd in WSHyBiParser::read (this=0x1e1d3da0, data=0x4487c630 "", len=0) at websockets.cpp:200
> > #1074 0x00007f396ff1d2df in HttpRequest::_on_request_read (this=0x2a4a3bf0, nread=64, buf=...) at http.cpp:343
> > #1075 0x00007f396ff31e4a in uv__read (stream=stream at entry=0x2a4a3c08) at src/unix/stream.c:1020
> > #1076 0x00007f396ff32500 in uv__stream_io (loop=<optimized out>, w=0x2a4a3c78, events=1) at src/unix/stream.c:1115
> > #1077 0x00007f396ff38ddd in uv__io_poll (loop=loop at entry=0x7f3970153fa0 <default_loop_struct>, timeout=99)
> >     at src/unix/linux-core.c:211
> > #1078 0x00007f396ff2df7c in uv_run (loop=0x7f3970153fa0 <default_loop_struct>, mode=<optimized out>) at src/unix/core.c:317
> > #1079 0x00007f396ff20584 in run (timeoutMillis=<optimized out>) at httpuv.cpp:405
> > #1080 0x00007f396ff130bc in httpuv_run (timeoutMillisSEXP=0x19f67e68) at RcppExports.cpp:83
> > #1081 0x00007f397ede7edd in do_dotcall () from /usr/lib64/R/lib/libR.so
> > #1082 0x00007f397ee2b831 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1083 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #1084 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1085 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1086 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1087 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #1088 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1089 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1090 0x00007f397ee23a35 in bcEval () from /usr/lib64/R/lib/libR.so
> > #1091 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1092 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1093 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1094 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #1095 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1096 0x00007f397ee323d2 in do_while () from /usr/lib64/R/lib/libR.so
> > #1097 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1098 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #1099 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1100 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #1101 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1102 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #1103 0x00007f397ee2a79a in bcEval () from /usr/lib64/R/lib/libR.so
> > #1104 0x00007f397ee2b218 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1105 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1106 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1107 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #1108 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1109 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1110 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1111 0x00007f397ee2bb5e in forcePromise () from /usr/lib64/R/lib/libR.so
> > #1112 0x00007f397ee2b897 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1113 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1114 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1115 0x00007f397ee2dfac in do_begin () from /usr/lib64/R/lib/libR.so
> > #1116 0x00007f397ee2b605 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1117 0x00007f397ee2d28f in R_execClosure () from /usr/lib64/R/lib/libR.so
> > #1118 0x00007f397ee2b3d4 in Rf_eval () from /usr/lib64/R/lib/libR.so
> > #1119 0x00007f397ee54e42 in Rf_ReplIteration () from /usr/lib64/R/lib/libR.so
> > #1120 0x00007f397ee55221 in R_ReplConsole () from /usr/lib64/R/lib/libR.so
> > #1121 0x00007f397ee552df in run_Rmainloop () from /usr/lib64/R/lib/libR.so
> > #1122 0x000000000040080b in main ()
> > 
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> > 
>


From marc_schwartz at me.com  Thu Jul 13 22:08:12 2017
From: marc_schwartz at me.com (Marc Schwartz)
Date: Thu, 13 Jul 2017 15:08:12 -0500
Subject: [Rd] Proposed Patch for poly.Rd
Message-ID: <DE3B9ECF-8CE2-460F-AAFC-4B6DFAAE958D@me.com>

Hi All,

As per the discussion today on R-Help:

  https://stat.ethz.ch/pipermail/r-help/2017-July/448132.html

I am attaching a proposed patch for poly.Rd to provide clarifying wording relative to naming the 'degree' argument explicitly, in the case where the 'x' argument is a matrix, rather than a vector.

This is based upon the svn trunk version of poly.Rd.

Thanks for your consideration.

Regards,

Marc Schwartz

-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: patch.txt
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20170713/7c923b4a/attachment.txt>
-------------- next part --------------



From murdoch.duncan at gmail.com  Thu Jul 13 22:22:35 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Thu, 13 Jul 2017 16:22:35 -0400
Subject: [Rd] Proposed Patch for poly.Rd
In-Reply-To: <DE3B9ECF-8CE2-460F-AAFC-4B6DFAAE958D@me.com>
References: <DE3B9ECF-8CE2-460F-AAFC-4B6DFAAE958D@me.com>
Message-ID: <600dfbc3-cfbc-110f-5ff7-965202c21a88@gmail.com>

On 13/07/2017 4:08 PM, Marc Schwartz wrote:
> Hi All,
>
> As per the discussion today on R-Help:
>
>   https://stat.ethz.ch/pipermail/r-help/2017-July/448132.html
>
> I am attaching a proposed patch for poly.Rd to provide clarifying wording relative to naming the 'degree' argument explicitly, in the case where the 'x' argument is a matrix, rather than a vector.
>
> This is based upon the svn trunk version of poly.Rd.

I don't think this is the right fix.  The use of the unnamed 2nd arg as 
degree happens whether the first arg is a matrix or not.

I didn't read the whole thread in detail, but it appears there's a bug 
somewhere, in the report or in the poly() code or in the plsr() code. 
That bug should be reported on the bug list if it turns out to be in 
base R, and to the package maintainer if it is in plsr().

Duncan Murdoch


From marc_schwartz at me.com  Thu Jul 13 22:37:15 2017
From: marc_schwartz at me.com (Marc Schwartz)
Date: Thu, 13 Jul 2017 15:37:15 -0500
Subject: [Rd] Proposed Patch for poly.Rd
In-Reply-To: <600dfbc3-cfbc-110f-5ff7-965202c21a88@gmail.com>
References: <DE3B9ECF-8CE2-460F-AAFC-4B6DFAAE958D@me.com>
 <600dfbc3-cfbc-110f-5ff7-965202c21a88@gmail.com>
Message-ID: <5DD6CF21-E2D0-4475-8CF9-D05504279499@me.com>


> On Jul 13, 2017, at 3:22 PM, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> 
> On 13/07/2017 4:08 PM, Marc Schwartz wrote:
>> Hi All,
>> 
>> As per the discussion today on R-Help:
>> 
>>  https://stat.ethz.ch/pipermail/r-help/2017-July/448132.html
>> 
>> I am attaching a proposed patch for poly.Rd to provide clarifying wording relative to naming the 'degree' argument explicitly, in the case where the 'x' argument is a matrix, rather than a vector.
>> 
>> This is based upon the svn trunk version of poly.Rd.
> 
> I don't think this is the right fix.  The use of the unnamed 2nd arg as degree happens whether the first arg is a matrix or not.
> 
> I didn't read the whole thread in detail, but it appears there's a bug somewhere, in the report or in the poly() code or in the plsr() code. That bug should be reported on the bug list if it turns out to be in base R, and to the package maintainer if it is in plsr().
> 
> Duncan Murdoch


Duncan,

Thanks for your reply. You only really need to read that last post in the thread linked to above.

I won't deny the possibility of a bug in poly(), relative to the handling of 'x' as a matrix. The behavior occurs in the poly() function in a pure stand alone fashion, without the need for plsr():

x1 <- runif(20)
x2 <- runif(20)
mx <- cbind(x1, x2)

> poly(mx, 2)
Error in poly(dots[[i]], degree, raw = raw, simple = raw) : 
  'degree' must be less than number of unique points

The above error occurs because of the way in which 'mx' is transformed internally in poly(), as per the R-Help post I linked to above.


Compare that to:

> poly(mx, degree = 2)
              1.0          2.0         0.1          1.1         0.2
 [1,] -0.11175349 -0.112802655  0.34729146 -0.038811031  0.29371194
 [2,]  0.27620511 -0.102592711  0.27672559  0.076433023  0.10192546
 [3,]  0.31709686 -0.000822981 -0.06017089 -0.019080000 -0.20283645
 [4,] -0.05873472 -0.213373684  0.26314361 -0.015455666  0.07009778
 [5,] -0.17389885  0.046175314  0.08393899 -0.014596893 -0.19610518
 [6,] -0.07143282 -0.192226574  0.12931566 -0.009237383 -0.15572309
 [7,] -0.20924410  0.156380030 -0.38783860  0.081152937  0.46977236
 [8,]  0.09192574 -0.322960534 -0.13012298 -0.011961651 -0.13946871
 [9,] -0.08030862 -0.176345544 -0.11855987  0.009521379 -0.15294790
[10,]  0.26551532 -0.126030940 -0.09225246 -0.024494442 -0.17918115
[11,] -0.16961102  0.033781845  0.23980484 -0.040673544  0.01924080
[12,] -0.23503411  0.245845222  0.37898576 -0.089074579  0.39427472
[13,]  0.44343189  0.434902694  0.19305658  0.085607445 -0.06804699
[14,] -0.16429372  0.018706099 -0.04315970  0.007090868 -0.21166328
[15,]  0.04616179 -0.317237087 -0.09818924 -0.004532591 -0.17379927
[16,] -0.20148531  0.130959507 -0.32805340  0.066097939  0.27578123
[17,] -0.25585213  0.323634018 -0.34406268  0.088029169  0.32460950
[18,] -0.21168308  0.164513794 -0.10037452  0.021247587 -0.17173927
[19,]  0.41817752  0.333143463 -0.04018127 -0.016802902 -0.21294380
[20,]  0.08481772 -0.323649275 -0.16929688 -0.014359375 -0.08495871
attr(,"degree")
[1] 1 2 1 2 2
attr(,"coefs")
attr(,"coefs")[[1]]
attr(,"coefs")[[1]]$alpha
[1] 0.3596862 0.5799695

attr(,"coefs")[[1]]$norm2
[1]  1.000000 20.000000  1.898620  0.109334


attr(,"coefs")[[2]]
attr(,"coefs")[[2]]$alpha
[1] 0.5123548 0.5290189

attr(,"coefs")[[2]]$norm2
[1]  1.0000000 20.0000000  1.5765605  0.1255148


attr(,"class")
[1] "poly"   "matrix"



Thoughts?

Regards,

Marc


From murdoch.duncan at gmail.com  Fri Jul 14 00:00:07 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Thu, 13 Jul 2017 18:00:07 -0400
Subject: [Rd] Proposed Patch for poly.Rd
In-Reply-To: <5DD6CF21-E2D0-4475-8CF9-D05504279499@me.com>
References: <DE3B9ECF-8CE2-460F-AAFC-4B6DFAAE958D@me.com>
 <600dfbc3-cfbc-110f-5ff7-965202c21a88@gmail.com>
 <5DD6CF21-E2D0-4475-8CF9-D05504279499@me.com>
Message-ID: <c409c5dc-0f22-a694-84da-8c3803eacff5@gmail.com>

On 13/07/2017 4:37 PM, Marc Schwartz wrote:
>
>> On Jul 13, 2017, at 3:22 PM, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>
>> On 13/07/2017 4:08 PM, Marc Schwartz wrote:
>>> Hi All,
>>>
>>> As per the discussion today on R-Help:
>>>
>>>  https://stat.ethz.ch/pipermail/r-help/2017-July/448132.html
>>>
>>> I am attaching a proposed patch for poly.Rd to provide clarifying wording relative to naming the 'degree' argument explicitly, in the case where the 'x' argument is a matrix, rather than a vector.
>>>
>>> This is based upon the svn trunk version of poly.Rd.
>>
>> I don't think this is the right fix.  The use of the unnamed 2nd arg as degree happens whether the first arg is a matrix or not.
>>
>> I didn't read the whole thread in detail, but it appears there's a bug somewhere, in the report or in the poly() code or in the plsr() code. That bug should be reported on the bug list if it turns out to be in base R, and to the package maintainer if it is in plsr().
>>
>> Duncan Murdoch
>
>
> Duncan,
>
> Thanks for your reply. You only really need to read that last post in the thread linked to above.
>
> I won't deny the possibility of a bug in poly(), relative to the handling of 'x' as a matrix. The behavior occurs in the poly() function in a pure stand alone fashion, without the need for plsr():
>
> x1 <- runif(20)
> x2 <- runif(20)
> mx <- cbind(x1, x2)
>
>> poly(mx, 2)
> Error in poly(dots[[i]], degree, raw = raw, simple = raw) :
>   'degree' must be less than number of unique points
>
> The above error occurs because of the way in which 'mx' is transformed internally in poly(), as per the R-Help post I linked to above.
>
>
> Compare that to:
>
>> poly(mx, degree = 2)
>               1.0          2.0         0.1          1.1         0.2
>  [1,] -0.11175349 -0.112802655  0.34729146 -0.038811031  0.29371194
>  [2,]  0.27620511 -0.102592711  0.27672559  0.076433023  0.10192546
>  [3,]  0.31709686 -0.000822981 -0.06017089 -0.019080000 -0.20283645
>  [4,] -0.05873472 -0.213373684  0.26314361 -0.015455666  0.07009778
>  [5,] -0.17389885  0.046175314  0.08393899 -0.014596893 -0.19610518
>  [6,] -0.07143282 -0.192226574  0.12931566 -0.009237383 -0.15572309
>  [7,] -0.20924410  0.156380030 -0.38783860  0.081152937  0.46977236
>  [8,]  0.09192574 -0.322960534 -0.13012298 -0.011961651 -0.13946871
>  [9,] -0.08030862 -0.176345544 -0.11855987  0.009521379 -0.15294790
> [10,]  0.26551532 -0.126030940 -0.09225246 -0.024494442 -0.17918115
> [11,] -0.16961102  0.033781845  0.23980484 -0.040673544  0.01924080
> [12,] -0.23503411  0.245845222  0.37898576 -0.089074579  0.39427472
> [13,]  0.44343189  0.434902694  0.19305658  0.085607445 -0.06804699
> [14,] -0.16429372  0.018706099 -0.04315970  0.007090868 -0.21166328
> [15,]  0.04616179 -0.317237087 -0.09818924 -0.004532591 -0.17379927
> [16,] -0.20148531  0.130959507 -0.32805340  0.066097939  0.27578123
> [17,] -0.25585213  0.323634018 -0.34406268  0.088029169  0.32460950
> [18,] -0.21168308  0.164513794 -0.10037452  0.021247587 -0.17173927
> [19,]  0.41817752  0.333143463 -0.04018127 -0.016802902 -0.21294380
> [20,]  0.08481772 -0.323649275 -0.16929688 -0.014359375 -0.08495871
> attr(,"degree")
> [1] 1 2 1 2 2
> attr(,"coefs")
> attr(,"coefs")[[1]]
> attr(,"coefs")[[1]]$alpha
> [1] 0.3596862 0.5799695
>
> attr(,"coefs")[[1]]$norm2
> [1]  1.000000 20.000000  1.898620  0.109334
>
>
> attr(,"coefs")[[2]]
> attr(,"coefs")[[2]]$alpha
> [1] 0.5123548 0.5290189
>
> attr(,"coefs")[[2]]$norm2
> [1]  1.0000000 20.0000000  1.5765605  0.1255148
>
>
> attr(,"class")
> [1] "poly"   "matrix"
>
>
>
> Thoughts?

I think based on this, there's a bug in poly():  poly(mx, 2) and 
poly(mx, degree = 2) should be the same.  I'll put in a bug report.

Duncan Murdoch


From marc_schwartz at me.com  Fri Jul 14 00:07:36 2017
From: marc_schwartz at me.com (Marc Schwartz)
Date: Thu, 13 Jul 2017 17:07:36 -0500
Subject: [Rd] Proposed Patch for poly.Rd
In-Reply-To: <5DD6CF21-E2D0-4475-8CF9-D05504279499@me.com>
References: <DE3B9ECF-8CE2-460F-AAFC-4B6DFAAE958D@me.com>
 <600dfbc3-cfbc-110f-5ff7-965202c21a88@gmail.com>
 <5DD6CF21-E2D0-4475-8CF9-D05504279499@me.com>
Message-ID: <3CCCE71C-B4A2-4C9D-A27F-18486AEA4F69@me.com>


> On Jul 13, 2017, at 3:37 PM, Marc Schwartz <marc_schwartz at me.com> wrote:
> 
> 
>> On Jul 13, 2017, at 3:22 PM, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>> 
>> On 13/07/2017 4:08 PM, Marc Schwartz wrote:
>>> Hi All,
>>> 
>>> As per the discussion today on R-Help:
>>> 
>>> https://stat.ethz.ch/pipermail/r-help/2017-July/448132.html
>>> 
>>> I am attaching a proposed patch for poly.Rd to provide clarifying wording relative to naming the 'degree' argument explicitly, in the case where the 'x' argument is a matrix, rather than a vector.
>>> 
>>> This is based upon the svn trunk version of poly.Rd.
>> 
>> I don't think this is the right fix.  The use of the unnamed 2nd arg as degree happens whether the first arg is a matrix or not.
>> 
>> I didn't read the whole thread in detail, but it appears there's a bug somewhere, in the report or in the poly() code or in the plsr() code. That bug should be reported on the bug list if it turns out to be in base R, and to the package maintainer if it is in plsr().
>> 
>> Duncan Murdoch
> 
> 
> Duncan,
> 
> Thanks for your reply. You only really need to read that last post in the thread linked to above.
> 
> I won't deny the possibility of a bug in poly(), relative to the handling of 'x' as a matrix. The behavior occurs in the poly() function in a pure stand alone fashion, without the need for plsr():
> 
> x1 <- runif(20)
> x2 <- runif(20)
> mx <- cbind(x1, x2)
> 

<snip>

Duncan,

Tracing through the code for poly() using debug once with:

  poly(mx, 2)

and then with:

  poly(mx, degree = 2)

there is a difference in the transformation of 'mx' internally by the use of:

if (is.matrix(x)) {
    m <- unclass(as.data.frame(cbind(x, ...)))
    return(do.call(polym, c(m, degree = degree, raw = raw, list(coefs = coefs))))
}


In the first case, 'mx' ends up being transformed to:

Browse[2]> m
$x1
 [1] 0.99056941 0.13953093 0.38965567 0.35353514 0.90838486 0.97552474
 [7] 0.01135743 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
[13] 0.31333549 0.97488211 0.54952630 0.71747157 0.31164777 0.81694822
[19] 0.58641410 0.08858699

$x2
 [1] 0.6628658 0.9221436 0.3162418 0.8494452 0.4665010 0.3403719
 [7] 0.4040692 0.4916650 0.9091161 0.2956006 0.3454689 0.3331070
[13] 0.8788974 0.5614636 0.7794396 0.2304009 0.6566537 0.6875646
[19] 0.5110733 0.4122336

$V3
 [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2

attr(,"row.names")
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

Thus, when do.call() is used, m$V3 is passed as the 'x' argument on the third iteration, essentially resulting in:

> polym(rep(2, 20), degree = 2)
Error in poly(dots[[1L]], degree, raw = raw, simple = raw && nd > 1) : 
 'degree' must be less than number of unique points


Note also that in this case, 'dots', which is the result of using list(...) on the initial call, is:

Browse[2]> dots
[[1]]
[1] 2


In the second case:

Browse[2]> m
$x1
 [1] 0.99056941 0.13953093 0.38965567 0.35353514 0.90838486 0.97552474
 [7] 0.01135743 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
[13] 0.31333549 0.97488211 0.54952630 0.71747157 0.31164777 0.81694822
[19] 0.58641410 0.08858699

$x2
 [1] 0.6628658 0.9221436 0.3162418 0.8494452 0.4665010 0.3403719
 [7] 0.4040692 0.4916650 0.9091161 0.2956006 0.3454689 0.3331070
[13] 0.8788974 0.5614636 0.7794396 0.2304009 0.6566537 0.6875646
[19] 0.5110733 0.4122336

attr(,"row.names")
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20


So, there is no m$V3.

Note also that 'dots' ends up being:

Browse[2]> dots
list()


In both cases, 'degree' is indeed 2, but the result of 'list(...)' on the initial function call is quite different.

So, I may be hypo-caffeinated, but if there is a bug here, it may be due to the way in which cbind() is being called in the code above, where the three dots are being used?

I can replicate the presumably correct behavior by using:

  m <- unclass(as.data.frame(cbind(x)))

instead of:

  m <- unclass(as.data.frame(cbind(x, ...)))

But I am not sure if removing the three dots in the cbind() call may have other unintended consequences.

Regards,

Marc


From marc_schwartz at me.com  Fri Jul 14 13:57:26 2017
From: marc_schwartz at me.com (Marc Schwartz)
Date: Fri, 14 Jul 2017 06:57:26 -0500
Subject: [Rd] Proposed Patch for poly.Rd
In-Reply-To: <3CCCE71C-B4A2-4C9D-A27F-18486AEA4F69@me.com>
References: <DE3B9ECF-8CE2-460F-AAFC-4B6DFAAE958D@me.com>
 <600dfbc3-cfbc-110f-5ff7-965202c21a88@gmail.com>
 <5DD6CF21-E2D0-4475-8CF9-D05504279499@me.com>
 <3CCCE71C-B4A2-4C9D-A27F-18486AEA4F69@me.com>
Message-ID: <C44434BD-CA2A-493C-8DBD-ED15CCB4C2B2@me.com>


> On Jul 13, 2017, at 5:07 PM, Marc Schwartz <marc_schwartz at me.com> wrote:
> 
> 
>> On Jul 13, 2017, at 3:37 PM, Marc Schwartz <marc_schwartz at me.com> wrote:
>> 
>> 
>>> On Jul 13, 2017, at 3:22 PM, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>> 
>>> On 13/07/2017 4:08 PM, Marc Schwartz wrote:
>>>> Hi All,
>>>> 
>>>> As per the discussion today on R-Help:
>>>> 
>>>> https://stat.ethz.ch/pipermail/r-help/2017-July/448132.html
>>>> 
>>>> I am attaching a proposed patch for poly.Rd to provide clarifying wording relative to naming the 'degree' argument explicitly, in the case where the 'x' argument is a matrix, rather than a vector.
>>>> 
>>>> This is based upon the svn trunk version of poly.Rd.
>>> 
>>> I don't think this is the right fix.  The use of the unnamed 2nd arg as degree happens whether the first arg is a matrix or not.
>>> 
>>> I didn't read the whole thread in detail, but it appears there's a bug somewhere, in the report or in the poly() code or in the plsr() code. That bug should be reported on the bug list if it turns out to be in base R, and to the package maintainer if it is in plsr().
>>> 
>>> Duncan Murdoch
>> 
>> 
>> Duncan,
>> 
>> Thanks for your reply. You only really need to read that last post in the thread linked to above.
>> 
>> I won't deny the possibility of a bug in poly(), relative to the handling of 'x' as a matrix. The behavior occurs in the poly() function in a pure stand alone fashion, without the need for plsr():
>> 
>> x1 <- runif(20)
>> x2 <- runif(20)
>> mx <- cbind(x1, x2)
>> 
> 
> <snip>
> 
> Duncan,
> 
> Tracing through the code for poly() using debug once with:
> 
>  poly(mx, 2)
> 
> and then with:
> 
>  poly(mx, degree = 2)
> 
> there is a difference in the transformation of 'mx' internally by the use of:
> 
> if (is.matrix(x)) {
>    m <- unclass(as.data.frame(cbind(x, ...)))
>    return(do.call(polym, c(m, degree = degree, raw = raw, list(coefs = coefs))))
> }
> 
> 
> In the first case, 'mx' ends up being transformed to:
> 
> Browse[2]> m
> $x1
> [1] 0.99056941 0.13953093 0.38965567 0.35353514 0.90838486 0.97552474
> [7] 0.01135743 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
> [13] 0.31333549 0.97488211 0.54952630 0.71747157 0.31164777 0.81694822
> [19] 0.58641410 0.08858699
> 
> $x2
> [1] 0.6628658 0.9221436 0.3162418 0.8494452 0.4665010 0.3403719
> [7] 0.4040692 0.4916650 0.9091161 0.2956006 0.3454689 0.3331070
> [13] 0.8788974 0.5614636 0.7794396 0.2304009 0.6566537 0.6875646
> [19] 0.5110733 0.4122336
> 
> $V3
> [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
> 
> attr(,"row.names")
> [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
> 
> Thus, when do.call() is used, m$V3 is passed as the 'x' argument on the third iteration, essentially resulting in:
> 
>> polym(rep(2, 20), degree = 2)
> Error in poly(dots[[1L]], degree, raw = raw, simple = raw && nd > 1) : 
> 'degree' must be less than number of unique points
> 
> 
> Note also that in this case, 'dots', which is the result of using list(...) on the initial call, is:
> 
> Browse[2]> dots
> [[1]]
> [1] 2
> 
> 
> In the second case:
> 
> Browse[2]> m
> $x1
> [1] 0.99056941 0.13953093 0.38965567 0.35353514 0.90838486 0.97552474
> [7] 0.01135743 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
> [13] 0.31333549 0.97488211 0.54952630 0.71747157 0.31164777 0.81694822
> [19] 0.58641410 0.08858699
> 
> $x2
> [1] 0.6628658 0.9221436 0.3162418 0.8494452 0.4665010 0.3403719
> [7] 0.4040692 0.4916650 0.9091161 0.2956006 0.3454689 0.3331070
> [13] 0.8788974 0.5614636 0.7794396 0.2304009 0.6566537 0.6875646
> [19] 0.5110733 0.4122336
> 
> attr(,"row.names")
> [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
> 
> 
> So, there is no m$V3.
> 
> Note also that 'dots' ends up being:
> 
> Browse[2]> dots
> list()
> 
> 
> In both cases, 'degree' is indeed 2, but the result of 'list(...)' on the initial function call is quite different.
> 
> So, I may be hypo-caffeinated, but if there is a bug here, it may be due to the way in which cbind() is being called in the code above, where the three dots are being used?
> 
> I can replicate the presumably correct behavior by using:
> 
>  m <- unclass(as.data.frame(cbind(x)))
> 
> instead of:
> 
>  m <- unclass(as.data.frame(cbind(x, ...)))
> 
> But I am not sure if removing the three dots in the cbind() call may have other unintended consequences.
> 
> Regards,
> 
> Marc


Duncan,

Some additional information here.

Reviewing the source code for the function in SVN:

  https://svn.r-project.org/R/trunk/src/library/stats/R/contr.poly.R

there is a relevant comment in the code:

 if(is.matrix(x)) { ## FIXME: fails when combined with 'unnamed degree' above
        m <- unclass(as.data.frame(cbind(x, ...)))
	return(do.call(polym, c(m, degree = degree, raw = raw,
				list(coefs=coefs))))
    }


A version review would suggest that the above comment was added to the code back in 2015.

So it would appear that the behavior being discussed here is known.

I am still confused by the need for the '...' in the call to cbind(), which as far as I can tell, has been in the code at least back to 2003, when the poly() code was split from base. I am not sure why one would want to pass on other '...' arguments to cbind(), but I am presumably missing something here.

Regards,

Marc


From maechler at stat.math.ethz.ch  Fri Jul 14 16:30:50 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Fri, 14 Jul 2017 16:30:50 +0200
Subject: [Rd] Proposed Patch for poly.Rd
In-Reply-To: <C44434BD-CA2A-493C-8DBD-ED15CCB4C2B2@me.com>
References: <DE3B9ECF-8CE2-460F-AAFC-4B6DFAAE958D@me.com>
 <600dfbc3-cfbc-110f-5ff7-965202c21a88@gmail.com>
 <5DD6CF21-E2D0-4475-8CF9-D05504279499@me.com>
 <3CCCE71C-B4A2-4C9D-A27F-18486AEA4F69@me.com>
 <C44434BD-CA2A-493C-8DBD-ED15CCB4C2B2@me.com>
Message-ID: <22888.54682.928801.33074@stat.math.ethz.ch>

>>>>> Marc Schwartz <marc_schwartz at me.com>
>>>>>     on Fri, 14 Jul 2017 06:57:26 -0500 writes:

    >> On Jul 13, 2017, at 5:07 PM, Marc Schwartz <marc_schwartz at me.com> wrote:
    >> 
    >> 
    >>> On Jul 13, 2017, at 3:37 PM, Marc Schwartz <marc_schwartz at me.com> wrote:
    >>> 
    >>> 
    >>>> On Jul 13, 2017, at 3:22 PM, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
    >>>> 
    >>>> On 13/07/2017 4:08 PM, Marc Schwartz wrote:
    >>>>> Hi All,
    >>>>> 
    >>>>> As per the discussion today on R-Help:
    >>>>> 
    >>>>> https://stat.ethz.ch/pipermail/r-help/2017-July/448132.html
    >>>>> 
    >>>>> I am attaching a proposed patch for poly.Rd to provide clarifying wording relative to naming the 'degree' argument explicitly, in the case where the 'x' argument is a matrix, rather than a vector.
    >>>>> 
    >>>>> This is based upon the svn trunk version of poly.Rd.
    >>>> 
    >>>> I don't think this is the right fix.  The use of the unnamed 2nd arg as degree happens whether the first arg is a matrix or not.
    >>>> 
    >>>> I didn't read the whole thread in detail, but it appears there's a bug somewhere, in the report or in the poly() code or in the plsr() code. That bug should be reported on the bug list if it turns out to be in base R, and to the package maintainer if it is in plsr().
    >>>> 
    >>>> Duncan Murdoch
    >>> 
    >>> 
    >>> Duncan,
    >>> 
    >>> Thanks for your reply. You only really need to read that last post in the thread linked to above.
    >>> 
    >>> I won't deny the possibility of a bug in poly(), relative to the handling of 'x' as a matrix. The behavior occurs in the poly() function in a pure stand alone fashion, without the need for plsr():
    >>> 
    >>> x1 <- runif(20)
    >>> x2 <- runif(20)
    >>> mx <- cbind(x1, x2)
    >>> 
    >> 
    >> <snip>
    >> 
    >> Duncan,
    >> 
    >> Tracing through the code for poly() using debug once with:
    >> 
    >> poly(mx, 2)
    >> 
    >> and then with:
    >> 
    >> poly(mx, degree = 2)
    >> 
    >> there is a difference in the transformation of 'mx' internally by the use of:
    >> 
    >> if (is.matrix(x)) {
    >> m <- unclass(as.data.frame(cbind(x, ...)))
    >> return(do.call(polym, c(m, degree = degree, raw = raw, list(coefs = coefs))))
    >> }
    >> 
    >> 
    >> In the first case, 'mx' ends up being transformed to:
    >> 
    >> Browse[2]> m
    >> $x1
    >> [1] 0.99056941 0.13953093 0.38965567 0.35353514 0.90838486 0.97552474
    >> [7] 0.01135743 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
    >> [13] 0.31333549 0.97488211 0.54952630 0.71747157 0.31164777 0.81694822
    >> [19] 0.58641410 0.08858699
    >> 
    >> $x2
    >> [1] 0.6628658 0.9221436 0.3162418 0.8494452 0.4665010 0.3403719
    >> [7] 0.4040692 0.4916650 0.9091161 0.2956006 0.3454689 0.3331070
    >> [13] 0.8788974 0.5614636 0.7794396 0.2304009 0.6566537 0.6875646
    >> [19] 0.5110733 0.4122336
    >> 
    >> $V3
    >> [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
    >> 
    >> attr(,"row.names")
    >> [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
    >> 
    >> Thus, when do.call() is used, m$V3 is passed as the 'x' argument on the third iteration, essentially resulting in:
    >> 
    >>> polym(rep(2, 20), degree = 2)
    >> Error in poly(dots[[1L]], degree, raw = raw, simple = raw && nd > 1) : 
    >> 'degree' must be less than number of unique points
    >> 
    >> 
    >> Note also that in this case, 'dots', which is the result of using list(...) on the initial call, is:
    >> 
    >> Browse[2]> dots
    >> [[1]]
    >> [1] 2
    >> 
    >> 
    >> In the second case:
    >> 
    >> Browse[2]> m
    >> $x1
    >> [1] 0.99056941 0.13953093 0.38965567 0.35353514 0.90838486 0.97552474
    >> [7] 0.01135743 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
    >> [13] 0.31333549 0.97488211 0.54952630 0.71747157 0.31164777 0.81694822
    >> [19] 0.58641410 0.08858699
    >> 
    >> $x2
    >> [1] 0.6628658 0.9221436 0.3162418 0.8494452 0.4665010 0.3403719
    >> [7] 0.4040692 0.4916650 0.9091161 0.2956006 0.3454689 0.3331070
    >> [13] 0.8788974 0.5614636 0.7794396 0.2304009 0.6566537 0.6875646
    >> [19] 0.5110733 0.4122336
    >> 
    >> attr(,"row.names")
    >> [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
    >> 
    >> 
    >> So, there is no m$V3.
    >> 
    >> Note also that 'dots' ends up being:
    >> 
    >> Browse[2]> dots
    >> list()
    >> 
    >> 
    >> In both cases, 'degree' is indeed 2, but the result of 'list(...)' on the initial function call is quite different.
    >> 
    >> So, I may be hypo-caffeinated, but if there is a bug here, it may be due to the way in which cbind() is being called in the code above, where the three dots are being used?
    >> 
    >> I can replicate the presumably correct behavior by using:
    >> 
    >> m <- unclass(as.data.frame(cbind(x)))
    >> 
    >> instead of:
    >> 
    >> m <- unclass(as.data.frame(cbind(x, ...)))
    >> 
    >> But I am not sure if removing the three dots in the cbind() call may have other unintended consequences.
    >> 
    >> Regards,
    >> 
    >> Marc


    > Duncan,

    > Some additional information here.
    > Reviewing the source code for the function in SVN:

    > https://svn.r-project.org/R/trunk/src/library/stats/R/contr.poly.R

    > there is a relevant comment in the code:

    > if(is.matrix(x)) { ## FIXME: fails when combined with 'unnamed degree' above
    >   m <- unclass(as.data.frame(cbind(x, ...)))
    >   return(do.call(polym, c(m, degree = degree, raw = raw,
    >                  list(coefs=coefs))))
    > }


    > A version review would suggest that the above comment was added to the code back in 2015.

Yes, by me, possibly here :

   $ svn log -v -c68727
   ------------------------------------------------------------------------
   r68727 | maechler | 2015-07-23 16:14:59 +0200 (Thu, 23 Jul 2015) | 1 line
   Changed paths:
      M /trunk/doc/NEWS.Rd
      M /trunk/src/library/stats/R/contr.poly.R
      M /trunk/src/library/stats/man/poly.Rd
      M /trunk/tests/Examples/stats-Ex.Rout.save
      M /trunk/tests/reg-tests-1c.R

   poly(), polym() now work better notably for prediction
   ------------------------------------------------------------------------
   $ svn-diffB -c68727 doc/NEWS.Rd
   Index: doc/NEWS.Rd
   ===================================================================
   126a127,133
   > 
   >       \item \code{polym()} gains a \code{coefs = NULL} argument and
   >       returns class \code{"poly"} just like \code{poly()} which gets a
   >       new \code{simple=FALSE} option.  They now lead to correct
   >       \code{predict()}ions, e.g., on subsets of the original data.
   >       %% see https://stat.ethz.ch/pipermail/r-devel/2015-July/071532.html


    > So it would appear that the behavior being discussed here is known.

Indeed!  I remember to have spent quite a few hours with the
code and its different uses before committing that patch.

    > I am still confused by the need for the '...' in the call to cbind(), which as far as I can tell, has been in the code at least back to 2003, when the poly() code was split from base. 

    > I am not sure why one would want to pass on other '...' arguments to cbind(), but I am presumably missing something here.

Yes, I think passing the '...' is important there...
OTOH, I'm almost sure that I wrote the 'FIXME' because I thought
one should be able to do things better.
So, I'm happy to e-talk to you about how to get rid of the FIXME
and still remain back-compatible: Notably with the paragraph in  ?poly
|> Details:
|>
|>      Although formally ?degree? should be named (as it follows ?...?),
|>      an unnamed second argument of length 1 will be interpreted as the
|>      degree, such that ?poly(x, 3)? can be used in formulas.

I'm appending an -- I think -- nice and pedagogical example on
how you can use  trace() in an easy but powerful way to see when
'...' is used in one example:

trExp <- quote({
    cat("'...':  "); str(list(...))
    cat("Local variables: "); print(ls.str())
    cat("---end{trace}---------------------\n")
    })
trace(poly, trExp)
trace(polym,trExp)

alm <- lm(stack.loss ~ poly(Air.Flow, Water.Temp, degree=3), stackloss)

which shows as

> alm <- lm(stack.loss ~ poly(Air.Flow, Water.Temp, degree=3), stackloss)
Tracing poly(Air.Flow, Water.Temp, degree = 3) on entry
'...':  List of 1
 $ : num [1:21] 27 27 25 24 22 23 24 24 23 18 ...
Local variables: coefs :  NULL
degree :  num 3
raw :  logi FALSE
simple :  logi FALSE
x :  num [1:21] 80 80 75 62 62 62 62 62 58 58 ...
---end{trace}---------------------
Tracing polym(x, ..., degree = degree, coefs = coefs, raw = raw) on entry
'...':  List of 2
 $ : num [1:21] 80 80 75 62 62 62 62 62 58 58 ...
 $ : num [1:21] 27 27 25 24 22 23 24 24 23 18 ...
Local variables: coefs :  NULL
degree :  num 3
raw :  logi FALSE
---end{trace}---------------------
Tracing poly(dots[[1L]], degree, raw = raw, simple = raw && nd > 1) on entry
'...':  List of 1
 $ : num 3
Local variables: coefs :  NULL
degree :  num 1
raw :  logi FALSE
simple :  logi FALSE
x :  num [1:21] 80 80 75 62 62 62 62 62 58 58 ...
---end{trace}---------------------
Tracing poly(dots[[i]], degree, raw = raw, simple = raw) on entry
'...':  List of 1
 $ : num 3
Local variables: coefs :  NULL
degree :  num 1
raw :  logi FALSE
simple :  logi FALSE
x :  num [1:21] 27 27 25 24 22 23 24 24 23 18 ...
---end{trace}---------------------
>


From maechler at stat.math.ethz.ch  Fri Jul 14 16:50:20 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Fri, 14 Jul 2017 16:50:20 +0200
Subject: [Rd] Proposed Patch for poly.Rd
In-Reply-To: <22888.54682.928801.33074@stat.math.ethz.ch>
References: <DE3B9ECF-8CE2-460F-AAFC-4B6DFAAE958D@me.com>
 <600dfbc3-cfbc-110f-5ff7-965202c21a88@gmail.com>
 <5DD6CF21-E2D0-4475-8CF9-D05504279499@me.com>
 <3CCCE71C-B4A2-4C9D-A27F-18486AEA4F69@me.com>
 <C44434BD-CA2A-493C-8DBD-ED15CCB4C2B2@me.com>
 <22888.54682.928801.33074@stat.math.ethz.ch>
Message-ID: <22888.55852.258809.522240@stat.math.ethz.ch>

>>>>> Martin Maechler <maechler at stat.math.ethz.ch>
>>>>>     on Fri, 14 Jul 2017 16:30:50 +0200 writes:

>>>>> Marc Schwartz <marc_schwartz at me.com>
>>>>>     on Fri, 14 Jul 2017 06:57:26 -0500 writes:

    >>> On Jul 13, 2017, at 5:07 PM, Marc Schwartz <marc_schwartz at me.com> wrote:
    >>> 
    >>> 
    >>>> On Jul 13, 2017, at 3:37 PM, Marc Schwartz <marc_schwartz at me.com> wrote:
    >>>> 
    >>>> 
    >>>>> On Jul 13, 2017, at 3:22 PM, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
    >>>>> 
    >>>>> On 13/07/2017 4:08 PM, Marc Schwartz wrote:
    >>>>>> Hi All,
    >>>>>> 
    >>>>>> As per the discussion today on R-Help:
    >>>>>> 
    >>>>>> https://stat.ethz.ch/pipermail/r-help/2017-July/448132.html
    >>>>>> 
    >>>>>> I am attaching a proposed patch for poly.Rd to provide clarifying wording relative to naming the 'degree' argument explicitly, in the case where the 'x' argument is a matrix, rather than a vector.
    >>>>>> 
    >>>>>> This is based upon the svn trunk version of poly.Rd.
    >>>>> 
    >>>>> I don't think this is the right fix.  The use of the unnamed 2nd arg as degree happens whether the first arg is a matrix or not.
    >>>>> 
    >>>>> I didn't read the whole thread in detail, but it appears there's a bug somewhere, in the report or in the poly() code or in the plsr() code. That bug should be reported on the bug list if it turns out to be in base R, and to the package maintainer if it is in plsr().
    >>>>> 
    >>>>> Duncan Murdoch
    >>>> 
    >>>> 
    >>>> Duncan,
    >>>> 
    >>>> Thanks for your reply. You only really need to read that last post in the thread linked to above.
    >>>> 
    >>>> I won't deny the possibility of a bug in poly(), relative to the handling of 'x' as a matrix. The behavior occurs in the poly() function in a pure stand alone fashion, without the need for plsr():
    >>>> 
    >>>> x1 <- runif(20)
    >>>> x2 <- runif(20)
    >>>> mx <- cbind(x1, x2)
    >>>> 
    >>> 
    >>> <snip>
    >>> 
    >>> Duncan,
    >>> 
    >>> Tracing through the code for poly() using debug once with:
    >>> 
    >>> poly(mx, 2)
    >>> 
    >>> and then with:
    >>> 
    >>> poly(mx, degree = 2)
    >>> 
    >>> there is a difference in the transformation of 'mx' internally by the use of:
    >>> 
    >>> if (is.matrix(x)) {
    >>> m <- unclass(as.data.frame(cbind(x, ...)))
    >>> return(do.call(polym, c(m, degree = degree, raw = raw, list(coefs = coefs))))
    >>> }
    >>> 
    >>> 
    >>> In the first case, 'mx' ends up being transformed to:
    >>> 
    >>> Browse[2]> m
    >>> $x1
    >>> [1] 0.99056941 0.13953093 0.38965567 0.35353514 0.90838486 0.97552474
    >>> [7] 0.01135743 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
    >>> [13] 0.31333549 0.97488211 0.54952630 0.71747157 0.31164777 0.81694822
    >>> [19] 0.58641410 0.08858699
    >>> 
    >>> $x2
    >>> [1] 0.6628658 0.9221436 0.3162418 0.8494452 0.4665010 0.3403719
    >>> [7] 0.4040692 0.4916650 0.9091161 0.2956006 0.3454689 0.3331070
    >>> [13] 0.8788974 0.5614636 0.7794396 0.2304009 0.6566537 0.6875646
    >>> [19] 0.5110733 0.4122336
    >>> 
    >>> $V3
    >>> [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
    >>> 
    >>> attr(,"row.names")
    >>> [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
    >>> 
    >>> Thus, when do.call() is used, m$V3 is passed as the 'x' argument on the third iteration, essentially resulting in:
    >>> 
    >>>> polym(rep(2, 20), degree = 2)
    >>> Error in poly(dots[[1L]], degree, raw = raw, simple = raw && nd > 1) : 
    >>> 'degree' must be less than number of unique points
    >>> 
    >>> 
    >>> Note also that in this case, 'dots', which is the result of using list(...) on the initial call, is:
    >>> 
    >>> Browse[2]> dots
    >>> [[1]]
    >>> [1] 2
    >>> 
    >>> 
    >>> In the second case:
    >>> 
    >>> Browse[2]> m
    >>> $x1
    >>> [1] 0.99056941 0.13953093 0.38965567 0.35353514 0.90838486 0.97552474
    >>> [7] 0.01135743 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
    >>> [13] 0.31333549 0.97488211 0.54952630 0.71747157 0.31164777 0.81694822
    >>> [19] 0.58641410 0.08858699
    >>> 
    >>> $x2
    >>> [1] 0.6628658 0.9221436 0.3162418 0.8494452 0.4665010 0.3403719
    >>> [7] 0.4040692 0.4916650 0.9091161 0.2956006 0.3454689 0.3331070
    >>> [13] 0.8788974 0.5614636 0.7794396 0.2304009 0.6566537 0.6875646
    >>> [19] 0.5110733 0.4122336
    >>> 
    >>> attr(,"row.names")
    >>> [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
    >>> 
    >>> 
    >>> So, there is no m$V3.
    >>> 
    >>> Note also that 'dots' ends up being:
    >>> 
    >>> Browse[2]> dots
    >>> list()
    >>> 
    >>> 
    >>> In both cases, 'degree' is indeed 2, but the result of 'list(...)' on the initial function call is quite different.
    >>> 
    >>> So, I may be hypo-caffeinated, but if there is a bug here, it may be due to the way in which cbind() is being called in the code above, where the three dots are being used?
    >>> 
    >>> I can replicate the presumably correct behavior by using:
    >>> 
    >>> m <- unclass(as.data.frame(cbind(x)))
    >>> 
    >>> instead of:
    >>> 
    >>> m <- unclass(as.data.frame(cbind(x, ...)))
    >>> 
    >>> But I am not sure if removing the three dots in the cbind() call may have other unintended consequences.
    >>> 
    >>> Regards,
    >>> 
    >>> Marc


    >> Duncan,

    >> Some additional information here.
    >> Reviewing the source code for the function in SVN:

    >> https://svn.r-project.org/R/trunk/src/library/stats/R/contr.poly.R

    >> there is a relevant comment in the code:

    >> if(is.matrix(x)) { ## FIXME: fails when combined with 'unnamed degree' above
    >> m <- unclass(as.data.frame(cbind(x, ...)))
    >> return(do.call(polym, c(m, degree = degree, raw = raw,
    >> list(coefs=coefs))))
    >> }


    >> A version review would suggest that the above comment was added to the code back in 2015.

    > Yes, by me, possibly here :

    > $ svn log -v -c68727
    > ------------------------------------------------------------------------
    > r68727 | maechler | 2015-07-23 16:14:59 +0200 (Thu, 23 Jul 2015) | 1 line
    > Changed paths:
    > M /trunk/doc/NEWS.Rd
    > M /trunk/src/library/stats/R/contr.poly.R
    > M /trunk/src/library/stats/man/poly.Rd
    > M /trunk/tests/Examples/stats-Ex.Rout.save
    > M /trunk/tests/reg-tests-1c.R

    > poly(), polym() now work better notably for prediction
    > ------------------------------------------------------------------------
    > $ svn-diffB -c68727 doc/NEWS.Rd
    > Index: doc/NEWS.Rd
    > ===================================================================
    > 126a127,133
    >> 
    >> \item \code{polym()} gains a \code{coefs = NULL} argument and
    >> returns class \code{"poly"} just like \code{poly()} which gets a
    >> new \code{simple=FALSE} option.  They now lead to correct
    >> \code{predict()}ions, e.g., on subsets of the original data.
    >> %% see https://stat.ethz.ch/pipermail/r-devel/2015-July/071532.html


    >> So it would appear that the behavior being discussed here is known.

    > Indeed!  I remember to have spent quite a few hours with the
    > code and its different uses before committing that patch.

    >> I am still confused by the need for the '...' in the call to cbind(), which as far as I can tell, has been in the code at least back to 2003, when the poly() code was split from base. 

    >> I am not sure why one would want to pass on other '...' arguments to cbind(), but I am presumably missing something here.

    > Yes, I think passing the '...' is important there...
    > OTOH, I'm almost sure that I wrote the 'FIXME' because I thought
    > one should be able to do things better.
    > So, I'm happy to e-talk to you about how to get rid of the FIXME
    > and still remain back-compatible: Notably with the paragraph in  ?poly
    > |> Details:
    > |>
    > |>      Although formally ?degree? should be named (as it follows ?...?),
    > |>      an unnamed second argument of length 1 will be interpreted as the
    > |>      degree, such that ?poly(x, 3)? can be used in formulas.

As a matter of fact,  a patch seems very simple, and I am
testing it now.

Won't have much more time today, but will return "on this channel"
later, maybe tomorrow.

Martin


From marc_schwartz at me.com  Fri Jul 14 18:01:03 2017
From: marc_schwartz at me.com (Marc Schwartz)
Date: Fri, 14 Jul 2017 11:01:03 -0500
Subject: [Rd] Proposed Patch for poly.Rd
In-Reply-To: <22888.55852.258809.522240@stat.math.ethz.ch>
References: <DE3B9ECF-8CE2-460F-AAFC-4B6DFAAE958D@me.com>
 <600dfbc3-cfbc-110f-5ff7-965202c21a88@gmail.com>
 <5DD6CF21-E2D0-4475-8CF9-D05504279499@me.com>
 <3CCCE71C-B4A2-4C9D-A27F-18486AEA4F69@me.com>
 <C44434BD-CA2A-493C-8DBD-ED15CCB4C2B2@me.com>
 <22888.54682.928801.33074@stat.math.ethz.ch>
 <22888.55852.258809.522240@stat.math.ethz.ch>
Message-ID: <0B38252A-6749-45F4-885E-73702CC32B53@me.com>


> On Jul 14, 2017, at 9:50 AM, Martin Maechler <maechler at stat.math.ethz.ch> wrote:
> 
>>>>>> Martin Maechler <maechler at stat.math.ethz.ch>
>>>>>>    on Fri, 14 Jul 2017 16:30:50 +0200 writes:
> 
>>>>>> Marc Schwartz <marc_schwartz at me.com>
>>>>>>    on Fri, 14 Jul 2017 06:57:26 -0500 writes:
> 
>>>> On Jul 13, 2017, at 5:07 PM, Marc Schwartz <marc_schwartz at me.com> wrote:
>>>> 
>>>> 
>>>>> On Jul 13, 2017, at 3:37 PM, Marc Schwartz <marc_schwartz at me.com> wrote:
>>>>> 
>>>>> 
>>>>>> On Jul 13, 2017, at 3:22 PM, Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>>>>> 
>>>>>> On 13/07/2017 4:08 PM, Marc Schwartz wrote:
>>>>>>> Hi All,
>>>>>>> 
>>>>>>> As per the discussion today on R-Help:
>>>>>>> 
>>>>>>> https://stat.ethz.ch/pipermail/r-help/2017-July/448132.html
>>>>>>> 
>>>>>>> I am attaching a proposed patch for poly.Rd to provide clarifying wording relative to naming the 'degree' argument explicitly, in the case where the 'x' argument is a matrix, rather than a vector.
>>>>>>> 
>>>>>>> This is based upon the svn trunk version of poly.Rd.
>>>>>> 
>>>>>> I don't think this is the right fix.  The use of the unnamed 2nd arg as degree happens whether the first arg is a matrix or not.
>>>>>> 
>>>>>> I didn't read the whole thread in detail, but it appears there's a bug somewhere, in the report or in the poly() code or in the plsr() code. That bug should be reported on the bug list if it turns out to be in base R, and to the package maintainer if it is in plsr().
>>>>>> 
>>>>>> Duncan Murdoch
>>>>> 
>>>>> 
>>>>> Duncan,
>>>>> 
>>>>> Thanks for your reply. You only really need to read that last post in the thread linked to above.
>>>>> 
>>>>> I won't deny the possibility of a bug in poly(), relative to the handling of 'x' as a matrix. The behavior occurs in the poly() function in a pure stand alone fashion, without the need for plsr():
>>>>> 
>>>>> x1 <- runif(20)
>>>>> x2 <- runif(20)
>>>>> mx <- cbind(x1, x2)
>>>>> 
>>>> 
>>>> <snip>
>>>> 
>>>> Duncan,
>>>> 
>>>> Tracing through the code for poly() using debug once with:
>>>> 
>>>> poly(mx, 2)
>>>> 
>>>> and then with:
>>>> 
>>>> poly(mx, degree = 2)
>>>> 
>>>> there is a difference in the transformation of 'mx' internally by the use of:
>>>> 
>>>> if (is.matrix(x)) {
>>>> m <- unclass(as.data.frame(cbind(x, ...)))
>>>> return(do.call(polym, c(m, degree = degree, raw = raw, list(coefs = coefs))))
>>>> }
>>>> 
>>>> 
>>>> In the first case, 'mx' ends up being transformed to:
>>>> 
>>>> Browse[2]> m
>>>> $x1
>>>> [1] 0.99056941 0.13953093 0.38965567 0.35353514 0.90838486 0.97552474
>>>> [7] 0.01135743 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
>>>> [13] 0.31333549 0.97488211 0.54952630 0.71747157 0.31164777 0.81694822
>>>> [19] 0.58641410 0.08858699
>>>> 
>>>> $x2
>>>> [1] 0.6628658 0.9221436 0.3162418 0.8494452 0.4665010 0.3403719
>>>> [7] 0.4040692 0.4916650 0.9091161 0.2956006 0.3454689 0.3331070
>>>> [13] 0.8788974 0.5614636 0.7794396 0.2304009 0.6566537 0.6875646
>>>> [19] 0.5110733 0.4122336
>>>> 
>>>> $V3
>>>> [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
>>>> 
>>>> attr(,"row.names")
>>>> [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
>>>> 
>>>> Thus, when do.call() is used, m$V3 is passed as the 'x' argument on the third iteration, essentially resulting in:
>>>> 
>>>>> polym(rep(2, 20), degree = 2)
>>>> Error in poly(dots[[1L]], degree, raw = raw, simple = raw && nd > 1) : 
>>>> 'degree' must be less than number of unique points
>>>> 
>>>> 
>>>> Note also that in this case, 'dots', which is the result of using list(...) on the initial call, is:
>>>> 
>>>> Browse[2]> dots
>>>> [[1]]
>>>> [1] 2
>>>> 
>>>> 
>>>> In the second case:
>>>> 
>>>> Browse[2]> m
>>>> $x1
>>>> [1] 0.99056941 0.13953093 0.38965567 0.35353514 0.90838486 0.97552474
>>>> [7] 0.01135743 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
>>>> [13] 0.31333549 0.97488211 0.54952630 0.71747157 0.31164777 0.81694822
>>>> [19] 0.58641410 0.08858699
>>>> 
>>>> $x2
>>>> [1] 0.6628658 0.9221436 0.3162418 0.8494452 0.4665010 0.3403719
>>>> [7] 0.4040692 0.4916650 0.9091161 0.2956006 0.3454689 0.3331070
>>>> [13] 0.8788974 0.5614636 0.7794396 0.2304009 0.6566537 0.6875646
>>>> [19] 0.5110733 0.4122336
>>>> 
>>>> attr(,"row.names")
>>>> [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
>>>> 
>>>> 
>>>> So, there is no m$V3.
>>>> 
>>>> Note also that 'dots' ends up being:
>>>> 
>>>> Browse[2]> dots
>>>> list()
>>>> 
>>>> 
>>>> In both cases, 'degree' is indeed 2, but the result of 'list(...)' on the initial function call is quite different.
>>>> 
>>>> So, I may be hypo-caffeinated, but if there is a bug here, it may be due to the way in which cbind() is being called in the code above, where the three dots are being used?
>>>> 
>>>> I can replicate the presumably correct behavior by using:
>>>> 
>>>> m <- unclass(as.data.frame(cbind(x)))
>>>> 
>>>> instead of:
>>>> 
>>>> m <- unclass(as.data.frame(cbind(x, ...)))
>>>> 
>>>> But I am not sure if removing the three dots in the cbind() call may have other unintended consequences.
>>>> 
>>>> Regards,
>>>> 
>>>> Marc
> 
> 
>>> Duncan,
> 
>>> Some additional information here.
>>> Reviewing the source code for the function in SVN:
> 
>>> https://svn.r-project.org/R/trunk/src/library/stats/R/contr.poly.R
> 
>>> there is a relevant comment in the code:
> 
>>> if(is.matrix(x)) { ## FIXME: fails when combined with 'unnamed degree' above
>>> m <- unclass(as.data.frame(cbind(x, ...)))
>>> return(do.call(polym, c(m, degree = degree, raw = raw,
>>> list(coefs=coefs))))
>>> }
> 
> 
>>> A version review would suggest that the above comment was added to the code back in 2015.
> 
>> Yes, by me, possibly here :
> 
>> $ svn log -v -c68727
>> ------------------------------------------------------------------------
>> r68727 | maechler | 2015-07-23 16:14:59 +0200 (Thu, 23 Jul 2015) | 1 line
>> Changed paths:
>> M /trunk/doc/NEWS.Rd
>> M /trunk/src/library/stats/R/contr.poly.R
>> M /trunk/src/library/stats/man/poly.Rd
>> M /trunk/tests/Examples/stats-Ex.Rout.save
>> M /trunk/tests/reg-tests-1c.R
> 
>> poly(), polym() now work better notably for prediction
>> ------------------------------------------------------------------------
>> $ svn-diffB -c68727 doc/NEWS.Rd
>> Index: doc/NEWS.Rd
>> ===================================================================
>> 126a127,133
>>> 
>>> \item \code{polym()} gains a \code{coefs = NULL} argument and
>>> returns class \code{"poly"} just like \code{poly()} which gets a
>>> new \code{simple=FALSE} option.  They now lead to correct
>>> \code{predict()}ions, e.g., on subsets of the original data.
>>> %% see https://stat.ethz.ch/pipermail/r-devel/2015-July/071532.html
> 
> 
>>> So it would appear that the behavior being discussed here is known.
> 
>> Indeed!  I remember to have spent quite a few hours with the
>> code and its different uses before committing that patch.
> 
>>> I am still confused by the need for the '...' in the call to cbind(), which as far as I can tell, has been in the code at least back to 2003, when the poly() code was split from base. 
> 
>>> I am not sure why one would want to pass on other '...' arguments to cbind(), but I am presumably missing something here.
> 
>> Yes, I think passing the '...' is important there...
>> OTOH, I'm almost sure that I wrote the 'FIXME' because I thought
>> one should be able to do things better.
>> So, I'm happy to e-talk to you about how to get rid of the FIXME
>> and still remain back-compatible: Notably with the paragraph in  ?poly
>> |> Details:
>> |>
>> |>      Although formally ?degree? should be named (as it follows ?...?),
>> |>      an unnamed second argument of length 1 will be interpreted as the
>> |>      degree, such that ?poly(x, 3)? can be used in formulas.
> 
> As a matter of fact,  a patch seems very simple, and I am
> testing it now.
> 
> Won't have much more time today, but will return "on this channel"
> later, maybe tomorrow.
> 
> Martin


Martin,

Thanks for taking the time to look at this!

Marc


From maechler at stat.math.ethz.ch  Sat Jul 15 17:37:16 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Sat, 15 Jul 2017 17:37:16 +0200
Subject: [Rd] Proposed Patch for poly.Rd
In-Reply-To: <0B38252A-6749-45F4-885E-73702CC32B53@me.com>
References: <DE3B9ECF-8CE2-460F-AAFC-4B6DFAAE958D@me.com>
 <600dfbc3-cfbc-110f-5ff7-965202c21a88@gmail.com>
 <5DD6CF21-E2D0-4475-8CF9-D05504279499@me.com>
 <3CCCE71C-B4A2-4C9D-A27F-18486AEA4F69@me.com>
 <C44434BD-CA2A-493C-8DBD-ED15CCB4C2B2@me.com>
 <22888.54682.928801.33074@stat.math.ethz.ch>
 <22888.55852.258809.522240@stat.math.ethz.ch>
 <0B38252A-6749-45F4-885E-73702CC32B53@me.com>
Message-ID: <22890.13996.34531.687653@stat.math.ethz.ch>

>>>>> Marc Schwartz <marc_schwartz at me.com>
>>>>>     on Fri, 14 Jul 2017 11:01:03 -0500 writes:

    >> On Jul 14, 2017, at 9:50 AM, Martin Maechler
    >> <maechler at stat.math.ethz.ch> wrote:
    >> 
    >>>>>>> Martin Maechler <maechler at stat.math.ethz.ch> on Fri,
    >>>>>>> 14 Jul 2017 16:30:50 +0200 writes:
    >> 
    >>>>>>> Marc Schwartz <marc_schwartz at me.com> on Fri, 14 Jul
    >>>>>>> 2017 06:57:26 -0500 writes:
    >> 
    >>>>> On Jul 13, 2017, at 5:07 PM, Marc Schwartz
    >>>>> <marc_schwartz at me.com> wrote:
    >>>>> 
    >>>>> 
>>>>> On Jul 13, 2017, at 3:37 PM, Marc Schwartz
    >>>>> <marc_schwartz at me.com> wrote:
>>>>> 
>>>>> 
    >>>>>>> On Jul 13, 2017, at 3:22 PM, Duncan Murdoch
    >>>>>>> <murdoch.duncan at gmail.com> wrote:
    >>>>>>> 
    >>>>>>> On 13/07/2017 4:08 PM, Marc Schwartz wrote:
    >>>>>>>> Hi All,
    >>>>>>>> 
    >>>>>>>> As per the discussion today on R-Help:
    >>>>>>>> 
    >>>>>>>> https://stat.ethz.ch/pipermail/r-help/2017-July/448132.html
    >>>>>>>> 
    >>>>>>>> I am attaching a proposed patch for poly.Rd to
    >>>>>>>> provide clarifying wording relative to naming the
    >>>>>>>> 'degree' argument explicitly, in the case where the
    >>>>>>>> 'x' argument is a matrix, rather than a vector.
    >>>>>>>> 
    >>>>>>>> This is based upon the svn trunk version of
    >>>>>>>> poly.Rd.
    >>>>>>> 
    >>>>>>> I don't think this is the right fix.  The use of the
    >>>>>>> unnamed 2nd arg as degree happens whether the first
    >>>>>>> arg is a matrix or not.
    >>>>>>> 
    >>>>>>> I didn't read the whole thread in detail, but it
    >>>>>>> appears there's a bug somewhere, in the report or in
    >>>>>>> the poly() code or in the plsr() code. That bug
    >>>>>>> should be reported on the bug list if it turns out
    >>>>>>> to be in base R, and to the package maintainer if it
    >>>>>>> is in plsr().
    >>>>>>> 
    >>>>>>> Duncan Murdoch
>>>>> 
>>>>> 
>>>>> Duncan,
>>>>> 
>>>>> Thanks for your reply. You only really need to read that
    >>>>>>> last post in the thread linked to above.
>>>>> 
>>>>> I won't deny the possibility of a bug in poly(), relative
    >>>>>>> to the handling of 'x' as a matrix. The behavior
    >>>>>>> occurs in the poly() function in a pure stand alone
    >>>>>>> fashion, without the need for plsr():
>>>>> 
>>>>> x1 <- runif(20)
>>>>> x2 <- runif(20)
>>>>> mx <- cbind(x1, x2)
>>>>> 
    >>>>> 
    >>>>> <snip>
    >>>>> 
    >>>>> Duncan,
    >>>>> 
    >>>>> Tracing through the code for poly() using debug once
    >>>>> with:
    >>>>> 
    >>>>> poly(mx, 2)
    >>>>> 
    >>>>> and then with:
    >>>>> 
    >>>>> poly(mx, degree = 2)
    >>>>> 
    >>>>> there is a difference in the transformation of 'mx'
    >>>>> internally by the use of:
    >>>>> 
    >>>>> if (is.matrix(x)) { m <-
    >>>>> unclass(as.data.frame(cbind(x, ...)))
    >>>>> return(do.call(polym, c(m, degree = degree, raw = raw,
    >>>>> list(coefs = coefs)))) }
    >>>>> 
    >>>>> 
    >>>>> In the first case, 'mx' ends up being transformed to:
    >>>>> 
    >>>>> Browse[2]> m $x1 [1] 0.99056941 0.13953093 0.38965567
    >>>>> 0.35353514 0.90838486 0.97552474 [7] 0.01135743
    >>>>> 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
    >>>>> [13] 0.31333549 0.97488211 0.54952630 0.71747157
    >>>>> 0.31164777 0.81694822 [19] 0.58641410 0.08858699
    >>>>> 
    >>>>> $x2 [1] 0.6628658 0.9221436 0.3162418 0.8494452
    >>>>> 0.4665010 0.3403719 [7] 0.4040692 0.4916650 0.9091161
    >>>>> 0.2956006 0.3454689 0.3331070 [13] 0.8788974 0.5614636
    >>>>> 0.7794396 0.2304009 0.6566537 0.6875646 [19] 0.5110733
    >>>>> 0.4122336
    >>>>> 
    >>>>> $V3 [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
    >>>>> 
    >>>>> attr(,"row.names") [1] 1 2 3 4 5 6 7 8 9 10 11 12 13
    >>>>> 14 15 16 17 18 19 20
    >>>>> 
    >>>>> Thus, when do.call() is used, m$V3 is passed as the
    >>>>> 'x' argument on the third iteration, essentially
    >>>>> resulting in:
    >>>>> 
>>>>> polym(rep(2, 20), degree = 2) Error in poly(dots[[1L]],
    >>>>> degree, raw = raw, simple = raw && nd > 1) : 'degree'
    >>>>> must be less than number of unique points
    >>>>> 
    >>>>> 
    >>>>> Note also that in this case, 'dots', which is the
    >>>>> result of using list(...) on the initial call, is:
    >>>>> 
    >>>>> Browse[2]> dots [[1]] [1] 2
    >>>>> 
    >>>>> 
    >>>>> In the second case:
    >>>>> 
    >>>>> Browse[2]> m $x1 [1] 0.99056941 0.13953093 0.38965567
    >>>>> 0.35353514 0.90838486 0.97552474 [7] 0.01135743
    >>>>> 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
    >>>>> [13] 0.31333549 0.97488211 0.54952630 0.71747157
    >>>>> 0.31164777 0.81694822 [19] 0.58641410 0.08858699
    >>>>> 
    >>>>> $x2 [1] 0.6628658 0.9221436 0.3162418 0.8494452
    >>>>> 0.4665010 0.3403719 [7] 0.4040692 0.4916650 0.9091161
    >>>>> 0.2956006 0.3454689 0.3331070 [13] 0.8788974 0.5614636
    >>>>> 0.7794396 0.2304009 0.6566537 0.6875646 [19] 0.5110733
    >>>>> 0.4122336
    >>>>> 
    >>>>> attr(,"row.names") [1] 1 2 3 4 5 6 7 8 9 10 11 12 13
    >>>>> 14 15 16 17 18 19 20
    >>>>> 
    >>>>> 
    >>>>> So, there is no m$V3.
    >>>>> 
    >>>>> Note also that 'dots' ends up being:
    >>>>> 
    >>>>> Browse[2]> dots list()
    >>>>> 
    >>>>> 
    >>>>> In both cases, 'degree' is indeed 2, but the result of
    >>>>> 'list(...)' on the initial function call is quite
    >>>>> different.
    >>>>> 
    >>>>> So, I may be hypo-caffeinated, but if there is a bug
    >>>>> here, it may be due to the way in which cbind() is
    >>>>> being called in the code above, where the three dots
    >>>>> are being used?
    >>>>> 
    >>>>> I can replicate the presumably correct behavior by
    >>>>> using:
    >>>>> 
    >>>>> m <- unclass(as.data.frame(cbind(x)))
    >>>>> 
    >>>>> instead of:
    >>>>> 
    >>>>> m <- unclass(as.data.frame(cbind(x, ...)))
    >>>>> 
    >>>>> But I am not sure if removing the three dots in the
    >>>>> cbind() call may have other unintended consequences.
    >>>>> 
    >>>>> Regards,
    >>>>> 
    >>>>> Marc
    >> 
    >> 
    >>>> Duncan,
    >> 
    >>>> Some additional information here.  Reviewing the source
    >>>> code for the function in SVN:
    >> 
    >>>> https://svn.r-project.org/R/trunk/src/library/stats/R/contr.poly.R
    >> 
    >>>> there is a relevant comment in the code:
    >> 
    >>>> if(is.matrix(x)) { ## FIXME: fails when combined with
    >>>> 'unnamed degree' above m <-
    >>>> unclass(as.data.frame(cbind(x, ...)))
    >>>> return(do.call(polym, c(m, degree = degree, raw = raw,
    >>>> list(coefs=coefs)))) }
    >> 
    >> 
    >>>> A version review would suggest that the above comment
    >>>> was added to the code back in 2015.
    >> 
    >>> Yes, by me, possibly here :
    >> 
    >>> $ svn log -v -c68727
    >>> ------------------------------------------------------------------------
    >>> r68727 | maechler | 2015-07-23 16:14:59 +0200 (Thu, 23
    >>> Jul 2015) | 1 line Changed paths: M /trunk/doc/NEWS.Rd M
    >>> /trunk/src/library/stats/R/contr.poly.R M
    >>> /trunk/src/library/stats/man/poly.Rd M
    >>> /trunk/tests/Examples/stats-Ex.Rout.save M
    >>> /trunk/tests/reg-tests-1c.R
    >> 
    >>> poly(), polym() now work better notably for prediction
    >>> ------------------------------------------------------------------------
    >>> $ svn-diffB -c68727 doc/NEWS.Rd Index: doc/NEWS.Rd
    >>> ===================================================================
    >>> 126a127,133
    >>>> 
    >>>> \item \code{polym()} gains a \code{coefs = NULL}
    >>>> argument and returns class \code{"poly"} just like
    >>>> \code{poly()} which gets a new \code{simple=FALSE}
    >>>> option.  They now lead to correct \code{predict()}ions,
    >>>> e.g., on subsets of the original data.  %% see
    >>>> https://stat.ethz.ch/pipermail/r-devel/2015-July/071532.html
    >> 
    >> 
    >>>> So it would appear that the behavior being discussed
    >>>> here is known.
    >> 
    >>> Indeed!  I remember to have spent quite a few hours with
    >>> the code and its different uses before committing that
    >>> patch.
    >> 
    >>>> I am still confused by the need for the '...' in the
    >>>> call to cbind(), which as far as I can tell, has been
    >>>> in the code at least back to 2003, when the poly() code
    >>>> was split from base.
    >> 
    >>>> I am not sure why one would want to pass on other '...'
    >>>> arguments to cbind(), but I am presumably missing
    >>>> something here.
    >> 
    >>> Yes, I think passing the '...' is important there...
    >>> OTOH, I'm almost sure that I wrote the 'FIXME' because I
    >>> thought one should be able to do things better.  So, I'm
    >>> happy to e-talk to you about how to get rid of the FIXME
    >>> and still remain back-compatible: Notably with the
    >>> paragraph in ?poly |> Details:
    >>> |>
    >>> |> Although formally ?degree? should be named (as it
    >>> follows ?...?), |> an unnamed second argument of length
    >>> 1 will be interpreted as the |> degree, such that
    >>> ?poly(x, 3)? can be used in formulas.
    >> 
    >> As a matter of fact, a patch seems very simple, and I am
    >> testing it now.
    >> 
    >> Won't have much more time today, but will return "on this
    >> channel" later, maybe tomorrow.
    >> 
    >> Martin


    > Martin,
    > Thanks for taking the time to look at this!

    > Marc

Duncan had in the mean time filed a bug report about this,
 --> https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17310
but I had fixed the issue even before seeing the PR.
    [currently fixed in R-devel only (svn r 72919)]

Martin


From murdoch.duncan at gmail.com  Sun Jul 16 01:27:57 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Sat, 15 Jul 2017 19:27:57 -0400
Subject: [Rd] Proposed Patch for poly.Rd
In-Reply-To: <22890.13996.34531.687653@stat.math.ethz.ch>
References: <DE3B9ECF-8CE2-460F-AAFC-4B6DFAAE958D@me.com>
 <600dfbc3-cfbc-110f-5ff7-965202c21a88@gmail.com>
 <5DD6CF21-E2D0-4475-8CF9-D05504279499@me.com>
 <3CCCE71C-B4A2-4C9D-A27F-18486AEA4F69@me.com>
 <C44434BD-CA2A-493C-8DBD-ED15CCB4C2B2@me.com>
 <22888.54682.928801.33074@stat.math.ethz.ch>
 <22888.55852.258809.522240@stat.math.ethz.ch>
 <0B38252A-6749-45F4-885E-73702CC32B53@me.com>
 <22890.13996.34531.687653@stat.math.ethz.ch>
Message-ID: <5b7bfc31-2538-127c-b7d0-9e3b7e839024@gmail.com>

On 15/07/2017 11:37 AM, Martin Maechler wrote:
>>>>>> Marc Schwartz <marc_schwartz at me.com>
>>>>>>     on Fri, 14 Jul 2017 11:01:03 -0500 writes:
>
>     >> On Jul 14, 2017, at 9:50 AM, Martin Maechler
>     >> <maechler at stat.math.ethz.ch> wrote:
>     >>
>     >>>>>>> Martin Maechler <maechler at stat.math.ethz.ch> on Fri,
>     >>>>>>> 14 Jul 2017 16:30:50 +0200 writes:
>     >>
>     >>>>>>> Marc Schwartz <marc_schwartz at me.com> on Fri, 14 Jul
>     >>>>>>> 2017 06:57:26 -0500 writes:
>     >>
>     >>>>> On Jul 13, 2017, at 5:07 PM, Marc Schwartz
>     >>>>> <marc_schwartz at me.com> wrote:
>     >>>>>
>     >>>>>
>>>>>> On Jul 13, 2017, at 3:37 PM, Marc Schwartz
>     >>>>> <marc_schwartz at me.com> wrote:
>>>>>>
>>>>>>
>     >>>>>>> On Jul 13, 2017, at 3:22 PM, Duncan Murdoch
>     >>>>>>> <murdoch.duncan at gmail.com> wrote:
>     >>>>>>>
>     >>>>>>> On 13/07/2017 4:08 PM, Marc Schwartz wrote:
>     >>>>>>>> Hi All,
>     >>>>>>>>
>     >>>>>>>> As per the discussion today on R-Help:
>     >>>>>>>>
>     >>>>>>>> https://stat.ethz.ch/pipermail/r-help/2017-July/448132.html
>     >>>>>>>>
>     >>>>>>>> I am attaching a proposed patch for poly.Rd to
>     >>>>>>>> provide clarifying wording relative to naming the
>     >>>>>>>> 'degree' argument explicitly, in the case where the
>     >>>>>>>> 'x' argument is a matrix, rather than a vector.
>     >>>>>>>>
>     >>>>>>>> This is based upon the svn trunk version of
>     >>>>>>>> poly.Rd.
>     >>>>>>>
>     >>>>>>> I don't think this is the right fix.  The use of the
>     >>>>>>> unnamed 2nd arg as degree happens whether the first
>     >>>>>>> arg is a matrix or not.
>     >>>>>>>
>     >>>>>>> I didn't read the whole thread in detail, but it
>     >>>>>>> appears there's a bug somewhere, in the report or in
>     >>>>>>> the poly() code or in the plsr() code. That bug
>     >>>>>>> should be reported on the bug list if it turns out
>     >>>>>>> to be in base R, and to the package maintainer if it
>     >>>>>>> is in plsr().
>     >>>>>>>
>     >>>>>>> Duncan Murdoch
>>>>>>
>>>>>>
>>>>>> Duncan,
>>>>>>
>>>>>> Thanks for your reply. You only really need to read that
>     >>>>>>> last post in the thread linked to above.
>>>>>>
>>>>>> I won't deny the possibility of a bug in poly(), relative
>     >>>>>>> to the handling of 'x' as a matrix. The behavior
>     >>>>>>> occurs in the poly() function in a pure stand alone
>     >>>>>>> fashion, without the need for plsr():
>>>>>>
>>>>>> x1 <- runif(20)
>>>>>> x2 <- runif(20)
>>>>>> mx <- cbind(x1, x2)
>>>>>>
>     >>>>>
>     >>>>> <snip>
>     >>>>>
>     >>>>> Duncan,
>     >>>>>
>     >>>>> Tracing through the code for poly() using debug once
>     >>>>> with:
>     >>>>>
>     >>>>> poly(mx, 2)
>     >>>>>
>     >>>>> and then with:
>     >>>>>
>     >>>>> poly(mx, degree = 2)
>     >>>>>
>     >>>>> there is a difference in the transformation of 'mx'
>     >>>>> internally by the use of:
>     >>>>>
>     >>>>> if (is.matrix(x)) { m <-
>     >>>>> unclass(as.data.frame(cbind(x, ...)))
>     >>>>> return(do.call(polym, c(m, degree = degree, raw = raw,
>     >>>>> list(coefs = coefs)))) }
>     >>>>>
>     >>>>>
>     >>>>> In the first case, 'mx' ends up being transformed to:
>     >>>>>
>     >>>>> Browse[2]> m $x1 [1] 0.99056941 0.13953093 0.38965567
>     >>>>> 0.35353514 0.90838486 0.97552474 [7] 0.01135743
>     >>>>> 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
>     >>>>> [13] 0.31333549 0.97488211 0.54952630 0.71747157
>     >>>>> 0.31164777 0.81694822 [19] 0.58641410 0.08858699
>     >>>>>
>     >>>>> $x2 [1] 0.6628658 0.9221436 0.3162418 0.8494452
>     >>>>> 0.4665010 0.3403719 [7] 0.4040692 0.4916650 0.9091161
>     >>>>> 0.2956006 0.3454689 0.3331070 [13] 0.8788974 0.5614636
>     >>>>> 0.7794396 0.2304009 0.6566537 0.6875646 [19] 0.5110733
>     >>>>> 0.4122336
>     >>>>>
>     >>>>> $V3 [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
>     >>>>>
>     >>>>> attr(,"row.names") [1] 1 2 3 4 5 6 7 8 9 10 11 12 13
>     >>>>> 14 15 16 17 18 19 20
>     >>>>>
>     >>>>> Thus, when do.call() is used, m$V3 is passed as the
>     >>>>> 'x' argument on the third iteration, essentially
>     >>>>> resulting in:
>     >>>>>
>>>>>> polym(rep(2, 20), degree = 2) Error in poly(dots[[1L]],
>     >>>>> degree, raw = raw, simple = raw && nd > 1) : 'degree'
>     >>>>> must be less than number of unique points
>     >>>>>
>     >>>>>
>     >>>>> Note also that in this case, 'dots', which is the
>     >>>>> result of using list(...) on the initial call, is:
>     >>>>>
>     >>>>> Browse[2]> dots [[1]] [1] 2
>     >>>>>
>     >>>>>
>     >>>>> In the second case:
>     >>>>>
>     >>>>> Browse[2]> m $x1 [1] 0.99056941 0.13953093 0.38965567
>     >>>>> 0.35353514 0.90838486 0.97552474 [7] 0.01135743
>     >>>>> 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
>     >>>>> [13] 0.31333549 0.97488211 0.54952630 0.71747157
>     >>>>> 0.31164777 0.81694822 [19] 0.58641410 0.08858699
>     >>>>>
>     >>>>> $x2 [1] 0.6628658 0.9221436 0.3162418 0.8494452
>     >>>>> 0.4665010 0.3403719 [7] 0.4040692 0.4916650 0.9091161
>     >>>>> 0.2956006 0.3454689 0.3331070 [13] 0.8788974 0.5614636
>     >>>>> 0.7794396 0.2304009 0.6566537 0.6875646 [19] 0.5110733
>     >>>>> 0.4122336
>     >>>>>
>     >>>>> attr(,"row.names") [1] 1 2 3 4 5 6 7 8 9 10 11 12 13
>     >>>>> 14 15 16 17 18 19 20
>     >>>>>
>     >>>>>
>     >>>>> So, there is no m$V3.
>     >>>>>
>     >>>>> Note also that 'dots' ends up being:
>     >>>>>
>     >>>>> Browse[2]> dots list()
>     >>>>>
>     >>>>>
>     >>>>> In both cases, 'degree' is indeed 2, but the result of
>     >>>>> 'list(...)' on the initial function call is quite
>     >>>>> different.
>     >>>>>
>     >>>>> So, I may be hypo-caffeinated, but if there is a bug
>     >>>>> here, it may be due to the way in which cbind() is
>     >>>>> being called in the code above, where the three dots
>     >>>>> are being used?
>     >>>>>
>     >>>>> I can replicate the presumably correct behavior by
>     >>>>> using:
>     >>>>>
>     >>>>> m <- unclass(as.data.frame(cbind(x)))
>     >>>>>
>     >>>>> instead of:
>     >>>>>
>     >>>>> m <- unclass(as.data.frame(cbind(x, ...)))
>     >>>>>
>     >>>>> But I am not sure if removing the three dots in the
>     >>>>> cbind() call may have other unintended consequences.
>     >>>>>
>     >>>>> Regards,
>     >>>>>
>     >>>>> Marc
>     >>
>     >>
>     >>>> Duncan,
>     >>
>     >>>> Some additional information here.  Reviewing the source
>     >>>> code for the function in SVN:
>     >>
>     >>>> https://svn.r-project.org/R/trunk/src/library/stats/R/contr.poly.R
>     >>
>     >>>> there is a relevant comment in the code:
>     >>
>     >>>> if(is.matrix(x)) { ## FIXME: fails when combined with
>     >>>> 'unnamed degree' above m <-
>     >>>> unclass(as.data.frame(cbind(x, ...)))
>     >>>> return(do.call(polym, c(m, degree = degree, raw = raw,
>     >>>> list(coefs=coefs)))) }
>     >>
>     >>
>     >>>> A version review would suggest that the above comment
>     >>>> was added to the code back in 2015.
>     >>
>     >>> Yes, by me, possibly here :
>     >>
>     >>> $ svn log -v -c68727
>     >>> ------------------------------------------------------------------------
>     >>> r68727 | maechler | 2015-07-23 16:14:59 +0200 (Thu, 23
>     >>> Jul 2015) | 1 line Changed paths: M /trunk/doc/NEWS.Rd M
>     >>> /trunk/src/library/stats/R/contr.poly.R M
>     >>> /trunk/src/library/stats/man/poly.Rd M
>     >>> /trunk/tests/Examples/stats-Ex.Rout.save M
>     >>> /trunk/tests/reg-tests-1c.R
>     >>
>     >>> poly(), polym() now work better notably for prediction
>     >>> ------------------------------------------------------------------------
>     >>> $ svn-diffB -c68727 doc/NEWS.Rd Index: doc/NEWS.Rd
>     >>> ===================================================================
>     >>> 126a127,133
>     >>>>
>     >>>> \item \code{polym()} gains a \code{coefs = NULL}
>     >>>> argument and returns class \code{"poly"} just like
>     >>>> \code{poly()} which gets a new \code{simple=FALSE}
>     >>>> option.  They now lead to correct \code{predict()}ions,
>     >>>> e.g., on subsets of the original data.  %% see
>     >>>> https://stat.ethz.ch/pipermail/r-devel/2015-July/071532.html
>     >>
>     >>
>     >>>> So it would appear that the behavior being discussed
>     >>>> here is known.
>     >>
>     >>> Indeed!  I remember to have spent quite a few hours with
>     >>> the code and its different uses before committing that
>     >>> patch.
>     >>
>     >>>> I am still confused by the need for the '...' in the
>     >>>> call to cbind(), which as far as I can tell, has been
>     >>>> in the code at least back to 2003, when the poly() code
>     >>>> was split from base.
>     >>
>     >>>> I am not sure why one would want to pass on other '...'
>     >>>> arguments to cbind(), but I am presumably missing
>     >>>> something here.
>     >>
>     >>> Yes, I think passing the '...' is important there...
>     >>> OTOH, I'm almost sure that I wrote the 'FIXME' because I
>     >>> thought one should be able to do things better.  So, I'm
>     >>> happy to e-talk to you about how to get rid of the FIXME
>     >>> and still remain back-compatible: Notably with the
>     >>> paragraph in ?poly |> Details:
>     >>> |>
>     >>> |> Although formally ?degree? should be named (as it
>     >>> follows ?...?), |> an unnamed second argument of length
>     >>> 1 will be interpreted as the |> degree, such that
>     >>> ?poly(x, 3)? can be used in formulas.
>     >>
>     >> As a matter of fact, a patch seems very simple, and I am
>     >> testing it now.
>     >>
>     >> Won't have much more time today, but will return "on this
>     >> channel" later, maybe tomorrow.
>     >>
>     >> Martin
>
>
>     > Martin,
>     > Thanks for taking the time to look at this!
>
>     > Marc
>
> Duncan had in the mean time filed a bug report about this,
>  --> https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17310
> but I had fixed the issue even before seeing the PR.
>     [currently fixed in R-devel only (svn r 72919)]

I wrote to you the next day, when Marc pointed out the FIXME comment. 
Did you not receive my message?

Duncan Murdoch


From maechler at stat.math.ethz.ch  Mon Jul 17 08:57:32 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Mon, 17 Jul 2017 08:57:32 +0200
Subject: [Rd] Proposed Patch for poly.Rd
In-Reply-To: <5b7bfc31-2538-127c-b7d0-9e3b7e839024@gmail.com>
References: <DE3B9ECF-8CE2-460F-AAFC-4B6DFAAE958D@me.com>
 <600dfbc3-cfbc-110f-5ff7-965202c21a88@gmail.com>
 <5DD6CF21-E2D0-4475-8CF9-D05504279499@me.com>
 <3CCCE71C-B4A2-4C9D-A27F-18486AEA4F69@me.com>
 <C44434BD-CA2A-493C-8DBD-ED15CCB4C2B2@me.com>
 <22888.54682.928801.33074@stat.math.ethz.ch>
 <22888.55852.258809.522240@stat.math.ethz.ch>
 <0B38252A-6749-45F4-885E-73702CC32B53@me.com>
 <22890.13996.34531.687653@stat.math.ethz.ch>
 <5b7bfc31-2538-127c-b7d0-9e3b7e839024@gmail.com>
Message-ID: <22892.24540.802634.378981@stat.math.ethz.ch>

>>>>> Duncan Murdoch <murdoch.duncan at gmail.com>
>>>>>     on Sat, 15 Jul 2017 19:27:57 -0400 writes:

    > On 15/07/2017 11:37 AM, Martin Maechler wrote:
    >>>>>>> Marc Schwartz <marc_schwartz at me.com>
    >>>>>>> on Fri, 14 Jul 2017 11:01:03 -0500 writes:
    >> 
    >> >> On Jul 14, 2017, at 9:50 AM, Martin Maechler
    >> >> <maechler at stat.math.ethz.ch> wrote:
    >> >>
    >> >>>>>>> Martin Maechler <maechler at stat.math.ethz.ch> on Fri,
    >> >>>>>>> 14 Jul 2017 16:30:50 +0200 writes:
    >> >>
    >> >>>>>>> Marc Schwartz <marc_schwartz at me.com> on Fri, 14 Jul
    >> >>>>>>> 2017 06:57:26 -0500 writes:
    >> >>
    >> >>>>> On Jul 13, 2017, at 5:07 PM, Marc Schwartz
    >> >>>>> <marc_schwartz at me.com> wrote:
    >> >>>>>
    >> >>>>>
    >>>>>>> On Jul 13, 2017, at 3:37 PM, Marc Schwartz
    >> >>>>> <marc_schwartz at me.com> wrote:
    >>>>>>> 
    >>>>>>> 
    >> >>>>>>> On Jul 13, 2017, at 3:22 PM, Duncan Murdoch
    >> >>>>>>> <murdoch.duncan at gmail.com> wrote:
    >> >>>>>>>
    >> >>>>>>> On 13/07/2017 4:08 PM, Marc Schwartz wrote:
    >> >>>>>>>> Hi All,
    >> >>>>>>>>
    >> >>>>>>>> As per the discussion today on R-Help:
    >> >>>>>>>>
    >> >>>>>>>> https://stat.ethz.ch/pipermail/r-help/2017-July/448132.html
    >> >>>>>>>>
    >> >>>>>>>> I am attaching a proposed patch for poly.Rd to
    >> >>>>>>>> provide clarifying wording relative to naming the
    >> >>>>>>>> 'degree' argument explicitly, in the case where the
    >> >>>>>>>> 'x' argument is a matrix, rather than a vector.
    >> >>>>>>>>
    >> >>>>>>>> This is based upon the svn trunk version of
    >> >>>>>>>> poly.Rd.
    >> >>>>>>>
    >> >>>>>>> I don't think this is the right fix.  The use of the
    >> >>>>>>> unnamed 2nd arg as degree happens whether the first
    >> >>>>>>> arg is a matrix or not.
    >> >>>>>>>
    >> >>>>>>> I didn't read the whole thread in detail, but it
    >> >>>>>>> appears there's a bug somewhere, in the report or in
    >> >>>>>>> the poly() code or in the plsr() code. That bug
    >> >>>>>>> should be reported on the bug list if it turns out
    >> >>>>>>> to be in base R, and to the package maintainer if it
    >> >>>>>>> is in plsr().
    >> >>>>>>>
    >> >>>>>>> Duncan Murdoch
    >>>>>>> 
    >>>>>>> 
    >>>>>>> Duncan,
    >>>>>>> 
    >>>>>>> Thanks for your reply. You only really need to read that
    >> >>>>>>> last post in the thread linked to above.
    >>>>>>> 
    >>>>>>> I won't deny the possibility of a bug in poly(), relative
    >> >>>>>>> to the handling of 'x' as a matrix. The behavior
    >> >>>>>>> occurs in the poly() function in a pure stand alone
    >> >>>>>>> fashion, without the need for plsr():
    >>>>>>> 
    >>>>>>> x1 <- runif(20)
    >>>>>>> x2 <- runif(20)
    >>>>>>> mx <- cbind(x1, x2)
    >>>>>>> 
    >> >>>>>
    >> >>>>> <snip>
    >> >>>>>
    >> >>>>> Duncan,
    >> >>>>>
    >> >>>>> Tracing through the code for poly() using debug once
    >> >>>>> with:
    >> >>>>>
    >> >>>>> poly(mx, 2)
    >> >>>>>
    >> >>>>> and then with:
    >> >>>>>
    >> >>>>> poly(mx, degree = 2)
    >> >>>>>
    >> >>>>> there is a difference in the transformation of 'mx'
    >> >>>>> internally by the use of:
    >> >>>>>
    >> >>>>> if (is.matrix(x)) { m <-
    >> >>>>> unclass(as.data.frame(cbind(x, ...)))
    >> >>>>> return(do.call(polym, c(m, degree = degree, raw = raw,
    >> >>>>> list(coefs = coefs)))) }
    >> >>>>>
    >> >>>>>
    >> >>>>> In the first case, 'mx' ends up being transformed to:
    >> >>>>>
    >> >>>>> Browse[2]> m $x1 [1] 0.99056941 0.13953093 0.38965567
    >> >>>>> 0.35353514 0.90838486 0.97552474 [7] 0.01135743
    >> >>>>> 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
    >> >>>>> [13] 0.31333549 0.97488211 0.54952630 0.71747157
    >> >>>>> 0.31164777 0.81694822 [19] 0.58641410 0.08858699
    >> >>>>>
    >> >>>>> $x2 [1] 0.6628658 0.9221436 0.3162418 0.8494452
    >> >>>>> 0.4665010 0.3403719 [7] 0.4040692 0.4916650 0.9091161
    >> >>>>> 0.2956006 0.3454689 0.3331070 [13] 0.8788974 0.5614636
    >> >>>>> 0.7794396 0.2304009 0.6566537 0.6875646 [19] 0.5110733
    >> >>>>> 0.4122336
    >> >>>>>
    >> >>>>> $V3 [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
    >> >>>>>
    >> >>>>> attr(,"row.names") [1] 1 2 3 4 5 6 7 8 9 10 11 12 13
    >> >>>>> 14 15 16 17 18 19 20
    >> >>>>>
    >> >>>>> Thus, when do.call() is used, m$V3 is passed as the
    >> >>>>> 'x' argument on the third iteration, essentially
    >> >>>>> resulting in:
    >> >>>>>
    >>>>>>> polym(rep(2, 20), degree = 2) Error in poly(dots[[1L]],
    >> >>>>> degree, raw = raw, simple = raw && nd > 1) : 'degree'
    >> >>>>> must be less than number of unique points
    >> >>>>>
    >> >>>>>
    >> >>>>> Note also that in this case, 'dots', which is the
    >> >>>>> result of using list(...) on the initial call, is:
    >> >>>>>
    >> >>>>> Browse[2]> dots [[1]] [1] 2
    >> >>>>>
    >> >>>>>
    >> >>>>> In the second case:
    >> >>>>>
    >> >>>>> Browse[2]> m $x1 [1] 0.99056941 0.13953093 0.38965567
    >> >>>>> 0.35353514 0.90838486 0.97552474 [7] 0.01135743
    >> >>>>> 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
    >> >>>>> [13] 0.31333549 0.97488211 0.54952630 0.71747157
    >> >>>>> 0.31164777 0.81694822 [19] 0.58641410 0.08858699
    >> >>>>>
    >> >>>>> $x2 [1] 0.6628658 0.9221436 0.3162418 0.8494452
    >> >>>>> 0.4665010 0.3403719 [7] 0.4040692 0.4916650 0.9091161
    >> >>>>> 0.2956006 0.3454689 0.3331070 [13] 0.8788974 0.5614636
    >> >>>>> 0.7794396 0.2304009 0.6566537 0.6875646 [19] 0.5110733
    >> >>>>> 0.4122336
    >> >>>>>
    >> >>>>> attr(,"row.names") [1] 1 2 3 4 5 6 7 8 9 10 11 12 13
    >> >>>>> 14 15 16 17 18 19 20
    >> >>>>>
    >> >>>>>
    >> >>>>> So, there is no m$V3.
    >> >>>>>
    >> >>>>> Note also that 'dots' ends up being:
    >> >>>>>
    >> >>>>> Browse[2]> dots list()
    >> >>>>>
    >> >>>>>
    >> >>>>> In both cases, 'degree' is indeed 2, but the result of
    >> >>>>> 'list(...)' on the initial function call is quite
    >> >>>>> different.
    >> >>>>>
    >> >>>>> So, I may be hypo-caffeinated, but if there is a bug
    >> >>>>> here, it may be due to the way in which cbind() is
    >> >>>>> being called in the code above, where the three dots
    >> >>>>> are being used?
    >> >>>>>
    >> >>>>> I can replicate the presumably correct behavior by
    >> >>>>> using:
    >> >>>>>
    >> >>>>> m <- unclass(as.data.frame(cbind(x)))
    >> >>>>>
    >> >>>>> instead of:
    >> >>>>>
    >> >>>>> m <- unclass(as.data.frame(cbind(x, ...)))
    >> >>>>>
    >> >>>>> But I am not sure if removing the three dots in the
    >> >>>>> cbind() call may have other unintended consequences.
    >> >>>>>
    >> >>>>> Regards,
    >> >>>>>
    >> >>>>> Marc
    >> >>
    >> >>
    >> >>>> Duncan,
    >> >>
    >> >>>> Some additional information here.  Reviewing the source
    >> >>>> code for the function in SVN:
    >> >>
    >> >>>> https://svn.r-project.org/R/trunk/src/library/stats/R/contr.poly.R
    >> >>
    >> >>>> there is a relevant comment in the code:
    >> >>
    >> >>>> if(is.matrix(x)) { ## FIXME: fails when combined with
    >> >>>> 'unnamed degree' above m <-
    >> >>>> unclass(as.data.frame(cbind(x, ...)))
    >> >>>> return(do.call(polym, c(m, degree = degree, raw = raw,
    >> >>>> list(coefs=coefs)))) }
    >> >>
    >> >>
    >> >>>> A version review would suggest that the above comment
    >> >>>> was added to the code back in 2015.
    >> >>
    >> >>> Yes, by me, possibly here :
    >> >>
    >> >>> $ svn log -v -c68727
    >> >>> ------------------------------------------------------------------------
    >> >>> r68727 | maechler | 2015-07-23 16:14:59 +0200 (Thu, 23
    >> >>> Jul 2015) | 1 line Changed paths: M /trunk/doc/NEWS.Rd M
    >> >>> /trunk/src/library/stats/R/contr.poly.R M
    >> >>> /trunk/src/library/stats/man/poly.Rd M
    >> >>> /trunk/tests/Examples/stats-Ex.Rout.save M
    >> >>> /trunk/tests/reg-tests-1c.R
    >> >>
    >> >>> poly(), polym() now work better notably for prediction
    >> >>> ------------------------------------------------------------------------
    >> >>> $ svn-diffB -c68727 doc/NEWS.Rd Index: doc/NEWS.Rd
    >> >>> ===================================================================
    >> >>> 126a127,133
    >> >>>>
    >> >>>> \item \code{polym()} gains a \code{coefs = NULL}
    >> >>>> argument and returns class \code{"poly"} just like
    >> >>>> \code{poly()} which gets a new \code{simple=FALSE}
    >> >>>> option.  They now lead to correct \code{predict()}ions,
    >> >>>> e.g., on subsets of the original data.  %% see
    >> >>>> https://stat.ethz.ch/pipermail/r-devel/2015-July/071532.html
    >> >>
    >> >>
    >> >>>> So it would appear that the behavior being discussed
    >> >>>> here is known.
    >> >>
    >> >>> Indeed!  I remember to have spent quite a few hours with
    >> >>> the code and its different uses before committing that
    >> >>> patch.
    >> >>
    >> >>>> I am still confused by the need for the '...' in the
    >> >>>> call to cbind(), which as far as I can tell, has been
    >> >>>> in the code at least back to 2003, when the poly() code
    >> >>>> was split from base.
    >> >>
    >> >>>> I am not sure why one would want to pass on other '...'
    >> >>>> arguments to cbind(), but I am presumably missing
    >> >>>> something here.
    >> >>
    >> >>> Yes, I think passing the '...' is important there...
    >> >>> OTOH, I'm almost sure that I wrote the 'FIXME' because I
    >> >>> thought one should be able to do things better.  So, I'm
    >> >>> happy to e-talk to you about how to get rid of the FIXME
    >> >>> and still remain back-compatible: Notably with the
    >> >>> paragraph in ?poly |> Details:
    >> >>> |>
    >> >>> |> Although formally ?degree? should be named (as it
    >> >>> follows ?...?), |> an unnamed second argument of length
    >> >>> 1 will be interpreted as the |> degree, such that
    >> >>> ?poly(x, 3)? can be used in formulas.
    >> >>
    >> >> As a matter of fact, a patch seems very simple, and I am
    >> >> testing it now.
    >> >>
    >> >> Won't have much more time today, but will return "on this
    >> >> channel" later, maybe tomorrow.
    >> >>
    >> >> Martin
    >> 
    >> 
    >> > Martin,
    >> > Thanks for taking the time to look at this!
    >> 
    >> > Marc
    >> 
    >> Duncan had in the mean time filed a bug report about this,
    --> https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17310
    >> but I had fixed the issue even before seeing the PR.
    >> [currently fixed in R-devel only (svn r 72919)]

    > I wrote to you the next day, when Marc pointed out the FIXME comment. 
    > Did you not receive my message?

    > Duncan Murdoch

I'm sorry Duncan,
there must have been messages crossing each other, possibly
delayed on this end, where some (including me) are using a new
spam/virus filtering service. 
Yes, I saw that too.. but also quite a bit *after* having
replied on R-devel that I was the author of the FIXME and that I
was going to look into the issue...
... and then I did look into the issue instead of checking my
(almost always much too many) e-mails.

But there's no problem about this, right?
I'm sorry if I gave the impression in some way.
It's good to have a bug report that we can quickly close isn't it?

Best,
Martin


From ruipbarradas at sapo.pt  Mon Jul 17 10:03:33 2017
From: ruipbarradas at sapo.pt (Rui Barradas)
Date: Mon, 17 Jul 2017 09:03:33 +0100
Subject: [Rd] install.packages problem
Message-ID: <596C6F55.8040501@sapo.pt>

Hello,

R 3.4.1 on Windows 7, sessionInfo at the end.
Is there a problem with install.packages? Since last friday every time I 
try to install a package in RGui, I start by choosing the CRAN mirror 
Cloud-0 and RGui hangs. So I restart RGui and choose Portugal (Lisbon) 
and get the following warning after a long while (minutes).

install.packages("igraph")
--- Please select a CRAN mirror for use in this session ---
Warning: unable to access index for repository 
http://www.stats.ox.ac.uk/pub/RWin/src/contrib:
   cannot open URL 'http://www.stats.ox.ac.uk/pub/RWin/src/contrib/PACKAGES'
Warning: unable to access index for repository 
http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/3.4:
   cannot open URL 
'http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/3.4/PACKAGES'

   There is a binary version available but the source version is later:
        binary source needs_compilation
igraph  1.0.1  1.1.1              TRUE

Do you want to install from sources the package which needs compilation?
y/n: y
installing the source package ?igraph?

trying URL 'http://cran.radicaldevelop.com/src/contrib/igraph_1.1.1.tar.gz'
Content type 'application/x-gzip' length 3376077 bytes (3.2 MB)
downloaded 3.2 MB
[...]

The rest of the process goes on with success.
The problem seems to be with http://www.stats.ox.ac.uk/pub/RWin/src/contrib

When I check
 > options("repos")
$repos
                                 CRAN                            CRANextra
     "http://cran.radicaldevelop.com" "http://www.stats.ox.ac.uk/pub/RWin"

I'm lead to think that install.packages should try 
"http://cran.radicaldevelop.com" first, only in case of failure CRANextra.

What is going on?

 > sessionInfo()
R version 3.4.1 (2017-06-30)
Platform: x86_64-w64-mingw32/x64 (64-bit)
Running under: Windows 7 x64 (build 7601) Service Pack 1

Matrix products: default

locale:
[1] LC_COLLATE=Portuguese_Portugal.1252 
LC_CTYPE=Portuguese_Portugal.1252
[3] LC_MONETARY=Portuguese_Portugal.1252 LC_NUMERIC=C 

[5] LC_TIME=Portuguese_Portugal.1252

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base

other attached packages:
[1] igraph_1.0.1

loaded via a namespace (and not attached):
[1] compiler_3.4.1 magrittr_1.5   tools_3.4.1

Thanks in advance,

Rui Barradas


From maechler at stat.math.ethz.ch  Mon Jul 17 10:29:49 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Mon, 17 Jul 2017 10:29:49 +0200
Subject: [Rd] install.packages problem on Windows:  CRANextras timeout
In-Reply-To: <596C6F55.8040501@sapo.pt>
References: <596C6F55.8040501@sapo.pt>
Message-ID: <22892.30077.106361.268044@stat.math.ethz.ch>

>>>>> Rui Barradas <ruipbarradas at sapo.pt>
>>>>>     on Mon, 17 Jul 2017 09:03:33 +0100 writes:

    > Hello,
    > R 3.4.1 on Windows 7, sessionInfo at the end.
    > Is there a problem with install.packages? Since last friday every time I 
    > try to install a package in RGui, I start by choosing the CRAN mirror 
    > Cloud-0 and RGui hangs. So I restart RGui and choose Portugal (Lisbon) 
    > and get the following warning after a long while (minutes).

As (I think) you notice below yourself, the problem is not with
the regular CRAN repos but with the  'CRANextra'  repos that
R users of Windows use sometimes.

We had heard offline of a potential timeout/downtime for a short
period at Oxford for that, so this may be the simple explanation.

On the other hand everything ends up working fine,
so all this is just a warning, right?

If I do the same thing I don't have to wait and get the same
warning as you (and when I then decide to use the older *binary*
for igraph that is installed fine).

Martin

    > install.packages("igraph")
    > --- Please select a CRAN mirror for use in this session ---
    > Warning: unable to access index for repository 
    > http://www.stats.ox.ac.uk/pub/RWin/src/contrib:
    > cannot open URL 'http://www.stats.ox.ac.uk/pub/RWin/src/contrib/PACKAGES'
    > Warning: unable to access index for repository 
    > http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/3.4:
    > cannot open URL 
    > 'http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/3.4/PACKAGES'

    > There is a binary version available but the source version is later:
    > binary source needs_compilation
    > igraph  1.0.1  1.1.1              TRUE

    > Do you want to install from sources the package which needs compilation?
    > y/n: y
    > installing the source package ?igraph?

    > trying URL 'http://cran.radicaldevelop.com/src/contrib/igraph_1.1.1.tar.gz'
    > Content type 'application/x-gzip' length 3376077 bytes (3.2 MB)
    > downloaded 3.2 MB
    > [...]

    > The rest of the process goes on with success.
    > The problem seems to be with http://www.stats.ox.ac.uk/pub/RWin/src/contrib

    > When I check
    >> options("repos")
    > $repos
    > CRAN                            CRANextra
    > "http://cran.radicaldevelop.com" "http://www.stats.ox.ac.uk/pub/RWin"

    > I'm lead to think that install.packages should try 
    > "http://cran.radicaldevelop.com" first, only in case of failure CRANextra.

    > What is going on?

    >> sessionInfo()
    > R version 3.4.1 (2017-06-30)
    > Platform: x86_64-w64-mingw32/x64 (64-bit)
    > Running under: Windows 7 x64 (build 7601) Service Pack 1

    > Matrix products: default

    > locale:
    > [1] LC_COLLATE=Portuguese_Portugal.1252 
    > LC_CTYPE=Portuguese_Portugal.1252
    > [3] LC_MONETARY=Portuguese_Portugal.1252 LC_NUMERIC=C 

    > [5] LC_TIME=Portuguese_Portugal.1252

    > attached base packages:
    > [1] stats     graphics  grDevices utils     datasets  methods   base

    > other attached packages:
    > [1] igraph_1.0.1

    > loaded via a namespace (and not attached):
    > [1] compiler_3.4.1 magrittr_1.5   tools_3.4.1

    > Thanks in advance,

    > Rui Barradas

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From ruipbarradas at sapo.pt  Mon Jul 17 10:45:46 2017
From: ruipbarradas at sapo.pt (Rui Barradas)
Date: Mon, 17 Jul 2017 09:45:46 +0100
Subject: [Rd] install.packages problem on Windows:  CRANextras timeout
In-Reply-To: <22892.30077.106361.268044@stat.math.ethz.ch>
References: <596C6F55.8040501@sapo.pt>
 <22892.30077.106361.268044@stat.math.ethz.ch>
Message-ID: <596C793A.4090608@sapo.pt>

Hello,

Thanks for the answer.
No, in the end there's no problem, just a warning.

Rui Barradas

Em 17-07-2017 09:29, Martin Maechler escreveu:
>>>>>> Rui Barradas <ruipbarradas at sapo.pt>
>>>>>>      on Mon, 17 Jul 2017 09:03:33 +0100 writes:
>
>      > Hello,
>      > R 3.4.1 on Windows 7, sessionInfo at the end.
>      > Is there a problem with install.packages? Since last friday every time I
>      > try to install a package in RGui, I start by choosing the CRAN mirror
>      > Cloud-0 and RGui hangs. So I restart RGui and choose Portugal (Lisbon)
>      > and get the following warning after a long while (minutes).
>
> As (I think) you notice below yourself, the problem is not with
> the regular CRAN repos but with the  'CRANextra'  repos that
> R users of Windows use sometimes.
>
> We had heard offline of a potential timeout/downtime for a short
> period at Oxford for that, so this may be the simple explanation.
>
> On the other hand everything ends up working fine,
> so all this is just a warning, right?
>
> If I do the same thing I don't have to wait and get the same
> warning as you (and when I then decide to use the older *binary*
> for igraph that is installed fine).
>
> Martin
>
>      > install.packages("igraph")
>      > --- Please select a CRAN mirror for use in this session ---
>      > Warning: unable to access index for repository
>      > http://www.stats.ox.ac.uk/pub/RWin/src/contrib:
>      > cannot open URL 'http://www.stats.ox.ac.uk/pub/RWin/src/contrib/PACKAGES'
>      > Warning: unable to access index for repository
>      > http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/3.4:
>      > cannot open URL
>      > 'http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/3.4/PACKAGES'
>
>      > There is a binary version available but the source version is later:
>      > binary source needs_compilation
>      > igraph  1.0.1  1.1.1              TRUE
>
>      > Do you want to install from sources the package which needs compilation?
>      > y/n: y
>      > installing the source package ?igraph?
>
>      > trying URL 'http://cran.radicaldevelop.com/src/contrib/igraph_1.1.1.tar.gz'
>      > Content type 'application/x-gzip' length 3376077 bytes (3.2 MB)
>      > downloaded 3.2 MB
>      > [...]
>
>      > The rest of the process goes on with success.
>      > The problem seems to be with http://www.stats.ox.ac.uk/pub/RWin/src/contrib
>
>      > When I check
>      >> options("repos")
>      > $repos
>      > CRAN                            CRANextra
>      > "http://cran.radicaldevelop.com" "http://www.stats.ox.ac.uk/pub/RWin"
>
>      > I'm lead to think that install.packages should try
>      > "http://cran.radicaldevelop.com" first, only in case of failure CRANextra.
>
>      > What is going on?
>
>      >> sessionInfo()
>      > R version 3.4.1 (2017-06-30)
>      > Platform: x86_64-w64-mingw32/x64 (64-bit)
>      > Running under: Windows 7 x64 (build 7601) Service Pack 1
>
>      > Matrix products: default
>
>      > locale:
>      > [1] LC_COLLATE=Portuguese_Portugal.1252
>      > LC_CTYPE=Portuguese_Portugal.1252
>      > [3] LC_MONETARY=Portuguese_Portugal.1252 LC_NUMERIC=C
>
>      > [5] LC_TIME=Portuguese_Portugal.1252
>
>      > attached base packages:
>      > [1] stats     graphics  grDevices utils     datasets  methods   base
>
>      > other attached packages:
>      > [1] igraph_1.0.1
>
>      > loaded via a namespace (and not attached):
>      > [1] compiler_3.4.1 magrittr_1.5   tools_3.4.1
>
>      > Thanks in advance,
>
>      > Rui Barradas
>
>      > ______________________________________________
>      > R-devel at r-project.org mailing list
>      > https://stat.ethz.ch/mailman/listinfo/r-devel
>


From murdoch.duncan at gmail.com  Mon Jul 17 12:32:15 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Mon, 17 Jul 2017 06:32:15 -0400
Subject: [Rd] Proposed Patch for poly.Rd
In-Reply-To: <22892.24540.802634.378981@stat.math.ethz.ch>
References: <DE3B9ECF-8CE2-460F-AAFC-4B6DFAAE958D@me.com>
 <600dfbc3-cfbc-110f-5ff7-965202c21a88@gmail.com>
 <5DD6CF21-E2D0-4475-8CF9-D05504279499@me.com>
 <3CCCE71C-B4A2-4C9D-A27F-18486AEA4F69@me.com>
 <C44434BD-CA2A-493C-8DBD-ED15CCB4C2B2@me.com>
 <22888.54682.928801.33074@stat.math.ethz.ch>
 <22888.55852.258809.522240@stat.math.ethz.ch>
 <0B38252A-6749-45F4-885E-73702CC32B53@me.com>
 <22890.13996.34531.687653@stat.math.ethz.ch>
 <5b7bfc31-2538-127c-b7d0-9e3b7e839024@gmail.com>
 <22892.24540.802634.378981@stat.math.ethz.ch>
Message-ID: <45abb1fd-8cd6-255a-89ce-add567153689@gmail.com>

On 17/07/2017 2:57 AM, Martin Maechler wrote:
>>>>>> Duncan Murdoch <murdoch.duncan at gmail.com>
>>>>>>     on Sat, 15 Jul 2017 19:27:57 -0400 writes:
>
>     > On 15/07/2017 11:37 AM, Martin Maechler wrote:
>     >>>>>>> Marc Schwartz <marc_schwartz at me.com>
>     >>>>>>> on Fri, 14 Jul 2017 11:01:03 -0500 writes:
>     >>
>     >> >> On Jul 14, 2017, at 9:50 AM, Martin Maechler
>     >> >> <maechler at stat.math.ethz.ch> wrote:
>     >> >>
>     >> >>>>>>> Martin Maechler <maechler at stat.math.ethz.ch> on Fri,
>     >> >>>>>>> 14 Jul 2017 16:30:50 +0200 writes:
>     >> >>
>     >> >>>>>>> Marc Schwartz <marc_schwartz at me.com> on Fri, 14 Jul
>     >> >>>>>>> 2017 06:57:26 -0500 writes:
>     >> >>
>     >> >>>>> On Jul 13, 2017, at 5:07 PM, Marc Schwartz
>     >> >>>>> <marc_schwartz at me.com> wrote:
>     >> >>>>>
>     >> >>>>>
>     >>>>>>> On Jul 13, 2017, at 3:37 PM, Marc Schwartz
>     >> >>>>> <marc_schwartz at me.com> wrote:
>     >>>>>>>
>     >>>>>>>
>     >> >>>>>>> On Jul 13, 2017, at 3:22 PM, Duncan Murdoch
>     >> >>>>>>> <murdoch.duncan at gmail.com> wrote:
>     >> >>>>>>>
>     >> >>>>>>> On 13/07/2017 4:08 PM, Marc Schwartz wrote:
>     >> >>>>>>>> Hi All,
>     >> >>>>>>>>
>     >> >>>>>>>> As per the discussion today on R-Help:
>     >> >>>>>>>>
>     >> >>>>>>>> https://stat.ethz.ch/pipermail/r-help/2017-July/448132.html
>     >> >>>>>>>>
>     >> >>>>>>>> I am attaching a proposed patch for poly.Rd to
>     >> >>>>>>>> provide clarifying wording relative to naming the
>     >> >>>>>>>> 'degree' argument explicitly, in the case where the
>     >> >>>>>>>> 'x' argument is a matrix, rather than a vector.
>     >> >>>>>>>>
>     >> >>>>>>>> This is based upon the svn trunk version of
>     >> >>>>>>>> poly.Rd.
>     >> >>>>>>>
>     >> >>>>>>> I don't think this is the right fix.  The use of the
>     >> >>>>>>> unnamed 2nd arg as degree happens whether the first
>     >> >>>>>>> arg is a matrix or not.
>     >> >>>>>>>
>     >> >>>>>>> I didn't read the whole thread in detail, but it
>     >> >>>>>>> appears there's a bug somewhere, in the report or in
>     >> >>>>>>> the poly() code or in the plsr() code. That bug
>     >> >>>>>>> should be reported on the bug list if it turns out
>     >> >>>>>>> to be in base R, and to the package maintainer if it
>     >> >>>>>>> is in plsr().
>     >> >>>>>>>
>     >> >>>>>>> Duncan Murdoch
>     >>>>>>>
>     >>>>>>>
>     >>>>>>> Duncan,
>     >>>>>>>
>     >>>>>>> Thanks for your reply. You only really need to read that
>     >> >>>>>>> last post in the thread linked to above.
>     >>>>>>>
>     >>>>>>> I won't deny the possibility of a bug in poly(), relative
>     >> >>>>>>> to the handling of 'x' as a matrix. The behavior
>     >> >>>>>>> occurs in the poly() function in a pure stand alone
>     >> >>>>>>> fashion, without the need for plsr():
>     >>>>>>>
>     >>>>>>> x1 <- runif(20)
>     >>>>>>> x2 <- runif(20)
>     >>>>>>> mx <- cbind(x1, x2)
>     >>>>>>>
>     >> >>>>>
>     >> >>>>> <snip>
>     >> >>>>>
>     >> >>>>> Duncan,
>     >> >>>>>
>     >> >>>>> Tracing through the code for poly() using debug once
>     >> >>>>> with:
>     >> >>>>>
>     >> >>>>> poly(mx, 2)
>     >> >>>>>
>     >> >>>>> and then with:
>     >> >>>>>
>     >> >>>>> poly(mx, degree = 2)
>     >> >>>>>
>     >> >>>>> there is a difference in the transformation of 'mx'
>     >> >>>>> internally by the use of:
>     >> >>>>>
>     >> >>>>> if (is.matrix(x)) { m <-
>     >> >>>>> unclass(as.data.frame(cbind(x, ...)))
>     >> >>>>> return(do.call(polym, c(m, degree = degree, raw = raw,
>     >> >>>>> list(coefs = coefs)))) }
>     >> >>>>>
>     >> >>>>>
>     >> >>>>> In the first case, 'mx' ends up being transformed to:
>     >> >>>>>
>     >> >>>>> Browse[2]> m $x1 [1] 0.99056941 0.13953093 0.38965567
>     >> >>>>> 0.35353514 0.90838486 0.97552474 [7] 0.01135743
>     >> >>>>> 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
>     >> >>>>> [13] 0.31333549 0.97488211 0.54952630 0.71747157
>     >> >>>>> 0.31164777 0.81694822 [19] 0.58641410 0.08858699
>     >> >>>>>
>     >> >>>>> $x2 [1] 0.6628658 0.9221436 0.3162418 0.8494452
>     >> >>>>> 0.4665010 0.3403719 [7] 0.4040692 0.4916650 0.9091161
>     >> >>>>> 0.2956006 0.3454689 0.3331070 [13] 0.8788974 0.5614636
>     >> >>>>> 0.7794396 0.2304009 0.6566537 0.6875646 [19] 0.5110733
>     >> >>>>> 0.4122336
>     >> >>>>>
>     >> >>>>> $V3 [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
>     >> >>>>>
>     >> >>>>> attr(,"row.names") [1] 1 2 3 4 5 6 7 8 9 10 11 12 13
>     >> >>>>> 14 15 16 17 18 19 20
>     >> >>>>>
>     >> >>>>> Thus, when do.call() is used, m$V3 is passed as the
>     >> >>>>> 'x' argument on the third iteration, essentially
>     >> >>>>> resulting in:
>     >> >>>>>
>     >>>>>>> polym(rep(2, 20), degree = 2) Error in poly(dots[[1L]],
>     >> >>>>> degree, raw = raw, simple = raw && nd > 1) : 'degree'
>     >> >>>>> must be less than number of unique points
>     >> >>>>>
>     >> >>>>>
>     >> >>>>> Note also that in this case, 'dots', which is the
>     >> >>>>> result of using list(...) on the initial call, is:
>     >> >>>>>
>     >> >>>>> Browse[2]> dots [[1]] [1] 2
>     >> >>>>>
>     >> >>>>>
>     >> >>>>> In the second case:
>     >> >>>>>
>     >> >>>>> Browse[2]> m $x1 [1] 0.99056941 0.13953093 0.38965567
>     >> >>>>> 0.35353514 0.90838486 0.97552474 [7] 0.01135743
>     >> >>>>> 0.06537047 0.56207834 0.50554056 0.96653391 0.69533973
>     >> >>>>> [13] 0.31333549 0.97488211 0.54952630 0.71747157
>     >> >>>>> 0.31164777 0.81694822 [19] 0.58641410 0.08858699
>     >> >>>>>
>     >> >>>>> $x2 [1] 0.6628658 0.9221436 0.3162418 0.8494452
>     >> >>>>> 0.4665010 0.3403719 [7] 0.4040692 0.4916650 0.9091161
>     >> >>>>> 0.2956006 0.3454689 0.3331070 [13] 0.8788974 0.5614636
>     >> >>>>> 0.7794396 0.2304009 0.6566537 0.6875646 [19] 0.5110733
>     >> >>>>> 0.4122336
>     >> >>>>>
>     >> >>>>> attr(,"row.names") [1] 1 2 3 4 5 6 7 8 9 10 11 12 13
>     >> >>>>> 14 15 16 17 18 19 20
>     >> >>>>>
>     >> >>>>>
>     >> >>>>> So, there is no m$V3.
>     >> >>>>>
>     >> >>>>> Note also that 'dots' ends up being:
>     >> >>>>>
>     >> >>>>> Browse[2]> dots list()
>     >> >>>>>
>     >> >>>>>
>     >> >>>>> In both cases, 'degree' is indeed 2, but the result of
>     >> >>>>> 'list(...)' on the initial function call is quite
>     >> >>>>> different.
>     >> >>>>>
>     >> >>>>> So, I may be hypo-caffeinated, but if there is a bug
>     >> >>>>> here, it may be due to the way in which cbind() is
>     >> >>>>> being called in the code above, where the three dots
>     >> >>>>> are being used?
>     >> >>>>>
>     >> >>>>> I can replicate the presumably correct behavior by
>     >> >>>>> using:
>     >> >>>>>
>     >> >>>>> m <- unclass(as.data.frame(cbind(x)))
>     >> >>>>>
>     >> >>>>> instead of:
>     >> >>>>>
>     >> >>>>> m <- unclass(as.data.frame(cbind(x, ...)))
>     >> >>>>>
>     >> >>>>> But I am not sure if removing the three dots in the
>     >> >>>>> cbind() call may have other unintended consequences.
>     >> >>>>>
>     >> >>>>> Regards,
>     >> >>>>>
>     >> >>>>> Marc
>     >> >>
>     >> >>
>     >> >>>> Duncan,
>     >> >>
>     >> >>>> Some additional information here.  Reviewing the source
>     >> >>>> code for the function in SVN:
>     >> >>
>     >> >>>> https://svn.r-project.org/R/trunk/src/library/stats/R/contr.poly.R
>     >> >>
>     >> >>>> there is a relevant comment in the code:
>     >> >>
>     >> >>>> if(is.matrix(x)) { ## FIXME: fails when combined with
>     >> >>>> 'unnamed degree' above m <-
>     >> >>>> unclass(as.data.frame(cbind(x, ...)))
>     >> >>>> return(do.call(polym, c(m, degree = degree, raw = raw,
>     >> >>>> list(coefs=coefs)))) }
>     >> >>
>     >> >>
>     >> >>>> A version review would suggest that the above comment
>     >> >>>> was added to the code back in 2015.
>     >> >>
>     >> >>> Yes, by me, possibly here :
>     >> >>
>     >> >>> $ svn log -v -c68727
>     >> >>> ------------------------------------------------------------------------
>     >> >>> r68727 | maechler | 2015-07-23 16:14:59 +0200 (Thu, 23
>     >> >>> Jul 2015) | 1 line Changed paths: M /trunk/doc/NEWS.Rd M
>     >> >>> /trunk/src/library/stats/R/contr.poly.R M
>     >> >>> /trunk/src/library/stats/man/poly.Rd M
>     >> >>> /trunk/tests/Examples/stats-Ex.Rout.save M
>     >> >>> /trunk/tests/reg-tests-1c.R
>     >> >>
>     >> >>> poly(), polym() now work better notably for prediction
>     >> >>> ------------------------------------------------------------------------
>     >> >>> $ svn-diffB -c68727 doc/NEWS.Rd Index: doc/NEWS.Rd
>     >> >>> ===================================================================
>     >> >>> 126a127,133
>     >> >>>>
>     >> >>>> \item \code{polym()} gains a \code{coefs = NULL}
>     >> >>>> argument and returns class \code{"poly"} just like
>     >> >>>> \code{poly()} which gets a new \code{simple=FALSE}
>     >> >>>> option.  They now lead to correct \code{predict()}ions,
>     >> >>>> e.g., on subsets of the original data.  %% see
>     >> >>>> https://stat.ethz.ch/pipermail/r-devel/2015-July/071532.html
>     >> >>
>     >> >>
>     >> >>>> So it would appear that the behavior being discussed
>     >> >>>> here is known.
>     >> >>
>     >> >>> Indeed!  I remember to have spent quite a few hours with
>     >> >>> the code and its different uses before committing that
>     >> >>> patch.
>     >> >>
>     >> >>>> I am still confused by the need for the '...' in the
>     >> >>>> call to cbind(), which as far as I can tell, has been
>     >> >>>> in the code at least back to 2003, when the poly() code
>     >> >>>> was split from base.
>     >> >>
>     >> >>>> I am not sure why one would want to pass on other '...'
>     >> >>>> arguments to cbind(), but I am presumably missing
>     >> >>>> something here.
>     >> >>
>     >> >>> Yes, I think passing the '...' is important there...
>     >> >>> OTOH, I'm almost sure that I wrote the 'FIXME' because I
>     >> >>> thought one should be able to do things better.  So, I'm
>     >> >>> happy to e-talk to you about how to get rid of the FIXME
>     >> >>> and still remain back-compatible: Notably with the
>     >> >>> paragraph in ?poly |> Details:
>     >> >>> |>
>     >> >>> |> Although formally ?degree? should be named (as it
>     >> >>> follows ?...?), |> an unnamed second argument of length
>     >> >>> 1 will be interpreted as the |> degree, such that
>     >> >>> ?poly(x, 3)? can be used in formulas.
>     >> >>
>     >> >> As a matter of fact, a patch seems very simple, and I am
>     >> >> testing it now.
>     >> >>
>     >> >> Won't have much more time today, but will return "on this
>     >> >> channel" later, maybe tomorrow.
>     >> >>
>     >> >> Martin
>     >>
>     >>
>     >> > Martin,
>     >> > Thanks for taking the time to look at this!
>     >>
>     >> > Marc
>     >>
>     >> Duncan had in the mean time filed a bug report about this,
>     --> https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17310
>     >> but I had fixed the issue even before seeing the PR.
>     >> [currently fixed in R-devel only (svn r 72919)]
>
>     > I wrote to you the next day, when Marc pointed out the FIXME comment.
>     > Did you not receive my message?
>
>     > Duncan Murdoch
>
> I'm sorry Duncan,
> there must have been messages crossing each other, possibly
> delayed on this end, where some (including me) are using a new
> spam/virus filtering service.
> Yes, I saw that too.. but also quite a bit *after* having
> replied on R-devel that I was the author of the FIXME and that I
> was going to look into the issue...
> ... and then I did look into the issue instead of checking my
> (almost always much too many) e-mails.
>
> But there's no problem about this, right?
> I'm sorry if I gave the impression in some way.
> It's good to have a bug report that we can quickly close isn't it?

No, there's no problem.  I was just concerned because it sounded as 
though you hadn't received it; if messages were getting lost, that would 
be a problem.

Duncan Murdoch


From jean-luc.lipatz at insee.fr  Tue Jul 18 13:03:46 2017
From: jean-luc.lipatz at insee.fr (Lipatz Jean-Luc)
Date: Tue, 18 Jul 2017 11:03:46 +0000
Subject: [Rd] list.files returns unwanted files
Message-ID: <FEF25E56AFC7064784FA97C576467E0AC7ACCD2B@pdexchbalwst01.ad.insee.intra>

Hi all,

I have found a strange behaviour with 'list.files' (it can easily be bypassed with the 'pattern' argument but doesn't seem to me very constistent to the 'files.all' one):
The problem is that Windows files begining with a tilde are returned by list.files, even if they are hidden.

I reproduced the behaviour, opening an existing document 'Test.doc' with Microsoft Word. The result is then:
> list.files("D:/h2izgk/Essais")
 [1] "~$Test.doc" "Test.doc"

Under the Windows explorer, the first file appears only if the hidden files are made visible, and the actual name that is displayed is ".~lock.Test.doc#" (another strange thing)
Such files seem to be temporary ones and are not specific to MS Word and it appears that some of them survive to the closing of their application.

Thanks

> sessionInfo()
R version 3.3.3 (2017-03-06)
Platform: i386-w64-mingw32/i386 (32-bit)
Running under: Windows 7 x64 (build 7601) Service Pack 1

locale:
[1] LC_COLLATE=French_France.1252  LC_CTYPE=French_France.1252    LC_MONETARY=French_France.1252
[4] LC_NUMERIC=C                   LC_TIME=French_France.1252

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base

other attached packages:
[1] inline_0.3.14     MASS_7.3-47       iplots_1.1-7      rJava_0.9-8       sourcetools_0.1.6

loaded via a namespace (and not attached):
[1] tools_3.3.3 png_0.1-7


	[[alternative HTML version deleted]]


From skostyshak at ufl.edu  Thu Jul 20 09:28:37 2017
From: skostyshak at ufl.edu (Scott Kostyshak)
Date: Thu, 20 Jul 2017 03:28:37 -0400
Subject: [Rd] [patch] ?confint: "assumes asymptotic normality"
Message-ID: <20170720072837.phhhg7q6lxmjzboj@steph>

>From ?confint:

"Computes confidence intervals" and "The default method assumes
asymptotic normality"

For me, a "confidence interval" implies an exact confidence interval in
formal statistics (I concede that when speaking, the term is often used
more loosely). And of course, even if a test statistic is asymptotically
normal (so the assumption is satisfied), the finite distribution might
not be normal and thus an exact confidence interval would not be
computed.

Attached is a patch that simply changes "asymptotic normality" to
"normality" in confint.Rd. This encourages the user of the function to
think about whether their asymptotically normal statistic is "normal
enough" in a finite sample to get something reliable from confint().

Alternatively, we could instead change "Computes confidence intervals"
to "Computes asymptotic confidence intervals".

I hope I'm not being too pedantic here.

Scott


-- 
Scott Kostyshak
Assistant Professor of Economics
University of Florida
https://people.clas.ufl.edu/skostyshak/

-------------- next part --------------
Index: src/library/stats/man/confint.Rd
===================================================================
--- src/library/stats/man/confint.Rd	(revision 72930)
+++ src/library/stats/man/confint.Rd	(working copy)
@@ -31,7 +31,7 @@
 }
 \details{
   \code{confint} is a generic function.  The default method assumes
-  asymptotic normality, and needs suitable \code{\link{coef}} and
+  normality, and needs suitable \code{\link{coef}} and
   \code{\link{vcov}} methods to be available.  The default method can be
   called directly for comparison with other methods.
 

From csardi.gabor at gmail.com  Thu Jul 20 12:19:57 2017
From: csardi.gabor at gmail.com (=?UTF-8?B?R8OhYm9yIENzw6FyZGk=?=)
Date: Thu, 20 Jul 2017 11:19:57 +0100
Subject: [Rd] configure check might fail for texi2any on Solaris
Message-ID: <CABtg=KkxPKhcaMg1BB9xOVWr_jrhVk55_VQrzNJy0V_xHRdNsQ@mail.gmail.com>

This is R-patched, from 15th of July. I get:

configure:5117: found /opt/csw/bin/texi2any
configure:5129: result: /opt/csw/bin/texi2any
configure:5141: checking whether texi2any is at least 5.1
configure:5163: result:no

However:

/opt/csw/bin/texi2any --version
texi2any (GNU texinfo) 6.1

Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Does the configure check fail or am I missing something?

Thanks,
Gabor


From csardi.gabor at gmail.com  Thu Jul 20 12:31:57 2017
From: csardi.gabor at gmail.com (=?UTF-8?B?R8OhYm9yIENzw6FyZGk=?=)
Date: Thu, 20 Jul 2017 11:31:57 +0100
Subject: [Rd] configure check might fail for texi2any on Solaris
In-Reply-To: <CABtg=KkxPKhcaMg1BB9xOVWr_jrhVk55_VQrzNJy0V_xHRdNsQ@mail.gmail.com>
References: <CABtg=KkxPKhcaMg1BB9xOVWr_jrhVk55_VQrzNJy0V_xHRdNsQ@mail.gmail.com>
Message-ID: <CABtg=Kka5pWXxWEd7szGEzfc4fO+SzNQkMgvLcWS6LWBqqnmfg@mail.gmail.com>

Seems like I just need to put /usr/xpg4/bin first in the PATH, that
has a feature full grep program, and then the configure test passes.

Gabor

On Thu, Jul 20, 2017 at 11:19 AM, G?bor Cs?rdi <csardi.gabor at gmail.com> wrote:
> This is R-patched, from 15th of July. I get:
>
> configure:5117: found /opt/csw/bin/texi2any
> configure:5129: result: /opt/csw/bin/texi2any
> configure:5141: checking whether texi2any is at least 5.1
> configure:5163: result:no
>
> However:
>
> /opt/csw/bin/texi2any --version
> texi2any (GNU texinfo) 6.1
>
> Copyright (C) 2016 Free Software Foundation, Inc.
> License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
> This is free software: you are free to change and redistribute it.
> There is NO WARRANTY, to the extent permitted by law.
>
> Does the configure check fail or am I missing something?
>
> Thanks,
> Gabor


From iago.mosqueira at gmail.com  Thu Jul 20 13:55:58 2017
From: iago.mosqueira at gmail.com (Iago Mosqueira)
Date: Thu, 20 Jul 2017 13:55:58 +0200
Subject: [Rd] Separate packages per windows subarch in repository
Message-ID: <CAAi6idX_HGY6QwNMnvVgwJ-EGD5FX8tY_vYjOEHd-O6YFFZUQg@mail.gmail.com>

Hi,

I maintain a repository of R packages, where some of them contain
executable binaries. I need to separate those compiled for 32 and 64 bit in
Windows, but I could not how to do any of the two options I can think of:

1. Have subarch subfolders in PKG/inst/bin to that the right one is
installed or called

2. Have separate versions of the packages accessible in the same repository
for each subarch, e.g. bin/windows/contrib/3.4/i386

Could I do thew first via a configure.win script?

Is the second option possible?

Any pointers to the documentation I might have missed would be appreciated.

Best regards,


Iago

	[[alternative HTML version deleted]]


From ligges at statistik.tu-dortmund.de  Thu Jul 20 15:38:14 2017
From: ligges at statistik.tu-dortmund.de (Uwe Ligges)
Date: Thu, 20 Jul 2017 15:38:14 +0200
Subject: [Rd] Separate packages per windows subarch in repository
In-Reply-To: <CAAi6idX_HGY6QwNMnvVgwJ-EGD5FX8tY_vYjOEHd-O6YFFZUQg@mail.gmail.com>
References: <CAAi6idX_HGY6QwNMnvVgwJ-EGD5FX8tY_vYjOEHd-O6YFFZUQg@mail.gmail.com>
Message-ID: <24eede53-227b-bb36-4071-fcfd112214fc@statistik.tu-dortmund.de>



On 20.07.2017 13:55, Iago Mosqueira wrote:
> Hi,
> 
> I maintain a repository of R packages, where some of them contain
> executable binaries. I need to separate those compiled for 32 and 64 bit in
> Windows, but I could not how to do any of the two options I can think of:
> 
> 1. Have subarch subfolders in PKG/inst/bin to that the right one is
> installed or called

Use 1., i.e. the same approach as for dlls, where we have the two 
subdirs for the two archs.

I think this will be difficult in Makevars.win when you build the 
executable binaries as part of the installation process, hence I think 
an appropriate Makefile.win should be used.

Best,
Uwe Ligges




> 2. Have separate versions of the packages accessible in the same repository
> for each subarch, e.g. bin/windows/contrib/3.4/i386
> 
> Could I do thew first via a configure.win script?
> 
> Is the second option possible?
> 
> Any pointers to the documentation I might have missed would be appreciated.
> 
> Best regards,
> 
> 
> Iago
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From jeroenooms at gmail.com  Thu Jul 20 15:47:15 2017
From: jeroenooms at gmail.com (Jeroen Ooms)
Date: Thu, 20 Jul 2017 15:47:15 +0200
Subject: [Rd] Separate packages per windows subarch in repository
In-Reply-To: <CAAi6idX_HGY6QwNMnvVgwJ-EGD5FX8tY_vYjOEHd-O6YFFZUQg@mail.gmail.com>
References: <CAAi6idX_HGY6QwNMnvVgwJ-EGD5FX8tY_vYjOEHd-O6YFFZUQg@mail.gmail.com>
Message-ID: <CABFfbXthOdM_c3D1chhFrs_p0CC7HjhcrQ=KcXZGUwY1NCwanA@mail.gmail.com>

On Thu, Jul 20, 2017 at 1:55 PM, Iago Mosqueira
<iago.mosqueira at gmail.com> wrote:
>
> I maintain a repository of R packages, where some of them contain
> executable binaries. I need to separate those compiled for 32 and 64 bit in
> Windows.

Have a look at the antiword package. It has a simple makevars which
builds antiword$(WIN) executable which is just the 'antiword' on unix,
and antiword32.exe + antiword64.exe on multiarch windows.


From maechler at stat.math.ethz.ch  Thu Jul 20 16:21:04 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Thu, 20 Jul 2017 16:21:04 +0200
Subject: [Rd] [patch] ?confint: "assumes asymptotic normality"
In-Reply-To: <20170720072837.phhhg7q6lxmjzboj@steph>
References: <20170720072837.phhhg7q6lxmjzboj@steph>
Message-ID: <22896.48208.806371.980068@stat.math.ethz.ch>

>>>>> Scott Kostyshak <skostyshak at ufl.edu>
>>>>>     on Thu, 20 Jul 2017 03:28:37 -0400 writes:

    >> From ?confint:
    > "Computes confidence intervals" and "The default method assumes
    > asymptotic normality"

    > For me, a "confidence interval" implies an exact confidence interval in
    > formal statistics (I concede that when speaking, the term is often used
    > more loosely). And of course, even if a test statistic is asymptotically
    > normal (so the assumption is satisfied), the finite distribution might
    > not be normal and thus an exact confidence interval would not be
    > computed.

    > Attached is a patch that simply changes "asymptotic normality" to
    > "normality" in confint.Rd. This encourages the user of the function to
    > think about whether their asymptotically normal statistic is "normal
    > enough" in a finite sample to get something reliable from confint().

    > Alternatively, we could instead change "Computes confidence intervals"
    > to "Computes asymptotic confidence intervals".

    > I hope I'm not being too pedantic here.

well, it's just at the 97.5% border line of "too pedantic"  ...
















;-)

I think you are right with your first proposal to drop
"asymptotic" here.  After all, there's the explict 'fac <- qnorm(a)'.

One could consider to make  'qnorm' an argument of the
default method to allow more general distributional assumptions,
but it may be wiser to have useRs write their own
confint.<foo>() method, notably for cases where
diag(vcov(object)) is an efficiency waste...

Martin


    > Scott


    > -- 
    > Scott Kostyshak
    > Assistant Professor of Economics
    > University of Florida
    > https://people.clas.ufl.edu/skostyshak/


    > ----------------------------------------------------------------------
    > Index: src/library/stats/man/confint.Rd
    > ===================================================================
    > --- src/library/stats/man/confint.Rd	(revision 72930)
    > +++ src/library/stats/man/confint.Rd	(working copy)
    > @@ -31,7 +31,7 @@
    > }
    > \details{
    > \code{confint} is a generic function.  The default method assumes
    > -  asymptotic normality, and needs suitable \code{\link{coef}} and
    > +  normality, and needs suitable \code{\link{coef}} and
    > \code{\link{vcov}} methods to be available.  The default method can be
    > called directly for comparison with other methods.
 

    > ----------------------------------------------------------------------
    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From iago.mosqueira at gmail.com  Thu Jul 20 16:21:20 2017
From: iago.mosqueira at gmail.com (Iago Mosqueira)
Date: Thu, 20 Jul 2017 16:21:20 +0200
Subject: [Rd] Separate packages per windows subarch in repository
In-Reply-To: <24eede53-227b-bb36-4071-fcfd112214fc@statistik.tu-dortmund.de>
References: <CAAi6idX_HGY6QwNMnvVgwJ-EGD5FX8tY_vYjOEHd-O6YFFZUQg@mail.gmail.com>
 <24eede53-227b-bb36-4071-fcfd112214fc@statistik.tu-dortmund.de>
Message-ID: <CAAi6idWLxm+M070s98ZEpaXNgx8_aLeSNyhswvp5BwS98en=Hg@mail.gmail.com>

Thanks. I did not explain clearly that the executables are not compiled
during package compilation, apologies. They are compiled beforehand, as
they use ADMB (AD Model Builder) and placed in inst/bin/windows.

I assume Makefile.win could copy the appropriate one from PKG/bin/$arch to
PKG/inst/bin/ so that the right one is installed?

Cheers,


Iago

On 20 July 2017 at 15:38, Uwe Ligges <ligges at statistik.tu-dortmund.de>
wrote:

>
>
> On 20.07.2017 13:55, Iago Mosqueira wrote:
>
>> Hi,
>>
>> I maintain a repository of R packages, where some of them contain
>> executable binaries. I need to separate those compiled for 32 and 64 bit
>> in
>> Windows, but I could not how to do any of the two options I can think of:
>>
>> 1. Have subarch subfolders in PKG/inst/bin to that the right one is
>> installed or called
>>
>
> Use 1., i.e. the same approach as for dlls, where we have the two subdirs
> for the two archs.
>
> I think this will be difficult in Makevars.win when you build the
> executable binaries as part of the installation process, hence I think an
> appropriate Makefile.win should be used.
>
> Best,
> Uwe Ligges
>
>
>
>
> 2. Have separate versions of the packages accessible in the same repository
>> for each subarch, e.g. bin/windows/contrib/3.4/i386
>>
>> Could I do thew first via a configure.win script?
>>
>> Is the second option possible?
>>
>> Any pointers to the documentation I might have missed would be
>> appreciated.
>>
>> Best regards,
>>
>>
>> Iago
>>
>>         [[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>>

	[[alternative HTML version deleted]]


From farinan at gmail.com  Thu Jul 20 16:51:54 2017
From: farinan at gmail.com (nicola farina)
Date: Thu, 20 Jul 2017 16:51:54 +0200
Subject: [Rd] Change in print.function between R 3.4.1 and R 3.4.0
Message-ID: <CACsp0uJMjDL-JjiWQN24XVtS2REwEbmR7h-h0eAWv+DrkF1QdA@mail.gmail.com>

Dear all,

I just installed R 3.4.1 and noticed a change in how user-defined functions
are printed. A small example:

string<-"f<-function(x){\n\tx^2\n}"
cat(string,file="tmp00a.R")
source("tmp00a.R")
f

And this is what I see:

#R 3.4.0
function(x){
    x^2
}

#R 3.4.1
function(x){
\tx^2
}

Seems that in 3.4.1 the tab character isn't "rendered". This is rather
annoying since it becomes very difficult to inspect the source code of user
defined functions. This behaviour seems to be present just for the tab
character (\n and \r are displayed correctly).

I'm on Ubuntu 14, 64bit. If you need more details I will gladly provide
what I can. Here is my sessionInfo():

R version 3.4.1 (2017-06-30)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 14.04.5 LTS

Matrix products: default
BLAS: /usr/local/R-3.4.1/lib/libRblas.so
LAPACK: /usr/local/R-3.4.1/lib/libRlapack.so

locale:
 [1] LC_CTYPE=it_IT.UTF-8       LC_NUMERIC=C
 [3] LC_TIME=it_IT.UTF-8        LC_COLLATE=it_IT.UTF-8
 [5] LC_MONETARY=it_IT.UTF-8    LC_MESSAGES=it_IT.UTF-8
 [7] LC_PAPER=it_IT.UTF-8       LC_NAME=C
 [9] LC_ADDRESS=C               LC_TELEPHONE=C
[11] LC_MEASUREMENT=it_IT.UTF-8 LC_IDENTIFICATION=C

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base

loaded via a namespace (and not attached):
[1] compiler_3.4.1 tools_3.4.1

(the value of sessionInfo() on R 3.4.0 is obviously identical aside from
the versions).


Thank you for your attention and your incredible work.

Nicola Farina

	[[alternative HTML version deleted]]


From westra.harmjan at outlook.com  Thu Jul 20 17:02:30 2017
From: westra.harmjan at outlook.com (Harm-Jan Westra)
Date: Thu, 20 Jul 2017 15:02:30 +0000
Subject: [Rd] Wrongly converging glm()
Message-ID: <DM3PR20MB05722D6CF8D15F73CC4CE65987A70@DM3PR20MB0572.namprd20.prod.outlook.com>

Dear R-core,


I have found an edge-case where the glm function falsely concludes that the model has converged. The issue is the following: my data contains a number of covariates, one of these covariates has a very small variance. For most of the rows of this covariate, the value is 0, except for one of the rows, where it is 1.


The glm function correctly determines the beta and standard error estimates for all other covariates.


I've placed the data here: http://www.harmjanwestra.nl/rtestdata.txt


The model I'm using is very simple:


data <- read.table("rtestdata.txt")

model <- glm(data[,1] ~ data[,2] + data[,3] + data[,4] + data[,5] + data[,6] + data[,7] + data[,8] + data[,9] + data[,10] + data[,11] + data[,12] + data[,13] + data[,14], family=binomial("logit"))

summary(model)


You will see that for covariate data[,13], the beta/coefficient estimate is around -9. The number of iterations that has been performed is 8, and model$converged returns TRUE.


I've used some alternate logistic regression code in C (https://github.com/czep/mlelr/blob/master/src/mlelr.c), which produces identical estimates for the other covariates and comparable deviance values. However, using this C code, I'm seeing that the estimate for data[,13] is around -100 (since I'm allowing a maximum of 100 MLE iterations). There, the conclusion is that the model does not converge.


The difference between the two pieces of code is that in R, the glm() function determines convergence of the whole model by measuring the difference between deviance of the current iteration versus the deviance of the prior iteration, and calls the model converged when it reaches a certain epsilon value. In the C++ code, the model is converged when all parameters haven't changed markedly compared to the previous iteration.


I think both approaches are valid, although the R variant (while faster) makes it vulnerable to wrongly concluding convergence in edge cases such as the one presented above, resulting in wrong coefficient estimates. For people wanting to use logistic regression in a training/prediction kind of setting, using these estimates might influence their predictive performance.


The problem here is that the glm function does not return any warnings when one of the covariates in the model does not converge. For someone who is not paying attention, this may lead them to conclude there is nothing wrong with their data. In my opinion, the default behavior in this case should therefore be to conclude that the model did not converge, or at least to show a warning message.


Please let me know whether you believe this is an issue, and whether I can provide additional information.


With kind regards,


Harm-Jan Westra









	[[alternative HTML version deleted]]


From iago.mosqueira at gmail.com  Thu Jul 20 17:25:10 2017
From: iago.mosqueira at gmail.com (Iago Mosqueira)
Date: Thu, 20 Jul 2017 17:25:10 +0200
Subject: [Rd] Separate packages per windows subarch in repository
In-Reply-To: <CAAi6idWLxm+M070s98ZEpaXNgx8_aLeSNyhswvp5BwS98en=Hg@mail.gmail.com>
References: <CAAi6idX_HGY6QwNMnvVgwJ-EGD5FX8tY_vYjOEHd-O6YFFZUQg@mail.gmail.com>
 <24eede53-227b-bb36-4071-fcfd112214fc@statistik.tu-dortmund.de>
 <CAAi6idWLxm+M070s98ZEpaXNgx8_aLeSNyhswvp5BwS98en=Hg@mail.gmail.com>
Message-ID: <CAAi6idWma2-KPSVSRWg1jWRcT6cpZ_nP8kLgBcD533qncOVpRg@mail.gmail.com>

I have something working using configure.win, but this changes the
executable when the windows version of the package is created via R CMD
INSTALL --build.

Could there be any way to do so at installation time from the binary
package?

Thanks,


Iago

On 20 July 2017 at 16:21, Iago Mosqueira <iago.mosqueira at gmail.com> wrote:

> Thanks. I did not explain clearly that the executables are not compiled
> during package compilation, apologies. They are compiled beforehand, as
> they use ADMB (AD Model Builder) and placed in inst/bin/windows.
>
> I assume Makefile.win could copy the appropriate one from PKG/bin/$arch to
> PKG/inst/bin/ so that the right one is installed?
>
> Cheers,
>
>
> Iago
>
> On 20 July 2017 at 15:38, Uwe Ligges <ligges at statistik.tu-dortmund.de>
> wrote:
>
>>
>>
>> On 20.07.2017 13:55, Iago Mosqueira wrote:
>>
>>> Hi,
>>>
>>> I maintain a repository of R packages, where some of them contain
>>> executable binaries. I need to separate those compiled for 32 and 64 bit
>>> in
>>> Windows, but I could not how to do any of the two options I can think of:
>>>
>>> 1. Have subarch subfolders in PKG/inst/bin to that the right one is
>>> installed or called
>>>
>>
>> Use 1., i.e. the same approach as for dlls, where we have the two subdirs
>> for the two archs.
>>
>> I think this will be difficult in Makevars.win when you build the
>> executable binaries as part of the installation process, hence I think an
>> appropriate Makefile.win should be used.
>>
>> Best,
>> Uwe Ligges
>>
>>
>>
>>
>> 2. Have separate versions of the packages accessible in the same
>>> repository
>>> for each subarch, e.g. bin/windows/contrib/3.4/i386
>>>
>>> Could I do thew first via a configure.win script?
>>>
>>> Is the second option possible?
>>>
>>> Any pointers to the documentation I might have missed would be
>>> appreciated.
>>>
>>> Best regards,
>>>
>>>
>>> Iago
>>>
>>>         [[alternative HTML version deleted]]
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>>
>

	[[alternative HTML version deleted]]


From maechler at stat.math.ethz.ch  Thu Jul 20 17:36:50 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Thu, 20 Jul 2017 17:36:50 +0200
Subject: [Rd] Change in print.function between R 3.4.1 and R 3.4.0
In-Reply-To: <CACsp0uJMjDL-JjiWQN24XVtS2REwEbmR7h-h0eAWv+DrkF1QdA@mail.gmail.com>
References: <CACsp0uJMjDL-JjiWQN24XVtS2REwEbmR7h-h0eAWv+DrkF1QdA@mail.gmail.com>
Message-ID: <22896.52754.12907.448687@stat.math.ethz.ch>

>>>>> nicola farina <farinan at gmail.com>
>>>>>     on Thu, 20 Jul 2017 16:51:54 +0200 writes:

    > Dear all,
    > I just installed R 3.4.1 and noticed a change in how user-defined functions
    > are printed. A small example:

    > string<-"f<-function(x){\n\tx^2\n}"
    > cat(string,file="tmp00a.R")
    > source("tmp00a.R")
    > f

    > And this is what I see:

    > #R 3.4.0
    > function(x){
    > x^2
    > }

    > #R 3.4.1
    > function(x){
    > \tx^2
    > }

    > Seems that in 3.4.1 the tab character isn't "rendered". This is rather
    > annoying since it becomes very difficult to inspect the source code of user
    > defined functions. This behaviour seems to be present just for the tab
    > character (\n and \r are displayed correctly).

    [..............]

    > Thank you for your attention and your incredible work.

Thank you for the flowers.

Believe it or not, I've detected this bug about 8 hours ago, after typing

  menu

at the R prompt after receiving a bug report about it.

It came from fixing bug  PR#16732  (which was about rendering
Japanese fonts in a function defintion when printing)

  https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16732

A (probably shortest possible!) symptom of the bug is
that in R <= 3.4.0,

> quote(-"\n")
-"\n"
> 

whereas in R 3.4.1 (and the current newer development versions of R)

> quote(-"\n")
-"\\n"
> 


Ideally, fixing this (wrong duplication of "\") will not make
bug 16732 resurface.

I expect a bug fix by tomorrow.
If this is a big problem for you, you will have to upgrade to
     "R 3.4.1 patched"
during the weekend.
(Downgrading to R 3.4.0 is not a good idea, compared to the above!)

Martin Maechler,
ETH Zurich


    > Nicola Farina

    > [[alternative HTML version deleted]]
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    (do learn to post in plain text on R-devel, please)


From jorismeys at gmail.com  Thu Jul 20 17:38:58 2017
From: jorismeys at gmail.com (Joris Meys)
Date: Thu, 20 Jul 2017 17:38:58 +0200
Subject: [Rd] Wrongly converging glm()
In-Reply-To: <DM3PR20MB05722D6CF8D15F73CC4CE65987A70@DM3PR20MB0572.namprd20.prod.outlook.com>
References: <DM3PR20MB05722D6CF8D15F73CC4CE65987A70@DM3PR20MB0572.namprd20.prod.outlook.com>
Message-ID: <CAO1zAVa5uOEswx8b8HhHMwGNazz8Pgq3nmYhR2okTiCM4+-cRg@mail.gmail.com>

Allow me to chime in. That's an interesting case you present, but as far as
I'm concerned the algorithm did converge. The estimate of -9.25 has an
estimated standard error of 72.4, meaning that frequentists would claim the
true value would lie anywhere between appx. -151 and 132 (CI) and hence the
estimate from the glm algorithm is perfectly compatible with the one from
the C++ code. And as the glm algorithm uses a different convergence rule,
the algorithm rightfully reported it converged. It's not because another
algorithm based on another rule doesn't converge, that the one glm uses
didn't.

On top of that: In both cases the huge standard error on that estimate
clearly tells you that the estimate should not be trusted, and the fit is
unstable. That's to be expected, given the insane inbalance in your data,
especially for the 13th column. If my students would incorporate that
variable in a generalized linear model and tries to formulate a conclusion
based on that coefficient, they failed the exam. So if somebody does this
analysis and tries to draw any conclusion whatsoever on that estimate,
maybe they should leave the analysis to somebody who does know what they're
doing.

Cheers
Joris

On Thu, Jul 20, 2017 at 5:02 PM, Harm-Jan Westra <westra.harmjan at outlook.com
> wrote:

> Dear R-core,
>
>
> I have found an edge-case where the glm function falsely concludes that
> the model has converged. The issue is the following: my data contains a
> number of covariates, one of these covariates has a very small variance.
> For most of the rows of this covariate, the value is 0, except for one of
> the rows, where it is 1.
>
>
> The glm function correctly determines the beta and standard error
> estimates for all other covariates.
>
>
> I've placed the data here: http://www.harmjanwestra.nl/rtestdata.txt
>
>
> The model I'm using is very simple:
>
>
> data <- read.table("rtestdata.txt")
>
> model <- glm(data[,1] ~ data[,2] + data[,3] + data[,4] + data[,5] +
> data[,6] + data[,7] + data[,8] + data[,9] + data[,10] + data[,11] +
> data[,12] + data[,13] + data[,14], family=binomial("logit"))
>
> summary(model)
>
>
> You will see that for covariate data[,13], the beta/coefficient estimate
> is around -9. The number of iterations that has been performed is 8, and
> model$converged returns TRUE.
>
>
> I've used some alternate logistic regression code in C (
> https://github.com/czep/mlelr/blob/master/src/mlelr.c), which produces
> identical estimates for the other covariates and comparable deviance
> values. However, using this C code, I'm seeing that the estimate for
> data[,13] is around -100 (since I'm allowing a maximum of 100 MLE
> iterations). There, the conclusion is that the model does not converge.
>
>
> The difference between the two pieces of code is that in R, the glm()
> function determines convergence of the whole model by measuring the
> difference between deviance of the current iteration versus the deviance of
> the prior iteration, and calls the model converged when it reaches a
> certain epsilon value. In the C++ code, the model is converged when all
> parameters haven't changed markedly compared to the previous iteration.
>
>
> I think both approaches are valid, although the R variant (while faster)
> makes it vulnerable to wrongly concluding convergence in edge cases such as
> the one presented above, resulting in wrong coefficient estimates. For
> people wanting to use logistic regression in a training/prediction kind of
> setting, using these estimates might influence their predictive performance.
>
>
> The problem here is that the glm function does not return any warnings
> when one of the covariates in the model does not converge. For someone who
> is not paying attention, this may lead them to conclude there is nothing
> wrong with their data. In my opinion, the default behavior in this case
> should therefore be to conclude that the model did not converge, or at
> least to show a warning message.
>
>
> Please let me know whether you believe this is an issue, and whether I can
> provide additional information.
>
>
> With kind regards,
>
>
> Harm-Jan Westra
>
>
>
>
>
>
>
>
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>



-- 
Joris Meys
Statistical consultant

Ghent University
Faculty of Bioscience Engineering
Department of Mathematical Modelling, Statistics and Bio-Informatics

tel :  +32 (0)9 264 61 79
Joris.Meys at Ugent.be
-------------------------------
Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php

	[[alternative HTML version deleted]]


From westra.harmjan at outlook.com  Thu Jul 20 18:21:54 2017
From: westra.harmjan at outlook.com (Harm-Jan Westra)
Date: Thu, 20 Jul 2017 16:21:54 +0000
Subject: [Rd] Wrongly converging glm()
In-Reply-To: <CAO1zAVa5uOEswx8b8HhHMwGNazz8Pgq3nmYhR2okTiCM4+-cRg@mail.gmail.com>
References: <DM3PR20MB05722D6CF8D15F73CC4CE65987A70@DM3PR20MB0572.namprd20.prod.outlook.com>,
 <CAO1zAVa5uOEswx8b8HhHMwGNazz8Pgq3nmYhR2okTiCM4+-cRg@mail.gmail.com>
Message-ID: <DM3PR20MB0572B9357503F0401CC5EABF87A70@DM3PR20MB0572.namprd20.prod.outlook.com>

Dear Joris,


I agree that such a covariate should not be used in the analysis, and fully agree with your assessment. However, your response assumes that everybody who uses R knows what they're doing, which is a dangerous assumption to make. I bet there are a lot of people who blindly trust the output from R, even when there's clearly something wrong with the estimates.


In terms of your conclusion that the C++ estimate corresponds to a value within the R estimated confidence interval: if I allow the C++ code to run for 1000 iterations, it's estimate would be around -1000. It simply never converges.


I think there's nothing wrong with letting the user know there might be something wrong with one of the estimates, especially if your code can easily figure it out for you, by adding an additional rule. Not everyone is always paying attention (even if they know what they're doing).


With kind regards,


Harm-Jan


________________________________
From: Joris Meys <jorismeys at gmail.com>
Sent: Thursday, July 20, 2017 11:38 AM
To: Harm-Jan Westra
Cc: r-devel at r-project.org
Subject: Re: [Rd] Wrongly converging glm()

Allow me to chime in. That's an interesting case you present, but as far as I'm concerned the algorithm did converge. The estimate of -9.25 has an estimated standard error of 72.4, meaning that frequentists would claim the true value would lie anywhere between appx. -151 and 132 (CI) and hence the estimate from the glm algorithm is perfectly compatible with the one from the C++ code. And as the glm algorithm uses a different convergence rule, the algorithm rightfully reported it converged. It's not because another algorithm based on another rule doesn't converge, that the one glm uses didn't.

On top of that: In both cases the huge standard error on that estimate clearly tells you that the estimate should not be trusted, and the fit is unstable. That's to be expected, given the insane inbalance in your data, especially for the 13th column. If my students would incorporate that variable in a generalized linear model and tries to formulate a conclusion based on that coefficient, they failed the exam. So if somebody does this analysis and tries to draw any conclusion whatsoever on that estimate, maybe they should leave the analysis to somebody who does know what they're doing.

Cheers
Joris

On Thu, Jul 20, 2017 at 5:02 PM, Harm-Jan Westra <westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com>> wrote:
Dear R-core,


I have found an edge-case where the glm function falsely concludes that the model has converged. The issue is the following: my data contains a number of covariates, one of these covariates has a very small variance. For most of the rows of this covariate, the value is 0, except for one of the rows, where it is 1.


The glm function correctly determines the beta and standard error estimates for all other covariates.


I've placed the data here: http://www.harmjanwestra.nl/rtestdata.txt


The model I'm using is very simple:


data <- read.table("rtestdata.txt")

model <- glm(data[,1] ~ data[,2] + data[,3] + data[,4] + data[,5] + data[,6] + data[,7] + data[,8] + data[,9] + data[,10] + data[,11] + data[,12] + data[,13] + data[,14], family=binomial("logit"))

summary(model)


You will see that for covariate data[,13], the beta/coefficient estimate is around -9. The number of iterations that has been performed is 8, and model$converged returns TRUE.


I've used some alternate logistic regression code in C (https://github.com/czep/mlelr/blob/master/src/mlelr.c), which produces identical estimates for the other covariates and comparable deviance values. However, using this C code, I'm seeing that the estimate for data[,13] is around -100 (since I'm allowing a maximum of 100 MLE iterations). There, the conclusion is that the model does not converge.


The difference between the two pieces of code is that in R, the glm() function determines convergence of the whole model by measuring the difference between deviance of the current iteration versus the deviance of the prior iteration, and calls the model converged when it reaches a certain epsilon value. In the C++ code, the model is converged when all parameters haven't changed markedly compared to the previous iteration.


I think both approaches are valid, although the R variant (while faster) makes it vulnerable to wrongly concluding convergence in edge cases such as the one presented above, resulting in wrong coefficient estimates. For people wanting to use logistic regression in a training/prediction kind of setting, using these estimates might influence their predictive performance.


The problem here is that the glm function does not return any warnings when one of the covariates in the model does not converge. For someone who is not paying attention, this may lead them to conclude there is nothing wrong with their data. In my opinion, the default behavior in this case should therefore be to conclude that the model did not converge, or at least to show a warning message.


Please let me know whether you believe this is an issue, and whether I can provide additional information.


With kind regards,


Harm-Jan Westra









        [[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel



--
Joris Meys
Statistical consultant

Ghent University
Faculty of Bioscience Engineering
Department of Mathematical Modelling, Statistics and Bio-Informatics

tel :  +32 (0)9 264 61 79
Joris.Meys at Ugent.be
-------------------------------
Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php

	[[alternative HTML version deleted]]


From sbonner6 at uwo.ca  Thu Jul 20 18:32:43 2017
From: sbonner6 at uwo.ca (Simon Bonner)
Date: Thu, 20 Jul 2017 16:32:43 +0000
Subject: [Rd] Wrongly converging glm()
In-Reply-To: <CAO1zAVa5uOEswx8b8HhHMwGNazz8Pgq3nmYhR2okTiCM4+-cRg@mail.gmail.com>
References: <DM3PR20MB05722D6CF8D15F73CC4CE65987A70@DM3PR20MB0572.namprd20.prod.outlook.com>
 <CAO1zAVa5uOEswx8b8HhHMwGNazz8Pgq3nmYhR2okTiCM4+-cRg@mail.gmail.com>
Message-ID: <DM5PR1101MB2364F3BE649E223A13655868E4A70@DM5PR1101MB2364.namprd11.prod.outlook.com>

In defence of Harma-Jan's original post I would say that there is a difference between true convergence and satisfying a convergence criterion. 

In my view the algorithm has not converged. This is a case of quasi-complete separate -- there are both successes and failures when x13=0 but only failures when x13=1. As a result, the likelihood has no maximum and increases, albeit slightly, as the associated coefficient tends to infinity while maximizing over the other parameters. The estimate given is not the MLE and the standard error is not meaningful because the conditions for convergence of MLEs to their asymptotic normal distribution has been violated.

I agree with Joris that someone familiar with logistic regression should be able to identify this situation -- though the solution is not as simple as throwing out the covariate. Suppose that there had been many failures when x13=1, not just 1. The same problem would arise, but x13 is clearly an important covariate. Removing it from the analysis is not the thing to do. A better solution is to penalize the likelihood or (and I'm showing my true colours here) conduct a Bayesian analysis. 

Regarding the statement that the algorithm has converged, perhaps R should say more truthfully that the convergence criterion has been satisfied -- but that might lead to more confusion. In this case, any convergence criterion will be satisfied eventually. If you increase the maximum number of iterations in the C implementation then the other convergence criterion will be satisfied and the code will say that the algorithm has converged. 

In the end, it's up to the analyst to be aware of the pitfalls and how to address them.

Cheers,

Simon

> -----Original Message-----
> From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of Joris Meys
> Sent: July 20, 2017 11:39 AM
> To: Harm-Jan Westra <westra.harmjan at outlook.com>
> Cc: r-devel at r-project.org
> Subject: Re: [Rd] Wrongly converging glm()
> 
> Allow me to chime in. That's an interesting case you present, but as far as I'm
> concerned the algorithm did converge. The estimate of -9.25 has an estimated
> standard error of 72.4, meaning that frequentists would claim the true value
> would lie anywhere between appx. -151 and 132 (CI) and hence the estimate
> from the glm algorithm is perfectly compatible with the one from the C++ code.
> And as the glm algorithm uses a different convergence rule, the algorithm
> rightfully reported it converged. It's not because another algorithm based on
> another rule doesn't converge, that the one glm uses didn't.
> 
> On top of that: In both cases the huge standard error on that estimate clearly
> tells you that the estimate should not be trusted, and the fit is unstable. That's
> to be expected, given the insane inbalance in your data, especially for the 13th
> column. If my students would incorporate that variable in a generalized linear
> model and tries to formulate a conclusion based on that coefficient, they failed
> the exam. So if somebody does this analysis and tries to draw any conclusion
> whatsoever on that estimate, maybe they should leave the analysis to
> somebody who does know what they're doing.
> 
> Cheers
> Joris
> 
> On Thu, Jul 20, 2017 at 5:02 PM, Harm-Jan Westra
> <westra.harmjan at outlook.com
> > wrote:
> 
> > Dear R-core,
> >
> >
> > I have found an edge-case where the glm function falsely concludes
> > that the model has converged. The issue is the following: my data
> > contains a number of covariates, one of these covariates has a very small
> variance.
> > For most of the rows of this covariate, the value is 0, except for one
> > of the rows, where it is 1.
> >
> >
> > The glm function correctly determines the beta and standard error
> > estimates for all other covariates.
> >
> >
> > I've placed the data here: http://www.harmjanwestra.nl/rtestdata.txt
> >
> >
> > The model I'm using is very simple:
> >
> >
> > data <- read.table("rtestdata.txt")
> >
> > model <- glm(data[,1] ~ data[,2] + data[,3] + data[,4] + data[,5] +
> > data[,6] + data[,7] + data[,8] + data[,9] + data[,10] + data[,11] +
> > data[,12] + data[,13] + data[,14], family=binomial("logit"))
> >
> > summary(model)
> >
> >
> > You will see that for covariate data[,13], the beta/coefficient
> > estimate is around -9. The number of iterations that has been
> > performed is 8, and model$converged returns TRUE.
> >
> >
> > I've used some alternate logistic regression code in C (
> > https://github.com/czep/mlelr/blob/master/src/mlelr.c), which produces
> > identical estimates for the other covariates and comparable deviance
> > values. However, using this C code, I'm seeing that the estimate for
> > data[,13] is around -100 (since I'm allowing a maximum of 100 MLE
> > iterations). There, the conclusion is that the model does not converge.
> >
> >
> > The difference between the two pieces of code is that in R, the glm()
> > function determines convergence of the whole model by measuring the
> > difference between deviance of the current iteration versus the
> > deviance of the prior iteration, and calls the model converged when it
> > reaches a certain epsilon value. In the C++ code, the model is
> > converged when all parameters haven't changed markedly compared to the
> previous iteration.
> >
> >
> > I think both approaches are valid, although the R variant (while
> > faster) makes it vulnerable to wrongly concluding convergence in edge
> > cases such as the one presented above, resulting in wrong coefficient
> > estimates. For people wanting to use logistic regression in a
> > training/prediction kind of setting, using these estimates might influence
> their predictive performance.
> >
> >
> > The problem here is that the glm function does not return any warnings
> > when one of the covariates in the model does not converge. For someone
> > who is not paying attention, this may lead them to conclude there is
> > nothing wrong with their data. In my opinion, the default behavior in
> > this case should therefore be to conclude that the model did not
> > converge, or at least to show a warning message.
> >
> >
> > Please let me know whether you believe this is an issue, and whether I
> > can provide additional information.
> >
> >
> > With kind regards,
> >
> >
> > Harm-Jan Westra
> >
> >
> >
> >
> >
> >
> >
> >
> >
> >         [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> 
> 
> 
> --
> Joris Meys
> Statistical consultant
> 
> Ghent University
> Faculty of Bioscience Engineering
> Department of Mathematical Modelling, Statistics and Bio-Informatics
> 
> tel :  +32 (0)9 264 61 79
> Joris.Meys at Ugent.be
> -------------------------------
> Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From wdunlap at tibco.com  Thu Jul 20 18:56:18 2017
From: wdunlap at tibco.com (William Dunlap)
Date: Thu, 20 Jul 2017 09:56:18 -0700
Subject: [Rd] matrices with names
Message-ID: <CAF8bMcZbHHzAmyXfzGfyMFysBu5S=0eiXJ3RxycE7qhYw8Yb9Q@mail.gmail.com>

How should R deal with matrices that have a 'names' attribute?  S (and S+)
did not allow an object to have both dims and names but R does.  However,
some R functions copy the dims but not the names to the returned value and
some copy both.  I don't see a pattern to it.  Is there a general rule for
when the names on a matrix should be copied to the return value of a
function?

> x <- matrix(11,1,1)
> names(x)<-"One"
> dput(x)
structure(11, .Dim = c(1L, 1L), .Names = "One")
> dput(log2(x))
structure(3.4594316186373, .Dim = c(1L, 1L), .Names = "One")
> dput(pchisq(x,8))
structure(0.798300801297471, .Dim = c(1L, 1L), .Names = "One")
> dput(x+1)
structure(12, .Dim = c(1L, 1L))
> dput(x > 3)
structure(TRUE, .Dim = c(1L, 1L))
> dput(!x)
structure(FALSE, .Names = "One", .Dim = c(1L, 1L))
> dput(-x)
structure(-11, .Dim = c(1L, 1L), .Names = "One")
> dput(0-x)
structure(-11, .Dim = c(1L, 1L))

The binary operators don't copy, unary operators do copy, and many other
low-level functions do copy.

Bill Dunlap
TIBCO Software
wdunlap tibco.com

	[[alternative HTML version deleted]]


From jorismeys at gmail.com  Thu Jul 20 19:16:18 2017
From: jorismeys at gmail.com (Joris Meys)
Date: Thu, 20 Jul 2017 19:16:18 +0200
Subject: [Rd] Wrongly converging glm()
In-Reply-To: <DM3PR20MB0572B9357503F0401CC5EABF87A70@DM3PR20MB0572.namprd20.prod.outlook.com>
References: <DM3PR20MB05722D6CF8D15F73CC4CE65987A70@DM3PR20MB0572.namprd20.prod.outlook.com>
 <CAO1zAVa5uOEswx8b8HhHMwGNazz8Pgq3nmYhR2okTiCM4+-cRg@mail.gmail.com>
 <DM3PR20MB0572B9357503F0401CC5EABF87A70@DM3PR20MB0572.namprd20.prod.outlook.com>
Message-ID: <CAO1zAVaWouvQ-p3kjxhH7V3RR5qP_3fwb4Je4KZXcyaZDfotqQ@mail.gmail.com>

On Thu, Jul 20, 2017 at 6:21 PM, Harm-Jan Westra <westra.harmjan at outlook.com
> wrote:

> Dear Joris,
>
>
> I agree that such a covariate should not be used in the analysis, and
> fully agree with your assessment. However, your response assumes that
> everybody who uses R knows what they're doing, which is a dangerous
> assumption to make. I bet there are a lot of people who blindly trust the
> output from R, even when there's clearly something wrong with the estimates.
>

You missed my point then. I don't assume that everybody who uses R knows
what they're doing. Actually, I know for a fact quite a few people using R
have absolutely no clue about what they are doing. My point is that
everybody using R should first do the effort of learning what they're
doing. And if they don't, one shouldn't blame R. There's a million
different cases where both algorithms would converge and the resulting
estimates are totally meaningless regardless. R cannot be held responsible
for that.


>
>
> In terms of your conclusion that the C++ estimate corresponds to a value
> within the R estimated confidence interval: if I allow the C++ code to run
> for 1000 iterations, it's estimate would be around -1000. It simply never
> converges.
>

I didn't test that far, and you're right in the sense that -100 is indeed
not the final estimate. After looking at the C code, it appears as if the
author of that code combines a Newton-Raphson approach with a different
convergence rule. And then it's quite understandible it doesn't converge.
You can wildly vary that estimate, the effect it has on the jacobian, log
likelihood or deviance will be insignificant. So the model won't improve,
it would just move all over the parameter space.


>
>
> I think there's nothing wrong with letting the user know there might be
> something wrong with one of the estimates, especially if your code can
> easily figure it out for you, by adding an additional rule. Not everyone is
> always paying attention (even if they know what they're doing).
>

If R would do that, it wouldn't start the fitting procedure but just return
an error "Your analysis died due to a lack of useable data." . Because
that's the problem here.


>
>
> With kind regards,
>
>
> Harm-Jan
>
>
> ________________________________
> From: Joris Meys <jorismeys at gmail.com>
> Sent: Thursday, July 20, 2017 11:38 AM
> To: Harm-Jan Westra
> Cc: r-devel at r-project.org
> Subject: Re: [Rd] Wrongly converging glm()
>
> Allow me to chime in. That's an interesting case you present, but as far
> as I'm concerned the algorithm did converge. The estimate of -9.25 has an
> estimated standard error of 72.4, meaning that frequentists would claim the
> true value would lie anywhere between appx. -151 and 132 (CI) and hence the
> estimate from the glm algorithm is perfectly compatible with the one from
> the C++ code. And as the glm algorithm uses a different convergence rule,
> the algorithm rightfully reported it converged. It's not because another
> algorithm based on another rule doesn't converge, that the one glm uses
> didn't.
>
> On top of that: In both cases the huge standard error on that estimate
> clearly tells you that the estimate should not be trusted, and the fit is
> unstable. That's to be expected, given the insane inbalance in your data,
> especially for the 13th column. If my students would incorporate that
> variable in a generalized linear model and tries to formulate a conclusion
> based on that coefficient, they failed the exam. So if somebody does this
> analysis and tries to draw any conclusion whatsoever on that estimate,
> maybe they should leave the analysis to somebody who does know what they're
> doing.
>
> Cheers
> Joris
>
> On Thu, Jul 20, 2017 at 5:02 PM, Harm-Jan Westra <
> westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com>> wrote:
> Dear R-core,
>
>
> I have found an edge-case where the glm function falsely concludes that
> the model has converged. The issue is the following: my data contains a
> number of covariates, one of these covariates has a very small variance.
> For most of the rows of this covariate, the value is 0, except for one of
> the rows, where it is 1.
>
>
> The glm function correctly determines the beta and standard error
> estimates for all other covariates.
>
>
> I've placed the data here: http://www.harmjanwestra.nl/rtestdata.txt
>
>
> The model I'm using is very simple:
>
>
> data <- read.table("rtestdata.txt")
>
> model <- glm(data[,1] ~ data[,2] + data[,3] + data[,4] + data[,5] +
> data[,6] + data[,7] + data[,8] + data[,9] + data[,10] + data[,11] +
> data[,12] + data[,13] + data[,14], family=binomial("logit"))
>
> summary(model)
>
>
> You will see that for covariate data[,13], the beta/coefficient estimate
> is around -9. The number of iterations that has been performed is 8, and
> model$converged returns TRUE.
>
>
> I've used some alternate logistic regression code in C (
> https://github.com/czep/mlelr/blob/master/src/mlelr.c), which produces
> identical estimates for the other covariates and comparable deviance
> values. However, using this C code, I'm seeing that the estimate for
> data[,13] is around -100 (since I'm allowing a maximum of 100 MLE
> iterations). There, the conclusion is that the model does not converge.
>
>
> The difference between the two pieces of code is that in R, the glm()
> function determines convergence of the whole model by measuring the
> difference between deviance of the current iteration versus the deviance of
> the prior iteration, and calls the model converged when it reaches a
> certain epsilon value. In the C++ code, the model is converged when all
> parameters haven't changed markedly compared to the previous iteration.
>
>
> I think both approaches are valid, although the R variant (while faster)
> makes it vulnerable to wrongly concluding convergence in edge cases such as
> the one presented above, resulting in wrong coefficient estimates. For
> people wanting to use logistic regression in a training/prediction kind of
> setting, using these estimates might influence their predictive performance.
>
>
> The problem here is that the glm function does not return any warnings
> when one of the covariates in the model does not converge. For someone who
> is not paying attention, this may lead them to conclude there is nothing
> wrong with their data. In my opinion, the default behavior in this case
> should therefore be to conclude that the model did not converge, or at
> least to show a warning message.
>
>
> Please let me know whether you believe this is an issue, and whether I can
> provide additional information.
>
>
> With kind regards,
>
>
> Harm-Jan Westra
>
>
>
>
>
>
>
>
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
>
>
> --
> Joris Meys
> Statistical consultant
>
> Ghent University
> Faculty of Bioscience Engineering
> Department of Mathematical Modelling, Statistics and Bio-Informatics
>
> tel :  +32 (0)9 264 61 79
> Joris.Meys at Ugent.be
> -------------------------------
> Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>



-- 
Joris Meys
Statistical consultant

Ghent University
Faculty of Bioscience Engineering
Department of Mathematical Modelling, Statistics and Bio-Informatics

tel :  +32 (0)9 264 61 79
Joris.Meys at Ugent.be
-------------------------------
Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php

	[[alternative HTML version deleted]]


From skostyshak at ufl.edu  Thu Jul 20 19:46:56 2017
From: skostyshak at ufl.edu (Scott Kostyshak)
Date: Thu, 20 Jul 2017 13:46:56 -0400
Subject: [Rd] [patch] ?confint: "assumes asymptotic normality"
In-Reply-To: <22896.48208.806371.980068@stat.math.ethz.ch>
References: <20170720072837.phhhg7q6lxmjzboj@steph>
 <22896.48208.806371.980068@stat.math.ethz.ch>
Message-ID: <20170720174656.xwiwool2mdyhkupi@steph>

On Thu, Jul 20, 2017 at 04:21:04PM +0200, Martin Maechler wrote:
> >>>>> Scott Kostyshak <skostyshak at ufl.edu>
> >>>>>     on Thu, 20 Jul 2017 03:28:37 -0400 writes:
> 
>     >> From ?confint:
>     > "Computes confidence intervals" and "The default method assumes
>     > asymptotic normality"
> 
>     > For me, a "confidence interval" implies an exact confidence interval in
>     > formal statistics (I concede that when speaking, the term is often used
>     > more loosely). And of course, even if a test statistic is asymptotically
>     > normal (so the assumption is satisfied), the finite distribution might
>     > not be normal and thus an exact confidence interval would not be
>     > computed.
> 
>     > Attached is a patch that simply changes "asymptotic normality" to
>     > "normality" in confint.Rd. This encourages the user of the function to
>     > think about whether their asymptotically normal statistic is "normal
>     > enough" in a finite sample to get something reliable from confint().
> 
>     > Alternatively, we could instead change "Computes confidence intervals"
>     > to "Computes asymptotic confidence intervals".
> 
>     > I hope I'm not being too pedantic here.
> 
> well, it's just at the 97.5% border line of "too pedantic"  ...

:)

> ;-)
> 
> I think you are right with your first proposal to drop
> "asymptotic" here.  After all, there's the explict 'fac <- qnorm(a)'.

Note that I received a private email that my message was indeed too
pedantic and expressed disagreement with the proposal. I'm not sure if
they intended it to be private so I will respond in private and see if
they feel like bringing the discussion on the list. Or perhaps this
minor (and perhaps controversial?) issue is not worth any additional
time.

> One could consider to make  'qnorm' an argument of the
> default method to allow more general distributional assumptions,
> but it may be wiser to have useRs write their own
> confint.<foo>() method, notably for cases where
> diag(vcov(object)) is an efficiency waste...

Thanks for your comments,

Scott

> Martin
> 
> 
>     > Scott
> 
> 
>     > -- 
>     > Scott Kostyshak
>     > Assistant Professor of Economics
>     > University of Florida
>     > https://people.clas.ufl.edu/skostyshak/
> 
> 
>     > ----------------------------------------------------------------------
>     > Index: src/library/stats/man/confint.Rd
>     > ===================================================================
>     > --- src/library/stats/man/confint.Rd	(revision 72930)
>     > +++ src/library/stats/man/confint.Rd	(working copy)
>     > @@ -31,7 +31,7 @@
>     > }
>     > \details{
>     > \code{confint} is a generic function.  The default method assumes
>     > -  asymptotic normality, and needs suitable \code{\link{coef}} and
>     > +  normality, and needs suitable \code{\link{coef}} and
>     > \code{\link{vcov}} methods to be available.  The default method can be
>     > called directly for comparison with other methods.
>  
> 
>     > ----------------------------------------------------------------------
>     > ______________________________________________
>     > R-devel at r-project.org mailing list
>     > https://stat.ethz.ch/mailman/listinfo/r-devel


From westra.harmjan at outlook.com  Thu Jul 20 18:45:56 2017
From: westra.harmjan at outlook.com (Harm-Jan Westra)
Date: Thu, 20 Jul 2017 16:45:56 +0000
Subject: [Rd] Wrongly converging glm()
In-Reply-To: <DM5PR1101MB2364F3BE649E223A13655868E4A70@DM5PR1101MB2364.namprd11.prod.outlook.com>
References: <DM3PR20MB05722D6CF8D15F73CC4CE65987A70@DM3PR20MB0572.namprd20.prod.outlook.com>
 <CAO1zAVa5uOEswx8b8HhHMwGNazz8Pgq3nmYhR2okTiCM4+-cRg@mail.gmail.com>,
 <DM5PR1101MB2364F3BE649E223A13655868E4A70@DM5PR1101MB2364.namprd11.prod.outlook.com>
Message-ID: <DM3PR20MB0572FE865B8AB8591DCDFD1F87A70@DM3PR20MB0572.namprd20.prod.outlook.com>

Dear Simon,


Thanks for your response. I have a suggestion that could be non-intrusive, but still provide some additional info to the user.


The glm function already checks for collinearity of the input, and you can easily check which covariate was aliased as a result, using summary(model)$aliased.


My suggestion would therefore be to add an additional variable to the model summary, e.g. summary(model)$estimateconverged, which states whether the MLE has converged for that particular covariate.


This would provide users a way to perform sanity checks on the models they fit: sometimes you're running hundreds or millions of models, making it infeasible to check every single one of them. I agree that investigating the estimates + standard errors would be a solution, but then again, the estimate that R produces for such a covariate might as well be random.


With kind regards,


Harm-Jan


________________________________
From: Simon Bonner <sbonner6 at uwo.ca>
Sent: Thursday, July 20, 2017 12:32 PM
To: Joris Meys; Harm-Jan Westra
Cc: r-devel at r-project.org
Subject: RE: [Rd] Wrongly converging glm()

In defence of Harma-Jan's original post I would say that there is a difference between true convergence and satisfying a convergence criterion.

In my view the algorithm has not converged. This is a case of quasi-complete separate -- there are both successes and failures when x13=0 but only failures when x13=1. As a result, the likelihood has no maximum and increases, albeit slightly, as the associated coefficient tends to infinity while maximizing over the other parameters. The estimate given is not the MLE and the standard error is not meaningful because the conditions for convergence of MLEs to their asymptotic normal distribution has been violated.

I agree with Joris that someone familiar with logistic regression should be able to identify this situation -- though the solution is not as simple as throwing out the covariate. Suppose that there had been many failures when x13=1, not just 1. The same problem would arise, but x13 is clearly an important covariate. Removing it from the analysis is not the thing to do. A better solution is to penalize the likelihood or (and I'm showing my true colours here) conduct a Bayesian analysis.

Regarding the statement that the algorithm has converged, perhaps R should say more truthfully that the convergence criterion has been satisfied -- but that might lead to more confusion. In this case, any convergence criterion will be satisfied eventually. If you increase the maximum number of iterations in the C implementation then the other convergence criterion will be satisfied and the code will say that the algorithm has converged.

In the end, it's up to the analyst to be aware of the pitfalls and how to address them.

Cheers,

Simon

> -----Original Message-----
> From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of Joris Meys
> Sent: July 20, 2017 11:39 AM
> To: Harm-Jan Westra <westra.harmjan at outlook.com>
> Cc: r-devel at r-project.org
> Subject: Re: [Rd] Wrongly converging glm()
>
> Allow me to chime in. That's an interesting case you present, but as far as I'm
> concerned the algorithm did converge. The estimate of -9.25 has an estimated
> standard error of 72.4, meaning that frequentists would claim the true value
> would lie anywhere between appx. -151 and 132 (CI) and hence the estimate
> from the glm algorithm is perfectly compatible with the one from the C++ code.
> And as the glm algorithm uses a different convergence rule, the algorithm
> rightfully reported it converged. It's not because another algorithm based on
> another rule doesn't converge, that the one glm uses didn't.
>
> On top of that: In both cases the huge standard error on that estimate clearly
> tells you that the estimate should not be trusted, and the fit is unstable. That's
> to be expected, given the insane inbalance in your data, especially for the 13th
> column. If my students would incorporate that variable in a generalized linear
> model and tries to formulate a conclusion based on that coefficient, they failed
> the exam. So if somebody does this analysis and tries to draw any conclusion
> whatsoever on that estimate, maybe they should leave the analysis to
> somebody who does know what they're doing.
>
> Cheers
> Joris
>
> On Thu, Jul 20, 2017 at 5:02 PM, Harm-Jan Westra
> <westra.harmjan at outlook.com
> > wrote:
>
> > Dear R-core,
> >
> >
> > I have found an edge-case where the glm function falsely concludes
> > that the model has converged. The issue is the following: my data
> > contains a number of covariates, one of these covariates has a very small
> variance.
> > For most of the rows of this covariate, the value is 0, except for one
> > of the rows, where it is 1.
> >
> >
> > The glm function correctly determines the beta and standard error
> > estimates for all other covariates.
> >
> >
> > I've placed the data here: http://www.harmjanwestra.nl/rtestdata.txt
> >
> >
> > The model I'm using is very simple:
> >
> >
> > data <- read.table("rtestdata.txt")
> >
> > model <- glm(data[,1] ~ data[,2] + data[,3] + data[,4] + data[,5] +
> > data[,6] + data[,7] + data[,8] + data[,9] + data[,10] + data[,11] +
> > data[,12] + data[,13] + data[,14], family=binomial("logit"))
> >
> > summary(model)
> >
> >
> > You will see that for covariate data[,13], the beta/coefficient
> > estimate is around -9. The number of iterations that has been
> > performed is 8, and model$converged returns TRUE.
> >
> >
> > I've used some alternate logistic regression code in C (
> > https://github.com/czep/mlelr/blob/master/src/mlelr.c), which produces
> > identical estimates for the other covariates and comparable deviance
> > values. However, using this C code, I'm seeing that the estimate for
> > data[,13] is around -100 (since I'm allowing a maximum of 100 MLE
> > iterations). There, the conclusion is that the model does not converge.
> >
> >
> > The difference between the two pieces of code is that in R, the glm()
> > function determines convergence of the whole model by measuring the
> > difference between deviance of the current iteration versus the
> > deviance of the prior iteration, and calls the model converged when it
> > reaches a certain epsilon value. In the C++ code, the model is
> > converged when all parameters haven't changed markedly compared to the
> previous iteration.
> >
> >
> > I think both approaches are valid, although the R variant (while
> > faster) makes it vulnerable to wrongly concluding convergence in edge
> > cases such as the one presented above, resulting in wrong coefficient
> > estimates. For people wanting to use logistic regression in a
> > training/prediction kind of setting, using these estimates might influence
> their predictive performance.
> >
> >
> > The problem here is that the glm function does not return any warnings
> > when one of the covariates in the model does not converge. For someone
> > who is not paying attention, this may lead them to conclude there is
> > nothing wrong with their data. In my opinion, the default behavior in
> > this case should therefore be to conclude that the model did not
> > converge, or at least to show a warning message.
> >
> >
> > Please let me know whether you believe this is an issue, and whether I
> > can provide additional information.
> >
> >
> > With kind regards,
> >
> >
> > Harm-Jan Westra
> >
> >
> >
> >
> >
> >
> >
> >
> >
> >         [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
>
>
> --
> Joris Meys
> Statistical consultant
>
> Ghent University
> Faculty of Bioscience Engineering
> Department of Mathematical Modelling, Statistics and Bio-Informatics
>
> tel :  +32 (0)9 264 61 79
> Joris.Meys at Ugent.be
> -------------------------------
> Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php
>
>        [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

	[[alternative HTML version deleted]]


From westra.harmjan at outlook.com  Thu Jul 20 20:32:24 2017
From: westra.harmjan at outlook.com (Harm-Jan Westra)
Date: Thu, 20 Jul 2017 18:32:24 +0000
Subject: [Rd] Wrongly converging glm()
In-Reply-To: <CAO1zAVaWouvQ-p3kjxhH7V3RR5qP_3fwb4Je4KZXcyaZDfotqQ@mail.gmail.com>
References: <DM3PR20MB05722D6CF8D15F73CC4CE65987A70@DM3PR20MB0572.namprd20.prod.outlook.com>
 <CAO1zAVa5uOEswx8b8HhHMwGNazz8Pgq3nmYhR2okTiCM4+-cRg@mail.gmail.com>
 <DM3PR20MB0572B9357503F0401CC5EABF87A70@DM3PR20MB0572.namprd20.prod.outlook.com>,
 <CAO1zAVaWouvQ-p3kjxhH7V3RR5qP_3fwb4Je4KZXcyaZDfotqQ@mail.gmail.com>
Message-ID: <DM3PR20MB05728541A9D1DD21D3354C0887A70@DM3PR20MB0572.namprd20.prod.outlook.com>

My apologies if I seemed to ?blame R?. This was in no way my intention. I get the feeling that you?re missing my point as well.

I observed something that I thought was confusing, when comparing two more or less identical methods (when validating the C code), and wanted to make a suggestion as to how to help future R users. Note that I already acknowledged that my data was bad. Note that I also mention that the way R determines convergence is a valid approach.

What strikes me as odd is that R would warn you when your data is faulty for a function such as cor(), but not for glm(). I don?t see why you wouldn?t want to check both convergence criteria if you know multiple of such criteria exist. It would make the software more user friendly in the end.

It may be true that there are millions of edge cases causing issues with glm(), as you say, but here I am presenting an edge case that can be easily detected, by checking whether the difference in beta estimates between the current and previous iteration is bigger than a certain epsilon value.

I agree ?that everybody using R should first do the effort of learning what they're doing?, but it is a bit of a non-argument, because we all know that, the world just doesn?t work that way, plus this is one of the arguments that has held for example the Linux community back for quite a while (i.e. let?s not make the software more user friendly because the user should be more knowledgeable).

Harm-Jan


From: Joris Meys<mailto:jorismeys at gmail.com>
Sent: Thursday, July 20, 2017 13:16
To: Harm-Jan Westra<mailto:westra.harmjan at outlook.com>
Cc: r-devel at r-project.org<mailto:r-devel at r-project.org>
Subject: Re: [Rd] Wrongly converging glm()



On Thu, Jul 20, 2017 at 6:21 PM, Harm-Jan Westra <westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com>> wrote:
Dear Joris,


I agree that such a covariate should not be used in the analysis, and fully agree with your assessment. However, your response assumes that everybody who uses R knows what they're doing, which is a dangerous assumption to make. I bet there are a lot of people who blindly trust the output from R, even when there's clearly something wrong with the estimates.

You missed my point then. I don't assume that everybody who uses R knows what they're doing. Actually, I know for a fact quite a few people using R have absolutely no clue about what they are doing. My point is that everybody using R should first do the effort of learning what they're doing. And if they don't, one shouldn't blame R. There's a million different cases where both algorithms would converge and the resulting estimates are totally meaningless regardless. R cannot be held responsible for that.



In terms of your conclusion that the C++ estimate corresponds to a value within the R estimated confidence interval: if I allow the C++ code to run for 1000 iterations, it's estimate would be around -1000. It simply never converges.

I didn't test that far, and you're right in the sense that -100 is indeed not the final estimate. After looking at the C code, it appears as if the author of that code combines a Newton-Raphson approach with a different convergence rule. And then it's quite understandible it doesn't converge. You can wildly vary that estimate, the effect it has on the jacobian, log likelihood or deviance will be insignificant. So the model won't improve, it would just move all over the parameter space.



I think there's nothing wrong with letting the user know there might be something wrong with one of the estimates, especially if your code can easily figure it out for you, by adding an additional rule. Not everyone is always paying attention (even if they know what they're doing).

If R would do that, it wouldn't start the fitting procedure but just return an error "Your analysis died due to a lack of useable data." . Because that's the problem here.



With kind regards,


Harm-Jan


________________________________
From: Joris Meys <jorismeys at gmail.com<mailto:jorismeys at gmail.com>>
Sent: Thursday, July 20, 2017 11:38 AM
To: Harm-Jan Westra
Cc: r-devel at r-project.org<mailto:r-devel at r-project.org>
Subject: Re: [Rd] Wrongly converging glm()

Allow me to chime in. That's an interesting case you present, but as far as I'm concerned the algorithm did converge. The estimate of -9.25 has an estimated standard error of 72.4, meaning that frequentists would claim the true value would lie anywhere between appx. -151 and 132 (CI) and hence the estimate from the glm algorithm is perfectly compatible with the one from the C++ code. And as the glm algorithm uses a different convergence rule, the algorithm rightfully reported it converged. It's not because another algorithm based on another rule doesn't converge, that the one glm uses didn't.

On top of that: In both cases the huge standard error on that estimate clearly tells you that the estimate should not be trusted, and the fit is unstable. That's to be expected, given the insane inbalance in your data, especially for the 13th column. If my students would incorporate that variable in a generalized linear model and tries to formulate a conclusion based on that coefficient, they failed the exam. So if somebody does this analysis and tries to draw any conclusion whatsoever on that estimate, maybe they should leave the analysis to somebody who does know what they're doing.

Cheers
Joris

On Thu, Jul 20, 2017 at 5:02 PM, Harm-Jan Westra <westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com><mailto:westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com>>> wrote:
Dear R-core,


I have found an edge-case where the glm function falsely concludes that the model has converged. The issue is the following: my data contains a number of covariates, one of these covariates has a very small variance. For most of the rows of this covariate, the value is 0, except for one of the rows, where it is 1.


The glm function correctly determines the beta and standard error estimates for all other covariates.


I've placed the data here: http://www.harmjanwestra.nl/rtestdata.txt


The model I'm using is very simple:


data <- read.table("rtestdata.txt")

model <- glm(data[,1] ~ data[,2] + data[,3] + data[,4] + data[,5] + data[,6] + data[,7] + data[,8] + data[,9] + data[,10] + data[,11] + data[,12] + data[,13] + data[,14], family=binomial("logit"))

summary(model)


You will see that for covariate data[,13], the beta/coefficient estimate is around -9. The number of iterations that has been performed is 8, and model$converged returns TRUE.


I've used some alternate logistic regression code in C (https://github.com/czep/mlelr/blob/master/src/mlelr.c), which produces identical estimates for the other covariates and comparable deviance values. However, using this C code, I'm seeing that the estimate for data[,13] is around -100 (since I'm allowing a maximum of 100 MLE iterations). There, the conclusion is that the model does not converge.


The difference between the two pieces of code is that in R, the glm() function determines convergence of the whole model by measuring the difference between deviance of the current iteration versus the deviance of the prior iteration, and calls the model converged when it reaches a certain epsilon value. In the C++ code, the model is converged when all parameters haven't changed markedly compared to the previous iteration.


I think both approaches are valid, although the R variant (while faster) makes it vulnerable to wrongly concluding convergence in edge cases such as the one presented above, resulting in wrong coefficient estimates. For people wanting to use logistic regression in a training/prediction kind of setting, using these estimates might influence their predictive performance.


The problem here is that the glm function does not return any warnings when one of the covariates in the model does not converge. For someone who is not paying attention, this may lead them to conclude there is nothing wrong with their data. In my opinion, the default behavior in this case should therefore be to conclude that the model did not converge, or at least to show a warning message.


Please let me know whether you believe this is an issue, and whether I can provide additional information.


With kind regards,


Harm-Jan Westra









        [[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org><mailto:R-devel at r-project.org<mailto:R-devel at r-project.org>> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel



--
Joris Meys
Statistical consultant

Ghent University
Faculty of Bioscience Engineering
Department of Mathematical Modelling, Statistics and Bio-Informatics

tel :  +32 (0)9 264 61 79<tel:%2B32%20%280%299%20264%2061%2079>
Joris.Meys at Ugent.be
-------------------------------
Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php

        [[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel



--
Joris Meys
Statistical consultant

Ghent University
Faculty of Bioscience Engineering
Department of Mathematical Modelling, Statistics and Bio-Informatics

tel :  +32 (0)9 264 61 79
Joris.Meys at Ugent.be
-------------------------------
Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php


	[[alternative HTML version deleted]]


From markleeds2 at gmail.com  Thu Jul 20 20:53:57 2017
From: markleeds2 at gmail.com (Mark Leeds)
Date: Thu, 20 Jul 2017 14:53:57 -0400
Subject: [Rd] Wrongly converging glm()
In-Reply-To: <DM3PR20MB05728541A9D1DD21D3354C0887A70@DM3PR20MB0572.namprd20.prod.outlook.com>
References: <DM3PR20MB05722D6CF8D15F73CC4CE65987A70@DM3PR20MB0572.namprd20.prod.outlook.com>
 <CAO1zAVa5uOEswx8b8HhHMwGNazz8Pgq3nmYhR2okTiCM4+-cRg@mail.gmail.com>
 <DM3PR20MB0572B9357503F0401CC5EABF87A70@DM3PR20MB0572.namprd20.prod.outlook.com>
 <CAO1zAVaWouvQ-p3kjxhH7V3RR5qP_3fwb4Je4KZXcyaZDfotqQ@mail.gmail.com>
 <DM3PR20MB05728541A9D1DD21D3354C0887A70@DM3PR20MB0572.namprd20.prod.outlook.com>
Message-ID: <CAHz+bWa+ddLiu0TRJDZxSYyALUowJfE7ovF_Yn5iEhLx7YUk8A@mail.gmail.com>

Hi Harm-Jan. I've been following this thread to some degree and just want
to add that
 this issue is not specific to the GLM. It's a problem with optimization of
functions in general. I was using use Rvmmin with constraints which is an
extremely solid optimization package written by John Nash ( uses a modified
BFGS  algorithm) and it took me two years to realize that, although my
optimization generally converged, there was an idenitifiability issue with
my model that basically meant that the results meant nothing. I only
eventually found this out because, in the econometrics literature,  the
type of economic model I was estimating ( rational expectations ) is known
to have an identifiability issue. I guess if I was an economics expert, I
may have been able to know this but, in general, I think what you are
asking
optimization code to do is EXTREMELY DIFFICULT.

John Nash can say more because he's THE optimization masteR but it's much
more difficult to write optimization algorithms with convergence rules that
are able to identify when mathematical convergence ( norm near zero say )
is not necessarily model convergence. That I can tell you from experience
!!!!!!!








On Thu, Jul 20, 2017 at 2:32 PM, Harm-Jan Westra <westra.harmjan at outlook.com
> wrote:

> My apologies if I seemed to ?blame R?. This was in no way my intention. I
> get the feeling that you?re missing my point as well.
>
> I observed something that I thought was confusing, when comparing two more
> or less identical methods (when validating the C code), and wanted to make
> a suggestion as to how to help future R users. Note that I already
> acknowledged that my data was bad. Note that I also mention that the way R
> determines convergence is a valid approach.
>
> What strikes me as odd is that R would warn you when your data is faulty
> for a function such as cor(), but not for glm(). I don?t see why you
> wouldn?t want to check both convergence criteria if you know multiple of
> such criteria exist. It would make the software more user friendly in the
> end.
>
> It may be true that there are millions of edge cases causing issues with
> glm(), as you say, but here I am presenting an edge case that can be easily
> detected, by checking whether the difference in beta estimates between the
> current and previous iteration is bigger than a certain epsilon value.
>
> I agree ?that everybody using R should first do the effort of learning
> what they're doing?, but it is a bit of a non-argument, because we all know
> that, the world just doesn?t work that way, plus this is one of the
> arguments that has held for example the Linux community back for quite a
> while (i.e. let?s not make the software more user friendly because the user
> should be more knowledgeable).
>
> Harm-Jan
>
>
> From: Joris Meys<mailto:jorismeys at gmail.com>
> Sent: Thursday, July 20, 2017 13:16
> To: Harm-Jan Westra<mailto:westra.harmjan at outlook.com>
> Cc: r-devel at r-project.org<mailto:r-devel at r-project.org>
> Subject: Re: [Rd] Wrongly converging glm()
>
>
>
> On Thu, Jul 20, 2017 at 6:21 PM, Harm-Jan Westra <
> westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com>> wrote:
> Dear Joris,
>
>
> I agree that such a covariate should not be used in the analysis, and
> fully agree with your assessment. However, your response assumes that
> everybody who uses R knows what they're doing, which is a dangerous
> assumption to make. I bet there are a lot of people who blindly trust the
> output from R, even when there's clearly something wrong with the estimates.
>
> You missed my point then. I don't assume that everybody who uses R knows
> what they're doing. Actually, I know for a fact quite a few people using R
> have absolutely no clue about what they are doing. My point is that
> everybody using R should first do the effort of learning what they're
> doing. And if they don't, one shouldn't blame R. There's a million
> different cases where both algorithms would converge and the resulting
> estimates are totally meaningless regardless. R cannot be held responsible
> for that.
>
>
>
> In terms of your conclusion that the C++ estimate corresponds to a value
> within the R estimated confidence interval: if I allow the C++ code to run
> for 1000 iterations, it's estimate would be around -1000. It simply never
> converges.
>
> I didn't test that far, and you're right in the sense that -100 is indeed
> not the final estimate. After looking at the C code, it appears as if the
> author of that code combines a Newton-Raphson approach with a different
> convergence rule. And then it's quite understandible it doesn't converge.
> You can wildly vary that estimate, the effect it has on the jacobian, log
> likelihood or deviance will be insignificant. So the model won't improve,
> it would just move all over the parameter space.
>
>
>
> I think there's nothing wrong with letting the user know there might be
> something wrong with one of the estimates, especially if your code can
> easily figure it out for you, by adding an additional rule. Not everyone is
> always paying attention (even if they know what they're doing).
>
> If R would do that, it wouldn't start the fitting procedure but just
> return an error "Your analysis died due to a lack of useable data." .
> Because that's the problem here.
>
>
>
> With kind regards,
>
>
> Harm-Jan
>
>
> ________________________________
> From: Joris Meys <jorismeys at gmail.com<mailto:jorismeys at gmail.com>>
> Sent: Thursday, July 20, 2017 11:38 AM
> To: Harm-Jan Westra
> Cc: r-devel at r-project.org<mailto:r-devel at r-project.org>
> Subject: Re: [Rd] Wrongly converging glm()
>
> Allow me to chime in. That's an interesting case you present, but as far
> as I'm concerned the algorithm did converge. The estimate of -9.25 has an
> estimated standard error of 72.4, meaning that frequentists would claim the
> true value would lie anywhere between appx. -151 and 132 (CI) and hence the
> estimate from the glm algorithm is perfectly compatible with the one from
> the C++ code. And as the glm algorithm uses a different convergence rule,
> the algorithm rightfully reported it converged. It's not because another
> algorithm based on another rule doesn't converge, that the one glm uses
> didn't.
>
> On top of that: In both cases the huge standard error on that estimate
> clearly tells you that the estimate should not be trusted, and the fit is
> unstable. That's to be expected, given the insane inbalance in your data,
> especially for the 13th column. If my students would incorporate that
> variable in a generalized linear model and tries to formulate a conclusion
> based on that coefficient, they failed the exam. So if somebody does this
> analysis and tries to draw any conclusion whatsoever on that estimate,
> maybe they should leave the analysis to somebody who does know what they're
> doing.
>
> Cheers
> Joris
>
> On Thu, Jul 20, 2017 at 5:02 PM, Harm-Jan Westra <
> westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com><mailto:
> westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com>>> wrote:
> Dear R-core,
>
>
> I have found an edge-case where the glm function falsely concludes that
> the model has converged. The issue is the following: my data contains a
> number of covariates, one of these covariates has a very small variance.
> For most of the rows of this covariate, the value is 0, except for one of
> the rows, where it is 1.
>
>
> The glm function correctly determines the beta and standard error
> estimates for all other covariates.
>
>
> I've placed the data here: http://www.harmjanwestra.nl/rtestdata.txt
>
>
> The model I'm using is very simple:
>
>
> data <- read.table("rtestdata.txt")
>
> model <- glm(data[,1] ~ data[,2] + data[,3] + data[,4] + data[,5] +
> data[,6] + data[,7] + data[,8] + data[,9] + data[,10] + data[,11] +
> data[,12] + data[,13] + data[,14], family=binomial("logit"))
>
> summary(model)
>
>
> You will see that for covariate data[,13], the beta/coefficient estimate
> is around -9. The number of iterations that has been performed is 8, and
> model$converged returns TRUE.
>
>
> I've used some alternate logistic regression code in C (
> https://github.com/czep/mlelr/blob/master/src/mlelr.c), which produces
> identical estimates for the other covariates and comparable deviance
> values. However, using this C code, I'm seeing that the estimate for
> data[,13] is around -100 (since I'm allowing a maximum of 100 MLE
> iterations). There, the conclusion is that the model does not converge.
>
>
> The difference between the two pieces of code is that in R, the glm()
> function determines convergence of the whole model by measuring the
> difference between deviance of the current iteration versus the deviance of
> the prior iteration, and calls the model converged when it reaches a
> certain epsilon value. In the C++ code, the model is converged when all
> parameters haven't changed markedly compared to the previous iteration.
>
>
> I think both approaches are valid, although the R variant (while faster)
> makes it vulnerable to wrongly concluding convergence in edge cases such as
> the one presented above, resulting in wrong coefficient estimates. For
> people wanting to use logistic regression in a training/prediction kind of
> setting, using these estimates might influence their predictive performance.
>
>
> The problem here is that the glm function does not return any warnings
> when one of the covariates in the model does not converge. For someone who
> is not paying attention, this may lead them to conclude there is nothing
> wrong with their data. In my opinion, the default behavior in this case
> should therefore be to conclude that the model did not converge, or at
> least to show a warning message.
>
>
> Please let me know whether you believe this is an issue, and whether I can
> provide additional information.
>
>
> With kind regards,
>
>
> Harm-Jan Westra
>
>
>
>
>
>
>
>
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org<mailto:R-devel at r-project.org><mailto:R
> -devel at r-project.org<mailto:R-devel at r-project.org>> mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
>
>
> --
> Joris Meys
> Statistical consultant
>
> Ghent University
> Faculty of Bioscience Engineering
> Department of Mathematical Modelling, Statistics and Bio-Informatics
>
> tel :  +32 (0)9 264 61 79<tel:%2B32%20%280%299%20264%2061%2079>
> Joris.Meys at Ugent.be
> -------------------------------
> Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
>
>
> --
> Joris Meys
> Statistical consultant
>
> Ghent University
> Faculty of Bioscience Engineering
> Department of Mathematical Modelling, Statistics and Bio-Informatics
>
> tel :  +32 (0)9 264 61 79
> Joris.Meys at Ugent.be
> -------------------------------
> Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php
>
>
>         [[alternative HTML version deleted]]
>
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From westra.harmjan at outlook.com  Thu Jul 20 21:28:15 2017
From: westra.harmjan at outlook.com (Harm-Jan Westra)
Date: Thu, 20 Jul 2017 19:28:15 +0000
Subject: [Rd] Wrongly converging glm()
In-Reply-To: <CAHz+bWa+ddLiu0TRJDZxSYyALUowJfE7ovF_Yn5iEhLx7YUk8A@mail.gmail.com>
References: <DM3PR20MB05722D6CF8D15F73CC4CE65987A70@DM3PR20MB0572.namprd20.prod.outlook.com>
 <CAO1zAVa5uOEswx8b8HhHMwGNazz8Pgq3nmYhR2okTiCM4+-cRg@mail.gmail.com>
 <DM3PR20MB0572B9357503F0401CC5EABF87A70@DM3PR20MB0572.namprd20.prod.outlook.com>
 <CAO1zAVaWouvQ-p3kjxhH7V3RR5qP_3fwb4Je4KZXcyaZDfotqQ@mail.gmail.com>
 <DM3PR20MB05728541A9D1DD21D3354C0887A70@DM3PR20MB0572.namprd20.prod.outlook.com>,
 <CAHz+bWa+ddLiu0TRJDZxSYyALUowJfE7ovF_Yn5iEhLx7YUk8A@mail.gmail.com>
Message-ID: <DM3PR20MB057281C85A6D6494ABBAAA1E87A70@DM3PR20MB0572.namprd20.prod.outlook.com>

Dear Mark,

I agree that convergence is a problem that applies to optimization in general, where the function you?re trying to optimize may have more than one local minimum. In your case, you probably would have to try different starting points for the MLE procedure. This should not be the case for logistic regression however (unless, like in my data, you have something that defies your model assumptions; check Simon Bonner?s response).

Still, I would think it would be a bit odd if the deviance wouldn?t change, but one of the model parameters did after the next MLE iteration. It would tell me that these parameters wouldn?t add to the model fit, which in my opinion would be useful debugging information, even when I would be hitting a local minimum (it could even help me inform that there is another, more optimal, solution?). Probably I should try to figure out whether this observation is also true for other models/link functions (I honestly don?t know).

However, thanks to your response, I can see that my suggestion is probably not applicable to all glm link functions, and I see how implementation of my proposed ?warning system? could be confusing to the user. Thanks alot!

With kind regards,

Harm-Jan

From: Mark Leeds<mailto:markleeds2 at gmail.com>
Sent: Thursday, July 20, 2017 14:54
To: Harm-Jan Westra<mailto:westra.harmjan at outlook.com>
Cc: Joris Meys<mailto:jorismeys at gmail.com>; r-devel at r-project.org<mailto:r-devel at r-project.org>
Subject: Re: [Rd] Wrongly converging glm()

Hi Harm-Jan. I've been following this thread to some degree and just want to add that
 this issue is not specific to the GLM. It's a problem with optimization of functions in general. I was using use Rvmmin with constraints which is an extremely solid optimization package written by John Nash ( uses a modified BFGS  algorithm) and it took me two years to realize that, although my optimization generally converged, there was an idenitifiability issue with my model that basically meant that the results meant nothing. I only eventually found this out because, in the econometrics literature,  the type of economic model I was estimating ( rational expectations ) is known to have an identifiability issue. I guess if I was an economics expert, I  may have been able to know this but, in general, I think what you are asking
optimization code to do is EXTREMELY DIFFICULT.

John Nash can say more because he's THE optimization masteR but it's much more difficult to write optimization algorithms with convergence rules that are able to identify when mathematical convergence ( norm near zero say ) is not necessarily model convergence. That I can tell you from experience !!!!!!!





On Thu, Jul 20, 2017 at 2:32 PM, Harm-Jan Westra <westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com>> wrote:
My apologies if I seemed to ?blame R?. This was in no way my intention. I get the feeling that you?re missing my point as well.

I observed something that I thought was confusing, when comparing two more or less identical methods (when validating the C code), and wanted to make a suggestion as to how to help future R users. Note that I already acknowledged that my data was bad. Note that I also mention that the way R determines convergence is a valid approach.

What strikes me as odd is that R would warn you when your data is faulty for a function such as cor(), but not for glm(). I don?t see why you wouldn?t want to check both convergence criteria if you know multiple of such criteria exist. It would make the software more user friendly in the end.

It may be true that there are millions of edge cases causing issues with glm(), as you say, but here I am presenting an edge case that can be easily detected, by checking whether the difference in beta estimates between the current and previous iteration is bigger than a certain epsilon value.

I agree ?that everybody using R should first do the effort of learning what they're doing?, but it is a bit of a non-argument, because we all know that, the world just doesn?t work that way, plus this is one of the arguments that has held for example the Linux community back for quite a while (i.e. let?s not make the software more user friendly because the user should be more knowledgeable).

Harm-Jan


From: Joris Meys<mailto:jorismeys at gmail.com<mailto:jorismeys at gmail.com>>
Sent: Thursday, July 20, 2017 13:16
To: Harm-Jan Westra<mailto:westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com>>
Cc: r-devel at r-project.org<mailto:r-devel at r-project.org><mailto:r-devel at r-project.org<mailto:r-devel at r-project.org>>
Subject: Re: [Rd] Wrongly converging glm()



On Thu, Jul 20, 2017 at 6:21 PM, Harm-Jan Westra <westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com><mailto:westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com>>> wrote:
Dear Joris,


I agree that such a covariate should not be used in the analysis, and fully agree with your assessment. However, your response assumes that everybody who uses R knows what they're doing, which is a dangerous assumption to make. I bet there are a lot of people who blindly trust the output from R, even when there's clearly something wrong with the estimates.

You missed my point then. I don't assume that everybody who uses R knows what they're doing. Actually, I know for a fact quite a few people using R have absolutely no clue about what they are doing. My point is that everybody using R should first do the effort of learning what they're doing. And if they don't, one shouldn't blame R. There's a million different cases where both algorithms would converge and the resulting estimates are totally meaningless regardless. R cannot be held responsible for that.



In terms of your conclusion that the C++ estimate corresponds to a value within the R estimated confidence interval: if I allow the C++ code to run for 1000 iterations, it's estimate would be around -1000. It simply never converges.

I didn't test that far, and you're right in the sense that -100 is indeed not the final estimate. After looking at the C code, it appears as if the author of that code combines a Newton-Raphson approach with a different convergence rule. And then it's quite understandible it doesn't converge. You can wildly vary that estimate, the effect it has on the jacobian, log likelihood or deviance will be insignificant. So the model won't improve, it would just move all over the parameter space.



I think there's nothing wrong with letting the user know there might be something wrong with one of the estimates, especially if your code can easily figure it out for you, by adding an additional rule. Not everyone is always paying attention (even if they know what they're doing).

If R would do that, it wouldn't start the fitting procedure but just return an error "Your analysis died due to a lack of useable data." . Because that's the problem here.



With kind regards,


Harm-Jan


________________________________
From: Joris Meys <jorismeys at gmail.com<mailto:jorismeys at gmail.com><mailto:jorismeys at gmail.com<mailto:jorismeys at gmail.com>>>
Sent: Thursday, July 20, 2017 11:38 AM
To: Harm-Jan Westra
Cc: r-devel at r-project.org<mailto:r-devel at r-project.org><mailto:r-devel at r-project.org<mailto:r-devel at r-project.org>>
Subject: Re: [Rd] Wrongly converging glm()

Allow me to chime in. That's an interesting case you present, but as far as I'm concerned the algorithm did converge. The estimate of -9.25 has an estimated standard error of 72.4, meaning that frequentists would claim the true value would lie anywhere between appx. -151 and 132 (CI) and hence the estimate from the glm algorithm is perfectly compatible with the one from the C++ code. And as the glm algorithm uses a different convergence rule, the algorithm rightfully reported it converged. It's not because another algorithm based on another rule doesn't converge, that the one glm uses didn't.

On top of that: In both cases the huge standard error on that estimate clearly tells you that the estimate should not be trusted, and the fit is unstable. That's to be expected, given the insane inbalance in your data, especially for the 13th column. If my students would incorporate that variable in a generalized linear model and tries to formulate a conclusion based on that coefficient, they failed the exam. So if somebody does this analysis and tries to draw any conclusion whatsoever on that estimate, maybe they should leave the analysis to somebody who does know what they're doing.

Cheers
Joris

On Thu, Jul 20, 2017 at 5:02 PM, Harm-Jan Westra <westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com><mailto:westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com>><mailto:westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com><mailto:westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com>>>> wrote:
Dear R-core,


I have found an edge-case where the glm function falsely concludes that the model has converged. The issue is the following: my data contains a number of covariates, one of these covariates has a very small variance. For most of the rows of this covariate, the value is 0, except for one of the rows, where it is 1.


The glm function correctly determines the beta and standard error estimates for all other covariates.


I've placed the data here: http://www.harmjanwestra.nl/rtestdata.txt


The model I'm using is very simple:


data <- read.table("rtestdata.txt")

model <- glm(data[,1] ~ data[,2] + data[,3] + data[,4] + data[,5] + data[,6] + data[,7] + data[,8] + data[,9] + data[,10] + data[,11] + data[,12] + data[,13] + data[,14], family=binomial("logit"))

summary(model)


You will see that for covariate data[,13], the beta/coefficient estimate is around -9. The number of iterations that has been performed is 8, and model$converged returns TRUE.


I've used some alternate logistic regression code in C (https://github.com/czep/mlelr/blob/master/src/mlelr.c), which produces identical estimates for the other covariates and comparable deviance values. However, using this C code, I'm seeing that the estimate for data[,13] is around -100 (since I'm allowing a maximum of 100 MLE iterations). There, the conclusion is that the model does not converge.


The difference between the two pieces of code is that in R, the glm() function determines convergence of the whole model by measuring the difference between deviance of the current iteration versus the deviance of the prior iteration, and calls the model converged when it reaches a certain epsilon value. In the C++ code, the model is converged when all parameters haven't changed markedly compared to the previous iteration.


I think both approaches are valid, although the R variant (while faster) makes it vulnerable to wrongly concluding convergence in edge cases such as the one presented above, resulting in wrong coefficient estimates. For people wanting to use logistic regression in a training/prediction kind of setting, using these estimates might influence their predictive performance.


The problem here is that the glm function does not return any warnings when one of the covariates in the model does not converge. For someone who is not paying attention, this may lead them to conclude there is nothing wrong with their data. In my opinion, the default behavior in this case should therefore be to conclude that the model did not converge, or at least to show a warning message.


Please let me know whether you believe this is an issue, and whether I can provide additional information.


With kind regards,


Harm-Jan Westra









        [[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org><mailto:R-devel at r-project.org<mailto:R-devel at r-project.org>><mailto:R-devel at r-project.org<mailto:R-devel at r-project.org><mailto:R-devel at r-project.org<mailto:R-devel at r-project.org>>> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel



--
Joris Meys
Statistical consultant

Ghent University
Faculty of Bioscience Engineering
Department of Mathematical Modelling, Statistics and Bio-Informatics

tel :  +32 (0)9 264 61 79<tel:%2B32%20%280%299%20264%2061%2079><tel:%2B32%20%280%299%20264%2061%2079>
Joris.Meys at Ugent.be
-------------------------------
Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php

        [[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org><mailto:R-devel at r-project.org<mailto:R-devel at r-project.org>> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel



--
Joris Meys
Statistical consultant

Ghent University
Faculty of Bioscience Engineering
Department of Mathematical Modelling, Statistics and Bio-Informatics

tel :  +32 (0)9 264 61 79<tel:%2B32%20%280%299%20264%2061%2079>
Joris.Meys at Ugent.be
-------------------------------
Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php


        [[alternative HTML version deleted]]


______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel



	[[alternative HTML version deleted]]


From jorismeys at gmail.com  Thu Jul 20 22:06:37 2017
From: jorismeys at gmail.com (Joris Meys)
Date: Thu, 20 Jul 2017 22:06:37 +0200
Subject: [Rd] Wrongly converging glm()
In-Reply-To: <DM3PR20MB05728541A9D1DD21D3354C0887A70@DM3PR20MB0572.namprd20.prod.outlook.com>
References: <DM3PR20MB05722D6CF8D15F73CC4CE65987A70@DM3PR20MB0572.namprd20.prod.outlook.com>
 <CAO1zAVa5uOEswx8b8HhHMwGNazz8Pgq3nmYhR2okTiCM4+-cRg@mail.gmail.com>
 <DM3PR20MB0572B9357503F0401CC5EABF87A70@DM3PR20MB0572.namprd20.prod.outlook.com>
 <CAO1zAVaWouvQ-p3kjxhH7V3RR5qP_3fwb4Je4KZXcyaZDfotqQ@mail.gmail.com>
 <DM3PR20MB05728541A9D1DD21D3354C0887A70@DM3PR20MB0572.namprd20.prod.outlook.com>
Message-ID: <CAO1zAVagjJ9kJ1dwoENXwkRi7OMFvt2e73vJyrnCBzq06Pkr_A@mail.gmail.com>

On Thu, Jul 20, 2017 at 8:32 PM, Harm-Jan Westra <westra.harmjan at outlook.com
> wrote:

> My apologies if I seemed to ?blame R?. This was in no way my intention. I
> get the feeling that you?re missing my point as well.
>

I get that now. But you're on R-devel and you started with the claim that R
"falsely reports...". That looks like a bug report, and that's why I
initially answered that R correctly reports it converged. Maybe to the
wrong value, but it converged.


>
>
> What strikes me as odd is that R would warn you when your data is faulty
> for a function such as cor(), but not for glm(). I don?t see why you
> wouldn?t want to check both convergence criteria if you know multiple of
> such criteria exist. It would make the software more user friendly in the
> end.
>

The unfitness of the data bears no relation to the convergence criterium
and vice versa. These data checks should be done before the convergence
algorithm is even started, and as Mark Leeds also indicated, that's one
hell of a job to do. That said, the glm function has an argument "method"
by which you can provide an alternative version of glm.fit().  Adapting
that one to use another convergence criterium is rather trivial, so
technically R even allows you to do that out of the box. No patches needed.


>
>
> I agree ?that everybody using R should first do the effort of learning
> what they're doing?, but it is a bit of a non-argument, because we all know
> that, the world just doesn?t work that way, plus this is one of the
> arguments that has held for example the Linux community back for quite a
> while (i.e. let?s not make the software more user friendly because the user
> should be more knowledgeable).
>

That's a wrong analogy imho. You can expect Linux to be user friendly, but
not "I will detect every logical fallacy in the article you're writing in
this text editor" friendly. And honestly, that's a bit what you're asking R
to do here. I understand why, but there's always cases that will be missed.
And I wouldn't dare to speak in the name of the R core team, but I can
imagine they have a little more urgent issues than helping my students to
pass their statistics course ;-)

Cheers
Joris


-- 
Joris Meys
Statistical consultant

Ghent University
Faculty of Bioscience Engineering
Department of Mathematical Modelling, Statistics and Bio-Informatics

tel :  +32 (0)9 264 61 79
Joris.Meys at Ugent.be
-------------------------------
Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php

	[[alternative HTML version deleted]]


From sgrubb at redhat.com  Thu Jul 20 23:02:10 2017
From: sgrubb at redhat.com (Steve Grubb)
Date: Thu, 20 Jul 2017 17:02:10 -0400
Subject: [Rd] [PATCH] Fix missing break
Message-ID: <60035856.27PnXlZqtm@x2>

Hello,

There appears to be a break missing in the switch/case for the LISTSXP case.
If this is supposed to fall through, I'd suggest a comment so that others
know its by design.

Signed-off-by: Steve Grubb <sgrubb at redhat.com>

Index: src/main/builtin.c
===================================================================
--- src/main/builtin.c	(revision 72935)
+++ src/main/builtin.c	(working copy)
@@ -888,6 +888,7 @@
 	    SETCAR(t, CAR(x));
 	    SET_TAG(t, TAG(x));
 	}
+	break;
     case VECSXP:
 	for (i = 0; i < len; i++)
 	    if (i < lenx) {


From sgrubb at redhat.com  Thu Jul 20 23:04:09 2017
From: sgrubb at redhat.com (Steve Grubb)
Date: Thu, 20 Jul 2017 17:04:09 -0400
Subject: [Rd] [PATCH] Fix bad free in connections
Message-ID: <2125974.DtE9TkYUl0@x2>

Hello, 

There are times when b points to buf which is a stack variable. This
leads to a bad free. The current test actually guarantees the stack
will try to get freed. Simplest to just drop the variable and directly
test if b should get freed.


Signed-off-by: Steve Grubb <sgrubb at redhat.com>


Index: src/main/connections.c
===================================================================
--- src/main/connections.c	(revision 72935)
+++ src/main/connections.c	(working copy)
@@ -421,7 +421,6 @@
     char buf[BUFSIZE], *b = buf;
     int res;
     const void *vmax = NULL; /* -Wall*/
-    int usedVasprintf = FALSE;
     va_list aq;
 
     va_copy(aq, ap);
@@ -434,7 +433,7 @@
 	    b = buf;
 	    buf[BUFSIZE-1] = '\0';
 	    warning(_("printing of extremely long output is truncated"));
-	} else usedVasprintf = TRUE;
+	}
     }
 #else
     if(res >= BUFSIZE) { /* res is the desired output length */
@@ -481,7 +480,7 @@
     } else
 	con->write(b, 1, res, con);
     if(vmax) vmaxset(vmax);
-    if(usedVasprintf) free(b);
+    if(b != buf) free(b);
     return res;
 }


From westra.harmjan at outlook.com  Thu Jul 20 22:16:03 2017
From: westra.harmjan at outlook.com (Harm-Jan Westra)
Date: Thu, 20 Jul 2017 20:16:03 +0000
Subject: [Rd] Wrongly converging glm()
In-Reply-To: <CAO1zAVagjJ9kJ1dwoENXwkRi7OMFvt2e73vJyrnCBzq06Pkr_A@mail.gmail.com>
References: <DM3PR20MB05722D6CF8D15F73CC4CE65987A70@DM3PR20MB0572.namprd20.prod.outlook.com>
 <CAO1zAVa5uOEswx8b8HhHMwGNazz8Pgq3nmYhR2okTiCM4+-cRg@mail.gmail.com>
 <DM3PR20MB0572B9357503F0401CC5EABF87A70@DM3PR20MB0572.namprd20.prod.outlook.com>
 <CAO1zAVaWouvQ-p3kjxhH7V3RR5qP_3fwb4Je4KZXcyaZDfotqQ@mail.gmail.com>
 <DM3PR20MB05728541A9D1DD21D3354C0887A70@DM3PR20MB0572.namprd20.prod.outlook.com>,
 <CAO1zAVagjJ9kJ1dwoENXwkRi7OMFvt2e73vJyrnCBzq06Pkr_A@mail.gmail.com>
Message-ID: <DM3PR20MB0572AA5455C5E3158AADB2F487A70@DM3PR20MB0572.namprd20.prod.outlook.com>

Dear Joris,

I?ll be more careful in my wording next time; thanks for the pointer, and thanks for the discussion. This whole process has been quite educational! ?. I think we?ve reached a consensus here, where the situation as it is right now has been chosen to allow for flexibility of R?s glm() function.

With kind regards,

Harm-Jan



From: Joris Meys<mailto:jorismeys at gmail.com>
Sent: Thursday, July 20, 2017 16:06
To: Harm-Jan Westra<mailto:westra.harmjan at outlook.com>
Cc: r-devel at r-project.org<mailto:r-devel at r-project.org>
Subject: Re: [Rd] Wrongly converging glm()




On Thu, Jul 20, 2017 at 8:32 PM, Harm-Jan Westra <westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com>> wrote:
My apologies if I seemed to ?blame R?. This was in no way my intention. I get the feeling that you?re missing my point as well.

I get that now. But you're on R-devel and you started with the claim that R "falsely reports...". That looks like a bug report, and that's why I initially answered that R correctly reports it converged. Maybe to the wrong value, but it converged.


What strikes me as odd is that R would warn you when your data is faulty for a function such as cor(), but not for glm(). I don?t see why you wouldn?t want to check both convergence criteria if you know multiple of such criteria exist. It would make the software more user friendly in the end.

The unfitness of the data bears no relation to the convergence criterium and vice versa. These data checks should be done before the convergence algorithm is even started, and as Mark Leeds also indicated, that's one hell of a job to do. That said, the glm function has an argument "method" by which you can provide an alternative version of glm.fit().  Adapting that one to use another convergence criterium is rather trivial, so technically R even allows you to do that out of the box. No patches needed.


I agree ?that everybody using R should first do the effort of learning what they're doing?, but it is a bit of a non-argument, because we all know that, the world just doesn?t work that way, plus this is one of the arguments that has held for example the Linux community back for quite a while (i.e. let?s not make the software more user friendly because the user should be more knowledgeable).

That's a wrong analogy imho. You can expect Linux to be user friendly, but not "I will detect every logical fallacy in the article you're writing in this text editor" friendly. And honestly, that's a bit what you're asking R to do here. I understand why, but there's always cases that will be missed. And I wouldn't dare to speak in the name of the R core team, but I can imagine they have a little more urgent issues than helping my students to pass their statistics course ;-)
Cheers
Joris


--
Joris Meys
Statistical consultant

Ghent University
Faculty of Bioscience Engineering
Department of Mathematical Modelling, Statistics and Bio-Informatics

tel :  +32 (0)9 264 61 79
Joris.Meys at Ugent.be
-------------------------------
Disclaimer : http://helpdesk.ugent.be/e-maildisclaimer.php


	[[alternative HTML version deleted]]


From sgrubb at redhat.com  Thu Jul 20 23:06:52 2017
From: sgrubb at redhat.com (Steve Grubb)
Date: Thu, 20 Jul 2017 17:06:52 -0400
Subject: [Rd] [PATCH] Fix memory leak in PicTeXDeviceDriver
Message-ID: <5314894.YKaiI5FJ7Q@x2>

Hello,

This patch fixes a memory leak due to ptd going out of scope
before its assigned to dd.

Signed-off-by: Steve Grubb <sgrubb at redhat.com>

Index: src/library/grDevices/src/devPicTeX.c
===================================================================
--- src/library/grDevices/src/devPicTeX.c	(revision 72935)
+++ src/library/grDevices/src/devPicTeX.c	(working copy)
@@ -665,8 +665,10 @@
     ptd->width = width;
     ptd->height = height;
 
-    if( ! PicTeX_Open(dd, ptd) ) 
+    if( ! PicTeX_Open(dd, ptd) ) {
+        free(ptd);
 	return FALSE;
+    }
 
     /* Base Pointsize */
     /* Nominal Character Sizes in Pixels */


From sgrubb at redhat.com  Thu Jul 20 23:28:53 2017
From: sgrubb at redhat.com (Steve Grubb)
Date: Thu, 20 Jul 2017 17:28:53 -0400
Subject: [Rd] [PATCH] Fix fscanf specifier in InIntegerAscii
Message-ID: <1981748.MGpVb1Uv45@x2>

Hello,

The SMBUF_SIZED_STRING allows fscanf to read upto 511 bytes. The buffer
at line 1382 is only 128 bytes. The fscanf format specifier ought to be
resized to prevent a stack overrun.

Signed-of-by: Steve Grubb <sgrubb at redhat.com>

Index: saveload.c
===================================================================
--- src/main/saveload.c	(revision 72935)
+++ src/main/saveload.c	(working copy)
@@ -1379,7 +1379,7 @@
 {
     char buf[128];
     int x, res;
-    res = fscanf(fp, SMBUF_SIZED_STRING, buf);
+    res = fscanf(fp, "%127s", buf);
     if(res != 1) error(_("read error"));
     if (strcmp(buf, "NA") == 0)
 	return NA_INTEGER;


From sgrubb at redhat.com  Thu Jul 20 23:31:51 2017
From: sgrubb at redhat.com (Steve Grubb)
Date: Thu, 20 Jul 2017 17:31:51 -0400
Subject: [Rd] [PATCH] Fix status in main
Message-ID: <1528218.0Ib1CH6ICv@x2>

Hello,

This is a patch to fix what appears to be a simple typo. The warning says
"invalid status assuming 0", but then instead sets runLast to 0.

Signed-of-by: Steve Grubb <sgrubb at redhat.com>

Index: src/main/main.c
===================================================================
--- src/main/main.c	(revision 72935)
+++ src/main/main.c	(working copy)
@@ -1341,7 +1341,7 @@
     status = asInteger(CADR(args));
     if (status == NA_INTEGER) {
 	warning(_("invalid 'status', 0 assumed"));
-	runLast = 0;
+	status = 0;
     }
     runLast = asLogical(CADDR(args));
     if (runLast == NA_LOGICAL) {


From pdalgd at gmail.com  Thu Jul 20 23:47:07 2017
From: pdalgd at gmail.com (peter dalgaard)
Date: Thu, 20 Jul 2017 23:47:07 +0200
Subject: [Rd] [patch] ?confint: "assumes asymptotic normality"
In-Reply-To: <20170720174656.xwiwool2mdyhkupi@steph>
References: <20170720072837.phhhg7q6lxmjzboj@steph>
 <22896.48208.806371.980068@stat.math.ethz.ch>
 <20170720174656.xwiwool2mdyhkupi@steph>
Message-ID: <50465019-76F4-47D3-B164-ABD1DB927EC5@gmail.com>


> On 20 Jul 2017, at 19:46 , Scott Kostyshak <skostyshak at ufl.edu> wrote:
> 
> On Thu, Jul 20, 2017 at 04:21:04PM +0200, Martin Maechler wrote:
>>>>>>> Scott Kostyshak <skostyshak at ufl.edu>
>>>>>>>    on Thu, 20 Jul 2017 03:28:37 -0400 writes:
>> 
>>>> From ?confint:
>>> "Computes confidence intervals" and "The default method assumes
>>> asymptotic normality"
>> 
>>> For me, a "confidence interval" implies an exact confidence interval in
>>> formal statistics (I concede that when speaking, the term is often used
>>> more loosely). And of course, even if a test statistic is asymptotically
>>> normal (so the assumption is satisfied), the finite distribution might
>>> not be normal and thus an exact confidence interval would not be
>>> computed.
>> 
>>> Attached is a patch that simply changes "asymptotic normality" to
>>> "normality" in confint.Rd. This encourages the user of the function to
>>> think about whether their asymptotically normal statistic is "normal
>>> enough" in a finite sample to get something reliable from confint().
>> 
>>> Alternatively, we could instead change "Computes confidence intervals"
>>> to "Computes asymptotic confidence intervals".
>> 
>>> I hope I'm not being too pedantic here.
>> 
>> well, it's just at the 97.5% border line of "too pedantic"  ...
> 
> :)
> 
>> ;-)
>> 
>> I think you are right with your first proposal to drop
>> "asymptotic" here.  After all, there's the explict 'fac <- qnorm(a)'.
> 
> Note that I received a private email that my message was indeed too
> pedantic and expressed disagreement with the proposal. I'm not sure if
> they intended it to be private so I will respond in private and see if
> they feel like bringing the discussion on the list. Or perhaps this
> minor (and perhaps controversial?) issue is not worth any additional
> time.

At any rate, it is important not to let the pedantry cause the text to become misleading. If you just write "assumes normality", readers may consider the procedure to be simply wrong when the estimator (or worse: the original data) is not normally distributed. And "computes asymptotic c.i." is just wrong, because they are sometimes exact. 

It may be necessary to spell things out more extensively. Something like "the default method assumes normality and that the s.e. is known. For asymptotically normally distributed estimators, it yields an asymptotic confidence interval."

-pd

  

> 
>> One could consider to make  'qnorm' an argument of the
>> default method to allow more general distributional assumptions,
>> but it may be wiser to have useRs write their own
>> confint.<foo>() method, notably for cases where
>> diag(vcov(object)) is an efficiency waste...
> 
> Thanks for your comments,
> 
> Scott
> 
>> Martin
>> 
>> 
>>> Scott
>> 
>> 
>>> -- 
>>> Scott Kostyshak
>>> Assistant Professor of Economics
>>> University of Florida
>>> https://people.clas.ufl.edu/skostyshak/
>> 
>> 
>>> ----------------------------------------------------------------------
>>> Index: src/library/stats/man/confint.Rd
>>> ===================================================================
>>> --- src/library/stats/man/confint.Rd	(revision 72930)
>>> +++ src/library/stats/man/confint.Rd	(working copy)
>>> @@ -31,7 +31,7 @@
>>> }
>>> \details{
>>> \code{confint} is a generic function.  The default method assumes
>>> -  asymptotic normality, and needs suitable \code{\link{coef}} and
>>> +  normality, and needs suitable \code{\link{coef}} and
>>> \code{\link{vcov}} methods to be available.  The default method can be
>>> called directly for comparison with other methods.
>> 
>> 
>>> ----------------------------------------------------------------------
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From murdoch.duncan at gmail.com  Fri Jul 21 01:41:00 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Thu, 20 Jul 2017 19:41:00 -0400
Subject: [Rd] [PATCH] Fix missing break
In-Reply-To: <60035856.27PnXlZqtm@x2>
References: <60035856.27PnXlZqtm@x2>
Message-ID: <f4b10bcb-aa8a-75cb-408f-236a24748aed@gmail.com>

Thanks for posting this series of patches.  Unfortunately, there's a 
good chance they'll get lost in all the traffic on R-devel.  If you 
don't hear that they've been fixed in the next couple of weeks, could 
you post them to bugs.r-project.org, and post future patches there as well?

In examples like the one below, if you have R code that shows symptoms, 
it would really help in the bug report.  Otherwise, someone else will 
have to analyze the code to decide whether it's a bug or missing 
comment.  That takes time, and if there are no known symptoms, it's 
likely to be assigned a low priority.  The sad truth is that very few 
members of R Core are currently actively fixing bugs.

Duncan Murdoch



On 20/07/2017 5:02 PM, Steve Grubb wrote:
> Hello,
>
> There appears to be a break missing in the switch/case for the LISTSXP case.
> If this is supposed to fall through, I'd suggest a comment so that others
> know its by design.
>
> Signed-off-by: Steve Grubb <sgrubb at redhat.com>
>
> Index: src/main/builtin.c
> ===================================================================
> --- src/main/builtin.c	(revision 72935)
> +++ src/main/builtin.c	(working copy)
> @@ -888,6 +888,7 @@
>  	    SETCAR(t, CAR(x));
>  	    SET_TAG(t, TAG(x));
>  	}
> +	break;
>      case VECSXP:
>  	for (i = 0; i < len; i++)
>  	    if (i < lenx) {
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From sgrubb at redhat.com  Fri Jul 21 04:20:33 2017
From: sgrubb at redhat.com (Steve Grubb)
Date: Thu, 20 Jul 2017 22:20:33 -0400
Subject: [Rd] [PATCH] Fix missing break
In-Reply-To: <f4b10bcb-aa8a-75cb-408f-236a24748aed@gmail.com>
References: <60035856.27PnXlZqtm@x2>
 <f4b10bcb-aa8a-75cb-408f-236a24748aed@gmail.com>
Message-ID: <4241711.WyxJnDo7EK@x2>

On Thursday, July 20, 2017 7:41:00 PM EDT Duncan Murdoch wrote:
> Thanks for posting this series of patches.  Unfortunately, there's a
> good chance they'll get lost in all the traffic on R-devel.  If you
> don't hear that they've been fixed in the next couple of weeks, could
> you post them to bugs.r-project.org, and post future patches there as well?

That was my first inclination. But there is no way to create an account unlike 
most open source projects I work with. And I work with quite a lot.


> In examples like the one below, if you have R code that shows symptoms,
> it would really help in the bug report. 

I am hoping that we can look at the code as seasoned programmers and say yeah, 
that is a bug. I run the code through Coverity and have quite a lot of 
problems to tell you about. I run these 5 out as tests to see how this 
community works. I am new to this community but not necessarily R and just 
want to contribute back to something I am using. But believe me, I have a 
bunch more that seasoned programmers can eyeball and say yep - that's a bug.


> Otherwise, someone else will have to analyze the code to decide whether it's
> a bug or missing comment.  That takes time, and if there are no known
> symptoms, it's likely to be assigned a low priority.  The sad truth is that
> very few members of R Core are currently actively fixing bugs.

That's a shame. I'd be happy to give the scan to people in core so they can 
see what the lay of the land looks like. R works amazingly good. So much so I 
decided to dig deeper. I'd recommend to the core developers that they ask to 
get on Coverity's open source scan list.

https://scan.coverity.com/

It's free to open source projects like this. :-)

-Steve


> On 20/07/2017 5:02 PM, Steve Grubb wrote:
> > Hello,
> > 
> > There appears to be a break missing in the switch/case for the LISTSXP
> > case. If this is supposed to fall through, I'd suggest a comment so that
> > others know its by design.
> > 
> > Signed-off-by: Steve Grubb <sgrubb at redhat.com>
> > 
> > Index: src/main/builtin.c
> > ===================================================================
> > --- src/main/builtin.c	(revision 72935)
> > +++ src/main/builtin.c	(working copy)
> > @@ -888,6 +888,7 @@
> > 
> >  	    SETCAR(t, CAR(x));
> >  	    SET_TAG(t, TAG(x));
> >  	
> >  	}
> > 
> > +	break;
> > 
> >      case VECSXP:
> >  	for (i = 0; i < len; i++)
> >  	
> >  	    if (i < lenx) {
> > 
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel


From martin.morgan at roswellpark.org  Fri Jul 21 09:43:48 2017
From: martin.morgan at roswellpark.org (Martin Morgan)
Date: Fri, 21 Jul 2017 03:43:48 -0400
Subject: [Rd] [PATCH] Fix missing break
In-Reply-To: <60035856.27PnXlZqtm@x2>
References: <60035856.27PnXlZqtm@x2>
Message-ID: <cadf2c7b-e6d7-e8ba-20e6-17f53a0a6197@roswellpark.org>

On 07/20/2017 05:02 PM, Steve Grubb wrote:
> Hello,
> 
> There appears to be a break missing in the switch/case for the LISTSXP case.
> If this is supposed to fall through, I'd suggest a comment so that others
> know its by design.
> 
> Signed-off-by: Steve Grubb <sgrubb at redhat.com>

An example is

$ R --vanilla -e "pl = pairlist(1, 2); length(pl) = 1; pl"
 > pl = pairlist(1, 2); length(pl) = 1; pl
Error in length(pl) = 1 :
   SET_VECTOR_ELT() can only be applied to a 'list', not a 'pairlist'
Execution halted

fixed in r72936 (R-devel) / 72937 (R-3-4-branch).

Martin Morgan

> 
> Index: src/main/builtin.c
> ===================================================================
> --- src/main/builtin.c	(revision 72935)
> +++ src/main/builtin.c	(working copy)
> @@ -888,6 +888,7 @@
>   	    SETCAR(t, CAR(x));
>   	    SET_TAG(t, TAG(x));
>   	}
> +	break;
>       case VECSXP:
>   	for (i = 0; i < len; i++)
>   	    if (i < lenx) {
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


This email message may contain legally privileged and/or...{{dropped:2}}


From martin.morgan at roswellpark.org  Fri Jul 21 10:13:47 2017
From: martin.morgan at roswellpark.org (Martin Morgan)
Date: Fri, 21 Jul 2017 04:13:47 -0400
Subject: [Rd] [PATCH] Fix status in main
In-Reply-To: <1528218.0Ib1CH6ICv@x2>
References: <1528218.0Ib1CH6ICv@x2>
Message-ID: <765b29ba-4512-5eb1-f26a-36abd0dd0be1@roswellpark.org>

On 07/20/2017 05:31 PM, Steve Grubb wrote:
> Hello,
> 
> This is a patch to fix what appears to be a simple typo. The warning says
> "invalid status assuming 0", but then instead sets runLast to 0.
> 
> Signed-of-by: Steve Grubb <sgrubb at redhat.com>

fixed in 72938 / 39.

This seemed not to have consequence, since exit() reports NA & 0377 
(i.e., 0) and the incorrect assignment to runLast is immediately 
over-written by the correct value.

Martin Morgan

> 
> Index: src/main/main.c
> ===================================================================
> --- src/main/main.c	(revision 72935)
> +++ src/main/main.c	(working copy)
> @@ -1341,7 +1341,7 @@
>       status = asInteger(CADR(args));
>       if (status == NA_INTEGER) {
>   	warning(_("invalid 'status', 0 assumed"));
> -	runLast = 0;
> +	status = 0;
>       }
>       runLast = asLogical(CADDR(args));
>       if (runLast == NA_LOGICAL) {
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


This email message may contain legally privileged and/or...{{dropped:2}}


From maechler at stat.math.ethz.ch  Fri Jul 21 10:21:21 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Fri, 21 Jul 2017 10:21:21 +0200
Subject: [Rd] [PATCH] Fix missing break
In-Reply-To: <4241711.WyxJnDo7EK@x2>
References: <60035856.27PnXlZqtm@x2>
 <f4b10bcb-aa8a-75cb-408f-236a24748aed@gmail.com>
 <4241711.WyxJnDo7EK@x2>
Message-ID: <22897.47489.517803.232885@stat.math.ethz.ch>

>>>>> Steve Grubb <sgrubb at redhat.com>
>>>>>     on Thu, 20 Jul 2017 22:20:33 -0400 writes:

    > On Thursday, July 20, 2017 7:41:00 PM EDT Duncan Murdoch wrote:
    >> Thanks for posting this series of patches.  Unfortunately, there's a
    >> good chance they'll get lost in all the traffic on R-devel.  If you
    >> don't hear that they've been fixed in the next couple of weeks, could
    >> you post them to bugs.r-project.org, and post future patches there as well?

    > That was my first inclination. But there is no way to create an account unlike 
    > most open source projects I work with. And I work with quite a lot.

It used to be easily possible, until someone urged students or
paid people to create such accounts and create crap bug reports.
For a while, we tried a few measures to deal with that but we
found no measure which was both fast and relatively foolproof.

--> See https://www.r-project.org/bugs.html and look for  "abuse".

I have now created an account for you.

    >> In examples like the one below, if you have R code that shows symptoms,
    >> it would really help in the bug report. 


    > I am hoping that we can look at the code as seasoned programmers and say yeah, 
    > that is a bug.

I agree in this case.
OTOH, it is exactly one of the case where the bug is not
triggerable currently:

  al <- formals(ls); length(al) <- 3

would trigger the bug... but you get an error message ".. vector .."
and as I now found that is from a slightly misguided check:
isVectorizable()  is not approriate here and should really be
replaced by isList().
  
So .. indeed, your report will have triggered an improvement in
the code, which I'm about to commit.

Thank you very much Steve!

    > I run the code through Coverity and have quite a lot of 
    > problems to tell you about.

I'm not the expert on static code analysis, but as a seasoned
statistician (*and* from experience with other such analyses) I
know that you always get false positives.

    > I run these 5 out as tests to see how this 
    > community works. I am new to this community but not necessarily R and just 
    > want to contribute back to something I am using. But believe me, I have a 
    > bunch more that seasoned programmers can eyeball and say yep - that's a bug.

Good, looking forward to see them.

    >> Otherwise, someone else will have to analyze the code to decide whether it's
    >> a bug or missing comment.  That takes time, and if there are no known
    >> symptoms, it's likely to be assigned a low priority.  The sad truth is that
    >> very few members of R Core are currently actively fixing bugs.

    > That's a shame. I'd be happy to give the scan to people in core so they can 
    > see what the lay of the land looks like.

 (hmm... the above does look a teeny tiny bit arrogant in my
  eyes; but then I'm not a native English (nor "American" :-)
  speaker ...)


    > R works amazingly good. So much so I decided to dig
    > deeper. I'd recommend to the core developers that they ask
    > to get on Coverity's open source scan list.

    > https://scan.coverity.com/

    > It's free to open source projects like this. :-)

    > -Steve


    >> On 20/07/2017 5:02 PM, Steve Grubb wrote:
    >> > Hello,
    >> > 
    >> > There appears to be a break missing in the switch/case for the LISTSXP
    >> > case. If this is supposed to fall through, I'd suggest a comment so that
    >> > others know its by design.
    >> > 
    >> > Signed-off-by: Steve Grubb <sgrubb at redhat.com>
    >> > 
    >> > Index: src/main/builtin.c
    >> > ===================================================================
    >> > --- src/main/builtin.c	(revision 72935)
    >> > +++ src/main/builtin.c	(working copy)
    >> > @@ -888,6 +888,7 @@
    >> > 
    >> >  	    SETCAR(t, CAR(x));
    >> >  	    SET_TAG(t, TAG(x));
    >> >  	
    >> >  	}
    >> > 
    >> > +	break;
    >> > 
    >> >      case VECSXP:
    >> >  	for (i = 0; i < len; i++)
    >> >  	
    >> >  	    if (i < lenx) {
    >> > 
    >> > ______________________________________________
    >> > R-devel at r-project.org mailing list
    >> > https://stat.ethz.ch/mailman/listinfo/r-devel

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From maechler at stat.math.ethz.ch  Fri Jul 21 10:23:43 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Fri, 21 Jul 2017 10:23:43 +0200
Subject: [Rd] [PATCH] Fix status in main
In-Reply-To: <1528218.0Ib1CH6ICv@x2>
References: <1528218.0Ib1CH6ICv@x2>
Message-ID: <22897.47631.684547.97268@stat.math.ethz.ch>


> Hello,
> This is a patch to fix what appears to be a simple typo. The warning says
> "invalid status assuming 0", but then instead sets runLast to 0.

> Signed-of-by: Steve Grubb <sgrubb at redhat.com>

> Index: src/main/main.c
> ===================================================================
> --- src/main/main.c	(revision 72935)
> +++ src/main/main.c	(working copy)
> @@ -1341,7 +1341,7 @@
>      status = asInteger(CADR(args));
>      if (status == NA_INTEGER) {
>  	warning(_("invalid 'status', 0 assumed"));
> -	runLast = 0;
> +	status = 0;
>      }
>      runLast = asLogical(CADDR(args));
>      if (runLast == NA_LOGICAL) {

Yes, thank you!

Martin


From maechler at stat.math.ethz.ch  Fri Jul 21 10:40:44 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Fri, 21 Jul 2017 10:40:44 +0200
Subject: [Rd] [PATCH] Fix missing break
In-Reply-To: <cadf2c7b-e6d7-e8ba-20e6-17f53a0a6197@roswellpark.org>
References: <60035856.27PnXlZqtm@x2>
 <cadf2c7b-e6d7-e8ba-20e6-17f53a0a6197@roswellpark.org>
Message-ID: <22897.48652.879059.602892@stat.math.ethz.ch>

>>>>> Martin Morgan <martin.morgan at roswellpark.org>
>>>>>     on Fri, 21 Jul 2017 03:43:48 -0400 writes:

    > On 07/20/2017 05:02 PM, Steve Grubb wrote:
    >> Hello,
    >> 
    >> There appears to be a break missing in the switch/case for the LISTSXP case.
    >> If this is supposed to fall through, I'd suggest a comment so that others
    >> know its by design.
    >> 
    >> Signed-off-by: Steve Grubb <sgrubb at redhat.com>

    > An example is

    > $ R --vanilla -e "pl = pairlist(1, 2); length(pl) = 1; pl"
    >> pl = pairlist(1, 2); length(pl) = 1; pl
    > Error in length(pl) = 1 :
    > SET_VECTOR_ELT() can only be applied to a 'list', not a 'pairlist'
    > Execution halted

    > fixed in r72936 (R-devel) / 72937 (R-3-4-branch).

    > Martin Morgan

Cool: The two  Martin M*'s  in the R core team have been "running in parallel".

The example which I meant where the missing break was hidden by
an earlier (wrong) errror message is this one:

> al <- formals(ls); length(al) <- 9
Error in length(al) <- 9 : invalid argument

which my extra changes will fix.

--
The other Martin M* - from the R Core Team


From martin.morgan at roswellpark.org  Fri Jul 21 11:03:09 2017
From: martin.morgan at roswellpark.org (Martin Morgan)
Date: Fri, 21 Jul 2017 05:03:09 -0400
Subject: [Rd] [PATCH] Fix bad free in connections
In-Reply-To: <2125974.DtE9TkYUl0@x2>
References: <2125974.DtE9TkYUl0@x2>
Message-ID: <25a319a3-d822-671f-06e9-5e2034f56c16@roswellpark.org>

On 07/20/2017 05:04 PM, Steve Grubb wrote:
> Hello,
> 
> There are times when b points to buf which is a stack variable. This
> leads to a bad free. The current test actually guarantees the stack
> will try to get freed. Simplest to just drop the variable and directly
> test if b should get freed.
> 
> 
> Signed-off-by: Steve Grubb <sgrubb at redhat.com>
> 
> 
> Index: src/main/connections.c
> ===================================================================
> --- src/main/connections.c	(revision 72935)
> +++ src/main/connections.c	(working copy)
> @@ -421,7 +421,6 @@
>       char buf[BUFSIZE], *b = buf;
>       int res;
>       const void *vmax = NULL; /* -Wall*/
> -    int usedVasprintf = FALSE;
>       va_list aq;
>   
>       va_copy(aq, ap);
> @@ -434,7 +433,7 @@
>   	    b = buf;
>   	    buf[BUFSIZE-1] = '\0';
>   	    warning(_("printing of extremely long output is truncated"));
> -	} else usedVasprintf = TRUE;
> +	}
>       }
>   #else
>       if(res >= BUFSIZE) { /* res is the desired output length */
> @@ -481,7 +480,7 @@
>       } else
>   	con->write(b, 1, res, con);
>       if(vmax) vmaxset(vmax);
> -    if(usedVasprintf) free(b);
> +    if(b != buf) free(b);

The code can be exercised with

   z = paste(rep("a", 11000), collapse="")
   f = fifo("foo", "w+")
   writeLines(z, f)

If the macro HAVE_VASPRINTF is not defined, then b is the result of 
R_alloc(), and it is not appropriate to free(b).

If the macro is defined we go through

	res = vasprintf(&b, format, ap);
	if (res < 0) {
	    b = buf;
	    buf[BUFSIZE-1] = '\0';
	    warning(_("printing of extremely long output is truncated"));
	} else usedVasprintf = TRUE;

b gets reallocated when

     res = vasprintf(&b, format, ap);

is successful and res >= 0. usedVasprintf is then set to TRUE, and 
free(b) called.

It seems like the code is correct as written?

Martin Morgan (the real other Martin M*)

>       return res;
>   }
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


This email message may contain legally privileged and/or...{{dropped:2}}


From jean-luc.lipatz at insee.fr  Fri Jul 21 11:26:34 2017
From: jean-luc.lipatz at insee.fr (Lipatz Jean-Luc)
Date: Fri, 21 Jul 2017 09:26:34 +0000
Subject: [Rd] 'gsub' not perl compatible?
Message-ID: <FEF25E56AFC7064784FA97C576467E0AC7ACD337@pdexchbalwst01.ad.insee.intra>

Hi all,

Working on some SAS program conversions, I was testing this (3.4.0 Windows, but also 2.10.1 MacOsX):
gsub("b?","!","abc",perl=T)

which returns
[1] "!a!c!"

that I didn't understand.

Unfortunately, asked for the same thing SAS 9.4 replies : "!a!!c!", and so does Perl (Strawberry 5.26), a more logical answer for me.
Is there some problem with PCRE or some subtility that I didn't catch?

Results are similar with * instead of ?
and there is a similar issue with the lazy operator:
gsub("b??","!","abc",perl=T) gives : "!a!b!c!", while the other softwares give "!a!!!c!"


Thanks

Jean-Luc LIPATZ




	[[alternative HTML version deleted]]


From therneau at mayo.edu  Fri Jul 21 14:04:06 2017
From: therneau at mayo.edu (Therneau, Terry M., Ph.D.)
Date: Fri, 21 Jul 2017 07:04:06 -0500
Subject: [Rd] Wrongly converging glm()
Message-ID: <9153c6$7hh050@ironport10.mayo.edu>

I'm chiming in late since I read the news in digest form, and I won't copy the entire 
conversation to date.

The issue raised comes up quite often in Cox models, so often that the Therneau and 
Grambsch book has a section on the issue (3.5, p 58).  After a few initial iterations the 
offending coefficient will increase by a constant at each iteration while the 
log-likelihood approaches an asymptote (essentially once the other coefficients "settle 
down").

The coxph routine tries to detect this case and print a warning, and this turns out to be 
very hard to do accurately.  I worked hard at tuning the threshold(s) for the message 
several years ago and finally gave up; I am guessing that the warning misses > 5% of the 
cases when the issue is true, and that 5% of the warnings that do print are incorrect.  
(And these estimates may be too optimistic.)   Highly correlated predictors tend to trip 
it up, e.g., the truncated power spline basis used by the rcs function in Hmisc.

All in all, I am not completely sure whether the message does more harm than good.  I'd be 
quite reluctant to go down the same path again with the glm function.

Terry Therneau


From ravi.varadhan at jhu.edu  Fri Jul 21 15:22:58 2017
From: ravi.varadhan at jhu.edu (Ravi Varadhan)
Date: Fri, 21 Jul 2017 13:22:58 +0000
Subject: [Rd] Wrongly converging glm()
In-Reply-To: <9153c6$7hh050@ironport10.mayo.edu>
References: <9153c6$7hh050@ironport10.mayo.edu>
Message-ID: <d30e71f8413846deb05ed98551af6974@ESGEBEX10.win.ad.jhu.edu>

Please allow me to add my 3 cents.  Stopping an iterative optimization algorithm at an "appropriate" juncture is very tricky.  All one can say is that the algorithm terminated because it triggered a particular stopping criterion.  A good software will tell you why it stopped - i.e. the stopping criterion that was triggered.  It is extremely difficult to make a failsafe guarantee that the triggered stopping criterion is the correct one and that the answer obtained is trustworthy. It is up to the user to determine whether the answer makes sense.  In the case of maximizing a likelihood function, it is perfectly reasonable to stop when the algorithm has not made any progress in increasing the log likelihood.  In this case, the software should print out something like "algorithm terminated due to lack of improvement in log-likelihood."  Therefore, I don't see a need to issue any warning, but simply report the stopping criterion that was applied to terminate the algorithm.

Best,
Ravi

-----Original Message-----
From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of Therneau, Terry M., Ph.D.
Sent: Friday, July 21, 2017 8:04 AM
To: r-devel at r-project.org; Mark Leeds <markleeds2 at gmail.com>; jorismeys at gmail.com; westra.harmjan at outlook.com
Subject: Re: [Rd] Wrongly converging glm()

I'm chiming in late since I read the news in digest form, and I won't copy the entire conversation to date.

The issue raised comes up quite often in Cox models, so often that the Therneau and Grambsch book has a section on the issue (3.5, p 58).  After a few initial iterations the offending coefficient will increase by a constant at each iteration while the log-likelihood approaches an asymptote (essentially once the other coefficients "settle down").

The coxph routine tries to detect this case and print a warning, and this turns out to be very hard to do accurately.  I worked hard at tuning the threshold(s) for the message several years ago and finally gave up; I am guessing that the warning misses > 5% of the cases when the issue is true, and that 5% of the warnings that do print are incorrect.  
(And these estimates may be too optimistic.)   Highly correlated predictors tend to trip 
it up, e.g., the truncated power spline basis used by the rcs function in Hmisc.

All in all, I am not completely sure whether the message does more harm than good.  I'd be quite reluctant to go down the same path again with the glm function.

Terry Therneau

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From maechler at stat.math.ethz.ch  Fri Jul 21 17:27:48 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Fri, 21 Jul 2017 17:27:48 +0200
Subject: [Rd] [PATCH] Fix memory leak in PicTeXDeviceDriver
In-Reply-To: <5314894.YKaiI5FJ7Q@x2>
References: <5314894.YKaiI5FJ7Q@x2>
Message-ID: <22898.7540.435383.438337@stat.math.ethz.ch>

>>>>> Steve Grubb <sgrubb at redhat.com>
>>>>>     on Thu, 20 Jul 2017 17:06:52 -0400 writes:

    > Hello,
    > This patch fixes a memory leak due to ptd going out of scope
    > before its assigned to dd.

Hmm, I'm not an expert here, but I tend to say 
that it may not be a memory leak because the corresponding
function is static and only called from inside PicTeX() and that has 

    const void *vmax = vmaxget();

at the beginning, and ends with

    vmaxset(vmax);
    return R_NilValue;

maybe because the code writer "saw" that it could not really
free everything correctly ?

The following code - after install.package("sfsmisc")
seems to suggest a very small "leak" but only up to some point, and your
patch does not seem to change much about it:

if(!require("sfsmisc")) install.packages("sfsmisc") # for Sys.sizes()
## but that's not available on Windoze ...

monitor <- function(call, n = 10000, every = n %/% 50, doGC = TRUE) {
    for(i in seq_len(n)) {
        if(i == 1 || i %% every == 0) {
            if(doGC) gc()
            ns <- names(ss <- Sys.sizes())
            cat(sprintf("%5d: (%s=%7d, %s=%7d)\n",
                        i, ns[1], ss[[1]], ns[2], ss[[2]]))
        }
        eval(call)
    }
}

monitor(quote({pictex(); dev.off()}))
##             --------  ^\______needed, otherwise have too many open devices
## goes up to some and then stays

monitor(quote({pdf(); dev.off()}))
##             ---
## goes up to some and then stays ...[almost, sometimes increases still a bit]
## is not much different to pictex()


But I've added a  free(ptd) --- in a way where the code
is slightly easier to parse by a human.

Thank you, Steve!
Martin


    > Signed-off-by: Steve Grubb <sgrubb at redhat.com>

    > Index: src/library/grDevices/src/devPicTeX.c
    > ===================================================================
    > --- src/library/grDevices/src/devPicTeX.c	(revision 72935)
    > +++ src/library/grDevices/src/devPicTeX.c	(working copy)
    > @@ -665,8 +665,10 @@
    > ptd-> width = width;
    > ptd-> height = height;
 
    > -    if( ! PicTeX_Open(dd, ptd) ) 
    > +    if( ! PicTeX_Open(dd, ptd) ) {
    > +        free(ptd);
    > return FALSE;
    > +    }
 
    > /* Base Pointsize */
    > /* Nominal Character Sizes in Pixels */


From maechler at stat.math.ethz.ch  Fri Jul 21 17:35:12 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Fri, 21 Jul 2017 17:35:12 +0200
Subject: [Rd] [PATCH] Fix fscanf specifier in InIntegerAscii
In-Reply-To: <1981748.MGpVb1Uv45@x2>
References: <1981748.MGpVb1Uv45@x2>
Message-ID: <22898.7984.182728.632418@stat.math.ethz.ch>

>>>>> Steve Grubb <sgrubb at redhat.com>
>>>>>     on Thu, 20 Jul 2017 17:28:53 -0400 writes:

    > Hello,
    > The SMBUF_SIZED_STRING allows fscanf to read upto 511 bytes. The buffer
    > at line 1382 is only 128 bytes. The fscanf format specifier ought to be
    > resized to prevent a stack overrun.

Yes, you are right, thank you!

Fix committed as svn rev  72945



    > Signed-of-by: Steve Grubb <sgrubb at redhat.com>

    > Index: saveload.c
    > ===================================================================
    > --- src/main/saveload.c	(revision 72935)
    > +++ src/main/saveload.c	(working copy)
    > @@ -1379,7 +1379,7 @@
    > {
    > char buf[128];
    > int x, res;
    > -    res = fscanf(fp, SMBUF_SIZED_STRING, buf);
    > +    res = fscanf(fp, "%127s", buf);
    > if(res != 1) error(_("read error"));
    > if (strcmp(buf, "NA") == 0)
    > return NA_INTEGER;

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From sgrubb at redhat.com  Fri Jul 21 19:40:44 2017
From: sgrubb at redhat.com (Steve Grubb)
Date: Fri, 21 Jul 2017 13:40:44 -0400
Subject: [Rd] [PATCH] Fix bad free in connections
In-Reply-To: <25a319a3-d822-671f-06e9-5e2034f56c16@roswellpark.org>
References: <2125974.DtE9TkYUl0@x2>
 <25a319a3-d822-671f-06e9-5e2034f56c16@roswellpark.org>
Message-ID: <5540301.g3gtRBd9oT@x2>

On Friday, July 21, 2017 5:03:09 AM EDT Martin Morgan wrote:
> b gets reallocated when
> 
>      res = vasprintf(&b, format, ap);
> 
> is successful and res >= 0. usedVasprintf is then set to TRUE, and
> free(b) called.
> 
> It seems like the code is correct as written?

Yes, I think I see the issue. vasprintf seems to not be tracked for memory 
allocation. So, yes I agree its correct as written. Sorry for the noise.

-Steve


From sgrubb at redhat.com  Fri Jul 21 19:53:12 2017
From: sgrubb at redhat.com (Steve Grubb)
Date: Fri, 21 Jul 2017 13:53:12 -0400
Subject: [Rd] [PATCH] Fix missing break
In-Reply-To: <22897.47489.517803.232885@stat.math.ethz.ch>
References: <60035856.27PnXlZqtm@x2> <4241711.WyxJnDo7EK@x2>
 <22897.47489.517803.232885@stat.math.ethz.ch>
Message-ID: <2491471.UUKbAB2nFm@x2>

Hello Martin,

On Friday, July 21, 2017 4:21:21 AM EDT Martin Maechler wrote:
> I have now created an account for you.

Thanks. Is that the preferred method of transferring these patches?


> >> In examples like the one below, if you have R code that shows symptoms,
> >> it would really help in the bug report.
> > 
> > I am hoping that we can look at the code as seasoned programmers and say
> > yeah, that is a bug.
> 
> I agree in this case.
> OTOH, it is exactly one of the case where the bug is not
> triggerable currently:
> 
>   al <- formals(ls); length(al) <- 3
> 
> would trigger the bug... but you get an error message ".. vector .."
> and as I now found that is from a slightly misguided check:
> isVectorizable()  is not approriate here and should really be
> replaced by isList().
> 
> So .. indeed, your report will have triggered an improvement in
> the code, which I'm about to commit.

That's what it's all about.  :-)
 
> Thank you very much Steve!
> 
> > I run the code through Coverity and have quite a lot of
> > problems to tell you about.
> 
> I'm not the expert on static code analysis, but as a seasoned
> statistician (*and* from experience with other such analyses) I
> know that you always get false positives.

Absolutely. I weeded the report down to 15 issues to start with. There are 
also ways to annotate the code so that checkers dismiss something it would 
otherwise be inclined to report.

> >> Otherwise, someone else will have to analyze the code to decide whether
> >> it's a bug or missing comment.  That takes time, and if there are no
> >> known symptoms, it's likely to be assigned a low priority.  The sad
> >> truth is that very few members of R Core are currently actively fixing
> >> bugs.
> > 
> > That's a shame. I'd be happy to give the scan to people in core so they
> > can see what the lay of the land looks like.
> 
>  (hmm... the above does look a teeny tiny bit arrogant in my
>   eyes; but then I'm not a native English (nor "American" 
>   speaker ...)

I apologize if that is the way it came across. "That's a shame" can also mean 
"That's unfortunate" because I was thinking that I spent some time fixing up 
patches that might not be wanted. However, I see that you have looked at the 
patches and I thank you for that.  :-)

The second sentence above is an honest offer. I'd be happy to send the output 
of the report off list (in case anything sensitive is listed). In this and the 
other patches I haven't sent, I'm just picking the low hanging fruit.

-Steve


From markleeds2 at gmail.com  Fri Jul 21 21:09:04 2017
From: markleeds2 at gmail.com (Mark Leeds)
Date: Fri, 21 Jul 2017 15:09:04 -0400
Subject: [Rd] Wrongly converging glm()
In-Reply-To: <d30e71f8413846deb05ed98551af6974@ESGEBEX10.win.ad.jhu.edu>
References: <9153c6$7hh050@ironport10.mayo.edu>
 <d30e71f8413846deb05ed98551af6974@ESGEBEX10.win.ad.jhu.edu>
Message-ID: <CAHz+bWZOx3oAuhMU129AAJmarpTrfau=jJVSGGweGuw8QgeDOg@mail.gmail.com>

Hi Ravi: Well said. In John's Rvmmin package, he has codes for explaining
the cause
of the termination. The codes returned were fine. The problem was that
the model I was using could have multiple solutions ( regardless of the data
sent in ) so, even though the stopping criteria was reached, it turned out
that one of the parameters ( there were two parameters ) could have really
been anything and the same likelihood value would  be returned. So, what I
learned the hard way was  termination due to reasonable stopping  criteria
DOES NOT NECESSARILY EQUAL OPTIMAL. But I lived in the dark about this for
a long time and only happened to notice it when playing around with the
likelihood by fixing the offending parameter to various values and
optimizing over the
non-offending parameter. Thanks for eloquent explanation.


      Mark




























On Fri, Jul 21, 2017 at 9:22 AM, Ravi Varadhan <ravi.varadhan at jhu.edu>
wrote:

> Please allow me to add my 3 cents.  Stopping an iterative optimization
> algorithm at an "appropriate" juncture is very tricky.  All one can say is
> that the algorithm terminated because it triggered a particular stopping
> criterion.  A good software will tell you why it stopped - i.e. the
> stopping criterion that was triggered.  It is extremely difficult to make a
> failsafe guarantee that the triggered stopping criterion is the correct one
> and that the answer obtained is trustworthy. It is up to the user to
> determine whether the answer makes sense.  In the case of maximizing a
> likelihood function, it is perfectly reasonable to stop when the algorithm
> has not made any progress in increasing the log likelihood.  In this case,
> the software should print out something like "algorithm terminated due to
> lack of improvement in log-likelihood."  Therefore, I don't see a need to
> issue any warning, but simply report the stopping criterion that was
> applied to terminate the algorithm.
>
> Best,
> Ravi
>
> -----Original Message-----
> From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of
> Therneau, Terry M., Ph.D.
> Sent: Friday, July 21, 2017 8:04 AM
> To: r-devel at r-project.org; Mark Leeds <markleeds2 at gmail.com>;
> jorismeys at gmail.com; westra.harmjan at outlook.com
> Subject: Re: [Rd] Wrongly converging glm()
>
> I'm chiming in late since I read the news in digest form, and I won't copy
> the entire conversation to date.
>
> The issue raised comes up quite often in Cox models, so often that the
> Therneau and Grambsch book has a section on the issue (3.5, p 58).  After a
> few initial iterations the offending coefficient will increase by a
> constant at each iteration while the log-likelihood approaches an asymptote
> (essentially once the other coefficients "settle down").
>
> The coxph routine tries to detect this case and print a warning, and this
> turns out to be very hard to do accurately.  I worked hard at tuning the
> threshold(s) for the message several years ago and finally gave up; I am
> guessing that the warning misses > 5% of the cases when the issue is true,
> and that 5% of the warnings that do print are incorrect.
> (And these estimates may be too optimistic.)   Highly correlated
> predictors tend to trip
> it up, e.g., the truncated power spline basis used by the rcs function in
> Hmisc.
>
> All in all, I am not completely sure whether the message does more harm
> than good.  I'd be quite reluctant to go down the same path again with the
> glm function.
>
> Terry Therneau
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From ravi.varadhan at jhu.edu  Fri Jul 21 22:36:21 2017
From: ravi.varadhan at jhu.edu (Ravi Varadhan)
Date: Fri, 21 Jul 2017 20:36:21 +0000
Subject: [Rd] Wrongly converging glm()
In-Reply-To: <CAHz+bWZOx3oAuhMU129AAJmarpTrfau=jJVSGGweGuw8QgeDOg@mail.gmail.com>
References: <9153c6$7hh050@ironport10.mayo.edu>
 <d30e71f8413846deb05ed98551af6974@ESGEBEX10.win.ad.jhu.edu>
 <CAHz+bWZOx3oAuhMU129AAJmarpTrfau=jJVSGGweGuw8QgeDOg@mail.gmail.com>
Message-ID: <c0fdfc61a5874424b0cda411d015e83e@ESGEBEX10.win.ad.jhu.edu>

?So, what I learned the hard way was  termination due to reasonable stopping  criteria DOES NOT NECESSARILY EQUAL OPTIMAL.?

Yes, I agree, Mark.

Let me add another observation.  In the ?optimx? package, John Nash and I implemented a check for optimality conditions ? first and second order KKT conditions.  This involves checking whether the gradient is sufficiently small and the Hessian is positive definite (for local minimum) at the final parameter values.  However, it can be quite time consuming to compute these quantities and in some problems checking KKT can take up more effort than finding the solution!  Furthermore, it is difficult to come up with good thresholds for determining ?small? gradient and ?positive definite? Hessian, since these can depend upon the scale of the objective function and the parameters.

Ravi

From: Mark Leeds [mailto:markleeds2 at gmail.com]
Sent: Friday, July 21, 2017 3:09 PM
To: Ravi Varadhan <ravi.varadhan at jhu.edu>
Cc: Therneau, Terry M., Ph.D. <therneau at mayo.edu>; r-devel at r-project.org; jorismeys at gmail.com; westra.harmjan at outlook.com
Subject: Re: [Rd] Wrongly converging glm()

Hi Ravi: Well said. In John's Rvmmin package, he has codes for explaining the cause
of the termination. The codes returned were fine. The problem was that
the model I was using could have multiple solutions ( regardless of the data
sent in ) so, even though the stopping criteria was reached, it turned out that one of the parameters ( there were two parameters ) could have really been anything and the same likelihood value would  be returned. So, what I learned the hard way was  termination due to reasonable stopping  criteria DOES NOT NECESSARILY EQUAL OPTIMAL. But I lived in the dark about this for a long time and only happened to notice it when playing around with the likelihood by fixing the offending parameter to various values and optimizing over the
non-offending parameter. Thanks for eloquent explanation.
                                                                                  Mark





















On Fri, Jul 21, 2017 at 9:22 AM, Ravi Varadhan <ravi.varadhan at jhu.edu<mailto:ravi.varadhan at jhu.edu>> wrote:
Please allow me to add my 3 cents.  Stopping an iterative optimization algorithm at an "appropriate" juncture is very tricky.  All one can say is that the algorithm terminated because it triggered a particular stopping criterion.  A good software will tell you why it stopped - i.e. the stopping criterion that was triggered.  It is extremely difficult to make a failsafe guarantee that the triggered stopping criterion is the correct one and that the answer obtained is trustworthy. It is up to the user to determine whether the answer makes sense.  In the case of maximizing a likelihood function, it is perfectly reasonable to stop when the algorithm has not made any progress in increasing the log likelihood.  In this case, the software should print out something like "algorithm terminated due to lack of improvement in log-likelihood."  Therefore, I don't see a need to issue any warning, but simply report the stopping criterion that was applied to terminate the algorithm.

Best,
Ravi

-----Original Message-----
From: R-devel [mailto:r-devel-bounces at r-project.org<mailto:r-devel-bounces at r-project.org>] On Behalf Of Therneau, Terry M., Ph.D.
Sent: Friday, July 21, 2017 8:04 AM
To: r-devel at r-project.org<mailto:r-devel at r-project.org>; Mark Leeds <markleeds2 at gmail.com<mailto:markleeds2 at gmail.com>>; jorismeys at gmail.com<mailto:jorismeys at gmail.com>; westra.harmjan at outlook.com<mailto:westra.harmjan at outlook.com>
Subject: Re: [Rd] Wrongly converging glm()
I'm chiming in late since I read the news in digest form, and I won't copy the entire conversation to date.

The issue raised comes up quite often in Cox models, so often that the Therneau and Grambsch book has a section on the issue (3.5, p 58).  After a few initial iterations the offending coefficient will increase by a constant at each iteration while the log-likelihood approaches an asymptote (essentially once the other coefficients "settle down").

The coxph routine tries to detect this case and print a warning, and this turns out to be very hard to do accurately.  I worked hard at tuning the threshold(s) for the message several years ago and finally gave up; I am guessing that the warning misses > 5% of the cases when the issue is true, and that 5% of the warnings that do print are incorrect.
(And these estimates may be too optimistic.)   Highly correlated predictors tend to trip
it up, e.g., the truncated power spline basis used by the rcs function in Hmisc.

All in all, I am not completely sure whether the message does more harm than good.  I'd be quite reluctant to go down the same path again with the glm function.

Terry Therneau
______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


	[[alternative HTML version deleted]]


From markleeds2 at gmail.com  Sat Jul 22 03:12:25 2017
From: markleeds2 at gmail.com (Mark Leeds)
Date: Fri, 21 Jul 2017 21:12:25 -0400
Subject: [Rd] Wrongly converging glm()
In-Reply-To: <c0fdfc61a5874424b0cda411d015e83e@ESGEBEX10.win.ad.jhu.edu>
References: <9153c6$7hh050@ironport10.mayo.edu>
 <d30e71f8413846deb05ed98551af6974@ESGEBEX10.win.ad.jhu.edu>
 <CAHz+bWZOx3oAuhMU129AAJmarpTrfau=jJVSGGweGuw8QgeDOg@mail.gmail.com>
 <c0fdfc61a5874424b0cda411d015e83e@ESGEBEX10.win.ad.jhu.edu>
Message-ID: <CAHz+bWY1G1rzGUW_VU0DwfF6QdnVXjZc5dz7PTEX8nGs2PGCsg@mail.gmail.com>

H Ravi: Yes, IIRC that's EXACTLY what was going on in my case. Based on
the codes from Rvmmin,  the objective functon wasn't changing much and I
think norm of the gradient was close to zero so it was difficult for me to
detect the issue. I found it when I
happenered to notice that the objective function seemed independent of one
of the parameters.






On Fri, Jul 21, 2017 at 4:36 PM, Ravi Varadhan <ravi.varadhan at jhu.edu>
wrote:

> ?So, what I learned the hard way was  termination due to reasonable
> stopping  criteria DOES NOT NECESSARILY EQUAL OPTIMAL.?
>
>
>
> Yes, I agree, Mark.
>
>
>
> Let me add another observation.  In the ?optimx? package, John Nash and I
> implemented a check for optimality conditions ? first and second order KKT
> conditions.  This involves checking whether the gradient is sufficiently
> small and the Hessian is positive definite (for local minimum) at the final
> parameter values.  However, it can be quite time consuming to compute these
> quantities and in some problems checking KKT can take up more effort than
> finding the solution!  Furthermore, it is difficult to come up with good
> thresholds for determining ?small? gradient and ?positive definite?
> Hessian, since these can depend upon the scale of the objective function
> and the parameters.
>
>
>
> Ravi
>
>
>
> *From:* Mark Leeds [mailto:markleeds2 at gmail.com]
> *Sent:* Friday, July 21, 2017 3:09 PM
> *To:* Ravi Varadhan <ravi.varadhan at jhu.edu>
> *Cc:* Therneau, Terry M., Ph.D. <therneau at mayo.edu>; r-devel at r-project.org;
> jorismeys at gmail.com; westra.harmjan at outlook.com
>
> *Subject:* Re: [Rd] Wrongly converging glm()
>
>
>
> Hi Ravi: Well said. In John's Rvmmin package, he has codes for explaining
> the cause
>
> of the termination. The codes returned were fine. The problem was that
>
> the model I was using could have multiple solutions ( regardless of the
> data
> sent in ) so, even though the stopping criteria was reached, it turned out
> that one of the parameters ( there were two parameters ) could have really
> been anything and the same likelihood value would  be returned. So, what I
> learned the hard way was  termination due to reasonable stopping  criteria
> DOES NOT NECESSARILY EQUAL OPTIMAL. But I lived in the dark about this for
> a long time and only happened to notice it when playing around with the
> likelihood by fixing the offending parameter to various values and
> optimizing over the
> non-offending parameter. Thanks for eloquent explanation.
>
>
>         Mark
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
> On Fri, Jul 21, 2017 at 9:22 AM, Ravi Varadhan <ravi.varadhan at jhu.edu>
> wrote:
>
> Please allow me to add my 3 cents.  Stopping an iterative optimization
> algorithm at an "appropriate" juncture is very tricky.  All one can say is
> that the algorithm terminated because it triggered a particular stopping
> criterion.  A good software will tell you why it stopped - i.e. the
> stopping criterion that was triggered.  It is extremely difficult to make a
> failsafe guarantee that the triggered stopping criterion is the correct one
> and that the answer obtained is trustworthy. It is up to the user to
> determine whether the answer makes sense.  In the case of maximizing a
> likelihood function, it is perfectly reasonable to stop when the algorithm
> has not made any progress in increasing the log likelihood.  In this case,
> the software should print out something like "algorithm terminated due to
> lack of improvement in log-likelihood."  Therefore, I don't see a need to
> issue any warning, but simply report the stopping criterion that was
> applied to terminate the algorithm.
>
> Best,
> Ravi
>
> -----Original Message-----
> From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of
> Therneau, Terry M., Ph.D.
> Sent: Friday, July 21, 2017 8:04 AM
> To: r-devel at r-project.org; Mark Leeds <markleeds2 at gmail.com>;
> jorismeys at gmail.com; westra.harmjan at outlook.com
> Subject: Re: [Rd] Wrongly converging glm()
>
> I'm chiming in late since I read the news in digest form, and I won't copy
> the entire conversation to date.
>
> The issue raised comes up quite often in Cox models, so often that the
> Therneau and Grambsch book has a section on the issue (3.5, p 58).  After a
> few initial iterations the offending coefficient will increase by a
> constant at each iteration while the log-likelihood approaches an asymptote
> (essentially once the other coefficients "settle down").
>
> The coxph routine tries to detect this case and print a warning, and this
> turns out to be very hard to do accurately.  I worked hard at tuning the
> threshold(s) for the message several years ago and finally gave up; I am
> guessing that the warning misses > 5% of the cases when the issue is true,
> and that 5% of the warnings that do print are incorrect.
> (And these estimates may be too optimistic.)   Highly correlated
> predictors tend to trip
> it up, e.g., the truncated power spline basis used by the rcs function in
> Hmisc.
>
> All in all, I am not completely sure whether the message does more harm
> than good.  I'd be quite reluctant to go down the same path again with the
> glm function.
>
> Terry Therneau
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
>
>

	[[alternative HTML version deleted]]


From bmarwick at uw.edu  Sat Jul 22 14:19:08 2017
From: bmarwick at uw.edu (Ben Marwick)
Date: Sat, 22 Jul 2017 14:19:08 +0200
Subject: [Rd] missing `=` in man page for files2
Message-ID: <b90d2530-da3d-fb33-70b9-10da900336af@uw.edu>

Hi everyone,

In the example code at the bottom of this page, 
https://stat.ethz.ch/R-manual/R-devel/library/base/html/files2.html, 
there is a missing `=`. That page has:

f <- list.files(".", all.files = TRUE, full.names = TRUE, recursive  TRUE)

but it should be:

f <- list.files(".", all.files = TRUE, full.names = TRUE, recursive = TRUE)

It's also missing from built-in help pages, for example ?Sys.chmod

best,

Ben


From murdoch.duncan at gmail.com  Sat Jul 22 16:08:58 2017
From: murdoch.duncan at gmail.com (Duncan Murdoch)
Date: Sat, 22 Jul 2017 10:08:58 -0400
Subject: [Rd] missing `=` in man page for files2
In-Reply-To: <b90d2530-da3d-fb33-70b9-10da900336af@uw.edu>
References: <b90d2530-da3d-fb33-70b9-10da900336af@uw.edu>
Message-ID: <513dda98-7c15-7aed-b78f-adf79fbee6e9@gmail.com>

On 22/07/2017 8:19 AM, Ben Marwick wrote:
> Hi everyone,
>
> In the example code at the bottom of this page,
> https://stat.ethz.ch/R-manual/R-devel/library/base/html/files2.html,
> there is a missing `=`. That page has:
>
> f <- list.files(".", all.files = TRUE, full.names = TRUE, recursive  TRUE)

Thanks, I'll fix that.
>
> but it should be:
>
> f <- list.files(".", all.files = TRUE, full.names = TRUE, recursive = TRUE)
>
> It's also missing from built-in help pages, for example ?Sys.chmod

That's the same page.  Each help page can have multiple "aliases" and 
"concepts", which are search terms leading to it.  For files2.Rd, they are:

\alias{dir.create}
\alias{dir.exists}
\alias{Sys.chmod}
\alias{Sys.umask}
\concept{directory}
\concept{mkdir}
\alias{umask} % for links

(Aliases work with ?, concepts only work with ??.)

Duncan Murdoch


>
> best,
>
> Ben
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From bmarwick at uw.edu  Sat Jul 22 16:13:35 2017
From: bmarwick at uw.edu (Ben Marwick)
Date: Sat, 22 Jul 2017 16:13:35 +0200
Subject: [Rd] missing `=` in man page for files2
In-Reply-To: <513dda98-7c15-7aed-b78f-adf79fbee6e9@gmail.com>
References: <b90d2530-da3d-fb33-70b9-10da900336af@uw.edu>
 <513dda98-7c15-7aed-b78f-adf79fbee6e9@gmail.com>
Message-ID: <7cf4c07b-5c1d-273b-c46f-493450ff6ab2@uw.edu>

Thanks!

On 22/07/2017 4:08 PM, Duncan Murdoch wrote:
> On 22/07/2017 8:19 AM, Ben Marwick wrote:
>> Hi everyone,
>>
>> In the example code at the bottom of this page,
>> https://stat.ethz.ch/R-manual/R-devel/library/base/html/files2.html,
>> there is a missing `=`. That page has:
>>
>> f <- list.files(".", all.files = TRUE, full.names = TRUE, recursive
>> TRUE)
>
> Thanks, I'll fix that.
>>
>> but it should be:
>>
>> f <- list.files(".", all.files = TRUE, full.names = TRUE, recursive =
>> TRUE)
>>
>> It's also missing from built-in help pages, for example ?Sys.chmod
>
> That's the same page.  Each help page can have multiple "aliases" and
> "concepts", which are search terms leading to it.  For files2.Rd, they are:
>
> \alias{dir.create}
> \alias{dir.exists}
> \alias{Sys.chmod}
> \alias{Sys.umask}
> \concept{directory}
> \concept{mkdir}
> \alias{umask} % for links
>
> (Aliases work with ?, concepts only work with ??.)
>
> Duncan Murdoch
>
>
>>
>> best,
>>
>> Ben
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>


From maechler at stat.math.ethz.ch  Sat Jul 22 18:20:11 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Sat, 22 Jul 2017 18:20:11 +0200
Subject: [Rd] [PATCH] Fix missing break
In-Reply-To: <2491471.UUKbAB2nFm@x2>
References: <60035856.27PnXlZqtm@x2> <4241711.WyxJnDo7EK@x2>
 <22897.47489.517803.232885@stat.math.ethz.ch>
 <2491471.UUKbAB2nFm@x2>
Message-ID: <22899.31547.640743.278243@stat.math.ethz.ch>

>>>>> Steve Grubb <sgrubb at redhat.com>
>>>>>     on Fri, 21 Jul 2017 13:53:12 -0400 writes:

    > Hello Martin,
    > On Friday, July 21, 2017 4:21:21 AM EDT Martin Maechler wrote:
    >> I have now created an account for you.

    > Thanks. Is that the preferred method of transferring these patches?

in such a case, yes .. but don't ask for a full definition of "such
a case" ;-)
If the issue may be somewhat controversial and rather in the
spirit of "I don't like what R is doing here, and I think we
       	   should change ..."
we'd prefer it be posted here, first, in any case;  but you had
no such examples.	   

    >> >> In examples like the one below, if you have R code that shows symptoms,
    >> >> it would really help in the bug report.
    >> > 
    >> > I am hoping that we can look at the code as seasoned programmers and say
    >> > yeah, that is a bug.
    >> 
    >> I agree in this case.
    >> OTOH, it is exactly one of the case where the bug is not
    >> triggerable currently:
    >> 
    >> al <- formals(ls); length(al) <- 3
    >> 
    >> would trigger the bug... but you get an error message ".. vector .."
    >> and as I now found that is from a slightly misguided check:
    >> isVectorizable()  is not approriate here and should really be
    >> replaced by isList().
    >> 
    >> So .. indeed, your report will have triggered an improvement in
    >> the code, which I'm about to commit.

    > That's what it's all about.  :-)
 
    >> Thank you very much Steve!
    >> 
    >> > I run the code through Coverity and have quite a lot of
    >> > problems to tell you about.
    >> 
    >> I'm not the expert on static code analysis, but as a seasoned
    >> statistician (*and* from experience with other such analyses) I
    >> know that you always get false positives.

    > Absolutely. I weeded the report down to 15 issues to start with. There are 
    > also ways to annotate the code so that checkers dismiss something it would 
    > otherwise be inclined to report.

    >> >> Otherwise, someone else will have to analyze the code to decide whether
    >> >> it's a bug or missing comment.  That takes time, and if there are no
    >> >> known symptoms, it's likely to be assigned a low priority.  The sad
    >> >> truth is that very few members of R Core are currently actively fixing
    >> >> bugs.
    >> > 
    >> > That's a shame. I'd be happy to give the scan to people in core so they
    >> > can see what the lay of the land looks like.
    >> 
    >> (hmm... the above does look a teeny tiny bit arrogant in my
    >> eyes; but then I'm not a native English (nor "American" 
    >> speaker ...)

    > I apologize if that is the way it came across. "That's a shame" can also mean 
    > "That's unfortunate" because I was thinking that I spent some time fixing up 
    > patches that might not be wanted. However, I see that you have looked at the 
    > patches and I thank you for that.  :-)

    > The second sentence above is an honest offer. I'd be happy to send the output 
    > of the report off list (in case anything sensitive is listed). In this and the 
    > other patches I haven't sent, I'm just picking the low hanging fruit.

    > -Steve

Ok, thank you for the offer!   In general, we would prefer public
communication of such issues because it can help to spread the
volunteer work load a bit wider than only to R Core.   OTOH,
yes, there are important exceptions to this rule, as we know.

Martin


From pdalgd at gmail.com  Sun Jul 23 23:04:25 2017
From: pdalgd at gmail.com (Peter Dalgaard)
Date: Sun, 23 Jul 2017 23:04:25 +0200
Subject: [Rd] italic font on cairo devices in R 3.4
In-Reply-To: <4f527daa-9959-4d42-b92b-9457e1c402db@gmx.net>
References: <2093e0fa-f923-0822-60d2-7509d38224af@gmx.net>
 <61d483b0-b6a5-7811-9a80-34dcaed55c81@stat.auckland.ac.nz>
 <4f527daa-9959-4d42-b92b-9457e1c402db@gmx.net>
Message-ID: <93D3E8FC-0432-4699-ADBF-53940FCE1DB7@gmail.com>


> On 12 Jul 2017, at 18:41 , Ilia Kats <ilia-kats at gmx.net> wrote:
> 
> FYI, I now have a second confirmed Mac OS system (with R 3.4.1) where the text is not rendered as italic.

Me three,

It affects cairo_pdf() only, plain pdf() renders the example just fine.

-pd

> 
> Ilia
> 
> 
> 
> -------- Original Message --------
> Subject: Re: [Rd] italic font on cairo devices in R 3.4
> Date: 2017-07-12 05:48:24 +0200
> From: Paul Murrell
> To: ilia-kats, r-devel
>> Hi
>> 
>> Do you have the 'fonts-texgyre' (Debian) package installed?
>> If not, does installing that help?
>> 
>> Paul
>> 
>> On 07/07/17 20:30, Ilia Kats wrote:
>>> [cross-post from R-help]
>>> 
>>> Hi all,
>>> 
>>> I have the following problem: Since R 3.4.0, italic fonts rendered on Cairo devices appear pixelated. Here's a minimal example:
>>> cairo_pdf('test.pdf')
>>> plot(1:10, ylab=expression(italic(test)))
>>> dev.off()
>>> 
>>> The same problem occurs with bolditalic, but not bold. I am using Debian Stretch. Several friends tried the same on their machines, another Debian machine has the same problem. On MacOSX the output was not pixelated, but it wasn't italic either. Ubuntu 16.04.2 xenial works fine. My impression is that R somehow can't find the proper font to use and falls back to something weird. Ideas?
>>> 
>>> Note that I'm not subscribed to the list, so please CC me in replies.
>>> 
>>> Cheers, Ilia
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>> 
> 
> -- 
> Linux - Where do you want to fly today?
> -- Unknown source
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From rmcgehee at walleyetrading.net  Mon Jul 24 22:51:56 2017
From: rmcgehee at walleyetrading.net (Robert McGehee)
Date: Mon, 24 Jul 2017 20:51:56 +0000
Subject: [Rd] 'gsub' not perl compatible?
In-Reply-To: <FEF25E56AFC7064784FA97C576467E0AC7ACD337@pdexchbalwst01.ad.insee.intra>
References: <FEF25E56AFC7064784FA97C576467E0AC7ACD337@pdexchbalwst01.ad.insee.intra>
Message-ID: <30D28A63376088428E8318DD67FD407F7C1E2D@ny-mailstore1.walleyetrading.net>

Hi Jean-Luc,
FWIW, you're pointing out a common discrepancy between regex parsers, which is whether or not a regex parser advances after finding both a zero-length match and a non-zero-length match.

I think this article is especially helpful for understanding the nuances here, particularly the section "Advancing After a Zero-Length Regex Match". 
http://www.regular-expressions.info/zerolength.html

For this article, their test example was gsub("\\d*", "x", "x1"), which demonstrates the same difference as in your example (i.e. the answer can be either "xxx" or "xxxx" depending on the parser). They also specifically provide a note on R's gsub function that notes this discrepancy:

"The regexp functions in R and PHP are based on PCRE, so they avoid getting stuck on a zero-length match by backtracking like PCRE does. But the gsub() function to search-and-replace in R also skips zero-length matches at the position where the previous non-zero-length match ended, like Python does."
	
All that said, your larger point still seems valid, that we should expect to see behavior consistent with the PCRE parser when we specify perl=TRUE, even if that is a different answer than we get from R's default TRE parser when perl=FALSE. And to take perl out of the equation, I also verified your test directly with PCRE (8.39) on my Linux box using the `pcretest` command, and sure enough, pcretest shows four matches to your example, consistent with an answer of !a!!c! like you said. Perhaps at a minimum, the ?gsub or ?regex man page should add a blurb indicating that the perl=TRUE behavior differs from PCRE in the case of non-zero length matches adjacent to zero-length matches. Though I'm not sure if this difference is known and intentional or just a side effect of some other decision. R also supports adding perl options embedded in the pattern. For example '(?i)' makes the pattern case insensitive and '(?U)' turns of greedy matching. I could imagine having the behavior you noted depend on such an option as well, if someone was inclined to make a patch and didn't want to change existing behavior.

However, to rewrite your query to get the result you want, it seems you may unfortunately have to rewrite the query using two calls to gsub using something like this: 

> gsub("b?", "!", gsub("b", "bb", "abc"))
 [1] "!a!!c!"

--Robert


-----Original Message-----
From: R-devel [mailto:r-devel-bounces at r-project.org] On Behalf Of Lipatz Jean-Luc
Sent: Friday, July 21, 2017 5:27 AM
To: r-devel at r-project.org
Subject: [Rd] 'gsub' not perl compatible?

Hi all,

Working on some SAS program conversions, I was testing this (3.4.0 Windows, but also 2.10.1 MacOsX):
gsub("b?","!","abc",perl=T)

which returns
[1] "!a!c!"

that I didn't understand.

Unfortunately, asked for the same thing SAS 9.4 replies : "!a!!c!", and so does Perl (Strawberry 5.26), a more logical answer for me.
Is there some problem with PCRE or some subtility that I didn't catch?

Results are similar with * instead of ?
and there is a similar issue with the lazy operator:
gsub("b??","!","abc",perl=T) gives : "!a!b!c!", while the other softwares give "!a!!!c!"


Thanks

Jean-Luc LIPATZ




	[[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From andrzej.oles at gmail.com  Wed Jul 26 13:02:22 2017
From: andrzej.oles at gmail.com (=?UTF-8?Q?Andrzej_Ole=C5=9B?=)
Date: Wed, 26 Jul 2017 13:02:22 +0200
Subject: [Rd] Problems with S4 methods dispatching on `...` (aka
	dotsMethods)
In-Reply-To: <CAH7mKkgTbdxpuiZz+V+zL-xCk6hQtSkj9UrmseDxzANqGEBkfQ@mail.gmail.com>
References: <CAH7mKkiZNJ_W8EsbEvobHmj1wHDcE2NmYVTuPq8Uxc+aGC6YOw@mail.gmail.com>
 <CAOQ5Nye8nD0FK5vuuz83i+5nEOomezMZx0iDjJ6ZKWK9M4Xk_w@mail.gmail.com>
 <CAH7mKkgwa_7FRChyrxmKf8Ub_mDtX-WfREq-A4FbCvanQt8zpg@mail.gmail.com>
 <CAH7mKkgSFg8ki8sS4NXwrnv0m6hL4f_gePAK0SQnnhtGrvu88A@mail.gmail.com>
 <CAOQ5Nyf0C3AQ3HJhyqY-ZW8fPxFVU6eJ6vvyysS5a9DPR408iQ@mail.gmail.com>
 <CAH7mKkgTbdxpuiZz+V+zL-xCk6hQtSkj9UrmseDxzANqGEBkfQ@mail.gmail.com>
Message-ID: <CAH7mKkg-aD4JF-H_6WKdifqpALHcdTLPCuAss+AvVB9138mZeQ@mail.gmail.com>

Hi Michael,

it seems that your patch to S4 generics dispatching on `...` is still
available only in R-devel, and was not included in the minor R-3.4.1
release. I was wondering what is the policy of incorporating bug fixes from
the devel branch into release, and whether there is any chance that the
broken `...` dispatch is fixed before R-3.5.0?

Cheers,
Andrzej


On Tue, Apr 25, 2017 at 4:15 PM, Andrzej Ole? <andrzej.oles at gmail.com>
wrote:

> You're right, I must have mixed up my R versions when running the example,
> as the problem seems to be resolved in R-devel.
>
> Sorry for the noise and thanks again for fixing this.
>
> Andrzej
>
> On Tue, Apr 25, 2017 at 3:55 PM, Michael Lawrence <
> lawrence.michael at gene.com> wrote:
>
>> I attempted to fix it, and that example seems to work for me. It's
>> also a (passing) regression test in R. Are you sure you're using a new
>> enough R-devel?
>>
>>
>> On Tue, Apr 25, 2017 at 2:34 AM, Andrzej Ole? <andrzej.oles at gmail.com>
>> wrote:
>> > Hi Michael,
>> >
>> > thanks again for your patch! I've tested it and I'm happy to confirm
>> that
>> > `callNextMethod()` works with methods dispatching on `...`.
>> >
>> > However, the second issue I reported still seems to be unresolved.
>> Consider
>> > the following toy example, where the `f()` calls differ in result
>> depending
>> > on whether the dispatch happens on a formal argument or the `...`
>> argument.
>> >
>> >
>> >     f = function(x, ..., a = b) {
>> >       b = "missing 'a'"
>> >       print(a)
>> >     }
>> >
>> >     f()
>> >     ## [1] missing 'a'
>> >
>> >     f(a = 1)
>> >     ## [1] 1
>> >
>> >     setGeneric("f", signature = "x")
>> >
>> >     # works as the non-generic version
>> >     f()
>> >     ## [1] missing 'a'
>> >
>> >     setGeneric("f", signature = "...")
>> >
>> >     # unexpectedly fails to find 'b'
>> >     f()
>> >     ## Error in print(a) : object 'b' not found
>> >
>> >
>> > Any chances of fixing this?
>> >
>> > Cheers,
>> > Andrzej
>> >
>> >
>> >
>> > On Fri, Apr 21, 2017 at 11:40 AM, Andrzej Ole? <andrzej.oles at gmail.com>
>> > wrote:
>> >>
>> >> Great, thanks Michael for you quick response!
>> >>
>> >> I started off with a question on SO because I was not sure whether this
>> >> was an actual bug or I was just missing something obvious. I'm looking
>> >> forward to the patch.
>> >>
>> >> Cheers,
>> >> Andrzej
>> >>
>> >>
>> >> On Thu, Apr 20, 2017 at 10:28 PM, Michael Lawrence
>> >> <lawrence.michael at gene.com> wrote:
>> >>>
>> >>> Thanks for pointing out these issues. I have a fix that I will commit
>> >>> soon.
>> >>>
>> >>> Btw, I would never have seen the post on Stack Overflow. It's best to
>> >>> report bugs on the bugzilla.
>> >>>
>> >>> Michael
>> >>>
>> >>> On Thu, Apr 20, 2017 at 8:30 AM, Andrzej Ole? <andrzej.oles at gmail.com
>> >
>> >>> wrote:
>> >>> > Hi all,
>> >>> >
>> >>> > I recently encountered some unexpected behavior with S4 generics
>> >>> > dispatching on `...`, which I described in
>> >>> >
>> >>> > http://stackoverflow.com/questions/43499203/use-callnextmeth
>> od-with-dotsmethods
>> >>> >
>> >>> > TL;DR: `callNextMethod()` doesn't work in methods dispatching on
>> `...`,
>> >>> > and
>> >>> > arguments of such methods are resolved differently than the
>> arguments
>> >>> > of
>> >>> > methods dispatching on formal arguments.
>> >>> >
>> >>> > Could this indicate a potential problem with the implementation of
>> the
>> >>> > `...` dispatch?
>> >>> >
>> >>> > Cheers,
>> >>> > Andrzej
>> >>> >
>> >>> >         [[alternative HTML version deleted]]
>> >>> >
>> >>> > ______________________________________________
>> >>> > R-devel at r-project.org mailing list
>> >>> > https://stat.ethz.ch/mailman/listinfo/r-devel
>> >>
>> >>
>> >
>>
>
>

	[[alternative HTML version deleted]]


From jdblischak at gmail.com  Wed Jul 26 23:22:22 2017
From: jdblischak at gmail.com (John Blischak)
Date: Wed, 26 Jul 2017 16:22:22 -0500
Subject: [Rd] dir.create typo in manual An Introduction to R
Message-ID: <CACmKiDxKXsiSTr2ZdZ7mHii0nmjRvUbfUMr25VNPc2iYWeHBDw@mail.gmail.com>

In the section FIles and Directories in the manual An Introduction to
R it refers to the function create.dir:

https://cran.r-project.org/doc/manuals/r-devel/R-intro.html#Files-and-directories

I've attached a patch against revision 72974 to change this to dir.create.

John
-------------- next part --------------
Index: doc/manual/R-intro.texi
===================================================================
--- doc/manual/R-intro.texi	(revision 72974)
+++ doc/manual/R-intro.texi	(working copy)
@@ -6567,7 +6567,7 @@
 pointers to some of the more commonly used ones.
 
 To create an (empty) file or directory, use @code{file.create} or
- at code{create.dir}.  (These are the analogues of the POSIX utilities
+ at code{dir.create}.  (These are the analogues of the POSIX utilities
 @command{touch} and @command{mkdir}.)  For temporary files and
 directories in the @R{} session directory see @code{tempfile}.
 

From maechler at stat.math.ethz.ch  Thu Jul 27 09:26:14 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Thu, 27 Jul 2017 09:26:14 +0200
Subject: [Rd] dir.create typo in manual An Introduction to R
In-Reply-To: <CACmKiDxKXsiSTr2ZdZ7mHii0nmjRvUbfUMr25VNPc2iYWeHBDw@mail.gmail.com>
References: <CACmKiDxKXsiSTr2ZdZ7mHii0nmjRvUbfUMr25VNPc2iYWeHBDw@mail.gmail.com>
Message-ID: <22905.38294.773338.647594@stat.math.ethz.ch>

>>>>> John Blischak <jdblischak at gmail.com>
>>>>>     on Wed, 26 Jul 2017 16:22:22 -0500 writes:

    > In the section FIles and Directories in the manual An Introduction to
    > R it refers to the function create.dir:

    > https://cran.r-project.org/doc/manuals/r-devel/R-intro.html#Files-and-directories

    > I've attached a patch against revision 72974 to change this to dir.create.

Thank you, John! -- fixed in the sources now.
Martin


From msuzen at gmail.com  Thu Jul 27 23:25:57 2017
From: msuzen at gmail.com (Suzen, Mehmet)
Date: Thu, 27 Jul 2017 23:25:57 +0200
Subject: [Rd] matrices with names
In-Reply-To: <CAF8bMcZbHHzAmyXfzGfyMFysBu5S=0eiXJ3RxycE7qhYw8Yb9Q@mail.gmail.com>
References: <CAF8bMcZbHHzAmyXfzGfyMFysBu5S=0eiXJ3RxycE7qhYw8Yb9Q@mail.gmail.com>
Message-ID: <CAPtbhHxAVTtZw+Kxk4C-ecRVf1T5ti5ua1Lnk+ZBejBpC=xCeg@mail.gmail.com>

Not always, see what happens with lapply:
> x<-matrix(12,1,1)
> names(x)<-"one"
> y<-matrix(1,1,1)
> names(y)<-"one"
> dput(lapply(x,`+`,e2=y))
structure(list(one = structure(13, .Dim = c(1L, 1L))), .Names = "one")
>dput(lapply(x,`+`,e2=1))
structure(list(one = 13), .Names = "one")


Prof. Ripley has pointed out this some time ago:
https://stat.ethz.ch/pipermail/r-devel/2011-October/062297.html

Note that ?`+` tells:

     The rules for determining the attributes of the result are rather
     complicated.  Most attributes are taken from the longer argument.
     Names will be copied from the first if it is the same length as
     the answer, otherwise from the second if that is.  If the
     arguments are the same length, attributes will be copied from
     both, with those of the first argument taking precedence when the
     same attribute is present in both arguments. For time series,
     these operations are allowed only if the series are compatible,
     when the class and ?tsp? attribute of whichever is a time series
     (the same, if both are) are used.  For arrays (and an array
     result) the dimensions and dimnames are taken from first argument
     if it is an array, otherwise the second.


From selivanov.dmitriy at gmail.com  Fri Jul 28 12:11:48 2017
From: selivanov.dmitriy at gmail.com (Dmitriy Selivanov)
Date: Fri, 28 Jul 2017 13:11:48 +0300
Subject: [Rd] Issue with memory deallocation/fragmentation on systems
	which use glibc
In-Reply-To: <CAJdZCv2wTRetp1ponmxKLfXARQmoPZVLTcbPc6E2mz9nfEFCWA@mail.gmail.com>
References: <CAJdZCv1acw4A1VOHgT7DWO3hp5XqLmwt5kmFHq6Kq-bQ8DGhXg@mail.gmail.com>
 <CAJdZCv2wTRetp1ponmxKLfXARQmoPZVLTcbPc6E2mz9nfEFCWA@mail.gmail.com>
Message-ID: <CAJdZCv373MZr=T+-XAeYaLROh9rgKWbOJJaf=uxSEp62VKBzLg@mail.gmail.com>

I would like to submit issue to wishlist at the bug reporting system (
https://www.r-project.org/bugs.html) based on my emails. Unfortunately I
don't have bugzilla account. Can someone from R-core help to obtain it? (I
see that I should *"ask an R Core member to add you manually to R?s
Bugzilla members"*)

   - https://stat.ethz.ch/pipermail/r-devel/2017-June/074487.html
   - https://stat.ethz.ch/pipermail/r-devel/2017-June/074500.html
   - https://stat.ethz.ch/pipermail/r-devel/2017-July/074614.html


2017-07-09 13:12 GMT+03:00 Dmitriy Selivanov <selivanov.dmitriy at gmail.com>:

> Dear R-devel mailing list and especially R-core, is there any chance to
> receive feedback on issue I described in previous emails? I would consider
> such behaviour as a bug.
>
> As a work-around I've created small "clean-up" function:
>
> malloc_trim_finalizer = function(e) {
>   res = NULL
>   if(R.version$os == "linux-gnu") {
>     flog.debug("Calling malloc_trim(0L) to trigger glibc to release
> memory\n")
>     res = malloc_trim(0L)
>   }
>   res
> }
>
> And at the end of each function which produce a lot of intermediate small
> objects I provide it to reg.finalizer():
> some_function = function(...) {
>   # do some useful work
>   result = TRUE
>   # register finalizer
>   e = environment()
>   reg.finalizer(e, malloc_trim_finalizer)
>   return(result)
> }
>
> 2017-06-22 11:12 GMT+04:00 Dmitriy Selivanov <selivanov.dmitriy at gmail.com>
> :
>
>> A few additional details. According to Linux Programmer's Manual
>>
>>    1. http://man7.org/linux/man-pages/man3/mallopt.3.html
>>    2. http://man7.org/linux/man-pages/man3/malloc_trim.3.html
>>
>> And if I understood everything correctly `free` could trigger
>> `malloc_trim` based on value of several environment variables -
>> MALLOC_TOP_PAD_ and MALLOC_TRIM_THRESHOLD_. However setting them as low as
>> 1 or 0 doesn't have any effect (but as I wrote in previous email manual
>> call of `malloc_trim` helps to release memory).
>>
>
>
>
> --
> Regards
> Dmitriy Selivanov
>



-- 
Regards
Dmitriy Selivanov

	[[alternative HTML version deleted]]


From lawrence.michael at gene.com  Fri Jul 28 21:15:27 2017
From: lawrence.michael at gene.com (Michael Lawrence)
Date: Fri, 28 Jul 2017 12:15:27 -0700
Subject: [Rd] Problems with S4 methods dispatching on `...` (aka
	dotsMethods)
In-Reply-To: <CAH7mKkg-aD4JF-H_6WKdifqpALHcdTLPCuAss+AvVB9138mZeQ@mail.gmail.com>
References: <CAH7mKkiZNJ_W8EsbEvobHmj1wHDcE2NmYVTuPq8Uxc+aGC6YOw@mail.gmail.com>
 <CAOQ5Nye8nD0FK5vuuz83i+5nEOomezMZx0iDjJ6ZKWK9M4Xk_w@mail.gmail.com>
 <CAH7mKkgwa_7FRChyrxmKf8Ub_mDtX-WfREq-A4FbCvanQt8zpg@mail.gmail.com>
 <CAH7mKkgSFg8ki8sS4NXwrnv0m6hL4f_gePAK0SQnnhtGrvu88A@mail.gmail.com>
 <CAOQ5Nyf0C3AQ3HJhyqY-ZW8fPxFVU6eJ6vvyysS5a9DPR408iQ@mail.gmail.com>
 <CAH7mKkgTbdxpuiZz+V+zL-xCk6hQtSkj9UrmseDxzANqGEBkfQ@mail.gmail.com>
 <CAH7mKkg-aD4JF-H_6WKdifqpALHcdTLPCuAss+AvVB9138mZeQ@mail.gmail.com>
Message-ID: <CAOQ5NyeUcKDvm-7TOL+aYUg4X+EPLzdxfs0e7hmnAcYAvFFDdA@mail.gmail.com>

I pushed the patch to the 3.4 branch. Feel free to test.

Michael

On Wed, Jul 26, 2017 at 4:02 AM, Andrzej Ole? <andrzej.oles at gmail.com> wrote:
> Hi Michael,
>
> it seems that your patch to S4 generics dispatching on `...` is still
> available only in R-devel, and was not included in the minor R-3.4.1
> release. I was wondering what is the policy of incorporating bug fixes from
> the devel branch into release, and whether there is any chance that the
> broken `...` dispatch is fixed before R-3.5.0?
>
> Cheers,
> Andrzej
>
>
> On Tue, Apr 25, 2017 at 4:15 PM, Andrzej Ole? <andrzej.oles at gmail.com>
> wrote:
>>
>> You're right, I must have mixed up my R versions when running the example,
>> as the problem seems to be resolved in R-devel.
>>
>> Sorry for the noise and thanks again for fixing this.
>>
>> Andrzej
>>
>> On Tue, Apr 25, 2017 at 3:55 PM, Michael Lawrence
>> <lawrence.michael at gene.com> wrote:
>>>
>>> I attempted to fix it, and that example seems to work for me. It's
>>> also a (passing) regression test in R. Are you sure you're using a new
>>> enough R-devel?
>>>
>>>
>>> On Tue, Apr 25, 2017 at 2:34 AM, Andrzej Ole? <andrzej.oles at gmail.com>
>>> wrote:
>>> > Hi Michael,
>>> >
>>> > thanks again for your patch! I've tested it and I'm happy to confirm
>>> > that
>>> > `callNextMethod()` works with methods dispatching on `...`.
>>> >
>>> > However, the second issue I reported still seems to be unresolved.
>>> > Consider
>>> > the following toy example, where the `f()` calls differ in result
>>> > depending
>>> > on whether the dispatch happens on a formal argument or the `...`
>>> > argument.
>>> >
>>> >
>>> >     f = function(x, ..., a = b) {
>>> >       b = "missing 'a'"
>>> >       print(a)
>>> >     }
>>> >
>>> >     f()
>>> >     ## [1] missing 'a'
>>> >
>>> >     f(a = 1)
>>> >     ## [1] 1
>>> >
>>> >     setGeneric("f", signature = "x")
>>> >
>>> >     # works as the non-generic version
>>> >     f()
>>> >     ## [1] missing 'a'
>>> >
>>> >     setGeneric("f", signature = "...")
>>> >
>>> >     # unexpectedly fails to find 'b'
>>> >     f()
>>> >     ## Error in print(a) : object 'b' not found
>>> >
>>> >
>>> > Any chances of fixing this?
>>> >
>>> > Cheers,
>>> > Andrzej
>>> >
>>> >
>>> >
>>> > On Fri, Apr 21, 2017 at 11:40 AM, Andrzej Ole? <andrzej.oles at gmail.com>
>>> > wrote:
>>> >>
>>> >> Great, thanks Michael for you quick response!
>>> >>
>>> >> I started off with a question on SO because I was not sure whether
>>> >> this
>>> >> was an actual bug or I was just missing something obvious. I'm looking
>>> >> forward to the patch.
>>> >>
>>> >> Cheers,
>>> >> Andrzej
>>> >>
>>> >>
>>> >> On Thu, Apr 20, 2017 at 10:28 PM, Michael Lawrence
>>> >> <lawrence.michael at gene.com> wrote:
>>> >>>
>>> >>> Thanks for pointing out these issues. I have a fix that I will commit
>>> >>> soon.
>>> >>>
>>> >>> Btw, I would never have seen the post on Stack Overflow. It's best to
>>> >>> report bugs on the bugzilla.
>>> >>>
>>> >>> Michael
>>> >>>
>>> >>> On Thu, Apr 20, 2017 at 8:30 AM, Andrzej Ole?
>>> >>> <andrzej.oles at gmail.com>
>>> >>> wrote:
>>> >>> > Hi all,
>>> >>> >
>>> >>> > I recently encountered some unexpected behavior with S4 generics
>>> >>> > dispatching on `...`, which I described in
>>> >>> >
>>> >>> >
>>> >>> > http://stackoverflow.com/questions/43499203/use-callnextmethod-with-dotsmethods
>>> >>> >
>>> >>> > TL;DR: `callNextMethod()` doesn't work in methods dispatching on
>>> >>> > `...`,
>>> >>> > and
>>> >>> > arguments of such methods are resolved differently than the
>>> >>> > arguments
>>> >>> > of
>>> >>> > methods dispatching on formal arguments.
>>> >>> >
>>> >>> > Could this indicate a potential problem with the implementation of
>>> >>> > the
>>> >>> > `...` dispatch?
>>> >>> >
>>> >>> > Cheers,
>>> >>> > Andrzej
>>> >>> >
>>> >>> >         [[alternative HTML version deleted]]
>>> >>> >
>>> >>> > ______________________________________________
>>> >>> > R-devel at r-project.org mailing list
>>> >>> > https://stat.ethz.ch/mailman/listinfo/r-devel
>>> >>
>>> >>
>>> >
>>
>>
>


From _ at thomaslevine.com  Fri Jul 28 20:53:16 2017
From: _ at thomaslevine.com (Thomas Levine)
Date: Fri, 28 Jul 2017 18:53:16 +0000
Subject: [Rd] I have corrected a dead link in the treering documentation
Message-ID: <20170728185317.E246C7E65E@mailuser.nyi.internal>

The attached patch corrects a dead link in the treering documentation.

The URL in the manual [1] refers to a personal home page belonging to
Christine Hallman (user "hallman") on the website of the University of
Arizona Laboratory of Tree-Ring Research (LTRR). It seems that the LTRR
personal homepages have been moved to a new root directory [2] and that
Hallman's webpage is no longer there.

I have contacted Dr. Hallman. She confirmed that the LTRR hosting has
changed and that she has not set up her website on a new host. Also,
I have not managed to find any other photographs of the Methuselah Walk.
So the page on the Wayback Machine [3] is the best option I see for now.

Dr. Hallman also told me that she has more photographs of the tree, and
she has offered to publish them in order that we may reference more
photographs eventually.

I have used approximately the following procedure to build and confirm
that the result is formatted properly. (I'm think all of these lines are
necessary, but I am not sure that this is the right order.)

  ./configure --without-recommended-packages
  cd src/library
  make all docs Rdfiles
  cd -
  make
  bin/R -e 'help(treering)'

I found other dead links in the base documentation, but I thought most
should be kept for reference, as they were usually links to a
publisher's webpage for a particular journal article or book. The link
of present interest just provides context about the tree whose rings
were measured, so I think it is okay to change the link.

[1] http://www.ltrr.arizona.edu/~hallman/sitephotos/meth.html
[2] http://www.ltrr.arizona.edu/webhome/
[3] https://web.archive.org/web/20110523225828/http://www.ltrr.arizona.edu/~hallman/sitephotos/meth.html
-------------- next part --------------
Index: src/library/datasets/man/treering.Rd
===================================================================
--- src/library/datasets/man/treering.Rd	(revision 72947)
+++ src/library/datasets/man/treering.Rd	(working copy)
@@ -32,6 +32,6 @@
 }
 \references{
   For some photos of Methuselah Walk see
-  \url{http://www.ltrr.arizona.edu/~hallman/sitephotos/meth.html}
+  \url{https://web.archive.org/web/20110523225828/http://www.ltrr.arizona.edu/~hallman/sitephotos/meth.html}
 }
 \keyword{datasets}

From btyner at gmail.com  Sat Jul 29 00:04:30 2017
From: btyner at gmail.com (Benjamin Tyner)
Date: Fri, 28 Jul 2017 18:04:30 -0400
Subject: [Rd] force promises inside lapply
Message-ID: <a08cf018-5c19-fe67-9ee8-6d0e403b9cfa@gmail.com>

Hi,

I thought I understood the change to lapply semantics resulting from this,

    https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16093

However, would someone care to explain why this does not work?

    > L <- list(a=1, b=2, c=3)
    > str(lapply(L, function(x){ y <- substitute(x); force(x); eval(y) }))
    Error in eval(y) : object 'X' not found

Basically, my primary goal is to achieve the same result as,

    > str(lapply(L, function(x){ eval.parent(substitute(x)) }))
    List of 3
     $ a: num 1
     $ b: num 2
     $ c: num 3

but without having to resort to eval.parent as that seems to rely on an 
implementation detail of lapply.

My secondary goal is to understand why force(x) does not actually force 
the promise here,

    > str(lapply(L, function(x){ force(x); pryr::is_promise(x) }))
    List of 3
     $ a: logi TRUE
     $ b: logi TRUE
     $ c: logi TRUE
,
Regards
Ben


From wdunlap at tibco.com  Sat Jul 29 00:53:44 2017
From: wdunlap at tibco.com (William Dunlap)
Date: Fri, 28 Jul 2017 15:53:44 -0700
Subject: [Rd] force promises inside lapply
In-Reply-To: <a08cf018-5c19-fe67-9ee8-6d0e403b9cfa@gmail.com>
References: <a08cf018-5c19-fe67-9ee8-6d0e403b9cfa@gmail.com>
Message-ID: <CAF8bMcZOh4W-imEt8tnFpH0zzEEx5PjCVKJO-yhF5X+Tvj_j3w@mail.gmail.com>

1: substitute(), when given an argument to a function (which will be a
promise) gives you the unevaluated expression given as the argument:

>  L <- list(a=1, b=2, c=3)
> str(lapply(L, function(x) substitute(x)))
List of 3
 $ a: language X[[i]]
 $ b: language X[[i]]
 $ c: language X[[i]]

The 'X' and 'i' are in a frame constructed by lapply and you are not really
supposed to depend on the precise form of those expressions.

2: An evaluated promise is still a promise: it has the 'evaled' field set
to TRUE and the 'value' field set to the result of evaluating 'code' in
'env'.

> f <- function(x, force) {
     if (force) force(x)
     if (pryr::is_promise(x)) promise_info(x)
     else "not a promise"
 }
> str(f(log(-1), force=FALSE))
List of 4
 $ code  : language log(-1)
 $ env   :<environment: R_GlobalEnv>
 $ evaled: logi FALSE
 $ value : NULL
> str(f(log(-1), force=TRUE))
List of 4
 $ code  : language log(-1)
 $ env   : NULL
 $ evaled: logi TRUE
 $ value : num NaN
Warning message:
In log(-1) : NaNs produced

Can you give a concrete example of what you are try to accomplish?

Bill Dunlap
TIBCO Software
wdunlap tibco.com

On Fri, Jul 28, 2017 at 3:04 PM, Benjamin Tyner <btyner at gmail.com> wrote:

> Hi,
>
> I thought I understood the change to lapply semantics resulting from this,
>
>    https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16093
>
> However, would someone care to explain why this does not work?
>
>    > L <- list(a=1, b=2, c=3)
>    > str(lapply(L, function(x){ y <- substitute(x); force(x); eval(y) }))
>    Error in eval(y) : object 'X' not found
>
> Basically, my primary goal is to achieve the same result as,
>
>    > str(lapply(L, function(x){ eval.parent(substitute(x)) }))
>    List of 3
>     $ a: num 1
>     $ b: num 2
>     $ c: num 3
>
> but without having to resort to eval.parent as that seems to rely on an
> implementation detail of lapply.
>
> My secondary goal is to understand why force(x) does not actually force
> the promise here,
>
>    > str(lapply(L, function(x){ force(x); pryr::is_promise(x) }))
>    List of 3
>     $ a: logi TRUE
>     $ b: logi TRUE
>     $ c: logi TRUE
> ,
> Regards
> Ben
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From btyner at gmail.com  Sat Jul 29 05:20:14 2017
From: btyner at gmail.com (Benjamin Tyner)
Date: Fri, 28 Jul 2017 23:20:14 -0400
Subject: [Rd] force promises inside lapply
In-Reply-To: <CAF8bMcZOh4W-imEt8tnFpH0zzEEx5PjCVKJO-yhF5X+Tvj_j3w@mail.gmail.com>
References: <a08cf018-5c19-fe67-9ee8-6d0e403b9cfa@gmail.com>
 <CAF8bMcZOh4W-imEt8tnFpH0zzEEx5PjCVKJO-yhF5X+Tvj_j3w@mail.gmail.com>
Message-ID: <aa9ac3c1-e8ac-5978-dcd2-693276c3afdc@gmail.com>

Thanks Bill. I think my confusion may have been in part due to my 
conflating two distinct meanings of the term "evaluate"; the help for 
force says it "forces the evaluation of a function argument" whereas the 
help for eval says it "evaluates the ... argument ... and returns the 
computed value". I found it helpful to compare:

    > lapply(list(a=1,b=2,c=3), function(x){ force(substitute(x)) })
    $a
    X[[i]]

    $b
    X[[i]]

    $c
    X[[i]]

versus

    > lapply(list(a=1,b=2,c=3), function(x){ eval(substitute(x)) })
    Error in eval(substitute(x)) : object 'X' not found

Now for the context my question arose in: given a function

    loader <- function(package, quietly = TRUE) {

        wrapper <- if (quietly) suppressPackageStartupMessages else `{`

        expr <- substitute(wrapper(library(package = package)))

        eval(expr)
    }

prior to R version 3.2, one could do things like

     lapply(c("MASS", "boot"), loader)

but not anymore (which is fine; I agree that one should not depend on 
lapply's implementation details).

Regards,
Ben

On 07/28/2017 06:53 PM, William Dunlap wrote:
> 1: substitute(), when given an argument to a function (which will be a 
> promise) gives you the unevaluated expression given as the argument:
>
> >  L <- list(a=1, b=2, c=3)
> > str(lapply(L, function(x) substitute(x)))
> List of 3
>  $ a: language X[[i]]
>  $ b: language X[[i]]
>  $ c: language X[[i]]
>
> The 'X' and 'i' are in a frame constructed by lapply and you are not 
> really supposed to depend on the precise form of those expressions.
>
> 2: An evaluated promise is still a promise: it has the 'evaled' field 
> set to TRUE and the 'value' field set to the result of evaluating 
> 'code' in 'env'.
>
> > f <- function(x, force) {
>      if (force) force(x)
>      if (pryr::is_promise(x)) promise_info(x)
>      else "not a promise"
>  }
> > str(f(log(-1), force=FALSE))
> List of 4
>  $ code  : language log(-1)
>  $ env   :<environment: R_GlobalEnv>
>  $ evaled: logi FALSE
>  $ value : NULL
> > str(f(log(-1), force=TRUE))
> List of 4
>  $ code  : language log(-1)
>  $ env   : NULL
>  $ evaled: logi TRUE
>  $ value : num NaN
> Warning message:
> In log(-1) : NaNs produced
>
> Can you give a concrete example of what you are try to accomplish?
>
> Bill Dunlap
> TIBCO Software
> wdunlap tibco.com <http://tibco.com>
>
> On Fri, Jul 28, 2017 at 3:04 PM, Benjamin Tyner <btyner at gmail.com 
> <mailto:btyner at gmail.com>> wrote:
>
>     Hi,
>
>     I thought I understood the change to lapply semantics resulting
>     from this,
>
>     https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16093
>     <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16093>
>
>     However, would someone care to explain why this does not work?
>
>        > L <- list(a=1, b=2, c=3)
>        > str(lapply(L, function(x){ y <- substitute(x); force(x);
>     eval(y) }))
>        Error in eval(y) : object 'X' not found
>
>     Basically, my primary goal is to achieve the same result as,
>
>        > str(lapply(L, function(x){ eval.parent(substitute(x)) }))
>        List of 3
>         $ a: num 1
>         $ b: num 2
>         $ c: num 3
>
>     but without having to resort to eval.parent as that seems to rely
>     on an implementation detail of lapply.
>
>     My secondary goal is to understand why force(x) does not actually
>     force the promise here,
>
>        > str(lapply(L, function(x){ force(x); pryr::is_promise(x) }))
>        List of 3
>         $ a: logi TRUE
>         $ b: logi TRUE
>         $ c: logi TRUE
>     ,
>     Regards
>     Ben
>
>     ______________________________________________
>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>     https://stat.ethz.ch/mailman/listinfo/r-devel
>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>
>


From wdunlap at tibco.com  Sat Jul 29 15:39:47 2017
From: wdunlap at tibco.com (William Dunlap)
Date: Sat, 29 Jul 2017 06:39:47 -0700
Subject: [Rd] force promises inside lapply
In-Reply-To: <aa9ac3c1-e8ac-5978-dcd2-693276c3afdc@gmail.com>
References: <a08cf018-5c19-fe67-9ee8-6d0e403b9cfa@gmail.com>
 <CAF8bMcZOh4W-imEt8tnFpH0zzEEx5PjCVKJO-yhF5X+Tvj_j3w@mail.gmail.com>
 <aa9ac3c1-e8ac-5978-dcd2-693276c3afdc@gmail.com>
Message-ID: <CAF8bMcaKVnNtrjsb6vFk3+_m=+BuzUk0gPk6CDbANHHiJrWkQQ@mail.gmail.com>

Functions, like your loader(), that use substitute to let users confound
things and their names, should give the user a way to avoid the use of
substitute.  E.g., library() has the 'character.only' argument; if TRUE
then the package argument is treated as an ordinary argument and not passed
through substitute().

myLoader <- function(package, quietly = TRUE) {
       wrapper <- if (quietly) suppressPackageStartupMessages else `{`
       wrapper(library(package = package, character.only=TRUE))
   }

> lapply(c("MASS","boot"), myLoader, quietly=FALSE)
[[1]]
 [1] "MASS"      "splines"   "pryr"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"

[[2]]
 [1] "boot"      "MASS"      "splines"   "pryr"      "stats"     "graphics"
 [7] "grDevices" "utils"     "datasets"  "methods"   "base"

"Non-standard" evaluation (using substitute(), formulas, promises, the
rlang or lazyeval packages, etc.) has it uses but I wouldn't use it for
such a function as your loader().


Bill Dunlap
TIBCO Software
wdunlap tibco.com

On Fri, Jul 28, 2017 at 8:20 PM, Benjamin Tyner <btyner at gmail.com> wrote:

> Thanks Bill. I think my confusion may have been in part due to my
> conflating two distinct meanings of the term "evaluate"; the help for force
> says it "forces the evaluation of a function argument" whereas the help for
> eval says it "evaluates the ... argument ... and returns the computed
> value". I found it helpful to compare:
>
>    > lapply(list(a=1,b=2,c=3), function(x){ force(substitute(x)) })
>    $a
>    X[[i]]
>
>    $b
>    X[[i]]
>
>    $c
>    X[[i]]
>
> versus
>
>    > lapply(list(a=1,b=2,c=3), function(x){ eval(substitute(x)) })
>    Error in eval(substitute(x)) : object 'X' not found
>
> Now for the context my question arose in: given a function
>
>    loader <- function(package, quietly = TRUE) {
>
>        wrapper <- if (quietly) suppressPackageStartupMessages else `{`
>
>        expr <- substitute(wrapper(library(package = package)))
>
>        eval(expr)
>    }
>
> prior to R version 3.2, one could do things like
>
>     lapply(c("MASS", "boot"), loader)
>
> but not anymore (which is fine; I agree that one should not depend on
> lapply's implementation details).
>
> Regards,
> Ben
>
>
> On 07/28/2017 06:53 PM, William Dunlap wrote:
>
>> 1: substitute(), when given an argument to a function (which will be a
>> promise) gives you the unevaluated expression given as the argument:
>>
>> >  L <- list(a=1, b=2, c=3)
>> > str(lapply(L, function(x) substitute(x)))
>> List of 3
>>  $ a: language X[[i]]
>>  $ b: language X[[i]]
>>  $ c: language X[[i]]
>>
>> The 'X' and 'i' are in a frame constructed by lapply and you are not
>> really supposed to depend on the precise form of those expressions.
>>
>> 2: An evaluated promise is still a promise: it has the 'evaled' field set
>> to TRUE and the 'value' field set to the result of evaluating 'code' in
>> 'env'.
>>
>> > f <- function(x, force) {
>>      if (force) force(x)
>>      if (pryr::is_promise(x)) promise_info(x)
>>      else "not a promise"
>>  }
>> > str(f(log(-1), force=FALSE))
>> List of 4
>>  $ code  : language log(-1)
>>  $ env   :<environment: R_GlobalEnv>
>>  $ evaled: logi FALSE
>>  $ value : NULL
>> > str(f(log(-1), force=TRUE))
>> List of 4
>>  $ code  : language log(-1)
>>  $ env   : NULL
>>  $ evaled: logi TRUE
>>  $ value : num NaN
>> Warning message:
>> In log(-1) : NaNs produced
>>
>> Can you give a concrete example of what you are try to accomplish?
>>
>> Bill Dunlap
>> TIBCO Software
>> wdunlap tibco.com <http://tibco.com>
>>
>>
>> On Fri, Jul 28, 2017 at 3:04 PM, Benjamin Tyner <btyner at gmail.com
>> <mailto:btyner at gmail.com>> wrote:
>>
>>     Hi,
>>
>>     I thought I understood the change to lapply semantics resulting
>>     from this,
>>
>>     https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16093
>>     <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16093>
>>
>>     However, would someone care to explain why this does not work?
>>
>>        > L <- list(a=1, b=2, c=3)
>>        > str(lapply(L, function(x){ y <- substitute(x); force(x);
>>     eval(y) }))
>>        Error in eval(y) : object 'X' not found
>>
>>     Basically, my primary goal is to achieve the same result as,
>>
>>        > str(lapply(L, function(x){ eval.parent(substitute(x)) }))
>>        List of 3
>>         $ a: num 1
>>         $ b: num 2
>>         $ c: num 3
>>
>>     but without having to resort to eval.parent as that seems to rely
>>     on an implementation detail of lapply.
>>
>>     My secondary goal is to understand why force(x) does not actually
>>     force the promise here,
>>
>>        > str(lapply(L, function(x){ force(x); pryr::is_promise(x) }))
>>        List of 3
>>         $ a: logi TRUE
>>         $ b: logi TRUE
>>         $ c: logi TRUE
>>     ,
>>     Regards
>>     Ben
>>
>>     ______________________________________________
>>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>>     https://stat.ethz.ch/mailman/listinfo/r-devel
>>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>>
>>
>>
>

	[[alternative HTML version deleted]]


From suharto_anggono at yahoo.com  Sun Jul 30 16:57:53 2017
From: suharto_anggono at yahoo.com (Suharto Anggono Suharto Anggono)
Date: Sun, 30 Jul 2017 14:57:53 +0000 (UTC)
Subject: [Rd] translateChar in NewName in bind.c
References: <712400930.2080961.1501426673388.ref@mail.yahoo.com>
Message-ID: <712400930.2080961.1501426673388@mail.yahoo.com>

R devel's bind.c has been ported to R patched. Is it OK while names of 'unlist' or 'c' result may be not strictly the same as in R 3.4.1 because of changed function 'NewName' in bind.c?

Using 'translateCharUTF8' instead of 'translateChar' is as it should be. It has an effect in non-UTF-8 locale for this example.
x <- list(1:2)
names(x) <- "\ue7"
res <- unlist(x)
charToRaw(names(res)[1])

Directly assigning 'tag' to 'ans' is more efficient, but may be different from in R 3.4.1 that involves 'translateCharUTF8', that is also correct. It has an effect for this example.
x <- 0
names(x) <- "\xe7"
Encoding(names(x)) <- "latin1"
res <- c(x)
Encoding(names(res))
charToRaw(names(res))

--------------------------------------------
On Tue, 13/6/17, Tomas Kalibera <tomas.kalibera at gmail.com> wrote:

 Subject: Re: [Rd] translateChar in NewName in bind.c

@r-project.org
 Date: Tuesday, 13 June, 2017, 2:35 PM

 Thanks, fixed in R-devel.
 Best
 Tomas

 On
 06/11/2017 02:30 PM, Suharto Anggono Suharto Anggono via
 R-devel wrote:
 > I see another thing in
 function 'NewName' in bind.c. In
 > else if (*CHAR(tag)) ,
 > 'ans' is basically copied from
 'tag'. Could the whole thing there be just the
 following?
 > ans = tag;
 > It seems to me that it can also replace
 > ans = R_BlankString;
 >
 in 'else'; so,
 > else if
 (*CHAR(tag))
 > and
 >
 else
 > can be merged to be just
 > else .
 >
 >
 --------------------------------------------
 >
 >
 >?? Subject: translateChar in NewName in
 bind.c
 >?? To: r-devel at r-project.org
 >?? Date: Saturday, 10 June, 2017, 9:14
 PM
 >?? 
 >?? In
 function 'NewName' in bind.c (https://svn.r-project.org/R/trunk/src/main/bind.c),
 in
 >?? else if (*CHAR(base)) ,
 >?? 'translateChar' is used. Should
 it be
 >?? 'translateCharUTF8'
 instead? The end result is marked as
 >? 
 UTF-8:
 >?? mkCharCE(cbuf, CE_UTF8)
 >?? Other cases already use
 >?? 'translateCharUTF8'.
 >
 >
 ______________________________________________
 > R-devel at r-project.org
 mailing list
 > https://stat.ethz.ch/mailman/listinfo/r-devel


From maechler at stat.math.ethz.ch  Mon Jul 31 15:38:42 2017
From: maechler at stat.math.ethz.ch (Martin Maechler)
Date: Mon, 31 Jul 2017 15:38:42 +0200
Subject: [Rd] translateChar in NewName in bind.c
In-Reply-To: <712400930.2080961.1501426673388@mail.yahoo.com>
References: <712400930.2080961.1501426673388.ref@mail.yahoo.com>
 <712400930.2080961.1501426673388@mail.yahoo.com>
Message-ID: <22911.13026.582197.526670@stat.math.ethz.ch>

>>>>> Suharto Anggono Suharto Anggono via R-devel <r-devel at r-project.org>
>>>>>     on Sun, 30 Jul 2017 14:57:53 +0000 writes:

    > R devel's bind.c has been ported to R patched. Is it OK while names of 'unlist' or 'c' result may be not strictly the same as in R 3.4.1 because of changed function 'NewName' in bind.c?

    > Using 'translateCharUTF8' instead of 'translateChar' is as it should be. It has an effect in non-UTF-8 locale for this example.

    > x <- list(1:2)
    > names(x) <- "\ue7"
    > res <- unlist(x)
    > charToRaw(names(res)[1])

    > Directly assigning 'tag' to 'ans' is more efficient, but
    > may be different from in R 3.4.1 that involves
    > 'translateCharUTF8', that is also correct. It has an
    > effect for this example. 

    > x <- 0
    > names(x) <- "\xe7"
    > Encoding(names(x)) <- "latin1"
    > res <- c(x)
    > Encoding(names(res))
    > charToRaw(names(res))

Yes, you are right, thank you:

That part of the changes in bind.c was *not* directly related to
the two R-bugs (PR#17284 & PR#17292)... and therefore, maybe I
should not have ported it to R-patched (= R 3.4.1 patched).

Your examples above are instructive..  notably the 2nd one seems
to demonstrate to me, that the change also *did* fix a bug:

   Encoding(names(res))

is "latin1" in R-devel  but interestingly is "UTF-8" in R 3.4.1,
indeed independently of the locale.

I would argue R-devel (and current R-patched) is more faithful
by keeping the Encoding "latin1" that was set for names(x) also
in the  names(c(x)) .

I could revert R-patched's  bind.c (so it only contains the two
official bug fixes PR#172(84|92)   but I wonder if it is
desirable in this case.

I'm glad for further reasoning.
Given current "knowledge"/"evidence",  I would not  revert
R-patched to R 3.4.1's behavior.

Martin

    > --------------------------------------------
    > On Tue, 13/6/17, Tomas Kalibera <tomas.kalibera at gmail.com> wrote:

    > Subject: Re: [Rd] translateChar in NewName in bind.c

    > @r-project.org
    > Date: Tuesday, 13 June, 2017, 2:35 PM

    > Thanks, fixed in R-devel.
    > Best
    > Tomas

    [.............]


From possenriede at gmail.com  Mon Jul 31 18:17:59 2017
From: possenriede at gmail.com (Daniel Possenriede)
Date: Mon, 31 Jul 2017 18:17:59 +0200
Subject: [Rd] special latin1 do not print as glyphs in current devel on
	windows
Message-ID: <CANu2KkMwkC3zOkrc7ijc4D2qdhkdacaxjNnqN2XUxhnBn8rRDw@mail.gmail.com>

Sorry, if I am spamming/not using the right list, but I think I might be
onto a regression in current devel.

Namely, special (non-ASCII) characters with latin1 encoding do not get
printed as glyphs with R 3.5.0 devel but were with R 3.4.1.

This output is from

# R version 3.4.1 (2017-06-30) -- "Single Candle"
# Platform: x86_64-w64-mingw32/x64 (64-bit)

> x <- c("?", "?", "?") # Euro, en-dash, promille
> # v3.4.1 prints latin1 characters fine
> print(x)
[1] "?" "?" "?"

And this (and all following) output is from

# R Under development (unstable) (2017-07-30 r73000) -- "Unsuffered
Consequences"
# Platform: x86_64-w64-mingw32/x64 (64-bit)

> x <- c("?", "?", "?") # Euro, en-dash, promille
> # printed as escapes with 3.5.0 devel
> print(x)
[1] "\u0080" "\u0096" "\u0089"

The possible regression ends here, all following output is the same with
v.3.4.1 and 3.5.0 devel.

Possibly a second, but IMHO related issue is that encoding to UTF-8 does
not help and that information is lost when encoding back to latin1.

First, chars are printed as escapes as well, when converted to UTF-8, which
is unexpected, considering that escapes can be printed as glyphs (see
below).

> Encoding(x)
[1] "latin1" "latin1" "latin1"
> x_utf8 <- enc2utf8(x)
> Encoding(x_utf8)
[1] "UTF-8" "UTF-8" "UTF-8"
> print(x_utf8)
[1] "\u0080" "\u0096" "\u0089"

Converting back to native is lossy (which, to me, is also unexpected).

# When converting x_utf8 back to native encoding, chars are not marked as
latin-1 ...
> x_nat <- enc2native(x_utf8)
> Encoding(x_nat)
[1] "unknown" "unknown" "unknown"
> print(x_nat)
[1] "<U+0080>" "<U+0096>" "<U+0089>"

Other unicode chars print fine as glyphs when entered as escapes (cf.
enc2utf8(x) above)

> z <- c("\u215B", "\u2105", "\u03B7") # 1/8, c/o, eta
> Encoding(z)
[1] "UTF-8" "UTF-8" "UTF-8"
> print(z)
[1] "?" "?" "?"

But changing encoding is also not such a good idea here.

> z_nat <- enc2native(z)
> Encoding(z_nat)
[1] "unknown" "unknown" "unknown"
> z_utf8 <- enc2utf8(z_nat)
> Encoding(z_utf8)
[1] "unknown" "unknown" "unknown"
> print(z_utf8)
[1] "<U+215B>" "<U+2105>" "<U+03B7>"

	[[alternative HTML version deleted]]


From btyner at gmail.com  Mon Jul 31 23:41:55 2017
From: btyner at gmail.com (Benjamin Tyner)
Date: Mon, 31 Jul 2017 17:41:55 -0400
Subject: [Rd] force promises inside lapply
In-Reply-To: <CAF8bMcaKVnNtrjsb6vFk3+_m=+BuzUk0gPk6CDbANHHiJrWkQQ@mail.gmail.com>
References: <a08cf018-5c19-fe67-9ee8-6d0e403b9cfa@gmail.com>
 <CAF8bMcZOh4W-imEt8tnFpH0zzEEx5PjCVKJO-yhF5X+Tvj_j3w@mail.gmail.com>
 <aa9ac3c1-e8ac-5978-dcd2-693276c3afdc@gmail.com>
 <CAF8bMcaKVnNtrjsb6vFk3+_m=+BuzUk0gPk6CDbANHHiJrWkQQ@mail.gmail.com>
Message-ID: <374bc000-0a16-e681-516f-4624cdd92f35@gmail.com>

Thanks again Bill; I agree that substitute is overkill here.

As an aside, for cases where someone may be tempted to use substitute(), 
it seems quote() might be a safer alternative; compare

    > lapply(list(1), function(y) c(quote(y), substitute(y)))
    [[1]]
    [[1]][[1]]
    y

    [[1]][[2]]
    X[[i]]

versus in R < 3.2,

    > lapply(list(1), function(y) c(quote(y), substitute(y)))
    [[1]]
    [[1]][[1]]
    y

    [[1]][[2]]
    X[[1L]]

in any case, the lesson seems to be that quote and substitute are not 
interchangeable, even though for example

    > (function() identical(quote({a}), substitute({a})))()
    [1] TRUE


On 07/29/2017 09:39 AM, William Dunlap wrote:
> Functions, like your loader(), that use substitute to let users 
> confound things and their names, should give the user a way to avoid 
> the use of substitute.  E.g., library() has the 'character.only' 
> argument; if TRUE then the package argument is treated as an ordinary 
> argument and not passed through substitute().
>
> myLoader <- function(package, quietly = TRUE) {
>        wrapper <- if (quietly) suppressPackageStartupMessages else `{`
>        wrapper(library(package = package, character.only=TRUE))
>    }
>
> > lapply(c("MASS","boot"), myLoader, quietly=FALSE)
> [[1]]
>  [1] "MASS"  "splines"   "pryr"      "stats"     "graphics"  "grDevices"
>  [7] "utils" "datasets"  "methods"   "base"
>
> [[2]]
>  [1] "boot"      "MASS"      "splines"   "pryr"      "stats"     
> "graphics"
>  [7] "grDevices" "utils"     "datasets"  "methods"   "base"
>
> "Non-standard" evaluation (using substitute(), formulas, promises, the 
> rlang or lazyeval packages, etc.) has it uses but I wouldn't use it 
> for such a function as your loader().
>
>
> Bill Dunlap
> TIBCO Software
> wdunlap tibco.com <http://tibco.com>
>
> On Fri, Jul 28, 2017 at 8:20 PM, Benjamin Tyner <btyner at gmail.com 
> <mailto:btyner at gmail.com>> wrote:
>
>     Thanks Bill. I think my confusion may have been in part due to my
>     conflating two distinct meanings of the term "evaluate"; the help
>     for force says it "forces the evaluation of a function argument"
>     whereas the help for eval says it "evaluates the ... argument ...
>     and returns the computed value". I found it helpful to compare:
>
>        > lapply(list(a=1,b=2,c=3), function(x){ force(substitute(x)) })
>        $a
>        X[[i]]
>
>        $b
>        X[[i]]
>
>        $c
>        X[[i]]
>
>     versus
>
>        > lapply(list(a=1,b=2,c=3), function(x){ eval(substitute(x)) })
>        Error in eval(substitute(x)) : object 'X' not found
>
>     Now for the context my question arose in: given a function
>
>        loader <- function(package, quietly = TRUE) {
>
>            wrapper <- if (quietly) suppressPackageStartupMessages else `{`
>
>            expr <- substitute(wrapper(library(package = package)))
>
>            eval(expr)
>        }
>
>     prior to R version 3.2, one could do things like
>
>         lapply(c("MASS", "boot"), loader)
>
>     but not anymore (which is fine; I agree that one should not depend
>     on lapply's implementation details).
>
>     Regards,
>     Ben
>
>
>     On 07/28/2017 06:53 PM, William Dunlap wrote:
>
>         1: substitute(), when given an argument to a function (which
>         will be a promise) gives you the unevaluated expression given
>         as the argument:
>
>         >  L <- list(a=1, b=2, c=3)
>         > str(lapply(L, function(x) substitute(x)))
>         List of 3
>          $ a: language X[[i]]
>          $ b: language X[[i]]
>          $ c: language X[[i]]
>
>         The 'X' and 'i' are in a frame constructed by lapply and you
>         are not really supposed to depend on the precise form of those
>         expressions.
>
>         2: An evaluated promise is still a promise: it has the
>         'evaled' field set to TRUE and the 'value' field set to the
>         result of evaluating 'code' in 'env'.
>
>         > f <- function(x, force) {
>              if (force) force(x)
>              if (pryr::is_promise(x)) promise_info(x)
>              else "not a promise"
>          }
>         > str(f(log(-1), force=FALSE))
>         List of 4
>          $ code  : language log(-1)
>          $ env   :<environment: R_GlobalEnv>
>          $ evaled: logi FALSE
>          $ value : NULL
>         > str(f(log(-1), force=TRUE))
>         List of 4
>          $ code  : language log(-1)
>          $ env   : NULL
>          $ evaled: logi TRUE
>          $ value : num NaN
>         Warning message:
>         In log(-1) : NaNs produced
>
>         Can you give a concrete example of what you are try to accomplish?
>
>         Bill Dunlap
>         TIBCO Software
>         wdunlap tibco.com <http://tibco.com> <http://tibco.com>
>
>
>         On Fri, Jul 28, 2017 at 3:04 PM, Benjamin Tyner
>         <btyner at gmail.com <mailto:btyner at gmail.com>
>         <mailto:btyner at gmail.com <mailto:btyner at gmail.com>>> wrote:
>
>             Hi,
>
>             I thought I understood the change to lapply semantics
>         resulting
>             from this,
>
>         https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16093
>         <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16093>
>             <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16093
>         <https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16093>>
>
>             However, would someone care to explain why this does not work?
>
>                > L <- list(a=1, b=2, c=3)
>                > str(lapply(L, function(x){ y <- substitute(x); force(x);
>             eval(y) }))
>                Error in eval(y) : object 'X' not found
>
>             Basically, my primary goal is to achieve the same result as,
>
>                > str(lapply(L, function(x){ eval.parent(substitute(x)) }))
>                List of 3
>                 $ a: num 1
>                 $ b: num 2
>                 $ c: num 3
>
>             but without having to resort to eval.parent as that seems
>         to rely
>             on an implementation detail of lapply.
>
>             My secondary goal is to understand why force(x) does not
>         actually
>             force the promise here,
>
>                > str(lapply(L, function(x){ force(x);
>         pryr::is_promise(x) }))
>                List of 3
>                 $ a: logi TRUE
>                 $ b: logi TRUE
>                 $ c: logi TRUE
>             ,
>             Regards
>             Ben
>
>             ______________________________________________
>         R-devel at r-project.org <mailto:R-devel at r-project.org>
>         <mailto:R-devel at r-project.org <mailto:R-devel at r-project.org>>
>         mailing list
>         https://stat.ethz.ch/mailman/listinfo/r-devel
>         <https://stat.ethz.ch/mailman/listinfo/r-devel>
>             <https://stat.ethz.ch/mailman/listinfo/r-devel
>         <https://stat.ethz.ch/mailman/listinfo/r-devel>>
>
>
>
>


